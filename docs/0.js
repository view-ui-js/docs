(this["webpackJsonp"] = this["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/@antv/g2/build/g2.js":
/*!*******************************************!*\
  !*** ./node_modules/@antv/g2/build/g2.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 389);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The util method based on the lodash.\n * @author dxq613@gmail.com\n * @see https://github.com/lodash/lodash\n */\nvar Utils = __webpack_require__(127);\n\nvar G = __webpack_require__(16);\n\nvar Util = Utils.mix({}, Utils, {\n  assign: Utils.mix,\n  // simple mix\n  merge: Utils.deepMix,\n  // deep mix\n  cloneDeep: Utils.clone,\n  isFinite: isFinite,\n  isNaN: isNaN,\n  snapEqual: Utils.isNumberEqual,\n  remove: Utils.pull,\n  inArray: Utils.contains,\n\n  /**\n   * 将用户输入的 padding 转换成 [top, right, bottom, right] 的模式\n   * @param  {Number|Array} padding 输入的padding\n   * @return {Array} 四个padding 值\n   */\n  toAllPadding: function toAllPadding(padding) {\n    var top = 0;\n    var left = 0;\n    var right = 0;\n    var bottom = 0;\n\n    if (Util.isNumber(padding) || Util.isString(padding)) {\n      top = left = right = bottom = padding;\n    } else if (Util.isArray(padding)) {\n      top = padding[0];\n      right = !Util.isNil(padding[1]) ? padding[1] : padding[0];\n      bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];\n      left = !Util.isNil(padding[3]) ? padding[3] : right;\n    } else if (Util.isObject(padding)) {\n      top = padding.top || 0;\n      right = padding.right || 0;\n      bottom = padding.bottom || 0;\n      left = padding.left || 0;\n    }\n\n    return [top, right, bottom, left];\n  },\n  getClipByRange: function getClipByRange(plotRange) {\n    var tl = plotRange.tl,\n        br = plotRange.br;\n    var clip = new G.Rect({\n      attrs: {\n        x: tl.x,\n        y: tl.y,\n        width: br.x - tl.x,\n        height: br.y - tl.y\n      }\n    });\n    return clip;\n  }\n});\nUtil.Array = {\n  groupToMap: Utils.groupToMap,\n  group: Utils.group,\n  merge: Utils.merge,\n  values: Utils.valuesOfKey,\n  getRange: Utils.getRange,\n  firstValue: Utils.firstValue,\n  remove: Utils.pull\n};\nmodule.exports = Util;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar CommonUtil = __webpack_require__(81);\n\nvar Util = {};\nCommonUtil.merge(Util, CommonUtil, {\n  mixin: function mixin(c, mixins) {\n    var Param = c.CFG ? 'CFG' : 'ATTRS';\n\n    if (c && mixins) {\n      c._mixins = mixins;\n      c[Param] = c[Param] || {};\n      var temp = {};\n      Util.each(mixins, function (mixin) {\n        Util.augment(c, mixin);\n        var attrs = mixin[Param];\n\n        if (attrs) {\n          Util.merge(temp, attrs);\n        }\n      });\n      c[Param] = Util.merge(temp, c[Param]);\n    }\n  }\n});\nmodule.exports = Util;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(24);\n\nvar isArray = __webpack_require__(4);\n\nvar each = function each(elements, func) {\n  if (!elements) {\n    return;\n  }\n\n  var rst = void 0;\n\n  if (isArray(elements)) {\n    for (var i = 0, len = elements.length; i < len; i++) {\n      rst = func(elements[i], i);\n\n      if (rst === false) {\n        break;\n      }\n    }\n  } else if (isObject(elements)) {\n    for (var k in elements) {\n      if (elements.hasOwnProperty(k)) {\n        rst = func(elements[k], k);\n\n        if (rst === false) {\n          break;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = each;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The util method based on the lodash.\n * @author dxq613@gmail.com\n */\nvar G = __webpack_require__(25);\n\nvar Utils = __webpack_require__(127);\n\nvar Util = Utils.mix({\n  assign: Utils.mix,\n  isFinite: isFinite,\n  isNaN: isNaN,\n  Group: G.Group,\n  Event: G.Event\n}, Utils);\nmodule.exports = Util;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(12);\n\nvar isArray = Array.isArray ? Array.isArray : function (value) {\n  return isType(value, 'Array');\n};\nmodule.exports = isArray;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// isFinite,\nvar isNil = function isNil(value) {\n  /**\n   * isNil(null) => true\n   * isNil() => true\n   */\n  return value === null || value === undefined;\n};\n\nmodule.exports = isNil;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar isPointInPath = __webpack_require__(189);\n\nvar Element = __webpack_require__(102);\n\nvar Inside = __webpack_require__(54);\n\nvar Shape = function Shape(cfg) {\n  Shape.superclass.constructor.call(this, cfg);\n};\n\nShape.ATTRS = {};\nUtil.extend(Shape, Element);\nvar ARRAY_ATTRS = {\n  matrix: 'matrix',\n  path: 'path',\n  points: 'points',\n  lineDash: 'lineDash'\n};\n\nfunction _cloneArrayAttr(arr) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (Util.isArray(arr[i])) {\n      result.push([].concat(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nUtil.augment(Shape, isPointInPath, {\n  isShape: true,\n  drawInner: function drawInner(context) {\n    var self = this;\n    var attrs = self._attrs;\n    self.createPath(context);\n    var originOpacity = context.globalAlpha;\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        context.fill();\n        context.globalAlpha = originOpacity;\n      } else {\n        context.fill();\n      }\n    }\n\n    if (self.hasStroke()) {\n      var lineWidth = self._attrs.lineWidth;\n\n      if (lineWidth > 0) {\n        var strokeOpacity = attrs.strokeOpacity;\n\n        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n\n        context.stroke();\n      }\n    }\n\n    self.afterPath(context);\n  },\n  afterPath: function afterPath() {},\n\n  /**\n   * 击中图形时是否进行包围盒判断\n   * @return {Boolean} [description]\n   */\n  isHitBox: function isHitBox() {\n    return true;\n  },\n\n  /**\n   * 节点是否能够被击中\n   * @param {Number} x x坐标\n   * @param {Number} y y坐标\n   * @return {Boolean} 是否在图形中\n   */\n  isHit: function isHit(x, y) {\n    var self = this;\n    var v = [x, y, 1];\n    self.invert(v); // canvas\n\n    if (self.isHitBox()) {\n      var box = self.getBBox();\n\n      if (box && !Inside.box(box.minX, box.maxX, box.minY, box.maxY, v[0], v[1])) {\n        return false;\n      }\n    }\n\n    var clip = self._attrs.clip;\n\n    if (clip) {\n      clip.invert(v, self.get('canvas'));\n\n      if (clip.isPointInPath(v[0], v[1])) {\n        return self.isPointInPath(v[0], v[1]);\n      }\n    } else {\n      return self.isPointInPath(v[0], v[1]);\n    }\n\n    return false;\n  },\n\n  /**\n   * @protected\n   * 计算包围盒\n   * @return {Object} 包围盒\n   */\n  calculateBox: function calculateBox() {\n    return null;\n  },\n  // 获取拾取时线的宽度，需要考虑附加的线的宽度\n  getHitLineWidth: function getHitLineWidth() {\n    var attrs = this._attrs; // if (!attrs.stroke) {\n    //   return 0;\n    // }\n\n    var lineAppendWidth = attrs.lineAppendWidth || 0;\n    var lineWidth = attrs.lineWidth || 0;\n    return lineWidth + lineAppendWidth;\n  },\n  // 清除当前的矩阵\n  clearTotalMatrix: function clearTotalMatrix() {\n    this._cfg.totalMatrix = null;\n    this._cfg.region = null;\n  },\n  clearBBox: function clearBBox() {\n    this._cfg.box = null;\n    this._cfg.region = null;\n  },\n  getBBox: function getBBox() {\n    var box = this._cfg.box; // 延迟计算\n\n    if (!box) {\n      box = this.calculateBox();\n\n      if (box) {\n        box.x = box.minX;\n        box.y = box.minY;\n        box.width = box.maxX - box.minX;\n        box.height = box.maxY - box.minY;\n      }\n\n      this._cfg.box = box;\n    }\n\n    return box;\n  },\n  clone: function clone() {\n    var self = this;\n    var clone = null;\n    var _attrs = self._attrs;\n    var attrs = {};\n    Util.each(_attrs, function (i, k) {\n      if (ARRAY_ATTRS[k] && Util.isArray(_attrs[k])) {\n        attrs[k] = _cloneArrayAttr(_attrs[k]);\n      } else {\n        attrs[k] = _attrs[k];\n      }\n    });\n    clone = new self.constructor({\n      attrs: attrs\n    }); // zIndex也是绘图属性，但是在cfg中，特殊处理\n\n    clone._cfg.zIndex = self._cfg.zIndex;\n    return clone;\n  }\n});\nmodule.exports = Shape;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 全局变量\n * @author dxq613\n */\nvar Util = __webpack_require__(0);\n\nvar Theme = __webpack_require__(151);\n\nvar Global = {\n  version: '3.4.10',\n  renderer: 'canvas',\n  // trackable: false,\n  trackingInfo: {},\n  animate: true,\n  widthRatio: {\n    // 宽度所占的分类的比例\n    column: 1 / 2,\n    // 一般的柱状图占比 1/2\n    rose: 0.9999999,\n    // 玫瑰图柱状占比 1\n    multiplePie: 1 / 1.3 // 多层的饼图、环图\n\n  },\n  // 折线图、区域图、path 当只有一个数据时，是否显示成点\n  showSinglePoint: false,\n  connectNulls: false,\n  scales: {},\n  registerTheme: function registerTheme(name, theme) {\n    Theme[name] = theme;\n  },\n  setTheme: function setTheme(theme) {\n    var newTheme = {};\n\n    if (Util.isObject(theme)) {\n      newTheme = theme;\n    } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {\n      newTheme = Theme[theme];\n    } else {\n      newTheme = Theme.default;\n    }\n\n    Util.deepMix(Global, newTheme);\n  }\n};\nGlobal.setTheme('default');\nmodule.exports = Global;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nfunction _mix(dist, obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n      dist[key] = obj[key];\n    }\n  }\n}\n\nvar mix = function mix(dist, src1, src2, src3) {\n  if (src1) _mix(dist, src1);\n  if (src2) _mix(dist, src2);\n  if (src3) _mix(dist, src3);\n  return dist;\n};\n\nmodule.exports = mix;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 判断是否数字\n * @return {Boolean} 是否数字\n */\nvar isType = __webpack_require__(12);\n\nvar isNumber = function isNumber(value) {\n  return isType(value, 'Number');\n};\n\nmodule.exports = isNumber;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(12);\n\nvar isString = function isString(str) {\n  return isType(str, 'String');\n};\n\nmodule.exports = isString;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否为函数\n * @param  {*} fn 对象\n * @return {Boolean}  是否函数\n */\nvar isType = __webpack_require__(12);\n\nvar isFunction = function isFunction(value) {\n  return isType(value, 'Function');\n};\n\nmodule.exports = isFunction;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nvar isType = function isType(value, type) {\n  return toString.call(value) === '[object ' + type + ']';\n};\n\nmodule.exports = isType;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nvar isArrayLike = function isArrayLike(value) {\n  /**\n   * isArrayLike([1, 2, 3]) => true\n   * isArrayLike(document.body.children) => true\n   * isArrayLike('abc') => true\n   * isArrayLike(Function) => false\n   */\n  return value !== null && typeof value !== 'function' && isFinite(value.length);\n};\n\nmodule.exports = isArrayLike;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  FONT_FAMILY: '\"-apple-system\", BlinkMacSystemFont, \"Segoe UI\", Roboto,\"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\",SimSun, \"sans-serif\"'\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Helper = __webpack_require__(156);\n\nvar Component = __webpack_require__(32);\n\nvar KEYWORDS = ['min', 'max', 'median', 'start', 'end'];\n\nvar Guide =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Guide, _Component);\n\n  function Guide() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Guide.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Component.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      xScales: null,\n      yScales: null,\n      el: null\n    });\n  };\n\n  _proto.render = function render() {};\n  /**\n   * clear container\n   * @override\n   */\n\n\n  _proto.clear = function clear() {\n    var self = this;\n    var el = self.get('el');\n    el && el.remove();\n  };\n  /**\n   * show or hide\n   * @protected\n   * @param {Boolean} visible true means show, false means hide\n   */\n\n\n  _proto.changeVisible = function changeVisible(visible) {\n    var self = this;\n    self.set('visible', visible);\n    var el = self.get('el');\n    if (!el) return;\n\n    if (el.set) {\n      el.set('visible', visible);\n    } else {\n      el.style.display = visible ? '' : 'none';\n    }\n  };\n  /**\n   * calculate the canvas coordinate value\n   * @protected\n   * @param  {Coordinate} coord  the instance of Coordinate class\n   * @param  {Object | Array | Function} position the value need to convert\n   * @return {Object} return the result\n   */\n\n\n  _proto.parsePoint = function parsePoint(coord, position) {\n    var self = this;\n    var xScales = self.get('xScales');\n    var yScales = self.get('yScales');\n\n    if (Util.isFunction(position)) {\n      position = position(xScales, yScales);\n    }\n\n    var x;\n    var y; // 如果数据格式是 ['50%', '50%'] 的格式\n\n    if (Util.isArray(position) && Util.isString(position[0]) && position[0].indexOf('%') !== -1) {\n      return this._parsePercentPoint(coord, position);\n    }\n\n    if (Util.isArray(position)) {\n      // Array，suuport for mixing of keyword, percent and value\n      x = self._getNormalizedValue(position[0], Helper.getFirstScale(xScales));\n      y = self._getNormalizedValue(position[1], Helper.getFirstScale(yScales));\n    } else {\n      for (var field in position) {\n        var value = position[field];\n\n        if (xScales[field]) {\n          x = self._getNormalizedValue(value, xScales[field]);\n        }\n\n        if (yScales[field]) {\n          y = self._getNormalizedValue(value, yScales[field], 'y');\n        }\n      }\n    }\n\n    if (!Util.isNil(x) && !Util.isNil(y)) {\n      return coord.convert({\n        x: x,\n        y: y\n      });\n    }\n  };\n  /**\n   * Normalized the value\n   * @param  {String | Number} val   param\n   * @param  {Scale} scale the instance of Scale\n   * @return {Number}       return the normalized value\n   */\n\n\n  _proto._getNormalizedValue = function _getNormalizedValue(val, scale) {\n    var result;\n\n    if (Util.indexOf(KEYWORDS, val) !== -1) {\n      // keyword\n      var scaleValue;\n\n      if (val === 'start') {\n        // the start of coordinate\n        result = 0;\n      } else if (val === 'end') {\n        result = 1;\n      } else if (val === 'median') {\n        scaleValue = scale.isCategory ? (scale.values.length - 1) / 2 : (scale.min + scale.max) / 2;\n        result = scale.scale(scaleValue);\n      } else {\n        if (scale.isCategory) {\n          scaleValue = val === 'min' ? 0 : scale.values.length - 1;\n        } else {\n          scaleValue = scale[val];\n        }\n\n        result = scale.scale(scaleValue);\n      }\n    } else {\n      // 数值\n      result = scale.scale(val);\n    }\n\n    return result;\n  };\n\n  _proto._parsePercentPoint = function _parsePercentPoint(coord, position) {\n    var xPercent = parseFloat(position[0]) / 100;\n    var yPercent = parseFloat(position[1]) / 100;\n    var start = coord.start,\n        end = coord.end;\n    var topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y)\n    };\n    var x = coord.width * xPercent + topLeft.x;\n    var y = coord.height * yPercent + topLeft.y;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  return Guide;\n}(Component);\n\nmodule.exports = Guide;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar G = __webpack_require__(25);\n\nmodule.exports = G;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mix = __webpack_require__(8);\n\nvar each = __webpack_require__(2);\n\nvar isObject = __webpack_require__(24);\n\nvar isNil = __webpack_require__(5);\n\nvar Scale =\n/*#__PURE__*/\nfunction () {\n  var _proto = Scale.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'base';\n    /**\n     * 格式化函数,输出文本或者tick时的格式化函数\n     * @type {Function}\n     */\n\n    this.formatter = null;\n    /**\n     * 输出的值域\n     * @type {Array}\n     */\n\n    this.range = [0, 1];\n    /**\n     * 度量的标记\n     * @type {Array}\n     */\n\n    this.ticks = null;\n    /**\n     * 参与度量计算的值，可选项\n     * @type {Array}\n     */\n\n    this.values = [];\n  };\n\n  function Scale(cfg) {\n    this._initDefaultCfg();\n\n    mix(this, cfg);\n    this.init();\n  }\n  /**\n   * 度量初始化\n   * @protected\n   */\n\n\n  _proto.init = function init() {};\n  /**\n   * 获取该度量的ticks,返回的是多个对象，\n   *   - text: tick 的文本\n   *   - value: 对应的度量转换后的值\n   * <code>\n   *   [\n   *     {text: 0,value:0}\n   *     {text: 1,value:0.2}\n   *     {text: 2,value:0.4}\n   *     {text: 3,value:0.6}\n   *     {text: 4,value:0.8}\n   *     {text: 5,value:1}\n   *   ]\n   * </code>\n   * @param {Number} count 输出tick的个数的近似值，默认是 10\n   * @return {Array} 返回 ticks 数组\n   */\n\n\n  _proto.getTicks = function getTicks() {\n    var self = this;\n    var ticks = self.ticks;\n    var rst = [];\n    each(ticks, function (tick) {\n      var obj;\n\n      if (isObject(tick)) {\n        obj = tick;\n      } else {\n        obj = {\n          text: self.getText(tick),\n          tickValue: tick,\n          value: self.scale(tick)\n        };\n      }\n\n      rst.push(obj);\n    });\n    return rst;\n  };\n  /**\n   * 获取格式化后的文本\n   * @param  {*} value 输入的数据\n   * @param  {*} key 字段的 key\n   * @return {String} 格式化的文本\n   */\n\n\n  _proto.getText = function getText(value, key) {\n    var formatter = this.formatter;\n    value = formatter ? formatter(value, key) : value;\n\n    if (isNil(value) || !value.toString) {\n      value = '';\n    }\n\n    return value.toString();\n  };\n  /**\n   * 输出的值域最小值\n   * @protected\n   * @return {Number} 返回最小的值\n   */\n\n\n  _proto.rangeMin = function rangeMin() {\n    return this.range[0];\n  };\n  /**\n   * 输出的值域最大值\n   * @protected\n   * @return {Number} 返回最大的值\n   */\n\n\n  _proto.rangeMax = function rangeMax() {\n    var range = this.range;\n    return range[range.length - 1];\n  };\n  /**\n   * 度量转换后的结果，翻转回输入域\n   * @param  {Number} value 需要翻转的数值\n   * @return {*} 度量的输入值\n   */\n\n\n  _proto.invert = function invert(value) {\n    return value;\n  };\n  /**\n   * 将传入的值从非数值转换成数值格式，如分类字符串、时间字符串等\n   * @param  {*} value 传入的值\n   * @return {Number} 转换的值\n   */\n\n\n  _proto.translate = function translate(value) {\n    return value;\n  };\n  /**\n   * 进行度量转换\n   * @param  {*} value 输入值\n   * @return {Number} 输出值，在设定的输出值域之间，默认[0,1]\n   */\n\n\n  _proto.scale = function scale(value) {\n    return value;\n  };\n  /**\n   * 克隆一个新的scale,拥有跟当前scale相同的输入域、输出域等\n   * @return {Scale} 克隆的度量\n   */\n\n\n  _proto.clone = function clone() {\n    var self = this;\n    var constr = self.constructor;\n    var cfg = {};\n    each(self, function (v, k) {\n      cfg[k] = self[k];\n    });\n    return new constr(cfg);\n  };\n  /**\n   * 更改度量的属性信息\n   * @param  {Object} info 属性信息\n   * @chainable\n   * @return {Scale} 返回自身的引用\n   */\n\n\n  _proto.change = function change(info) {\n    this.ticks = null;\n    mix(this, info);\n    this.init();\n    return this;\n  };\n\n  return Scale;\n}();\n\nmodule.exports = Scale;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 工厂类，管理各种类型的 shape\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar PathUtil = __webpack_require__(22);\n\nvar GPath = Util.PathUtil;\nvar Shape = {};\nvar ShapeBase = {\n  _coord: null,\n\n  /**\n   * 绘制图形\n   * @param {Object} cfg 配置项\n   * @param {Object} container 容器\n   * @return {Object} shape 创建的 shape\n   */\n  draw: function draw(cfg, container) {\n    if (this.drawShape) {\n      return this.drawShape(cfg, container);\n    }\n\n    return null;\n  },\n\n  /**\n   * 获取绘制图形需要的点, 可以不定义，则使用默认的\n  getPoints(cfg) {\n    if (this.getShapePoints) {\n      return this.getShapePoints(cfg);\n    }\n    return null;\n  },*/\n\n  /**\n   * 设置坐标系\n   * @param {Coord} coord 坐标系\n   */\n  setCoord: function setCoord(coord) {\n    this._coord = coord;\n  },\n\n  /**\n   * 0～1 path 转 画布 path\n   * @param  {path} path 路径\n   * @param  {Boolean} islineToArc 是否转换成圆弧\n   * @return {path} path 转换到画布坐标的path\n   */\n  parsePath: function parsePath(path, islineToArc) {\n    var coord = this._coord;\n    path = GPath.parsePathString(path);\n\n    if (coord.isPolar && islineToArc !== false) {\n      path = PathUtil.convertPolarPath(coord, path);\n    } else {\n      path = PathUtil.convertNormalPath(coord, path);\n    }\n\n    return path;\n  },\n\n  /**\n   * 0～1 point 转 画布 point\n   * @param  {point} point 节点\n   * @return {point} point 转换后的点\n   */\n  parsePoint: function parsePoint(point) {\n    var coord = this._coord;\n    return coord.convertPoint(point);\n  },\n\n  /**\n   * 0～1 points 转 画布 points\n   * @param  {points} points 节点集合\n   * @return {points} points 转换后的多个节点\n   */\n  parsePoints: function parsePoints(points) {\n    var coord = this._coord;\n    var rst = [];\n    Util.each(points, function (point) {\n      rst.push(coord.convertPoint(point));\n    });\n    return rst;\n  }\n};\nvar ShapeFactoryBase = {\n  defaultShapeType: null,\n  setCoord: function setCoord(coord) {\n    this._coord = coord;\n  },\n  getShape: function getShape(type) {\n    var self = this;\n\n    if (Util.isArray(type)) {\n      type = type[0];\n    }\n\n    var shape = self[type] || self[self.defaultShapeType];\n    shape._coord = self._coord;\n    return shape;\n  },\n  getShapePoints: function getShapePoints(type, cfg) {\n    var shape = this.getShape(type);\n    var fn = shape.getPoints || shape.getShapePoints || this.getDefaultPoints;\n    var points = fn(cfg);\n    return points;\n  },\n  getDefaultPoints: function getDefaultPoints()\n  /* cfg */\n  {\n    return [];\n  },\n  getMarkerCfg: function getMarkerCfg(type, cfg) {\n    var shape = this.getShape(type);\n\n    if (!shape.getMarkerCfg) {\n      var defaultShapeType = this.defaultShapeType;\n      shape = this.getShape(defaultShapeType);\n    }\n\n    return shape.getMarkerCfg(cfg);\n  },\n  getSelectedCfg: function getSelectedCfg()\n  /* type, cfg */\n  {\n    return {};\n  },\n  drawShape: function drawShape(type, cfg, container) {\n    var shape = this.getShape(type);\n    var gShape = shape.draw(cfg, container);\n\n    if (gShape) {\n      gShape.setSilent('origin', cfg.origin);\n      gShape._id = cfg.yIndex ? cfg._id + cfg.yIndex : cfg._id;\n      gShape.name = this.name;\n    }\n\n    return gShape;\n  }\n}; // 注册 Geometry 获取图形的入口\n\nShape.registerFactory = function (factoryName, cfg) {\n  var className = Util.upperFirst(factoryName);\n  var geomObj = Util.assign({}, ShapeFactoryBase, cfg);\n  Shape[className] = geomObj;\n  geomObj.name = factoryName;\n  return geomObj;\n}; // 注册图形\n\n\nShape.registerShape = function (factoryName, shapeType, cfg) {\n  var className = Util.upperFirst(factoryName);\n  var factory = Shape[className];\n  var shapeObj = Util.assign({}, ShapeBase, cfg);\n  factory[shapeType] = shapeObj;\n  return shapeObj;\n}; // 获得Geom 对应的 shapeFactory\n\n\nShape.getShapeFactory = function (factoryName) {\n  var self = this;\n  factoryName = factoryName || 'point';\n  var className = Util.upperFirst(factoryName);\n  return self[className];\n};\n\nmodule.exports = Shape;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_color__ = __webpack_require__(60);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__[\"e\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__[\"g\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_color__[\"f\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_lab__ = __webpack_require__(203);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_lab__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__ = __webpack_require__(204);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubehelix__[\"a\"]; });\n\n\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview 所有 Geometry 的基类\n * @author dxq613@gmail.com\n */\nvar Attr = __webpack_require__(73);\n\nvar Adjust = __webpack_require__(297);\n\nvar Base = __webpack_require__(148);\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(7);\n\nvar Labels = __webpack_require__(305);\n\nvar Shape = __webpack_require__(18);\n\nvar TooltipMixin = __webpack_require__(337);\n\nvar ActiveMixin = __webpack_require__(338);\n\nvar SelectMixin = __webpack_require__(339);\n\nvar parseFields = __webpack_require__(340);\n\nvar GROUP_ATTRS = ['color', 'shape', 'size'];\nvar FIELD_ORIGIN = '_origin'; // 转换成对象的数组 [{type: 'adjust'}]\n\nfunction parseAdjusts(adjusts) {\n  // 如果是字符串或者对象转换成数组\n  if (Util.isString(adjusts) || Util.isPlainObject(adjusts)) {\n    adjusts = [adjusts];\n  }\n\n  Util.each(adjusts, function (adjust, index) {\n    if (!Util.isObject(adjust)) {\n      adjusts[index] = {\n        type: adjust\n      };\n    }\n  });\n  return adjusts;\n}\n/**\n * 几何标记\n * @class Geom\n */\n\n\nvar GeomBase =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(GeomBase, _Base);\n\n  var _proto = GeomBase.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * 标记 _id 用于区分执行动画\n       * @type {String}\n       */\n      _id: null,\n\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'base',\n\n      /**\n       * 坐标系\n       * @type {Object}\n       */\n      coord: null,\n\n      /**\n       * 属性映射集\n       * @protected\n       * @type {Object}\n       */\n      attrs: {},\n\n      /**\n       * 所属的View\n       * @type {View}\n       */\n      view: null,\n\n      /**\n       * 几何标记显示的数据\n       * @type {Array}\n       */\n      data: [],\n\n      /**\n       * 相关的度量\n       * @type {Object}\n       */\n      scales: {},\n\n      /**\n       * 绘图容器\n       * @type {Object}\n       */\n      container: null,\n\n      /**\n       * 文本容器\n       * @type {Object}\n       */\n      labelContainer: null,\n\n      /**\n       * 图形容器\n       * @type {Object}\n       */\n      shapeContainer: null,\n\n      /**\n       * 几何标记的一些配置项，用于延迟生成图表\n       * @type {Object}\n       */\n      attrOptions: {},\n      // 样式配置项\n      styleOptions: null,\n      // 选中时的配置项\n      selectedOptions: null,\n      // active 时的配置项\n      activedOptions: null,\n\n      /**\n       * 某些类存在默认的adjust，不能更改 adjust\n       * @type {Boolean}\n       */\n      hasDefaultAdjust: false,\n      // 数据调整类型\n      adjusts: null,\n\n      /**\n       * 使用形状的类型\n       * @protected\n       * @type {String}\n       */\n      shapeType: null,\n\n      /**\n       * 是否生成多个点来绘制图形\n       * @protected\n       * @type {Boolean}\n       */\n      generatePoints: false,\n\n      /**\n       * 数据是否进行排序\n       * @type {Boolean}\n       */\n      sortable: false,\n      labelCfg: null,\n\n      /**\n       * 是否共享 tooltip\n       * @type {Boolean}\n       */\n      shareTooltip: true,\n      tooltipCfg: null,\n\n      /**\n       * 是否执行动画，默认执行\n       * @type {Boolean}\n       */\n      animate: true,\n\n      /**\n       * 动画配置\n       * @type {[type]}\n       */\n      animateCfg: null,\n      visible: true\n    };\n  };\n\n  function GeomBase(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.viewTheme = _this.get('viewTheme');\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), TooltipMixin, ActiveMixin, SelectMixin);\n\n    if (_this.get('container')) {\n      _this._initContainer();\n    }\n\n    _this._initOptions();\n\n    return _this;\n  } // 初始化时对配置项的格式化\n\n\n  _proto._initOptions = function _initOptions() {\n    var adjusts = this.get('adjusts');\n\n    if (adjusts) {\n      adjusts = parseAdjusts(adjusts);\n      this.set('adjusts', adjusts);\n    }\n  };\n\n  _proto._createScale = function _createScale(field, data) {\n    var scales = this.get('scales');\n    var scale = scales[field];\n\n    if (!scale) {\n      scale = this.get('view').createScale(field, data);\n      scales[field] = scale;\n    }\n\n    return scale;\n  };\n\n  _proto._setAttrOptions = function _setAttrOptions(attrName, attrCfg) {\n    var options = this.get('attrOptions');\n    options[attrName] = attrCfg;\n  };\n\n  _proto._createAttrOption = function _createAttrOption(attrName, field, cfg, defaultValues) {\n    var attrCfg = {};\n    attrCfg.field = field;\n\n    if (cfg) {\n      if (Util.isFunction(cfg)) {\n        attrCfg.callback = cfg;\n      } else {\n        attrCfg.values = cfg;\n      }\n    } else if (attrName !== 'color') {\n      attrCfg.values = defaultValues;\n    }\n\n    this._setAttrOptions(attrName, attrCfg);\n  };\n  /**\n   * 位置属性映射\n   * @chainable\n   * @param  {String} field 字段名\n   * @return {Geom} geom 当前几何标记\n   */\n\n\n  _proto.position = function position(field) {\n    this._setAttrOptions('position', {\n      field: field\n    });\n\n    return this;\n  };\n  /**\n   * 颜色属性映射\n   * @chainable\n   * @param  {String} field 字段名\n   * @param  {Array|Function} values 颜色的数组或者回调函数\n   * @return {Geom} geom 当前几何标记\n   */\n\n\n  _proto.color = function color(field, values) {\n    var viewTheme = this.viewTheme || Global;\n\n    this._createAttrOption('color', field, values, viewTheme.colors);\n\n    return this;\n  };\n  /**\n   * 大小属性映射\n   * @chainable\n   * @param  {String} field 字段名\n   * @param  {Array|Function} values 大小的数组或者回调函数\n   * @return {Geom} geom 当前几何标记\n   */\n\n\n  _proto.size = function size(field, values) {\n    var viewTheme = this.viewTheme || Global;\n\n    this._createAttrOption('size', field, values, viewTheme.sizes);\n\n    return this;\n  };\n  /**\n   * 形状属性映射\n   * @chainable\n   * @param  {String} field 字段名\n   * @param  {Array|Function} values 大小的数组或者回调函数\n   * @return {Geom} geom 当前几何标记\n   */\n\n\n  _proto.shape = function shape(field, values) {\n    var viewTheme = this.viewTheme || Global;\n    var type = this.get('type');\n    var shapes = viewTheme.shapes[type] || [];\n\n    this._createAttrOption('shape', field, values, shapes);\n\n    return this;\n  };\n  /**\n   * 透明度属性映射\n   * @chainable\n   * @param  {String} field 字段名\n   * @param  {Array|Function} values 透明度的数组或者回调函数\n   * @return {Geom} geom 当前几何标记\n   */\n\n\n  _proto.opacity = function opacity(field, values) {\n    var viewTheme = this.viewTheme || Global;\n\n    this._createAttrOption('opacity', field, values, viewTheme.opacities);\n\n    return this;\n  };\n\n  _proto.style = function style(field, cfg) {\n    var styleOptions = this.get('styleOptions');\n\n    if (!styleOptions) {\n      styleOptions = {};\n      this.set('styleOptions', styleOptions);\n    }\n\n    if (Util.isObject(field)) {\n      cfg = field;\n      field = null;\n    }\n\n    var fields;\n\n    if (field) {\n      fields = parseFields(field);\n    }\n\n    styleOptions.fields = fields;\n    styleOptions.style = cfg;\n    return this;\n  };\n\n  _proto.label = function label(field, callback, cfg) {\n    var self = this;\n    var labelCfg = self.get('labelCfg'); // const scales = Util.map(self.get('labelCfg').fields, field => self._createScale(field));\n\n    if (!labelCfg) {\n      labelCfg = {};\n      self.set('labelCfg', labelCfg);\n    }\n\n    var fields;\n\n    if (field) {\n      fields = parseFields(field);\n    }\n\n    labelCfg.fields = fields; // 如果存在回调函数\n\n    if (Util.isFunction(callback)) {\n      if (!cfg) {\n        cfg = {};\n      }\n\n      labelCfg.callback = callback;\n    } else if (Util.isObject(callback)) {\n      // 如果没有设置回调函数\n      cfg = callback;\n    }\n\n    labelCfg.globalCfg = cfg;\n    return this;\n  };\n\n  _proto.tooltip = function tooltip(field, cfg) {\n    var tooltipCfg = this.get('tooltipCfg');\n\n    if (!tooltipCfg) {\n      tooltipCfg = {};\n    }\n\n    if (field === false) {\n      // geom 关闭 tooltip\n      this.set('tooltipCfg', false);\n    } else {\n      var tooltipFields;\n\n      if (field) {\n        tooltipFields = parseFields(field);\n      }\n\n      tooltipCfg.fields = tooltipFields;\n      tooltipCfg.cfg = cfg;\n    }\n\n    this.set('tooltipCfg', tooltipCfg);\n    return this;\n  };\n\n  _proto.animate = function animate(cfg) {\n    this.set('animateCfg', cfg);\n    return this;\n  };\n  /**\n   * 是否允许使用默认的图形激活交互\n   * @param  {Boolean} enable 是否允许激活开关\n   * @param {Object} cfg 激活的配置项\n   * @return {Geom}    返回 geom 自身\n   */\n\n\n  _proto.active = function active(enable, cfg) {\n    if (enable === false) {\n      this.set('allowActive', false);\n    } else if (Util.isObject(enable)) {\n      this.set('allowActive', true);\n      this.set('activedOptions', enable);\n    } else {\n      this.set('allowActive', true);\n      this.set('activedOptions', cfg);\n    }\n\n    return this;\n  };\n  /**\n   * 对 geometry 进行数据调整\n   * @chainable\n   * @param  {String|Array|null} adjusts 数据调整的类型\n   * @return {Object} geometry 对象\n   */\n\n\n  _proto.adjust = function adjust(adjusts) {\n    if (!this.get('hasDefaultAdjust')) {\n      if (adjusts) {\n        adjusts = parseAdjusts(adjusts);\n      }\n\n      this.set('adjusts', adjusts);\n    }\n\n    return this;\n  };\n  /**\n   * 设置图形的选中模式\n   * @param  {Boolean|Object} enable 布尔类型用于模式开关，对象类型用于配置\n   * @param  {Object} cfg    选中配置项\n   * @return {Geom}          返回 geom 自身\n   */\n\n\n  _proto.select = function select(enable, cfg) {\n    if (enable === false) {\n      this.set('allowSelect', false);\n    } else if (Util.isObject(enable)) {\n      this.set('allowSelect', true);\n      this.set('selectedOptions', enable);\n    } else {\n      this.set('allowSelect', true);\n      this.set('selectedOptions', cfg);\n    }\n\n    return this;\n  };\n\n  _proto.hasAdjust = function hasAdjust(adjustType) {\n    var self = this;\n    var adjusts = self.get('adjusts');\n\n    if (!adjustType) {\n      return false;\n    }\n\n    var rst = false;\n    Util.each(adjusts, function (adjust) {\n      if (adjust.type === adjustType) {\n        rst = true;\n        return false;\n      }\n    });\n    return rst;\n  };\n\n  _proto.hasStack = function hasStack() {\n    var isStacked = this.get('isStacked');\n\n    if (Util.isNil(isStacked)) {\n      isStacked = this.hasAdjust('stack');\n      this.set('isStacked', isStacked);\n    }\n\n    return isStacked;\n  };\n\n  _proto.isInCircle = function isInCircle() {\n    var coord = this.get('coord');\n    return coord && coord.isPolar;\n  };\n\n  _proto._initContainer = function _initContainer() {\n    var self = this;\n    var shapeContainer = self.get('shapeContainer');\n\n    if (!shapeContainer) {\n      var container = self.get('container');\n      var view = self.get('view');\n      var viewId = view && view.get('_id');\n      shapeContainer = container.addGroup({\n        viewId: viewId,\n        visible: self.get('visible')\n      });\n      self.set('shapeContainer', shapeContainer);\n    }\n  };\n\n  _proto.init = function init() {\n    var self = this;\n\n    self._initContainer();\n\n    self._initAttrs();\n\n    if (self.get('tooltipCfg') && self.get('tooltipCfg').fields) {\n      var tooltipFields = self.get('tooltipCfg').fields;\n      Util.each(tooltipFields, function (field) {\n        self._createScale(field);\n      });\n    }\n\n    var dataArray = self._processData();\n\n    if (self.get('adjusts')) {\n      self._adjust(dataArray);\n    }\n\n    self.set('dataArray', dataArray);\n  }; // step 1: init attrs\n\n\n  _proto._initAttrs = function _initAttrs() {\n    var self = this;\n    var attrs = self.get('attrs');\n    var attrOptions = self.get('attrOptions');\n    var coord = self.get('coord');\n    var viewTheme = self.viewTheme || Global;\n    var isPie = false;\n\n    for (var type in attrOptions) {\n      if (attrOptions.hasOwnProperty(type)) {\n        var option = attrOptions[type];\n        var className = Util.upperFirst(type);\n        var fields = parseFields(option.field);\n\n        if (type === 'position') {\n          option.coord = coord; // 饼图坐标系下，填充一维\n\n          if (fields.length === 1 && coord.type === 'theta') {\n            fields.unshift('1');\n            isPie = true;\n          }\n        }\n\n        var scales = [];\n\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n\n          var scale = self._createScale(field);\n\n          if (type === 'color' && Util.isNil(option.values)) {\n            // 设置 color 的默认色值\n            if (scale.values.length <= 8) {\n              option.values = isPie ? viewTheme.colors_pie : viewTheme.colors;\n            } else if (scale.values.length <= 16) {\n              option.values = isPie ? viewTheme.colors_pie_16 : viewTheme.colors_16;\n            } else {\n              option.values = viewTheme.colors_24;\n            }\n\n            if (Util.isNil(option.values)) {\n              option.values = viewTheme.colors; // 防止主题没有声明诸如 colors_pie 的属性\n            }\n          }\n\n          scales.push(scale);\n        } // 饼图需要填充满整个空间\n\n\n        if (coord.type === 'theta' && type === 'position' && scales.length > 1) {\n          var yScale = scales[1];\n          yScale.change({\n            nice: false,\n            min: 0,\n            max: Math.max.apply(null, yScale.values)\n          });\n        }\n\n        option.scales = scales;\n        var attr = new Attr[className](option);\n        attrs[type] = attr;\n      }\n    }\n  }; // step 2: 处理数据\n\n\n  _proto._processData = function _processData() {\n    var self = this;\n    var data = this.get('data');\n    var dataArray = [];\n\n    var groupedArray = this._groupData(data);\n\n    for (var i = 0; i < groupedArray.length; i++) {\n      var subData = groupedArray[i];\n\n      var tempData = self._saveOrigin(subData);\n\n      self._numberic(tempData);\n\n      dataArray.push(tempData);\n    }\n\n    return dataArray;\n  }; // step 2.1 数据分组\n\n\n  _proto._groupData = function _groupData(data) {\n    var groupScales = this._getGroupScales();\n\n    var fields = groupScales.map(function (scale) {\n      return scale.field;\n    });\n    return Util.Array.group(data, fields);\n  }; // step 2.2 数据调整前保存原始数据\n\n\n  _proto._saveOrigin = function _saveOrigin(data) {\n    var rst = [];\n\n    for (var i = 0; i < data.length; i++) {\n      var origin = data[i];\n      var obj = {};\n\n      for (var k in origin) {\n        obj[k] = origin[k];\n      } // const obj = Util.mix({}, origin);\n\n\n      obj[FIELD_ORIGIN] = origin;\n      rst.push(obj);\n    }\n\n    return rst;\n  }; // step 2.3 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n\n\n  _proto._numberic = function _numberic(data) {\n    var positionAttr = this.getAttr('position');\n    var scales = positionAttr.scales;\n\n    for (var j = 0; j < data.length; j++) {\n      var obj = data[j];\n\n      for (var i = 0; i < Math.min(2, scales.length); i++) {\n        var scale = scales[i];\n\n        if (scale.isCategory) {\n          var field = scale.field;\n          obj[field] = scale.translate(obj[field]);\n        }\n      }\n    }\n  };\n\n  _proto._getGroupScales = function _getGroupScales() {\n    var self = this;\n    var scales = self.get('groupScales');\n\n    if (!scales) {\n      scales = [];\n      var attrs = self.get('attrs');\n      Util.each(attrs, function (attr) {\n        if (GROUP_ATTRS.indexOf(attr.type) !== -1) {\n          var attrScales = attr.scales;\n          Util.each(attrScales, function (scale) {\n            if (scale.isCategory && Util.indexOf(scales, scale) === -1) {\n              scales.push(scale);\n            }\n          });\n        }\n      });\n      self.set('groupScales', scales);\n    }\n\n    return scales;\n  };\n\n  _proto._updateStackRange = function _updateStackRange(field, scale, dataArray) {\n    var mergeArray = Util.Array.merge(dataArray);\n    var min = scale.min;\n    var max = scale.max;\n\n    for (var i = 0; i < mergeArray.length; i++) {\n      var obj = mergeArray[i];\n      var tmpMin = Math.min.apply(null, obj[field]);\n      var tmpMax = Math.max.apply(null, obj[field]);\n\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n\n    if (min < scale.min || max > scale.max) {\n      scale.change({\n        min: min,\n        max: max\n      });\n    }\n  }; // step 2.2 调整数据\n\n\n  _proto._adjust = function _adjust(dataArray) {\n    var self = this;\n    var adjusts = self.get('adjusts');\n    var viewTheme = this.viewTheme || Global;\n    var yScale = self.getYScale();\n    var xScale = self.getXScale();\n    var xField = xScale.field;\n    var yField = yScale ? yScale.field : null;\n    Util.each(adjusts, function (adjust) {\n      var adjustCfg = Util.mix({\n        xField: xField,\n        yField: yField\n      }, adjust);\n      var adjustType = Util.upperFirst(adjust.type);\n\n      if (adjustType === 'Dodge') {\n        var adjustNames = [];\n\n        if (xScale.isCategory || xScale.isIdentity) {\n          adjustNames.push('x');\n        } else if (!yScale) {\n          adjustNames.push('y');\n        } else {\n          throw new Error('dodge is not support linear attribute, please use category attribute!');\n        }\n\n        adjustCfg.adjustNames = adjustNames;\n        adjustCfg.dodgeRatio = viewTheme.widthRatio.column;\n        /* if (self.isInCircle()) {\n          adjustCfg.dodgeRatio = 1;\n          adjustCfg.marginRatio = 0;\n        }*/\n      } else if (adjustType === 'Stack') {\n        var coord = self.get('coord');\n\n        if (!yScale) {\n          // 一维的情况下获取高度和默认size\n          adjustCfg.height = coord.getHeight();\n          var size = self.getDefaultValue('size') || 3;\n          adjustCfg.size = size;\n        } // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n\n\n        if (!coord.isTransposed && Util.isNil(adjustCfg.reverseOrder)) {\n          adjustCfg.reverseOrder = true;\n        }\n      }\n\n      var adjustElement = new Adjust[adjustType](adjustCfg);\n      adjustElement.processAdjust(dataArray);\n\n      if (adjustType === 'Stack' && yScale) {\n        self._updateStackRange(yField, yScale, dataArray);\n      }\n    });\n  };\n  /**\n   * @internal 设置coord，通常外部容器变化时，coord 会发生变化\n   * @param {Object} coord 坐标系\n   */\n\n\n  _proto.setCoord = function setCoord(coord) {\n    this.set('coord', coord);\n    var position = this.getAttr('position');\n    var shapeContainer = this.get('shapeContainer');\n    shapeContainer.setMatrix(coord.matrix);\n\n    if (position) {\n      position.coord = coord;\n    }\n  }; // step 3 绘制\n\n\n  _proto.paint = function paint() {\n    var self = this;\n    var dataArray = self.get('dataArray');\n    var mappedArray = [];\n    var shapeFactory = self.getShapeFactory();\n    shapeFactory.setCoord(self.get('coord'));\n    self.set('shapeFactory', shapeFactory);\n    var shapeContainer = self.get('shapeContainer');\n\n    self._beforeMapping(dataArray);\n\n    for (var i = 0; i < dataArray.length; i++) {\n      var data = dataArray[i];\n      var index = i;\n      data = self._mapping(data);\n      mappedArray.push(data);\n      self.draw(data, shapeContainer, shapeFactory, index);\n    }\n\n    if (self.get('labelCfg')) {\n      self._addLabels(Util.union.apply(null, mappedArray), shapeContainer.get('children'));\n    }\n\n    if (!self.get('sortable')) {\n      self._sort(mappedArray); // 便于数据的查找，需要对数据进行排序，用于 geom.findPoint()\n\n    } else {\n      self.set('dataArray', mappedArray);\n    }\n  };\n\n  _proto._sort = function _sort(mappedArray) {\n    var self = this;\n    var xScale = self.getXScale();\n    var xField = xScale.field;\n    Util.each(mappedArray, function (itemArr) {\n      itemArr.sort(function (obj1, obj2) {\n        return xScale.translate(obj1[FIELD_ORIGIN][xField]) - xScale.translate(obj2[FIELD_ORIGIN][xField]);\n      });\n    });\n    self.set('dataArray', mappedArray);\n  }; // step 3.1 before mapping\n\n\n  _proto._beforeMapping = function _beforeMapping(dataArray) {\n    var self = this;\n\n    if (self.get('sortable')) {\n      var xScale = self.getXScale();\n      var field = xScale.field;\n      Util.each(dataArray, function (data) {\n        data.sort(function (v1, v2) {\n          return xScale.translate(v1[field]) - xScale.translate(v2[field]);\n        });\n      });\n    }\n\n    if (self.get('generatePoints')) {\n      Util.each(dataArray, function (data) {\n        self._generatePoints(data);\n      });\n      Util.each(dataArray, function (data, index) {\n        var nextData = dataArray[index + 1];\n\n        if (nextData) {\n          data[0].nextPoints = nextData[0].points;\n        }\n      });\n    }\n  }; // step 3.2 add labels\n\n\n  _proto._addLabels = function _addLabels(points, shapes) {\n    var self = this;\n    var type = self.get('type');\n    var viewTheme = self.get('viewTheme') || Global;\n    var coord = self.get('coord');\n    var C = Labels.getLabelsClass(coord.type, type);\n    var container = self.get('container');\n    var scales = Util.map(self.get('labelCfg').fields, function (field) {\n      return self._createScale(field);\n    });\n    var labelContainer = container.addGroup(C, {\n      _id: this.get('_id'),\n      labelCfg: Util.mix({\n        scales: scales\n      }, self.get('labelCfg')),\n      coord: coord,\n      geom: self,\n      geomType: type,\n      viewTheme: viewTheme,\n      visible: self.get('visible')\n    });\n    labelContainer.showLabels(points, shapes);\n    self.set('labelContainer', labelContainer);\n  };\n  /**\n   * @protected\n   * 获取图形的工厂类\n   * @return {Object} 工厂类对象\n   */\n\n\n  _proto.getShapeFactory = function getShapeFactory() {\n    var shapeFactory = this.get('shapeFactory');\n\n    if (!shapeFactory) {\n      var shapeType = this.get('shapeType');\n      shapeFactory = Shape.getShapeFactory(shapeType);\n      this.set('shapeFactory', shapeFactory);\n    }\n\n    return shapeFactory;\n  }; // step 3.2 generate points\n\n\n  _proto._generatePoints = function _generatePoints(data) {\n    var self = this;\n    var shapeFactory = self.getShapeFactory();\n    var shapeAttr = self.getAttr('shape');\n\n    for (var i = 0; i < data.length; i++) {\n      var obj = data[i];\n      var cfg = self.createShapePointsCfg(obj);\n      var shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;\n      var points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  };\n  /**\n   * 获取图形对应点的配置项\n   * @protected\n   * @param  {Object} obj 数据对象\n   * @return {Object} cfg 获取图形对应点的配置项\n   */\n\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n\n    var x = this._normalizeValues(obj[xScale.field], xScale);\n\n    var y; // 存在没有 y 的情况\n\n    if (yScale) {\n      y = this._normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x: x,\n      y: y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  };\n  /**\n   * @protected\n   * 如果y轴的最小值小于0则返回0，否则返回最小值\n   * @return {Number} y轴上的最小值\n   */\n\n\n  _proto.getYMinValue = function getYMinValue() {\n    var yScale = this.getYScale();\n    var min = yScale.min,\n        max = yScale.max;\n    var value;\n\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n\n    return value;\n  }; // 将数据归一化\n\n\n  _proto._normalizeValues = function _normalizeValues(values, scale) {\n    var rst = [];\n\n    if (Util.isArray(values)) {\n      for (var i = 0; i < values.length; i++) {\n        var v = values[i];\n        rst.push(scale.scale(v));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n\n    return rst;\n  }; // step 3.2 mapping\n\n\n  _proto._mapping = function _mapping(data) {\n    var self = this;\n    var attrs = self.get('attrs');\n    var mappedData = [];\n\n    for (var i = 0; i < data.length; i++) {\n      var record = data[i];\n      var newRecord = {};\n      newRecord[FIELD_ORIGIN] = record[FIELD_ORIGIN];\n      newRecord.points = record.points;\n      newRecord.nextPoints = record.nextPoints;\n\n      for (var k in attrs) {\n        if (attrs.hasOwnProperty(k)) {\n          var attr = attrs[k];\n          var names = attr.names;\n\n          var values = self._getAttrValues(attr, record);\n\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (var j = 0; j < values.length; j++) {\n              var val = values[j];\n              var name = names[j];\n              newRecord[name] = Util.isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n\n      mappedData.push(newRecord);\n    }\n\n    return mappedData;\n  }; // 获取属性映射的值\n\n\n  _proto._getAttrValues = function _getAttrValues(attr, record) {\n    var scales = attr.scales;\n    var params = [];\n\n    for (var i = 0; i < scales.length; i++) {\n      var scale = scales[i];\n      var field = scale.field;\n\n      if (scale.type === 'identity') {\n        params.push(scale.value);\n      } else {\n        params.push(record[field]);\n      }\n    }\n\n    var values = attr.mapping.apply(attr, params);\n    return values;\n  };\n\n  _proto.getAttrValue = function getAttrValue(attrName, record) {\n    var attr = this.getAttr(attrName);\n    var rst = null;\n\n    if (attr) {\n      var values = this._getAttrValues(attr, record);\n\n      rst = values[0];\n    }\n\n    return rst;\n  };\n\n  _proto.getDefaultValue = function getDefaultValue(attrName) {\n    var value = this.get(attrName);\n    var attr = this.getAttr(attrName);\n\n    if (attr) {\n      var scale = attr.getScale(attrName);\n\n      if (scale.type === 'identity') {\n        value = scale.value;\n      }\n    }\n\n    return value;\n  };\n  /**\n   * step 3.3 draw\n   * @protected\n   * @param  {Array} data 绘制图形\n   * @param {Object} container 绘图容器\n   * @param {Object} shapeFactory 绘制图形的工厂类\n   * @param {Number} index 每个 shape 的索引值\n   */\n\n\n  _proto.draw = function draw(data, container, shapeFactory, index) {\n    var self = this;\n\n    for (var i = 0; i < data.length; i++) {\n      var obj = data[i];\n      self.drawPoint(obj, container, shapeFactory, index + i);\n    }\n  };\n\n  _proto.getCallbackCfg = function getCallbackCfg(fields, cfg, origin) {\n    if (!fields) {\n      return cfg;\n    }\n\n    var tmpCfg = {};\n    var params = fields.map(function (field) {\n      return origin[field];\n    });\n    Util.each(cfg, function (v, k) {\n      if (Util.isFunction(v)) {\n        tmpCfg[k] = v.apply(null, params);\n      } else {\n        tmpCfg[k] = v;\n      }\n    });\n    return tmpCfg;\n  };\n\n  _proto._getShapeId = function _getShapeId(dataObj) {\n    var id = this.get('_id');\n    var keyFields = this.get('keyFields');\n\n    if (keyFields && keyFields.length > 0) {\n      Util.each(keyFields, function (key) {\n        id += '-' + dataObj[key];\n      });\n    } else {\n      var type = this.get('type');\n      var xScale = this.getXScale();\n      var yScale = this.getYScale();\n      var xField = xScale.field || 'x';\n      var yField = yScale.field || 'y';\n      var yVal = dataObj[yField];\n      var xVal;\n\n      if (xScale.isIdentity) {\n        xVal = xScale.value;\n      } else {\n        xVal = dataObj[xField];\n      }\n\n      if (type === 'interval' || type === 'schema') {\n        id += '-' + xVal;\n      } else if (type === 'line' || type === 'area' || type === 'path') {\n        id += '-' + type;\n      } else {\n        id += '-' + xVal + '-' + yVal;\n      }\n\n      var groupScales = this._getGroupScales();\n\n      if (!Util.isEmpty(groupScales)) {\n        Util.each(groupScales, function (groupScale) {\n          var field = groupScale.field;\n\n          if (groupScale.type !== 'identity') {\n            id += '-' + dataObj[field];\n          }\n        });\n      }\n    }\n\n    return id;\n  };\n\n  _proto.getDrawCfg = function getDrawCfg(obj) {\n    var self = this;\n    var cfg = {\n      origin: obj,\n      x: obj.x,\n      y: obj.y,\n      color: obj.color,\n      size: obj.size,\n      shape: obj.shape,\n      isInCircle: self.isInCircle(),\n      opacity: obj.opacity\n    };\n    var styleOptions = self.get('styleOptions');\n\n    if (styleOptions && styleOptions.style) {\n      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);\n    }\n\n    if (self.get('generatePoints')) {\n      cfg.points = obj.points;\n      cfg.nextPoints = obj.nextPoints;\n    }\n\n    if (self.get('animate')) {\n      // _id 字段仅用于动画\n      cfg._id = self._getShapeId(obj[FIELD_ORIGIN]);\n    }\n\n    return cfg;\n  };\n\n  _proto.appendShapeInfo = function appendShapeInfo(shape, index) {\n    if (shape) {\n      shape.setSilent('index', index);\n      shape.setSilent('coord', this.get('coord'));\n\n      if (this.get('animate') && this.get('animateCfg')) {\n        shape.setSilent('animateCfg', this.get('animateCfg'));\n      }\n    }\n  };\n\n  _proto._applyViewThemeShapeStyle = function _applyViewThemeShapeStyle(cfg, shape, shapeFactory) {\n    // applying view theme\n    var self = this;\n    var viewTheme = self.viewTheme || Global;\n    var shapeName = shapeFactory.name;\n\n    if (shape) {\n      if (shape && (shape.indexOf('hollow') > -1 || shape.indexOf('liquid') > -1)) {\n        shapeName = \"hollow\" + Util.upperFirst(shapeName);\n      }\n    } else if (shapeFactory.defaultShapeType.indexOf('hollow') > -1) {\n      shapeName = \"hollow\" + Util.upperFirst(shapeName);\n    }\n\n    var defaultStyle = viewTheme.shape[shapeName] || {};\n    cfg.style = Util.mix({}, defaultStyle, cfg.style);\n  };\n\n  _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {\n    var self = this;\n    var shape = obj.shape;\n    var cfg = self.getDrawCfg(obj);\n\n    self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);\n\n    var geomShape = shapeFactory.drawShape(shape, cfg, container);\n    self.appendShapeInfo(geomShape, index);\n  };\n  /**\n   * 获取属性\n   * @protected\n   * @param {String} name 属性名\n   * @return {Scale} 度量\n   */\n\n\n  _proto.getAttr = function getAttr(name) {\n    return this.get('attrs')[name];\n  };\n  /**\n   * 获取 x 对应的度量\n   * @return {Scale} x 对应的度量\n   */\n\n\n  _proto.getXScale = function getXScale() {\n    return this.getAttr('position').scales[0];\n  };\n  /**\n   * 获取 y 对应的度量\n   * @return {Scale} y 对应的度量\n   */\n\n\n  _proto.getYScale = function getYScale() {\n    return this.getAttr('position').scales[1];\n  };\n\n  _proto.getShapes = function getShapes() {\n    var result = [];\n    var shapeContainer = this.get('shapeContainer');\n    var children = shapeContainer.get('children');\n    Util.each(children, function (child) {\n      if (child.get('origin')) {\n        // 过滤 label\n        result.push(child);\n      }\n    });\n    return result;\n  };\n\n  _proto.getAttrsForLegend = function getAttrsForLegend() {\n    var attrs = this.get('attrs');\n    var rst = [];\n    Util.each(attrs, function (attr) {\n      if (GROUP_ATTRS.indexOf(attr.type) !== -1) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  };\n\n  _proto.getFieldsForLegend = function getFieldsForLegend() {\n    var fields = [];\n    var attrOptions = this.get('attrOptions');\n    Util.each(GROUP_ATTRS, function (attrName) {\n      var attrCfg = attrOptions[attrName];\n\n      if (attrCfg && attrCfg.field && Util.isString(attrCfg.field)) {\n        fields = fields.concat(attrCfg.field.split('*'));\n      }\n    });\n    return Util.uniq(fields);\n  };\n\n  _proto.changeVisible = function changeVisible(visible, stopDraw) {\n    var me = this;\n    me.set('visible', visible);\n    var shapeContainer = this.get('shapeContainer');\n\n    if (shapeContainer) {\n      shapeContainer.set('visible', visible);\n    }\n\n    var labelContainer = this.get('labelContainer');\n\n    if (labelContainer) {\n      labelContainer.set('visible', visible);\n    }\n\n    if (!stopDraw && shapeContainer) {\n      var canvas = shapeContainer.get('canvas');\n      canvas.draw();\n    }\n  };\n\n  _proto.reset = function reset() {\n    this.set('attrOptions', {});\n    this.clearInner();\n  };\n\n  _proto.clearInner = function clearInner() {\n    this.clearActivedShapes();\n    this.clearSelected();\n    var shapeContainer = this.get('shapeContainer');\n    shapeContainer && shapeContainer.clear(); // 由于 Labels 对应的模块需要生成group，所以这个地方需要删除\n\n    var labelContainer = this.get('labelContainer');\n    labelContainer && labelContainer.remove();\n    this.set('attrs', {});\n    this.set('groupScales', null); // if (!this.get('hasDefaultAdjust')) {\n    //   this.set('adjusts', null);\n    // }\n\n    this.set('labelContainer', null);\n    this.set('xDistance', null);\n    this.set('isStacked', null);\n  };\n\n  _proto.clear = function clear() {\n    this.clearInner();\n    this.set('scales', {});\n  };\n\n  _proto.destroy = function destroy() {\n    this.clear();\n    var shapeContainer = this.get('shapeContainer');\n    shapeContainer && shapeContainer.remove();\n    this.offEvents();\n\n    _Base.prototype.destroy.call(this);\n  };\n\n  _proto.bindEvents = function bindEvents() {\n    if (this.get('view')) {\n      this._bindActiveAction();\n\n      this._bindSelectedAction();\n    }\n  };\n\n  _proto.offEvents = function offEvents() {\n    if (this.get('view')) {\n      this._offActiveAction();\n\n      this._offSelectedAction();\n    }\n  };\n\n  return GeomBase;\n}(Base);\n\nmodule.exports = GeomBase;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Axis: __webpack_require__(306),\n  Component: __webpack_require__(66),\n  Guide: __webpack_require__(314),\n  Label: __webpack_require__(323),\n  Legend: __webpack_require__(324),\n  Tooltip: __webpack_require__(330)\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 计算path 使用的工具方法\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Spline = __webpack_require__(334);\n\nfunction points2path(points, isInCircle) {\n  if (!points.length) {\n    return [];\n  }\n\n  var path = [];\n\n  for (var i = 0, length = points.length; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      path.push(['M', item.x, item.y]);\n    } else {\n      path.push(['L', item.x, item.y]);\n    }\n  }\n\n  if (isInCircle) {\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\nfunction _getPointRadius(coord, point) {\n  var center = coord.getCenter();\n  var r = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n  return r;\n}\n\nfunction convertArr(arr, coord) {\n  var len = arr.length;\n  var tmp = [arr[0]];\n\n  for (var i = 1; i < len; i = i + 2) {\n    var point = coord.convertPoint({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  // const radius = coord.getRadius();\n  // const inner = coord.innerRadius || 0;\n  // let innerRadius = inner * radius;\n  var transposed = coord.isTransposed;\n  var startAngle = coord.startAngle;\n  var endAngle = coord.endAngle;\n  var prePoint = {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = []; // innerRadius = innerRadius || 0;\n\n  var xDim = transposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convertPoint(curPoint);\n\n  var r = _getPointRadius(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convertPoint(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction filterFullCirleLine(path) {\n  Util.each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\nvar PathUtil = {\n  // 线的path\n  getLinePath: function getLinePath(points, isInCircle) {\n    return points2path(points, isInCircle);\n  },\n  // get spline： 限定了范围的平滑线\n  getSplinePath: function getSplinePath(points, isInCircle, constaint) {\n    var data = [];\n    var first = points[0];\n    var prePoint = null;\n\n    if (points.length <= 2) {\n      return PathUtil.getLinePath(points, isInCircle);\n    }\n\n    Util.each(points, function (point) {\n      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n        data.push(point.x);\n        data.push(point.y);\n        prePoint = point;\n      }\n    });\n    constaint = constaint || [// 范围\n    [0, 0], [1, 1]];\n    var splinePath = Spline.catmullRom2bezier(data, isInCircle, constaint);\n    splinePath.unshift(['M', first.x, first.y]);\n    return splinePath;\n  },\n  getPointRadius: function getPointRadius(coord, point) {\n    var result = _getPointRadius(coord, point);\n\n    return result;\n  },\n  getPointAngle: function getPointAngle(coord, point) {\n    var center = coord.getCenter();\n    var angle = Math.atan2(point.y - center.y, point.x - center.x);\n    return angle;\n  },\n  convertNormalPath: function convertNormalPath(coord, path) {\n    var tmp = [];\n    Util.each(path, function (subPath) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'l':\n        case 'c':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    return tmp;\n  },\n  convertPolarPath: function convertPolarPath(coord, path) {\n    var tmp = [];\n    var pre;\n    var cur;\n    var transposed;\n    var equals;\n    Util.each(path, function (subPath, index) {\n      var action = subPath[0];\n\n      switch (action.toLowerCase()) {\n        case 'm':\n        case 'c':\n        case 'q':\n          tmp.push(convertArr(subPath, coord));\n          break;\n\n        case 'l':\n          pre = path[index - 1];\n          cur = subPath;\n          transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n          equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n          if (equals) {\n            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n          } else {\n            // y 不相等，所以直接转换\n            tmp.push(convertArr(subPath, coord));\n          }\n\n          break;\n\n        case 'z':\n        default:\n          tmp.push(subPath);\n          break;\n      }\n    });\n    filterFullCirleLine(tmp); // 过滤多余的直线\n\n    return tmp;\n  }\n};\nmodule.exports = PathUtil;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(5);\n\nfunction toString(value) {\n  if (isNil(value)) return '';\n  return value.toString();\n}\n\nmodule.exports = toString;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObject = function isObject(value) {\n  /**\n   * isObject({}) => true\n   * isObject([1, 2, 3]) => true\n   * isObject(Function) => true\n   * isObject(null) => false\n   */\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return value !== null && type === 'object' || type === 'function';\n};\n\nmodule.exports = isObject;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Canvas: __webpack_require__(181),\n  Group: __webpack_require__(101),\n  Shape: __webpack_require__(6),\n  Arc: __webpack_require__(105),\n  Circle: __webpack_require__(106),\n  Dom: __webpack_require__(107),\n  Ellipse: __webpack_require__(108),\n  Fan: __webpack_require__(109),\n  Image: __webpack_require__(110),\n  Line: __webpack_require__(111),\n  Marker: __webpack_require__(56),\n  Path: __webpack_require__(112),\n  Polygon: __webpack_require__(113),\n  Polyline: __webpack_require__(114),\n  Rect: __webpack_require__(115),\n  Text: __webpack_require__(116),\n  PathSegment: __webpack_require__(39),\n  PathUtil: __webpack_require__(57),\n  Event: __webpack_require__(100),\n  // version, etc.\n  version: '3.3.5'\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObjectLike = __webpack_require__(48);\n\nvar isType = __webpack_require__(12);\n\nvar isPlainObject = function isPlainObject(value) {\n  /**\n   * isObjectLike(new Foo) => false\n   * isObjectLike([1, 2, 3]) => false\n   * isObjectLike({ x: 0, y: 0 }) => true\n   * isObjectLike(Object.create(null)) => true\n   */\n  if (!isObjectLike(value) || !isType(value, 'Object')) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(value) === null) {\n    return true;\n  }\n\n  var proto = value;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(value) === proto;\n};\n\nmodule.exports = isPlainObject;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nvar regexDot = /[^\\s\\,]+/ig;\nmodule.exports = {\n  parseRadius: function parseRadius(radius) {\n    var r1 = 0,\n        r2 = 0,\n        r3 = 0,\n        r4 = 0;\n\n    if (Util.isArray(radius)) {\n      if (radius.length === 1) {\n        r1 = r2 = r3 = r4 = radius[0];\n      } else if (radius.length === 2) {\n        r1 = r3 = radius[0];\n        r2 = r4 = radius[1];\n      } else if (radius.length === 3) {\n        r1 = radius[0];\n        r2 = r4 = radius[1];\n        r3 = radius[2];\n      } else {\n        r1 = radius[0];\n        r2 = radius[1];\n        r3 = radius[2];\n        r4 = radius[3];\n      }\n    } else {\n      r1 = r2 = r3 = r4 = radius;\n    }\n\n    return {\n      r1: r1,\n      r2: r2,\n      r3: r3,\n      r4: r4\n    };\n  },\n  parsePath: function parsePath(path) {\n    path = path || [];\n\n    if (Util.isArray(path)) {\n      return path;\n    }\n\n    if (Util.isString(path)) {\n      path = path.match(regexTags);\n      Util.each(path, function (item, index) {\n        item = item.match(regexDot);\n\n        if (item[0].length > 1) {\n          var tag = item[0].charAt(0);\n          item.splice(1, 0, item[0].substr(1));\n          item[0] = tag;\n        }\n\n        Util.each(item, function (sub, i) {\n          if (!isNaN(sub)) {\n            item[i] = +sub;\n          }\n        });\n        path[index] = item;\n      });\n      return path;\n    }\n  }\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = hue;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = gamma;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = nogamma;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant__ = __webpack_require__(121);\n\n\nfunction linear(a, d) {\n  return function (t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nfunction hue(a, b) {\n  var d = b - a;\n  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__[\"a\" /* default */])(isNaN(a) ? b : a);\n}\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function (a, b) {\n    return b - a ? exponential(a, b, y) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__[\"a\" /* default */])(isNaN(a) ? b : a);\n  };\n}\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : Object(__WEBPACK_IMPORTED_MODULE_0__constant__[\"a\" /* default */])(isNaN(a) ? b : a);\n}\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview the Attribute base class\n */\nvar isString = __webpack_require__(10);\n\nvar isArray = __webpack_require__(4);\n\nvar isNil = __webpack_require__(5);\n\nvar mix = __webpack_require__(8);\n\nvar each = __webpack_require__(2);\n\nfunction toScaleString(scale, value) {\n  if (isString(value)) {\n    return value;\n  }\n\n  return scale.invert(scale.scale(value));\n}\n/**\n * 所有视觉通道属性的基类\n * @class Attr\n */\n\n\nvar AttributeBase =\n/*#__PURE__*/\nfunction () {\n  function AttributeBase(cfg) {\n    var _this = this;\n    /**\n     * 属性的类型\n     * @type {String}\n     */\n\n\n    this.type = 'base';\n    /**\n     * 属性的名称\n     * @type {String}\n     */\n\n    this.name = null;\n    /**\n     * 回调函数\n     * @type {Function}\n     */\n\n    this.method = null;\n    /**\n     * 备选的值数组\n     * @type {Array}\n     */\n\n    this.values = [];\n    /**\n     * 属性内部的度量\n     * @type {Array}\n     */\n\n    this.scales = [];\n    /**\n     * 是否通过线性取值, 如果未指定，则根据数值的类型判定\n     * @type {Boolean}\n     */\n\n    this.linear = null;\n    /**\n     * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值\n     */\n\n    var mixedCallback = null;\n    var defaultCallback = this.callback;\n\n    if (cfg.callback) {\n      var userCallback = cfg.callback;\n\n      mixedCallback = function mixedCallback() {\n        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n          params[_key] = arguments[_key];\n        }\n\n        var ret = userCallback.apply(void 0, params);\n\n        if (isNil(ret)) {\n          ret = defaultCallback.apply(_this, params);\n        }\n\n        return ret;\n      };\n    }\n\n    mix(this, cfg);\n\n    if (mixedCallback) {\n      mix(this, {\n        callback: mixedCallback\n      });\n    }\n  } // 获取属性值，将值映射到视觉通道\n\n\n  var _proto = AttributeBase.prototype;\n\n  _proto._getAttrValue = function _getAttrValue(scale, value) {\n    var values = this.values;\n\n    if (scale.isCategory && !this.linear) {\n      var index = scale.translate(value);\n      return values[index % values.length];\n    }\n\n    var percent = scale.scale(value);\n    return this.getLinearValue(percent);\n  };\n  /**\n   * 如果进行线性映射，返回对应的映射值\n   * @protected\n   * @param  {Number} percent 百分比\n   * @return {*}  颜色值、形状、大小等\n   */\n\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var values = this.values;\n    var steps = values.length - 1;\n    var step = Math.floor(steps * percent);\n    var leftPercent = steps * percent - step;\n    var start = values[step];\n    var end = step === steps ? start : values[step + 1];\n    var rstValue = start + (end - start) * leftPercent;\n    return rstValue;\n  };\n  /**\n   * 默认的回调函数\n   * @param {*} value 回调函数的值\n   * @type {Function}\n   * @return {Array} 返回映射后的值\n   */\n\n\n  _proto.callback = function callback(value) {\n    var self = this;\n    var scale = self.scales[0];\n    var rstValue = null;\n\n    if (scale.type === 'identity') {\n      rstValue = scale.value;\n    } else {\n      rstValue = self._getAttrValue(scale, value);\n    }\n\n    return rstValue;\n  };\n  /**\n   * 根据度量获取属性名\n   * @return {Array} dims of this Attribute\n   */\n\n\n  _proto.getNames = function getNames() {\n    var scales = this.scales;\n    var names = this.names;\n    var length = Math.min(scales.length, names.length);\n    var rst = [];\n\n    for (var i = 0; i < length; i++) {\n      rst.push(names[i]);\n    }\n\n    return rst;\n  };\n  /**\n   * 根据度量获取维度名\n   * @return {Array} dims of this Attribute\n   */\n\n\n  _proto.getFields = function getFields() {\n    var scales = this.scales;\n    var rst = [];\n    each(scales, function (scale) {\n      rst.push(scale.field);\n    });\n    return rst;\n  };\n  /**\n   * 根据名称获取度量\n   * @param  {String} name the name of scale\n   * @return {Scale} scale\n   */\n\n\n  _proto.getScale = function getScale(name) {\n    var scales = this.scales;\n    var names = this.names;\n    var index = names.indexOf(name);\n    return scales[index];\n  };\n  /**\n   * 映射数据\n   * @param {*} param1...paramn 多个数值\n   * @return {Array} 映射的值组成的数组\n   */\n\n\n  _proto.mapping = function mapping() {\n    var scales = this.scales;\n    var callback = this.callback;\n\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n\n    var values = params;\n\n    if (callback) {\n      for (var i = 0, len = params.length; i < len; i++) {\n        params[i] = this._toOriginParam(params[i], scales[i]);\n      }\n\n      values = callback.apply(this, params);\n    }\n\n    values = [].concat(values);\n    return values;\n  }; // 原始的参数\n\n\n  _proto._toOriginParam = function _toOriginParam(param, scale) {\n    var rst = param;\n\n    if (!scale.isLinear) {\n      if (isArray(param)) {\n        rst = [];\n\n        for (var i = 0, len = param.length; i < len; i++) {\n          rst.push(toScaleString(scale, param[i]));\n        }\n      } else {\n        rst = toScaleString(scale, param);\n      }\n    }\n\n    return rst;\n  };\n\n  return AttributeBase;\n}();\n\nmodule.exports = AttributeBase;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mix = __webpack_require__(8);\n\nvar Adjust =\n/*#__PURE__*/\nfunction () {\n  var _proto = Adjust.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整\n  };\n\n  function Adjust(cfg) {\n    this._initDefaultCfg();\n\n    mix(this, cfg);\n  }\n  /**\n   * @override\n   */\n\n\n  _proto.processAdjust = function processAdjust()\n  /* dataArray */\n  {};\n\n  return Adjust;\n}();\n\nmodule.exports = Adjust;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Component = __webpack_require__(32);\n\nvar Util = __webpack_require__(3);\n\nvar Grid = __webpack_require__(153);\n\nvar Label = __webpack_require__(154);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar Axis =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Axis, _Component);\n\n  function Axis() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Axis.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Component.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 用于动画，唯一标识的 id\n       * @type {[type]}\n       */\n      _id: null,\n      zIndex: 4,\n\n      /**\n       * 坐标轴上的坐标点\n       * @type {Array}\n       */\n      ticks: null,\n\n      /**\n       * 坐标轴线的配置信息，如果设置成null，则不显示轴线\n       * @type {Object}\n       */\n      line: null,\n\n      /**\n       * 坐标轴刻度线的配置,如果设置成null，则不显示刻度线\n       * @type {Object}\n       */\n      tickLine: null,\n\n      /**\n       * 次刻度线个数配置\n       * @type {Number}\n       */\n      subTickCount: 0,\n\n      /**\n       * 次刻度线样式配置\n       * @type {Object}\n       */\n      subTickLine: null,\n\n      /**\n       * 网格线配置，如果值为 null，则不显示\n       * @type {Object}\n       */\n      grid: null,\n\n      /**\n       * 坐标轴文本配置\n       * @type {Object}\n       */\n      label: {\n        offset: 0,\n        offsetX: 0,\n        offsetY: 0,\n        textStyle: {},\n        // 坐标轴文本样式\n        autoRotate: true,\n        autoHide: false,\n        formatter: null // 坐标轴文本格式化回调函数\n\n      },\n      labelItems: [],\n\n      /**\n       * 坐标轴标题配置\n       * @type {Object}\n       */\n      title: {\n        autoRotate: true,\n        // 文本是否自动旋转\n        textStyle: {} // 坐标轴标题样式\n\n      },\n      autoPaint: true\n    });\n  };\n\n  _proto.beforeRender = function beforeRender() {\n    var self = this;\n    var title = self.get('title');\n    var label = self.get('label');\n    var grid = self.get('grid');\n\n    if (title) {\n      self.set('title', Util.deepMix({\n        autoRotate: true,\n        textStyle: {\n          fontSize: 12,\n          fill: '#ccc',\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY,\n          textAlign: 'center'\n        },\n        offset: 48\n      }, title));\n    }\n\n    if (label) {\n      self.set('label', Util.deepMix({\n        autoRotate: true,\n        autoHide: true,\n        textStyle: {\n          fontSize: 12,\n          fill: '#ccc',\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        },\n        offset: 10\n      }, label));\n    }\n\n    if (grid) {\n      self.set('grid', Util.deepMix({\n        lineStyle: {\n          lineWidth: 1,\n          stroke: '#C0D0E0'\n        }\n      }, grid));\n    }\n  };\n\n  _proto.render = function render() {\n    var self = this;\n    self.beforeRender();\n    var labelCfg = self.get('label');\n\n    if (labelCfg) {\n      self.renderLabels();\n    }\n\n    if (self.get('autoPaint')) {\n      self.paint();\n    }\n\n    if (!Util.isNil(self.get('title'))) {\n      self.renderTitle();\n    }\n\n    self.get('group').sort();\n  };\n\n  _proto.renderLabels = function renderLabels() {\n    var self = this;\n    var group = self.get('group');\n    var labelCfg = self.get('label');\n    var labelRenderer = new Label();\n    self.set('labelRenderer', labelRenderer);\n    labelRenderer.set('labelCfg', labelCfg);\n    var cfgs2copy = ['formatter', 'htmlTemplate', 'labelLine', 'textStyle', 'useHtml'];\n    Util.each(cfgs2copy, function (cfg) {\n      if (labelCfg[cfg]) {\n        labelRenderer.set(cfg, labelCfg[cfg]);\n      }\n    });\n    labelRenderer.set('coord', self.get('coord'));\n    labelRenderer.set('group', group.addGroup());\n    labelRenderer.set('canvas', self.get('canvas'));\n  };\n\n  _proto._parseTicks = function _parseTicks(ticks) {\n    ticks = ticks || [];\n    var ticksLength = ticks.length;\n\n    for (var i = 0; i < ticksLength; i++) {\n      var item = ticks[i];\n\n      if (!Util.isObject(item)) {\n        ticks[i] = this.parseTick(item, i, ticksLength);\n      }\n    }\n\n    this.set('ticks', ticks);\n    return ticks;\n  };\n\n  _proto._addTickItem = function _addTickItem(index, point, length, type) {\n    if (type === void 0) {\n      type = '';\n    }\n\n    var tickItems = this.get('tickItems');\n    var subTickItems = this.get('subTickItems');\n    var end = this.getTickEnd(point, length, index);\n    var cfg = {\n      x1: point.x,\n      y1: point.y,\n      x2: end.x,\n      y2: end.y\n    };\n\n    if (!tickItems) {\n      tickItems = [];\n    }\n\n    if (!subTickItems) {\n      subTickItems = [];\n    }\n\n    if (type === 'sub') {\n      subTickItems.push(cfg);\n    } else {\n      tickItems.push(cfg);\n    }\n\n    this.set('tickItems', tickItems);\n    this.set('subTickItems', subTickItems);\n  };\n\n  _proto._renderLine = function _renderLine() {\n    var self = this;\n    var lineCfg = self.get('line');\n    var path;\n\n    if (lineCfg) {\n      path = self.getLinePath();\n      lineCfg = Util.mix({\n        path: path\n      }, lineCfg);\n      var group = self.get('group');\n      var lineShape = group.addShape('path', {\n        attrs: lineCfg\n      });\n      lineShape.name = 'axis-line';\n      self.get('appendInfo') && lineShape.setSilent('appendInfo', self.get('appendInfo'));\n      self.set('lineShape', lineShape);\n    }\n  };\n\n  _proto._processCatTicks = function _processCatTicks() {\n    var self = this;\n    var labelCfg = self.get('label');\n    var tickLineCfg = self.get('tickLine');\n    var ticks = self.get('ticks');\n    ticks = self._parseTicks(ticks);\n\n    var new_ticks = self._getNormalizedTicks(ticks);\n\n    for (var i = 0; i < new_ticks.length; i += 3) {\n      var p = self.getTickPoint(new_ticks[i]);\n      var p0 = self.getTickPoint(new_ticks[i + 1]);\n      var p1 = self.getTickPoint(new_ticks[i + 2]);\n      var index = Math.floor(i / 3);\n      var tick = ticks[index];\n\n      if (tickLineCfg) {\n        if (index === 0) {\n          self._addTickItem(index, p0, tickLineCfg.length);\n        }\n\n        self._addTickItem(index, p1, tickLineCfg.length);\n      }\n\n      if (labelCfg) {\n        self.addLabel(tick, p, index);\n      }\n    }\n  };\n\n  _proto._getNormalizedTicks = function _getNormalizedTicks(ticks) {\n    var tickSeg = 0;\n\n    if (ticks.length > 1) {\n      tickSeg = (ticks[1].value - ticks[0].value) / 2;\n    }\n\n    var points = [];\n\n    for (var i = 0; i < ticks.length; i++) {\n      var tick = ticks[i];\n      var p = tick.value;\n      var p0 = tick.value - tickSeg;\n      var p1 = tick.value + tickSeg;\n      points.push(p, p0, p1);\n    }\n\n    var range = Util.arrayUtil.getRange(points);\n    return points.map(function (p) {\n      var norm = (p - range.min) / (range.max - range.min);\n      return norm;\n    });\n  };\n\n  _proto.addLabel = function addLabel(tick, point, index) {\n    var self = this;\n    var labelItems = self.get('labelItems');\n    var labelRenderer = self.get('labelRenderer');\n    var label = Util.deepMix({}, self.get('label'));\n    var rst;\n\n    if (labelRenderer) {\n      var offset = self.get('_labelOffset');\n\n      if (!Util.isNil(self.get('label').offset)) {\n        offset = self.get('label').offset;\n      }\n\n      var vector = self.getSideVector(offset, point, index);\n      point = {\n        x: point.x + vector[0] + label.offsetX,\n        y: point.y + vector[1] + label.offsetY\n      };\n      label.text = tick.text;\n      label.x = point.x;\n      label.y = point.y;\n      label.point = point;\n      label.textAlign = self.getTextAnchor(vector);\n\n      if (point.rotate) {\n        label.rotate = point.rotate;\n      }\n\n      labelItems.push(label);\n    }\n\n    return rst;\n  };\n\n  _proto._processTicks = function _processTicks() {\n    var self = this;\n    var labelCfg = self.get('label');\n    var subTickCount = self.get('subTickCount');\n    var tickLineCfg = self.get('tickLine');\n    var ticks = self.get('ticks');\n    ticks = self._parseTicks(ticks);\n    Util.each(ticks, function (tick, index) {\n      var tickPoint = self.getTickPoint(tick.value, index);\n\n      if (tickLineCfg) {\n        self._addTickItem(index, tickPoint, tickLineCfg.length);\n      }\n\n      if (labelCfg) {\n        self.addLabel(tick, tickPoint, index);\n      }\n    });\n\n    if (subTickCount) {\n      // 如果有设置次级分点，添加次级tick\n      var subTickLineCfg = self.get('subTickLine');\n      Util.each(ticks, function (tick, index) {\n        if (index > 0) {\n          var diff = tick.value - ticks[index - 1].value;\n          diff = diff / (self.get('subTickCount') + 1);\n\n          for (var i = 1; i <= subTickCount; i++) {\n            var subTick = {\n              text: '',\n              value: index ? ticks[index - 1].value + i * diff : i * diff\n            };\n            var tickPoint = self.getTickPoint(subTick.value);\n            var subTickLength = void 0;\n\n            if (subTickLineCfg && subTickLineCfg.length) {\n              subTickLength = subTickLineCfg.length;\n            } else {\n              subTickLength = parseInt(tickLineCfg.length * (3 / 5), 10);\n            }\n\n            self._addTickItem(i - 1, tickPoint, subTickLength, 'sub');\n          }\n        }\n      });\n    }\n  };\n\n  _proto._addTickLine = function _addTickLine(ticks, lineCfg) {\n    var self = this;\n    var cfg = Util.mix({}, lineCfg);\n    var path = [];\n    Util.each(ticks, function (item) {\n      path.push(['M', item.x1, item.y1]);\n      path.push(['L', item.x2, item.y2]);\n    });\n    delete cfg.length;\n    cfg.path = path;\n    var group = self.get('group');\n    var tickShape = group.addShape('path', {\n      attrs: cfg\n    });\n    tickShape.name = 'axis-ticks';\n    tickShape._id = self.get('_id') + '-ticks';\n    tickShape.set('coord', self.get('coord'));\n    self.get('appendInfo') && tickShape.setSilent('appendInfo', self.get('appendInfo'));\n  };\n\n  _proto._renderTicks = function _renderTicks() {\n    var self = this;\n    var tickItems = self.get('tickItems');\n    var subTickItems = self.get('subTickItems');\n\n    if (!Util.isEmpty(tickItems)) {\n      var tickLineCfg = self.get('tickLine');\n\n      self._addTickLine(tickItems, tickLineCfg);\n    }\n\n    if (!Util.isEmpty(subTickItems)) {\n      var subTickLineCfg = self.get('subTickLine') || self.get('tickLine');\n\n      self._addTickLine(subTickItems, subTickLineCfg);\n    }\n  };\n\n  _proto._renderGrid = function _renderGrid() {\n    var grid = this.get('grid');\n\n    if (!grid) {\n      return;\n    }\n\n    grid.coord = this.get('coord');\n    grid.appendInfo = this.get('appendInfo');\n    var group = this.get('group');\n    this.set('gridGroup', group.addGroup(Grid, grid));\n  };\n\n  _proto._renderLabels = function _renderLabels() {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var labelItems = self.get('labelItems');\n\n    if (labelRenderer) {\n      labelRenderer.set('items', labelItems);\n\n      labelRenderer._dryDraw();\n    }\n  };\n\n  _proto.paint = function paint() {\n    var self = this;\n    var tickLineCfg = self.get('tickLine');\n    var alignWithLabel = true;\n\n    if (tickLineCfg && tickLineCfg.hasOwnProperty('alignWithLabel')) {\n      alignWithLabel = tickLineCfg.alignWithLabel;\n    }\n\n    self._renderLine();\n\n    var type = self.get('type');\n    var isCat = type === 'cat' || type === 'timeCat';\n\n    if (isCat && alignWithLabel === false) {\n      self._processCatTicks();\n    } else {\n      self._processTicks();\n    }\n\n    self._renderTicks();\n\n    self._renderGrid();\n\n    self._renderLabels();\n\n    var labelCfg = this.get('label');\n\n    if (labelCfg && labelCfg.autoRotate) {\n      self.autoRotateLabels();\n    }\n\n    if (labelCfg && labelCfg.autoHide) {\n      self.autoHideLabels();\n    }\n  };\n\n  _proto.parseTick = function parseTick(tick, index, length) {\n    return {\n      text: tick,\n      value: index / (length - 1)\n    };\n  };\n\n  _proto.getTextAnchor = function getTextAnchor(vector) {\n    var ratio = Math.abs(vector[1] / vector[0]);\n    var align;\n\n    if (ratio >= 1) {\n      // 上面或者下面\n      align = 'center';\n    } else {\n      if (vector[0] > 0) {\n        // 右侧\n        align = 'start';\n      } else {\n        // 左侧\n        align = 'end';\n      }\n    }\n\n    return align;\n  };\n\n  _proto.getMaxLabelWidth = function getMaxLabelWidth(labelRenderer) {\n    var labels = labelRenderer.getLabels();\n    var max = 0;\n    Util.each(labels, function (label) {\n      var bbox = label.getBBox();\n      var width = bbox.width;\n\n      if (max < width) {\n        max = width;\n      }\n    });\n    return max;\n  };\n\n  _proto.getMaxLabelHeight = function getMaxLabelHeight(labelRenderer) {\n    var labels = labelRenderer.getLabels();\n    var max = 0;\n    Util.each(labels, function (label) {\n      var bbox = label.getBBox();\n      var height = bbox.height;\n\n      if (max < height) {\n        max = height;\n      }\n    });\n    return max;\n  };\n\n  _proto.destroy = function destroy() {\n    var self = this;\n\n    if (!self.destroyed) {\n      _Component.prototype.destroy.call(this);\n\n      var gridGroup = self.get('gridGroup');\n      gridGroup && gridGroup.remove();\n      var labelRenderer = this.get('labelRenderer');\n      labelRenderer && labelRenderer.destroy();\n      var group = self.get('group');\n      group.destroy();\n      self.destroyed = true;\n    }\n  };\n\n  _proto.clear = function clear() {\n    var self = this;\n    var group = self.get('group');\n\n    if (!group.get('destroyed') && group.get('children').length) {\n      var gridGroup = self.get('gridGroup');\n      gridGroup && gridGroup.clear();\n      var labelRenderer = this.get('labelRenderer');\n      labelRenderer && labelRenderer.clear();\n\n      var _group = self.get('group');\n\n      _group.clear();\n    }\n  };\n  /**\n   * 旋转文本\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.autoRotateLabels = function autoRotateLabels() {};\n  /**\n   * 文本自动防遮罩\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.autoHideLabels = function autoHideLabels() {};\n  /**\n   * 渲染标题\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.renderTitle = function renderTitle() {};\n  /**\n   * 获取坐标轴线的 path\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.getLinePath = function getLinePath() {};\n  /**\n   * 获取 tick 在画布上的位置\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.getTickPoint = function getTickPoint() {};\n  /**\n   * 获取标示坐标点的线的终点\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.getTickEnd = function getTickEnd() {};\n  /**\n   * 获取距离坐标轴的向量\n   * @abstract\n   * @return {[type]} [description]\n   */\n\n\n  _proto.getSideVector = function getSideVector() {};\n\n  return Axis;\n}(Component);\n\nmodule.exports = Axis;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(66);\n\nvar Component =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Component, _Base);\n\n  function Component() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Component.prototype; // 配置\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      // 顶层标志位\n      _id: null,\n      // 用于动画\n      // 容器\n      canvas: null,\n      container: null,\n      // html，可选\n      group: null,\n      // G Group，可选\n      // 交互属性\n      capture: false,\n      // props\n      coord: null,\n      offset: [0, 0],\n      plotRange: null,\n      // BBox\n      position: [0, 0],\n      visible: true,\n      zIndex: 1\n    };\n  }; // 基础生命周期\n\n\n  _proto._init = function _init() {};\n\n  _proto.clear = function clear() {};\n\n  _proto.destroy = function destroy() {}; // 绘图\n\n\n  _proto.beforeRender = function beforeRender() {};\n\n  _proto.render = function render() {}; // 初始化、绑事件和绘图\n\n\n  _proto.afterRender = function afterRender() {};\n\n  _proto.beforeDraw = function beforeDraw() {};\n\n  _proto.draw = function draw() {}; // 单纯更新视图\n\n\n  _proto.afterDraw = function afterDraw() {}; // visibility\n\n\n  _proto.show = function show() {};\n\n  _proto.hide = function hide() {}; // props operating syntactic sugar\n\n\n  _proto.setOffset = function setOffset() {};\n\n  _proto.setPosition = function setPosition() {};\n\n  _proto.setVisible = function setVisible() {};\n\n  _proto.setZIndex = function setZIndex() {};\n\n  return Component;\n}(Base);\n\nmodule.exports = Component;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The measurement of linear data scale function\n * @author dxq613@gmail.com\n */\n\n\nvar isNil = __webpack_require__(5);\n\nvar each = __webpack_require__(2);\n\nvar Base = __webpack_require__(17);\n\nvar numberAuto = __webpack_require__(174);\n/**\n * 线性度量\n * @class Scale.Linear\n */\n\n\nvar Linear =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Linear, _Base);\n\n  function Linear() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Linear.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    var self = this;\n    self.type = 'linear';\n    self.isLinear = true;\n    /**\n     * 是否为了用户习惯，优化min,max和ticks，如果进行优化，则会根据生成的ticks调整min,max，否则舍弃(min,max)范围之外的ticks\n     * @type {Boolean}\n     * @default false\n     */\n\n    self.nice = false;\n    /**\n     * min value of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.min = null;\n    /**\n     * min value limitted of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.minLimit = null;\n    /**\n     * max value of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.max = null;\n    /**\n     * max value limitted of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.maxLimit = null;\n    /**\n     * 自动生成标记时的个数\n     * @type {Number}\n     * @default null\n     */\n\n    self.tickCount = null;\n    /**\n     * 坐标轴点之间的间距，指的是真实数据的差值\n     * @type {Number}\n     * @default null\n     */\n\n    self.tickInterval = null;\n    /**\n     * 坐标轴点之间的最小间距，指的是真实数据的差值\n     * @type {Number}\n     * @default null\n     */\n\n    self.minTickInterval = null;\n    /**\n     * 用于计算坐标点时逼近的数组\n     * @type {Array}\n     */\n\n    self.snapArray = null;\n  };\n  /**\n   * @protected\n   * @override\n   */\n\n\n  _proto.init = function init() {\n    var self = this;\n\n    if (!self.ticks) {\n      self.min = self.translate(self.min);\n      self.max = self.translate(self.max);\n      self.initTicks();\n    } else {\n      var ticks = self.ticks;\n      var firstValue = self.translate(ticks[0]);\n      var lastValue = self.translate(ticks[ticks.length - 1]);\n\n      if (isNil(self.min) || self.min > firstValue) {\n        self.min = firstValue;\n      }\n\n      if (isNil(self.max) || self.max < lastValue) {\n        self.max = lastValue;\n      }\n    }\n  };\n  /**\n   * 计算坐标点\n   * @protected\n   * @return {Array} 计算完成的坐标点\n   */\n\n\n  _proto.calculateTicks = function calculateTicks() {\n    var min = this.min,\n        max = this.max,\n        minLimit = this.minLimit,\n        maxLimit = this.maxLimit,\n        tickCount = this.tickCount,\n        tickInterval = this.tickInterval,\n        minTickInterval = this.minTickInterval,\n        snapArray = this.snapArray;\n\n    if (tickCount === 1) {\n      throw new Error('linear scale\\'tickCount should not be 1');\n    }\n\n    if (max < min) {\n      throw new Error(\"max: \" + max + \" should not be less than min: \" + min);\n    }\n\n    var tmp = numberAuto({\n      min: min,\n      max: max,\n      minLimit: minLimit,\n      maxLimit: maxLimit,\n      minCount: tickCount,\n      maxCount: tickCount,\n      interval: tickInterval,\n      minTickInterval: minTickInterval,\n      snapArray: snapArray\n    });\n    return tmp.ticks;\n  }; // 初始化ticks\n\n\n  _proto.initTicks = function initTicks() {\n    var self = this;\n    var calTicks = self.calculateTicks();\n\n    if (self.nice) {\n      // 如果需要优化显示的tick\n      self.ticks = calTicks;\n      self.min = calTicks[0];\n      self.max = calTicks[calTicks.length - 1];\n    } else {\n      var ticks = [];\n      each(calTicks, function (tick) {\n        if (tick >= self.min && tick <= self.max) {\n          ticks.push(tick);\n        }\n      }); // 如果 ticks 为空，直接输入最小值、最大值\n\n      if (!ticks.length) {\n        ticks.push(self.min);\n        ticks.push(self.max);\n      }\n\n      self.ticks = ticks;\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    if (isNil(value)) {\n      return NaN;\n    }\n\n    var max = this.max;\n    var min = this.min;\n\n    if (max === min) {\n      return 0;\n    }\n\n    var percent = (value - min) / (max - min);\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    return rangeMin + percent * (rangeMax - rangeMin);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.invert = function invert(value) {\n    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());\n    return this.min + percent * (this.max - this.min);\n  };\n\n  return Linear;\n}(Base);\n\nBase.Linear = Linear;\nmodule.exports = Linear;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(13);\n\nfunction toArray(value) {\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [];\n}\n\nmodule.exports = toArray;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\nvar PRECISION = 0.00001; // numbers less than this is considered as 0\n\nmodule.exports = function isNumberEqual(a, b) {\n  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PRECISION;\n  return Math.abs(a - b) < precision;\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar vec2 = __webpack_require__(1).vec2;\n\nmodule.exports = {\n  at: function at(p1, p2, t) {\n    return (p2 - p1) * t + p1;\n  },\n  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {\n    var d = [x2 - x1, y2 - y1];\n\n    if (vec2.exactEquals(d, [0, 0])) {\n      return NaN;\n    }\n\n    var u = [-d[1], d[0]];\n    vec2.normalize(u, u);\n    var a = [x - x1, y - y1];\n    return Math.abs(vec2.dot(a, u));\n  },\n  box: function box(x1, y1, x2, y2, lineWidth) {\n    var halfWidth = lineWidth / 2;\n    var minX = Math.min(x1, x2);\n    var maxX = Math.max(x1, x2);\n    var minY = Math.min(y1, y2);\n    var maxY = Math.max(y1, y2);\n    return {\n      minX: minX - halfWidth,\n      minY: minY - halfWidth,\n      maxX: maxX + halfWidth,\n      maxY: maxY + halfWidth\n    };\n  },\n  len: function len(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nfunction circlePoint(cx, cy, r, angle) {\n  return {\n    x: Math.cos(angle) * r + cx,\n    y: Math.sin(angle) * r + cy\n  };\n}\n\nfunction angleNearTo(angle, min, max, out) {\n  var v1;\n  var v2;\n\n  if (out) {\n    if (angle < min) {\n      v1 = min - angle;\n      v2 = Math.PI * 2 - max + angle;\n    } else if (angle > max) {\n      v1 = Math.PI * 2 - angle + min;\n      v2 = angle - max;\n    }\n  } else {\n    v1 = angle - min;\n    v2 = max - angle;\n  }\n\n  return v1 > v2 ? max : min;\n}\n\nfunction nearAngle(angle, startAngle, endAngle, clockwise) {\n  var plus = 0;\n\n  if (endAngle - startAngle >= Math.PI * 2) {\n    plus = Math.PI * 2;\n  }\n\n  startAngle = Util.mod(startAngle, Math.PI * 2);\n  endAngle = Util.mod(endAngle, Math.PI * 2) + plus;\n  angle = Util.mod(angle, Math.PI * 2);\n\n  if (clockwise) {\n    if (startAngle >= endAngle) {\n      if (angle > endAngle && angle < startAngle) {\n        return angle;\n      }\n\n      return angleNearTo(angle, endAngle, startAngle, true);\n    }\n\n    if (angle < startAngle || angle > endAngle) {\n      return angle;\n    }\n\n    return angleNearTo(angle, startAngle, endAngle);\n  }\n\n  if (startAngle <= endAngle) {\n    if (startAngle < angle && angle < endAngle) {\n      return angle;\n    }\n\n    return angleNearTo(angle, startAngle, endAngle, true);\n  }\n\n  if (angle > startAngle || angle < endAngle) {\n    return angle;\n  }\n\n  return angleNearTo(angle, endAngle, startAngle);\n}\n\nfunction arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, out) {\n  var v = [x, y];\n  var v0 = [cx, cy];\n  var v1 = [1, 0];\n  var subv = Util.vec2.subtract([], v, v0);\n  var angle = Util.vec2.angleTo(v1, subv);\n  angle = nearAngle(angle, startAngle, endAngle, clockwise);\n  var vpoint = [r * Math.cos(angle) + cx, r * Math.sin(angle) + cy];\n\n  if (out) {\n    out.x = vpoint[0];\n    out.y = vpoint[1];\n  }\n\n  var d = Util.vec2.distance(vpoint, v);\n  return d;\n}\n\nfunction arcBox(cx, cy, r, startAngle, endAngle, clockwise) {\n  var angleRight = 0;\n  var angleBottom = Math.PI / 2;\n  var angleLeft = Math.PI;\n  var angleTop = Math.PI * 3 / 2;\n  var points = [];\n  var angle = nearAngle(angleRight, startAngle, endAngle, clockwise);\n\n  if (angle === angleRight) {\n    points.push(circlePoint(cx, cy, r, angleRight));\n  }\n\n  angle = nearAngle(angleBottom, startAngle, endAngle, clockwise);\n\n  if (angle === angleBottom) {\n    points.push(circlePoint(cx, cy, r, angleBottom));\n  }\n\n  angle = nearAngle(angleLeft, startAngle, endAngle, clockwise);\n\n  if (angle === angleLeft) {\n    points.push(circlePoint(cx, cy, r, angleLeft));\n  }\n\n  angle = nearAngle(angleTop, startAngle, endAngle, clockwise);\n\n  if (angle === angleTop) {\n    points.push(circlePoint(cx, cy, r, angleTop));\n  }\n\n  points.push(circlePoint(cx, cy, r, startAngle));\n  points.push(circlePoint(cx, cy, r, endAngle));\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n  Util.each(points, function (point) {\n    if (minX > point.x) {\n      minX = point.x;\n    }\n\n    if (maxX < point.x) {\n      maxX = point.x;\n    }\n\n    if (minY > point.y) {\n      minY = point.y;\n    }\n\n    if (maxY < point.y) {\n      maxY = point.y;\n    }\n  });\n  return {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  };\n}\n\nmodule.exports = {\n  nearAngle: nearAngle,\n  projectPoint: function projectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y) {\n    var rst = {};\n    arcProjectPoint(cx, cy, r, startAngle, endAngle, clockwise, x, y, rst);\n    return rst;\n  },\n  pointDistance: arcProjectPoint,\n  box: arcBox\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Format = __webpack_require__(27);\n\nvar PathSegment = __webpack_require__(39);\n\nvar PI = Math.PI;\nvar sin = Math.sin;\nvar cos = Math.cos;\nvar atan2 = Math.atan2;\nvar DEFAULT_LENGTH = 10;\nvar DEFAULT_ANGLE = PI / 3;\n\nfunction _addArrow(ctx, attrs, x1, y1, x2, y2, isStart) {\n  var leftX;\n  var leftY;\n  var rightX;\n  var rightY;\n  var offsetX;\n  var offsetY;\n  var angle;\n\n  if (!attrs.fill) {\n    // 闭合的不绘制箭头\n    var arrowLength = attrs.arrowLength || DEFAULT_LENGTH;\n    var arrowAngle = attrs.arrowAngle ? attrs.arrowAngle * PI / 180 : DEFAULT_ANGLE; // 转换为弧\n    // Calculate angle\n\n    angle = atan2(y1 - y2, x1 - x2);\n    /* // Adjust angle correctly\n    angle -= PI;*/\n    // Calculate offset to place arrow at edge of path\n\n    offsetX = Math.abs(attrs.lineWidth * cos(angle)) / 2;\n    offsetY = Math.abs(attrs.lineWidth * sin(angle)) / 2;\n\n    if (isStart) {\n      offsetX = -offsetX;\n      offsetY = -offsetY;\n    } // Calculate coordinates for left half of arrow\n\n\n    leftX = x2 + arrowLength * cos(angle + arrowAngle / 2);\n    leftY = y2 + arrowLength * sin(angle + arrowAngle / 2); // Calculate coordinates for right half of arrow\n\n    rightX = x2 + arrowLength * cos(angle - arrowAngle / 2);\n    rightY = y2 + arrowLength * sin(angle - arrowAngle / 2);\n    ctx.beginPath(); // Draw left half of arrow\n\n    ctx.moveTo(leftX - offsetX, leftY - offsetY);\n    ctx.lineTo(x2 - offsetX, y2 - offsetY); // Draw right half of arrow\n\n    ctx.lineTo(rightX - offsetX, rightY - offsetY); // Visually connect arrow to path\n\n    ctx.moveTo(x2 - offsetX, y2 - offsetY);\n    ctx.lineTo(x2 + offsetX, y2 + offsetY); // Move back to end of path\n\n    ctx.moveTo(x2, y2);\n    ctx.stroke();\n  }\n}\n\nfunction parsePath(attrs) {\n  var segments = [];\n  var pathArray = Format.parsePath(attrs.path);\n  var preSegment;\n\n  if (!Array.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {\n    return false;\n  }\n\n  var count = pathArray.length;\n\n  for (var i = 0; i < pathArray.length; i++) {\n    var item = pathArray[i];\n    preSegment = new PathSegment(item, preSegment, i === count - 1);\n    segments.push(preSegment);\n  }\n\n  return segments;\n}\n\nfunction _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, isStart) {\n  var shape = isStart ? attrs.startArrow : attrs.endArrow;\n  var d = shape.d;\n  var deg = 0;\n  var x = x2 - x1;\n  var y = y2 - y1;\n  var tan = Math.atan(x / y);\n\n  if (y === 0 && x < 0) {\n    deg = Math.PI;\n  } else if (x > 0 && y > 0) {\n    deg = Math.PI / 2 - tan;\n  } else if (x < 0 && y < 0) {\n    deg = -Math.PI / 2 - tan;\n  } else if (x >= 0 && y < 0) {\n    deg = -tan - Math.PI / 2;\n  } else if (x <= 0 && y > 0) {\n    deg = Math.PI / 2 - tan;\n  }\n\n  var path = parsePath(shape);\n\n  if (!path) {\n    return;\n  }\n\n  if (d) {\n    if (isStart) {\n      x2 = x2 + Math.sin(Math.abs(tan)) * d;\n      y2 = y2 + Math.cos(Math.abs(tan)) * d - 0.5 * ctx.lineWidth;\n    } else {\n      x2 = x2 - Math.sin(Math.abs(tan)) * d;\n      y2 = y2 - Math.cos(Math.abs(tan)) * d + 0.5 * ctx.lineWidth;\n    }\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.translate(x2, y2);\n  ctx.rotate(deg);\n\n  for (var i = 0; i < path.length; i++) {\n    path[i].draw(ctx);\n  }\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.fillStyle = ctx.strokeStyle;\n  ctx.fill();\n  ctx.restore();\n}\n\nmodule.exports = {\n  addStartArrow: function addStartArrow(ctx, attrs, x1, y1, x2, y2) {\n    if (typeof attrs.startArrow === 'object') {\n      _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, true);\n    } else if (attrs.startArrow) {\n      _addArrow(ctx, attrs, x1, y1, x2, y2, true);\n    }\n  },\n  addEndArrow: function addEndArrow(ctx, attrs, x1, y1, x2, y2) {\n    if (typeof attrs.endArrow === 'object') {\n      _addCustomizedArrow(ctx, attrs, x1, y1, x2, y2, false);\n    } else if (attrs.endArrow) {\n      _addArrow(ctx, attrs, x1, y1, x2, y2, false);\n    }\n  }\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Inside = __webpack_require__(54);\n\nvar Cubic = __webpack_require__(55);\n\nvar Quadratic = __webpack_require__(103);\n\nvar Ellipse = __webpack_require__(104);\n\nvar vec3 = Util.vec3;\nvar mat3 = Util.mat3;\nvar ARR_CMD = ['m', 'l', 'c', 'a', 'q', 'h', 'v', 't', 's', 'z'];\n\nfunction toAbsolute(x, y, curPoint) {\n  // 获取绝对坐标\n  return {\n    x: curPoint.x + x,\n    y: curPoint.y + y\n  };\n}\n\nfunction toSymmetry(point, center) {\n  // 点对称\n  return {\n    x: center.x + (center.x - point.x),\n    y: center.y + (center.y - point.y)\n  };\n}\n\nfunction vMag(v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n\nfunction vRatio(u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n}\n\nfunction vAngle(u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n\nfunction getArcParams(point1, point2, fa, fs, rx, ry, psiDeg) {\n  var psi = Util.mod(Util.toRadian(psiDeg), Math.PI * 2);\n  var x1 = point1.x;\n  var y1 = point1.y;\n  var x2 = point2.x;\n  var y2 = point2.y;\n  var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n  var f = Math.sqrt((rx * rx * (ry * ry) - diff) / diff);\n\n  if (fa === fs) {\n    f *= -1;\n  }\n\n  if (isNaN(f)) {\n    f = 0;\n  }\n\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = Math.PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * Math.PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * Math.PI;\n  }\n\n  return [point1, cx, cy, rx, ry, theta, dTheta, psi, fs];\n}\n\nvar PathSegment = function PathSegment(item, preSegment, isLast) {\n  this.preSegment = preSegment;\n  this.isLast = isLast;\n  this.init(item, preSegment);\n};\n\nUtil.augment(PathSegment, {\n  init: function init(item, preSegment) {\n    var command = item[0];\n    preSegment = preSegment || {\n      endPoint: {\n        x: 0,\n        y: 0\n      }\n    };\n    var relative = ARR_CMD.indexOf(command) >= 0; // /[a-z]/.test(command);\n\n    var cmd = relative ? command.toUpperCase() : command;\n    var p = item;\n    var point1;\n    var point2;\n    var point3;\n    var point;\n    var preEndPoint = preSegment.endPoint;\n    var p1 = p[1];\n    var p2 = p[2];\n\n    switch (cmd) {\n      default:\n        break;\n\n      case 'M':\n        if (relative) {\n          point = toAbsolute(p1, p2, preEndPoint);\n        } else {\n          point = {\n            x: p1,\n            y: p2\n          };\n        }\n\n        this.command = 'M';\n        this.params = [preEndPoint, point];\n        this.subStart = point;\n        this.endPoint = point;\n        break;\n\n      case 'L':\n        if (relative) {\n          point = toAbsolute(p1, p2, preEndPoint);\n        } else {\n          point = {\n            x: p1,\n            y: p2\n          };\n        }\n\n        this.command = 'L';\n        this.params = [preEndPoint, point];\n        this.subStart = preSegment.subStart;\n        this.endPoint = point;\n\n        this.endTangent = function () {\n          return [point.x - preEndPoint.x, point.y - preEndPoint.y];\n        };\n\n        this.startTangent = function () {\n          return [preEndPoint.x - point.x, preEndPoint.y - point.y];\n        };\n\n        break;\n\n      case 'H':\n        if (relative) {\n          point = toAbsolute(p1, 0, preEndPoint);\n        } else {\n          point = {\n            x: p1,\n            y: preEndPoint.y\n          };\n        }\n\n        this.command = 'L';\n        this.params = [preEndPoint, point];\n        this.subStart = preSegment.subStart;\n        this.endPoint = point;\n\n        this.endTangent = function () {\n          return [point.x - preEndPoint.x, point.y - preEndPoint.y];\n        };\n\n        this.startTangent = function () {\n          return [preEndPoint.x - point.x, preEndPoint.y - point.y];\n        };\n\n        break;\n\n      case 'V':\n        if (relative) {\n          point = toAbsolute(0, p1, preEndPoint);\n        } else {\n          point = {\n            x: preEndPoint.x,\n            y: p1\n          };\n        }\n\n        this.command = 'L';\n        this.params = [preEndPoint, point];\n        this.subStart = preSegment.subStart;\n        this.endPoint = point;\n\n        this.endTangent = function () {\n          return [point.x - preEndPoint.x, point.y - preEndPoint.y];\n        };\n\n        this.startTangent = function () {\n          return [preEndPoint.x - point.x, preEndPoint.y - point.y];\n        };\n\n        break;\n\n      case 'Q':\n        if (relative) {\n          point1 = toAbsolute(p1, p2, preEndPoint);\n          point2 = toAbsolute(p[3], p[4], preEndPoint);\n        } else {\n          point1 = {\n            x: p1,\n            y: p2\n          };\n          point2 = {\n            x: p[3],\n            y: p[4]\n          };\n        }\n\n        this.command = 'Q';\n        this.params = [preEndPoint, point1, point2];\n        this.subStart = preSegment.subStart;\n        this.endPoint = point2;\n\n        this.endTangent = function () {\n          return [point2.x - point1.x, point2.y - point1.y];\n        };\n\n        this.startTangent = function () {\n          return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];\n        };\n\n        break;\n\n      case 'T':\n        if (relative) {\n          point2 = toAbsolute(p1, p2, preEndPoint);\n        } else {\n          point2 = {\n            x: p1,\n            y: p2\n          };\n        }\n\n        if (preSegment.command === 'Q') {\n          point1 = toSymmetry(preSegment.params[1], preEndPoint);\n          this.command = 'Q';\n          this.params = [preEndPoint, point1, point2];\n          this.subStart = preSegment.subStart;\n          this.endPoint = point2;\n\n          this.endTangent = function () {\n            return [point2.x - point1.x, point2.y - point1.y];\n          };\n\n          this.startTangent = function () {\n            return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];\n          };\n        } else {\n          this.command = 'TL';\n          this.params = [preEndPoint, point2];\n          this.subStart = preSegment.subStart;\n          this.endPoint = point2;\n\n          this.endTangent = function () {\n            return [point2.x - preEndPoint.x, point2.y - preEndPoint.y];\n          };\n\n          this.startTangent = function () {\n            return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];\n          };\n        }\n\n        break;\n\n      case 'C':\n        if (relative) {\n          point1 = toAbsolute(p1, p2, preEndPoint);\n          point2 = toAbsolute(p[3], p[4], preEndPoint);\n          point3 = toAbsolute(p[5], p[6], preEndPoint);\n        } else {\n          point1 = {\n            x: p1,\n            y: p2\n          };\n          point2 = {\n            x: p[3],\n            y: p[4]\n          };\n          point3 = {\n            x: p[5],\n            y: p[6]\n          };\n        }\n\n        this.command = 'C';\n        this.params = [preEndPoint, point1, point2, point3];\n        this.subStart = preSegment.subStart;\n        this.endPoint = point3;\n\n        this.endTangent = function () {\n          return [point3.x - point2.x, point3.y - point2.y];\n        };\n\n        this.startTangent = function () {\n          return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];\n        };\n\n        break;\n\n      case 'S':\n        if (relative) {\n          point2 = toAbsolute(p1, p2, preEndPoint);\n          point3 = toAbsolute(p[3], p[4], preEndPoint);\n        } else {\n          point2 = {\n            x: p1,\n            y: p2\n          };\n          point3 = {\n            x: p[3],\n            y: p[4]\n          };\n        }\n\n        if (preSegment.command === 'C') {\n          point1 = toSymmetry(preSegment.params[2], preEndPoint);\n          this.command = 'C';\n          this.params = [preEndPoint, point1, point2, point3];\n          this.subStart = preSegment.subStart;\n          this.endPoint = point3;\n\n          this.endTangent = function () {\n            return [point3.x - point2.x, point3.y - point2.y];\n          };\n\n          this.startTangent = function () {\n            return [preEndPoint.x - point1.x, preEndPoint.y - point1.y];\n          };\n        } else {\n          this.command = 'SQ';\n          this.params = [preEndPoint, point2, point3];\n          this.subStart = preSegment.subStart;\n          this.endPoint = point3;\n\n          this.endTangent = function () {\n            return [point3.x - point2.x, point3.y - point2.y];\n          };\n\n          this.startTangent = function () {\n            return [preEndPoint.x - point2.x, preEndPoint.y - point2.y];\n          };\n        }\n\n        break;\n\n      case 'A':\n        {\n          var rx = p1;\n          var ry = p2;\n          var psi = p[3];\n          var fa = p[4];\n          var fs = p[5];\n\n          if (relative) {\n            point = toAbsolute(p[6], p[7], preEndPoint);\n          } else {\n            point = {\n              x: p[6],\n              y: p[7]\n            };\n          }\n\n          this.command = 'A';\n          var params = getArcParams(preEndPoint, point, fa, fs, rx, ry, psi);\n          this.params = params;\n          var start = preSegment.subStart;\n          this.subStart = start;\n          this.endPoint = point;\n          var startAngle = params[5] % (Math.PI * 2);\n\n          if (Util.isNumberEqual(startAngle, Math.PI * 2)) {\n            startAngle = 0;\n          }\n\n          var endAngle = params[6] % (Math.PI * 2);\n\n          if (Util.isNumberEqual(endAngle, Math.PI * 2)) {\n            endAngle = 0;\n          }\n\n          var d = 0.001;\n\n          this.startTangent = function () {\n            if (fs === 0) {\n              d *= -1;\n            }\n\n            var dx = params[3] * Math.cos(startAngle - d) + params[1];\n            var dy = params[4] * Math.sin(startAngle - d) + params[2];\n            return [dx - start.x, dy - start.y];\n          };\n\n          this.endTangent = function () {\n            var endAngle = params[6];\n\n            if (endAngle - Math.PI * 2 < 0.0001) {\n              endAngle = 0;\n            }\n\n            var dx = params[3] * Math.cos(startAngle + endAngle + d) + params[1];\n            var dy = params[4] * Math.sin(startAngle + endAngle - d) + params[2];\n            return [preEndPoint.x - dx, preEndPoint.y - dy];\n          };\n\n          break;\n        }\n\n      case 'Z':\n        {\n          this.command = 'Z';\n          this.params = [preEndPoint, preSegment.subStart];\n          this.subStart = preSegment.subStart;\n          this.endPoint = preSegment.subStart;\n        }\n    }\n  },\n  isInside: function isInside(x, y, lineWidth) {\n    var self = this;\n    var command = self.command;\n    var params = self.params;\n    var box = self.box;\n\n    if (box) {\n      if (!Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {\n        return false;\n      }\n    }\n\n    switch (command) {\n      default:\n        break;\n\n      case 'M':\n        return false;\n\n      case 'TL':\n      case 'L':\n      case 'Z':\n        return Inside.line(params[0].x, params[0].y, params[1].x, params[1].y, lineWidth, x, y);\n\n      case 'SQ':\n      case 'Q':\n        return Inside.quadraticline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, lineWidth, x, y);\n\n      case 'C':\n        {\n          return Inside.cubicline(params[0].x, params[0].y, params[1].x, params[1].y, params[2].x, params[2].y, params[3].x, params[3].y, lineWidth, x, y);\n        }\n\n      case 'A':\n        {\n          var p = params;\n          var cx = p[1];\n          var cy = p[2];\n          var rx = p[3];\n          var ry = p[4];\n          var theta = p[5];\n          var dTheta = p[6];\n          var psi = p[7];\n          var fs = p[8];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          p = [x, y, 1];\n          var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          mat3.translate(m, m, [-cx, -cy]);\n          mat3.rotate(m, m, -psi);\n          mat3.scale(m, m, [1 / scaleX, 1 / scaleY]);\n          vec3.transformMat3(p, p, m);\n          return Inside.arcline(0, 0, r, theta, theta + dTheta, 1 - fs, lineWidth, p[0], p[1]);\n        }\n    }\n\n    return false;\n  },\n  draw: function draw(context) {\n    var command = this.command;\n    var params = this.params;\n    var point1;\n    var point2;\n    var point3;\n\n    switch (command) {\n      default:\n        break;\n\n      case 'M':\n        context.moveTo(params[1].x, params[1].y);\n        break;\n\n      case 'TL':\n      case 'L':\n        context.lineTo(params[1].x, params[1].y);\n        break;\n\n      case 'SQ':\n      case 'Q':\n        point1 = params[1];\n        point2 = params[2];\n        context.quadraticCurveTo(point1.x, point1.y, point2.x, point2.y);\n        break;\n\n      case 'C':\n        point1 = params[1];\n        point2 = params[2];\n        point3 = params[3];\n        context.bezierCurveTo(point1.x, point1.y, point2.x, point2.y, point3.x, point3.y);\n        break;\n\n      case 'A':\n        {\n          var p = params;\n          var p1 = p[1];\n          var p2 = p[2];\n          var cx = p1;\n          var cy = p2;\n          var rx = p[3];\n          var ry = p[4];\n          var theta = p[5];\n          var dTheta = p[6];\n          var psi = p[7];\n          var fs = p[8];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          context.translate(cx, cy);\n          context.rotate(psi);\n          context.scale(scaleX, scaleY);\n          context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);\n          context.scale(1 / scaleX, 1 / scaleY);\n          context.rotate(-psi);\n          context.translate(-cx, -cy);\n          break;\n        }\n\n      case 'Z':\n        context.closePath();\n        break;\n    }\n  },\n  getBBox: function getBBox(lineWidth) {\n    var halfWidth = lineWidth / 2;\n    var params = this.params;\n    var yDims;\n    var xDims;\n    var i;\n    var l;\n\n    switch (this.command) {\n      default:\n      case 'M':\n      case 'Z':\n        break;\n\n      case 'TL':\n      case 'L':\n        this.box = {\n          minX: Math.min(params[0].x, params[1].x) - halfWidth,\n          maxX: Math.max(params[0].x, params[1].x) + halfWidth,\n          minY: Math.min(params[0].y, params[1].y) - halfWidth,\n          maxY: Math.max(params[0].y, params[1].y) + halfWidth\n        };\n        break;\n\n      case 'SQ':\n      case 'Q':\n        xDims = Quadratic.extrema(params[0].x, params[1].x, params[2].x);\n\n        for (i = 0, l = xDims.length; i < l; i++) {\n          xDims[i] = Quadratic.at(params[0].x, params[1].x, params[2].x, xDims[i]);\n        }\n\n        xDims.push(params[0].x, params[2].x);\n        yDims = Quadratic.extrema(params[0].y, params[1].y, params[2].y);\n\n        for (i = 0, l = yDims.length; i < l; i++) {\n          yDims[i] = Quadratic.at(params[0].y, params[1].y, params[2].y, yDims);\n        }\n\n        yDims.push(params[0].y, params[2].y);\n        this.box = {\n          minX: Math.min.apply(Math, xDims) - halfWidth,\n          maxX: Math.max.apply(Math, xDims) + halfWidth,\n          minY: Math.min.apply(Math, yDims) - halfWidth,\n          maxY: Math.max.apply(Math, yDims) + halfWidth\n        };\n        break;\n\n      case 'C':\n        xDims = Cubic.extrema(params[0].x, params[1].x, params[2].x, params[3].x);\n\n        for (i = 0, l = xDims.length; i < l; i++) {\n          xDims[i] = Cubic.at(params[0].x, params[1].x, params[2].x, params[3].x, xDims[i]);\n        }\n\n        yDims = Cubic.extrema(params[0].y, params[1].y, params[2].y, params[3].y);\n\n        for (i = 0, l = yDims.length; i < l; i++) {\n          yDims[i] = Cubic.at(params[0].y, params[1].y, params[2].y, params[3].y, yDims[i]);\n        }\n\n        xDims.push(params[0].x, params[3].x);\n        yDims.push(params[0].y, params[3].y);\n        this.box = {\n          minX: Math.min.apply(Math, xDims) - halfWidth,\n          maxX: Math.max.apply(Math, xDims) + halfWidth,\n          minY: Math.min.apply(Math, yDims) - halfWidth,\n          maxY: Math.max.apply(Math, yDims) + halfWidth\n        };\n        break;\n\n      case 'A':\n        {\n          // todo 待优化\n          var p = params;\n          var cx = p[1];\n          var cy = p[2];\n          var rx = p[3];\n          var ry = p[4];\n          var theta = p[5];\n          var dTheta = p[6];\n          var psi = p[7];\n          var fs = p[8];\n          var start = theta;\n          var end = theta + dTheta;\n          var xDim = Ellipse.xExtrema(psi, rx, ry);\n          var minX = Infinity;\n          var maxX = -Infinity;\n          var xs = [start, end];\n\n          for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var xAngle = xDim + i;\n\n            if (fs === 1) {\n              if (start < xAngle && xAngle < end) {\n                xs.push(xAngle);\n              }\n            } else {\n              if (end < xAngle && xAngle < start) {\n                xs.push(xAngle);\n              }\n            }\n          }\n\n          for (i = 0, l = xs.length; i < l; i++) {\n            var x = Ellipse.xAt(psi, rx, ry, cx, xs[i]);\n\n            if (x < minX) {\n              minX = x;\n            }\n\n            if (x > maxX) {\n              maxX = x;\n            }\n          }\n\n          var yDim = Ellipse.yExtrema(psi, rx, ry);\n          var minY = Infinity;\n          var maxY = -Infinity;\n          var ys = [start, end];\n\n          for (i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var yAngle = yDim + i;\n\n            if (fs === 1) {\n              if (start < yAngle && yAngle < end) {\n                ys.push(yAngle);\n              }\n            } else {\n              if (end < yAngle && yAngle < start) {\n                ys.push(yAngle);\n              }\n            }\n          }\n\n          for (i = 0, l = ys.length; i < l; i++) {\n            var y = Ellipse.yAt(psi, rx, ry, cy, ys[i]);\n\n            if (y < minY) {\n              minY = y;\n            }\n\n            if (y > maxY) {\n              maxY = y;\n            }\n          }\n\n          this.box = {\n            minX: minX - halfWidth,\n            maxX: maxX + halfWidth,\n            minY: minY - halfWidth,\n            maxY: maxY + halfWidth\n          };\n          break;\n        }\n    }\n  }\n});\nmodule.exports = PathSegment;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  return a = +a, b -= a, function (t) {\n    return a + b * t;\n  };\n});\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(13);\n\nvar indexOf = Array.prototype.indexOf;\n\nvar contains = function contains(arr, value) {\n  if (!isArrayLike(arr)) {\n    return false;\n  }\n\n  return indexOf.call(arr, value) > -1;\n};\n\nmodule.exports = contains;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\nvar merge = function merge(dataArray) {\n  var rst = [];\n\n  for (var i = 0; i < dataArray.length; i++) {\n    rst = rst.concat(dataArray[i]);\n  }\n\n  return rst;\n};\n\nmodule.exports = merge;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  mat3: __webpack_require__(51),\n  vec2: __webpack_require__(97),\n  vec3: __webpack_require__(98),\n  transform: __webpack_require__(99)\n};\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/**\n * @fileOverview the base class of Coordinate\n * @author sima.zhang\n */\n\n\nvar MatrixUtil = __webpack_require__(43);\n\nvar mix = __webpack_require__(8);\n\nvar mat3 = MatrixUtil.mat3;\nvar vec3 = MatrixUtil.vec3;\n\nvar Coord =\n/*#__PURE__*/\nfunction () {\n  _createClass(Coord, [{\n    key: \"getDefaultCfg\",\n\n    /**\n     * 获取默认的配置属性\n     * @protected\n     * @return {Object} 默认属性\n     */\n    value: function getDefaultCfg() {\n      return {\n        /**\n         * Mark x y is transposed.\n         * @type {Boolean}\n         */\n        isTransposed: false,\n\n        /**\n         * The matrix of coordinate\n         * @type {Array}\n         */\n        matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n      };\n    }\n  }]);\n\n  function Coord(cfg) {\n    _classCallCheck(this, Coord);\n\n    var defaultCfg = this.getDefaultCfg();\n    mix(this, defaultCfg, cfg);\n    this.init();\n  }\n\n  _createClass(Coord, [{\n    key: \"init\",\n    value: function init() {\n      var start = this.start;\n      var end = this.end;\n      var center = {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2\n      };\n      this.center = center;\n      this.width = Math.abs(end.x - start.x);\n      this.height = Math.abs(end.y - start.y);\n    }\n  }, {\n    key: \"_swapDim\",\n    value: function _swapDim(dim) {\n      var dimRange = this[dim];\n\n      if (dimRange) {\n        var tmp = dimRange.start;\n        dimRange.start = dimRange.end;\n        dimRange.end = tmp;\n      }\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.width;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.height;\n    }\n  }, {\n    key: \"convertDim\",\n    value: function convertDim(percent, dim) {\n      var _this$dim = this[dim],\n          start = _this$dim.start,\n          end = _this$dim.end;\n      return start + percent * (end - start);\n    }\n  }, {\n    key: \"invertDim\",\n    value: function invertDim(value, dim) {\n      var _this$dim2 = this[dim],\n          start = _this$dim2.start,\n          end = _this$dim2.end;\n      return (value - start) / (end - start);\n    }\n    /**\n     * 将归一化的坐标点数据转换为画布坐标\n     * @override\n     * @param  {Object} point 归一化的坐标点\n     * @return {Object}       返回画布坐标\n     */\n\n  }, {\n    key: \"convertPoint\",\n    value: function convertPoint(point) {\n      return point;\n    }\n    /**\n     * 将画布坐标转换为归一化的坐标点数据\n     * @override\n     * @param  {Object} point 画布坐标点数据\n     * @return {Object}       归一化后的数据点\n     */\n\n  }, {\n    key: \"invertPoint\",\n    value: function invertPoint(point) {\n      return point;\n    }\n    /**\n     * 将坐标点进行矩阵变换\n     * @param  {Number} x   对应 x 轴画布坐标\n     * @param  {Number} y   对应 y 轴画布坐标\n     * @param  {Number} tag 默认为 0，可取值 0, 1\n     * @return {Array}     返回变换后的三阶向量 [x, y, z]\n     */\n\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(x, y) {\n      var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var matrix = this.matrix;\n      var vector = [x, y, tag];\n      vec3.transformMat3(vector, vector, matrix);\n      return vector;\n    }\n    /**\n     * 将坐标点进行矩阵逆变换\n     * @param  {Number} x   对应 x 轴画布坐标\n     * @param  {Number} y   对应 y 轴画布坐标\n     * @param  {Number} tag 默认为 0，可取值 0, 1\n     * @return {Array}     返回矩阵逆变换后的三阶向量 [x, y, z]\n     */\n\n  }, {\n    key: \"invertMatrix\",\n    value: function invertMatrix(x, y) {\n      var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var matrix = this.matrix;\n      var inversedMatrix = mat3.invert([], matrix);\n      var vector = [x, y, tag];\n      vec3.transformMat3(vector, vector, inversedMatrix);\n      return vector;\n    }\n    /**\n     * 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换\n     * @param  {Object} point 归一化的坐标点\n     * @return {Object}       返回进行矩阵变换后的画布坐标\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(point) {\n      var _this$convertPoint = this.convertPoint(point),\n          x = _this$convertPoint.x,\n          y = _this$convertPoint.y;\n\n      var vector = this.applyMatrix(x, y, 1);\n      return {\n        x: vector[0],\n        y: vector[1]\n      };\n    }\n    /**\n     * 将进行过矩阵变换画布坐标转换为归一化坐标\n     * @param  {Object} point 画布坐标\n     * @return {Object}       返回归一化的坐标点\n     */\n\n  }, {\n    key: \"invert\",\n    value: function invert(point) {\n      var vector = this.invertMatrix(point.x, point.y, 1);\n      return this.invertPoint({\n        x: vector[0],\n        y: vector[1]\n      });\n    }\n    /**\n     * 坐标系旋转变换\n     * @param  {Number} radian 旋转弧度\n     * @return {Object}        返回坐标系对象\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(radian) {\n      var matrix = this.matrix;\n      var center = this.center;\n      mat3.translate(matrix, matrix, [-center.x, -center.y]);\n      mat3.rotate(matrix, matrix, radian);\n      mat3.translate(matrix, matrix, [center.x, center.y]);\n      return this;\n    }\n    /**\n     * 坐标系反射变换\n     * @param  {String} dim 反射维度\n     * @return {Object}     返回坐标系对象\n     */\n\n  }, {\n    key: \"reflect\",\n    value: function reflect(dim) {\n      switch (dim) {\n        case 'x':\n          this._swapDim('x');\n\n          break;\n\n        case 'y':\n          this._swapDim('y');\n\n          break;\n\n        default:\n          this._swapDim('y');\n\n      }\n\n      return this;\n    }\n    /**\n     * 坐标系比例变换\n     * @param  {Number} s1 x 方向缩放比例\n     * @param  {Number} s2 y 方向缩放比例\n     * @return {Object}    返回坐标系对象\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(s1, s2) {\n      var matrix = this.matrix;\n      var center = this.center;\n      mat3.translate(matrix, matrix, [-center.x, -center.y]);\n      mat3.scale(matrix, matrix, [s1, s2]);\n      mat3.translate(matrix, matrix, [center.x, center.y]);\n      return this;\n    }\n    /**\n     * 坐标系平移变换\n     * @param  {Number} x x 方向平移像素\n     * @param  {Number} y y 方向平移像素\n     * @return {Object}   返回坐标系对象\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      var matrix = this.matrix;\n      mat3.translate(matrix, matrix, [x, y]);\n      return this;\n    }\n    /**\n     * 将坐标系 x y 两个轴进行转置\n     * @return {Object} 返回坐标系对象\n     */\n\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      this.isTransposed = !this.isTransposed;\n      return this;\n    }\n  }]);\n\n  return Coord;\n}();\n\nmodule.exports = Coord;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview shape 的辅助方法\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar ShapeUtil = {\n  splitPoints: function splitPoints(obj) {\n    var points = [];\n    var x = obj.x;\n    var y = obj.y;\n    y = Util.isArray(y) ? y : [y];\n    Util.each(y, function (yItem, index) {\n      var point = {\n        x: Util.isArray(x) ? x[index] : x,\n        y: yItem\n      };\n      points.push(point);\n    });\n    return points;\n  },\n  addFillAttrs: function addFillAttrs(attrs, cfg) {\n    if (cfg.color) {\n      attrs.fill = cfg.color;\n    }\n\n    if (Util.isNumber(cfg.opacity)) {\n      attrs.opacity = attrs.fillOpacity = cfg.opacity;\n    }\n  },\n  addStrokeAttrs: function addStrokeAttrs(attrs, cfg) {\n    if (cfg.color) {\n      attrs.stroke = cfg.color;\n    }\n\n    if (Util.isNumber(cfg.opacity)) {\n      attrs.opacity = attrs.strokeOpacity = cfg.opacity;\n    }\n  }\n};\nmodule.exports = ShapeUtil;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isArray = __webpack_require__(4);\n\nvar clone = function clone(obj) {\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {\n    return obj;\n  }\n\n  var rst = void 0;\n\n  if (isArray(obj)) {\n    rst = [];\n\n    for (var i = 0, l = obj.length; i < l; i++) {\n      if (_typeof(obj[i]) === 'object' && obj[i] != null) {\n        rst[i] = clone(obj[i]);\n      } else {\n        rst[i] = obj[i];\n      }\n    }\n  } else {\n    rst = {};\n\n    for (var k in obj) {\n      if (_typeof(obj[k]) === 'object' && obj[k] != null) {\n        rst[k] = clone(obj[k]);\n      } else {\n        rst[k] = obj[k];\n      }\n    }\n  }\n\n  return rst;\n};\n\nmodule.exports = clone;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPlainObject = __webpack_require__(26);\n\nvar isArray = __webpack_require__(4);\n\nvar MAX_MIX_LEVEL = 5;\n\nfunction _deepMix(dist, src, level, maxLevel) {\n  level = level || 0;\n  maxLevel = maxLevel || MAX_MIX_LEVEL;\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key)) {\n      var value = src[key];\n\n      if (value !== null && isPlainObject(value)) {\n        if (!isPlainObject(dist[key])) {\n          dist[key] = {};\n        }\n\n        if (level < maxLevel) {\n          _deepMix(dist[key], value, level + 1, maxLevel);\n        } else {\n          dist[key] = src[key];\n        }\n      } else if (isArray(value)) {\n        dist[key] = [];\n        dist[key] = dist[key].concat(value);\n      } else if (value !== undefined) {\n        dist[key] = value;\n      }\n    }\n  }\n}\n\nvar deepMix = function deepMix() {\n  var args = new Array(arguments.length);\n  var length = args.length;\n\n  for (var i = 0; i < length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var rst = args[0];\n\n  for (var _i = 1; _i < length; _i++) {\n    _deepMix(rst, args[_i]);\n  }\n\n  return rst;\n};\n\nmodule.exports = deepMix;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObjectLike = function isObjectLike(value) {\n  /**\n   * isObjectLike({}) => true\n   * isObjectLike([1, 2, 3]) => true\n   * isObjectLike(Function) => false\n   * isObjectLike(null) => false\n   */\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;\n};\n\nmodule.exports = isObjectLike;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObjectLike = __webpack_require__(48);\n\nvar isArrayLike = __webpack_require__(13);\n\nvar isString = __webpack_require__(10);\n\nvar isEqual = function isEqual(value, other) {\n  if (value === other) {\n    return true;\n  }\n\n  if (!value || !other) {\n    return false;\n  }\n\n  if (isString(value) || isString(other)) {\n    return false;\n  }\n\n  if (isArrayLike(value) || isArrayLike(other)) {\n    if (value.length !== other.length) {\n      return false;\n    }\n\n    var rst = true;\n\n    for (var i = 0; i < value.length; i++) {\n      rst = isEqual(value[i], other[i]);\n\n      if (!rst) {\n        break;\n      }\n    }\n\n    return rst;\n  }\n\n  if (isObjectLike(value) || isObjectLike(other)) {\n    var valueKeys = Object.keys(value);\n    var otherKeys = Object.keys(other);\n\n    if (valueKeys.length !== otherKeys.length) {\n      return false;\n    }\n\n    var _rst = true;\n\n    for (var _i = 0; _i < valueKeys.length; _i++) {\n      _rst = isEqual(value[valueKeys[_i]], other[valueKeys[_i]]);\n\n      if (!_rst) {\n        break;\n      }\n    }\n\n    return _rst;\n  }\n\n  return false;\n};\n\nmodule.exports = isEqual;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\nvar clamp = function clamp(a, min, max) {\n  if (a < min) {\n    return min;\n  } else if (a > max) {\n    return max;\n  }\n\n  return a;\n};\n\nmodule.exports = clamp;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mat3 = __webpack_require__(182);\n\nmat3.translate = function (out, a, v) {\n  var transMat = new Array(9);\n  mat3.fromTranslation(transMat, v);\n  return mat3.multiply(out, transMat, a);\n};\n\nmat3.rotate = function (out, a, rad) {\n  var rotateMat = new Array(9);\n  mat3.fromRotation(rotateMat, rad);\n  return mat3.multiply(out, rotateMat, a);\n};\n\nmat3.scale = function (out, a, v) {\n  var scaleMat = new Array(9);\n  mat3.fromScaling(scaleMat, v);\n  return mat3.multiply(out, scaleMat, a);\n};\n\nmodule.exports = mat3;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setMatrixArrayType = setMatrixArrayType;\nexports.toRadian = toRadian;\nexports.equals = equals;\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\n\nvar EPSILON = exports.EPSILON = 0.000001;\nvar ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = exports.RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  exports.ARRAY_TYPE = ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter v5.1.0 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - http://oli.me.uk/\n * @preserve\n */\n;\n\n(function (exports) {\n  'use strict';\n  /**\n   * Class for managing events.\n   * Can be extended to provide event functionality in other classes.\n   *\n   * @class EventEmitter Manages event registering and emitting.\n   */\n\n  function EventEmitter() {} // Shortcuts to improve speed and size\n\n\n  var proto = EventEmitter.prototype;\n  var originalGlobalValue = exports.EventEmitter;\n  /**\n   * Finds the index of the listener for the event in its storage array.\n   *\n   * @param {Function[]} listeners Array of listeners to search through.\n   * @param {Function} listener Method to look for.\n   * @return {Number} Index of the specified listener, -1 if not found\n   * @api private\n   */\n\n  function indexOfListener(listeners, listener) {\n    var i = listeners.length;\n\n    while (i--) {\n      if (listeners[i].listener === listener) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Alias a method while keeping the context correct, to allow for overwriting of target method.\n   *\n   * @param {String} name The name of the target method.\n   * @return {Function} The aliased method\n   * @api private\n   */\n\n\n  function alias(name) {\n    return function aliasClosure() {\n      return this[name].apply(this, arguments);\n    };\n  }\n  /**\n   * Returns the listener array for the specified event.\n   * Will initialise the event object and listener arrays if required.\n   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n   * Each property in the object response is an array of listener functions.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Function[]|Object} All listener functions for the event.\n   */\n\n\n  proto.getListeners = function getListeners(evt) {\n    var events = this._getEvents();\n\n    var response;\n    var key; // Return a concatenated array of all matching events if\n    // the selector is a regular expression.\n\n    if (evt instanceof RegExp) {\n      response = {};\n\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          response[key] = events[key];\n        }\n      }\n    } else {\n      response = events[evt] || (events[evt] = []);\n    }\n\n    return response;\n  };\n  /**\n   * Takes a list of listener objects and flattens it into a list of listener functions.\n   *\n   * @param {Object[]} listeners Raw listener objects.\n   * @return {Function[]} Just the listener functions.\n   */\n\n\n  proto.flattenListeners = function flattenListeners(listeners) {\n    var flatListeners = [];\n    var i;\n\n    for (i = 0; i < listeners.length; i += 1) {\n      flatListeners.push(listeners[i].listener);\n    }\n\n    return flatListeners;\n  };\n  /**\n   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n   *\n   * @param {String|RegExp} evt Name of the event to return the listeners from.\n   * @return {Object} All listener functions for an event in an object.\n   */\n\n\n  proto.getListenersAsObject = function getListenersAsObject(evt) {\n    var listeners = this.getListeners(evt);\n    var response;\n\n    if (listeners instanceof Array) {\n      response = {};\n      response[evt] = listeners;\n    }\n\n    return response || listeners;\n  };\n\n  function isValidListener(listener) {\n    if (typeof listener === 'function' || listener instanceof RegExp) {\n      return true;\n    } else if (listener && typeof listener === 'object') {\n      return isValidListener(listener.listener);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Adds a listener function to the specified event.\n   * The listener will not be added if it is a duplicate.\n   * If the listener returns true then it will be removed after it is called.\n   * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.addListener = function addListener(evt, listener) {\n    if (!isValidListener(listener)) {\n      throw new TypeError('listener must be a function');\n    }\n\n    var listeners = this.getListenersAsObject(evt);\n    var listenerIsWrapped = typeof listener === 'object';\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n        listeners[key].push(listenerIsWrapped ? listener : {\n          listener: listener,\n          once: false\n        });\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of addListener\n   */\n\n\n  proto.on = alias('addListener');\n  /**\n   * Semi-alias of addListener. It will add a listener that will be\n   * automatically removed after its first execution.\n   *\n   * @param {String|RegExp} evt Name of the event to attach the listener to.\n   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addOnceListener = function addOnceListener(evt, listener) {\n    return this.addListener(evt, {\n      listener: listener,\n      once: true\n    });\n  };\n  /**\n   * Alias of addOnceListener.\n   */\n\n\n  proto.once = alias('addOnceListener');\n  /**\n   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n   * You need to tell it what event names should be matched by a regex.\n   *\n   * @param {String} evt Name of the event to create.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.defineEvent = function defineEvent(evt) {\n    this.getListeners(evt);\n    return this;\n  };\n  /**\n   * Uses defineEvent to define multiple events.\n   *\n   * @param {String[]} evts An array of event names to define.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.defineEvents = function defineEvents(evts) {\n    for (var i = 0; i < evts.length; i += 1) {\n      this.defineEvent(evts[i]);\n    }\n\n    return this;\n  };\n  /**\n   * Removes a listener function from the specified event.\n   * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to remove the listener from.\n   * @param {Function} listener Method to remove from the event.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListener = function removeListener(evt, listener) {\n    var listeners = this.getListenersAsObject(evt);\n    var index;\n    var key;\n\n    for (key in listeners) {\n      if (listeners.hasOwnProperty(key)) {\n        index = indexOfListener(listeners[key], listener);\n\n        if (index !== -1) {\n          listeners[key].splice(index, 1);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeListener\n   */\n\n\n  proto.off = alias('removeListener');\n  /**\n   * Adds listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n   * You can also pass it a regular expression to add the array of listeners to all events that match it.\n   * Yeah, this function does quite a bit. That's probably a bad thing.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.addListeners = function addListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(false, evt, listeners);\n  };\n  /**\n   * Removes listeners in bulk using the manipulateListeners method.\n   * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be removed.\n   * You can also pass it a regular expression to remove the listeners from all events that match it.\n   *\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeListeners = function removeListeners(evt, listeners) {\n    // Pass through to manipulateListeners\n    return this.manipulateListeners(true, evt, listeners);\n  };\n  /**\n   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n   * The first argument will determine if the listeners are removed (true) or added (false).\n   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n   * You can also pass it an event name and an array of listeners to be added/removed.\n   * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n   *\n   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n    var i;\n    var value;\n    var single = remove ? this.removeListener : this.addListener;\n    var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method\n\n    if (typeof evt === 'object' && !(evt instanceof RegExp)) {\n      for (i in evt) {\n        if (evt.hasOwnProperty(i) && (value = evt[i])) {\n          // Pass the single listener straight through to the singular method\n          if (typeof value === 'function') {\n            single.call(this, i, value);\n          } else {\n            // Otherwise pass back to the multiple function\n            multiple.call(this, i, value);\n          }\n        }\n      }\n    } else {\n      // So evt must be a string\n      // And listeners must be an array of listeners\n      // Loop over it and pass each one to the multiple method\n      i = listeners.length;\n\n      while (i--) {\n        single.call(this, evt, listeners[i]);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Removes all listeners from a specified event.\n   * If you do not specify an event then all listeners will be removed.\n   * That means every event will be emptied.\n   * You can also pass a regex to remove all events that match it.\n   *\n   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.removeEvent = function removeEvent(evt) {\n    var type = typeof evt;\n\n    var events = this._getEvents();\n\n    var key; // Remove different things depending on the state of evt\n\n    if (type === 'string') {\n      // Remove all listeners for the specified event\n      delete events[evt];\n    } else if (evt instanceof RegExp) {\n      // Remove all events matching the regex.\n      for (key in events) {\n        if (events.hasOwnProperty(key) && evt.test(key)) {\n          delete events[key];\n        }\n      }\n    } else {\n      // Remove all listeners in all events\n      delete this._events;\n    }\n\n    return this;\n  };\n  /**\n   * Alias of removeEvent.\n   *\n   * Added to mirror the node API.\n   */\n\n\n  proto.removeAllListeners = alias('removeEvent');\n  /**\n   * Emits an event of your choice.\n   * When emitted, every listener attached to that event will be executed.\n   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n   * So they will not arrive within the array on the other side, they will be separate.\n   * You can also pass a regular expression to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {Array} [args] Optional array of arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emitEvent = function emitEvent(evt, args) {\n    var listenersMap = this.getListenersAsObject(evt);\n    var listeners;\n    var listener;\n    var i;\n    var key;\n    var response;\n\n    for (key in listenersMap) {\n      if (listenersMap.hasOwnProperty(key)) {\n        listeners = listenersMap[key].slice(0);\n\n        for (i = 0; i < listeners.length; i++) {\n          // If the listener returns true then it shall be removed from the event\n          // The function is executed either with a basic call or an apply if there is an args array\n          listener = listeners[i];\n\n          if (listener.once === true) {\n            this.removeListener(evt, listener.listener);\n          }\n\n          response = listener.listener.apply(this, args || []);\n\n          if (response === this._getOnceReturnValue()) {\n            this.removeListener(evt, listener.listener);\n          }\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Alias of emitEvent\n   */\n\n\n  proto.trigger = alias('emitEvent');\n  /**\n   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n   *\n   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n   * @param {...*} Optional additional arguments to be passed to each listener.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n  proto.emit = function emit(evt) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return this.emitEvent(evt, args);\n  };\n  /**\n   * Sets the current value to check against when executing listeners. If a\n   * listeners return value matches the one set here then it will be removed\n   * after execution. This value defaults to true.\n   *\n   * @param {*} value The new value to check for when executing listeners.\n   * @return {Object} Current instance of EventEmitter for chaining.\n   */\n\n\n  proto.setOnceReturnValue = function setOnceReturnValue(value) {\n    this._onceReturnValue = value;\n    return this;\n  };\n  /**\n   * Fetches the current value to check against when executing listeners. If\n   * the listeners return value matches this one then it should be removed\n   * automatically. It will return true by default.\n   *\n   * @return {*|Boolean} The current value to check for or the default, true.\n   * @api private\n   */\n\n\n  proto._getOnceReturnValue = function _getOnceReturnValue() {\n    if (this.hasOwnProperty('_onceReturnValue')) {\n      return this._onceReturnValue;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * Fetches the events object and creates one if required.\n   *\n   * @return {Object} The events storage object.\n   * @api private\n   */\n\n\n  proto._getEvents = function _getEvents() {\n    return this._events || (this._events = {});\n  };\n  /**\n   * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n   *\n   * @return {Function} Non conflicting EventEmitter class.\n   */\n\n\n  EventEmitter.noConflict = function noConflict() {\n    exports.EventEmitter = originalGlobalValue;\n    return EventEmitter;\n  }; // Expose the class either via AMD, CommonJS or the global object\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this || {});\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Line = __webpack_require__(36);\n\nvar Quadratic = __webpack_require__(103);\n\nvar Cubic = __webpack_require__(55);\n\nvar Arc = __webpack_require__(37);\n\nmodule.exports = {\n  line: function line(x1, y1, x2, y2, lineWidth, x, y) {\n    var box = Line.box(x1, y1, x2, y2, lineWidth);\n\n    if (!this.box(box.minX, box.maxX, box.minY, box.maxY, x, y)) {\n      return false;\n    }\n\n    var d = Line.pointDistance(x1, y1, x2, y2, x, y);\n\n    if (isNaN(d)) {\n      return false;\n    }\n\n    return d <= lineWidth / 2;\n  },\n  polyline: function polyline(points, lineWidth, x, y) {\n    var l = points.length - 1;\n\n    if (l < 1) {\n      return false;\n    }\n\n    for (var i = 0; i < l; i++) {\n      var x1 = points[i][0];\n      var y1 = points[i][1];\n      var x2 = points[i + 1][0];\n      var y2 = points[i + 1][1];\n\n      if (this.line(x1, y1, x2, y2, lineWidth, x, y)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  cubicline: function cubicline(x1, y1, x2, y2, x3, y3, x4, y4, lineWidth, x, y) {\n    return Cubic.pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x, y) <= lineWidth / 2;\n  },\n  quadraticline: function quadraticline(x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n    return Quadratic.pointDistance(x1, y1, x2, y2, x3, y3, x, y) <= lineWidth / 2;\n  },\n  arcline: function arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y) {\n    return Arc.pointDistance(cx, cy, r, startAngle, endAngle, clockwise, x, y) <= lineWidth / 2;\n  },\n  rect: function rect(rx, ry, width, height, x, y) {\n    return rx <= x && x <= rx + width && ry <= y && y <= ry + height;\n  },\n  circle: function circle(cx, cy, r, x, y) {\n    return Math.pow(x - cx, 2) + Math.pow(y - cy, 2) <= Math.pow(r, 2);\n  },\n  box: function box(minX, maxX, minY, maxY, x, y) {\n    return minX <= x && x <= maxX && minY <= y && y <= maxY;\n  }\n};\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar vec2 = Util.vec2;\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p3 + 3 * t * p2) + t * t * (t * p0 + 3 * onet * p1);\n}\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n\nfunction cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, out) {\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n\n  var _t;\n\n  var v1;\n  var d1;\n  var d2;\n  var v2;\n  var prev;\n  var next;\n  var EPSILON = 0.0001;\n  var v0 = [x, y];\n\n  for (_t = 0; _t < 1; _t += 0.05) {\n    v1 = [cubicAt(x1, x2, x3, x4, _t), cubicAt(y1, y2, y3, y4, _t)];\n    d1 = vec2.squaredDistance(v0, v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity;\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval;\n    v1 = [cubicAt(x1, x2, x3, x4, prev), cubicAt(y1, y2, y3, y4, prev)];\n    d1 = vec2.squaredDistance(v0, v1);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      v2 = [cubicAt(x1, x2, x3, x4, next), cubicAt(y1, y2, y3, y4, next)];\n      d2 = vec2.squaredDistance(v0, v2);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  if (out) {\n    out.x = cubicAt(x1, x2, x3, x4, t);\n    out.y = cubicAt(y1, y2, y3, y4, t);\n  }\n\n  return Math.sqrt(d);\n}\n\nfunction cubicExtrema(p0, p1, p2, p3) {\n  var a = 3 * p0 - 9 * p1 + 9 * p2 - 3 * p3;\n  var b = 6 * p1 - 12 * p2 + 6 * p3;\n  var c = 3 * p2 - 3 * p3;\n  var extrema = [];\n  var t1;\n  var t2;\n  var discSqrt;\n\n  if (Util.isNumberEqual(a, 0)) {\n    if (!Util.isNumberEqual(b, 0)) {\n      t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema.push(t1);\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (Util.isNumberEqual(disc, 0)) {\n      extrema.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema.push(t1);\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema.push(t2);\n      }\n    }\n  }\n\n  return extrema;\n}\n\nfunction base3(t, p1, p2, p3, p4) {\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;\n  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n  return t * t2 - 3 * p1 + 3 * p2;\n}\n\nfunction cubiclLen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n  if (Util.isNil(z)) {\n    z = 1;\n  }\n\n  z = z > 1 ? 1 : z < 0 ? 0 : z;\n  var z2 = z / 2;\n  var n = 12;\n  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];\n  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\n  var sum = 0;\n\n  for (var i = 0; i < n; i++) {\n    var ct = z2 * Tvalues[i] + z2;\n    var xbase = base3(ct, x1, x2, x3, x4);\n    var ybase = base3(ct, y1, y2, y3, y4);\n    var comb = xbase * xbase + ybase * ybase;\n    sum += Cvalues[i] * Math.sqrt(comb);\n  }\n\n  return z2 * sum;\n}\n\nmodule.exports = {\n  at: cubicAt,\n  derivativeAt: cubicDerivativeAt,\n  projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y) {\n    var rst = {};\n    cubicProjectPoint(x1, y1, x2, y2, x3, y3, x4, y4, x, y, rst);\n    return rst;\n  },\n  pointDistance: cubicProjectPoint,\n  extrema: cubicExtrema,\n  len: cubiclLen\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Format = __webpack_require__(27);\n\nvar PathSegment = __webpack_require__(39);\n\nvar Marker = function Marker(cfg) {\n  Marker.superclass.constructor.call(this, cfg);\n};\n\nMarker.Symbols = {\n  // 圆\n  circle: function circle(x, y, r) {\n    return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];\n  },\n  // 正方形\n  square: function square(x, y, r) {\n    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];\n  },\n  // 菱形\n  diamond: function diamond(x, y, r) {\n    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];\n  },\n  // 三角形\n  triangle: function triangle(x, y, r) {\n    var diffY = r * Math.sin(1 / 3 * Math.PI);\n    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];\n  },\n  // 倒三角形\n  'triangle-down': function triangleDown(x, y, r) {\n    var diffY = r * Math.sin(1 / 3 * Math.PI);\n    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];\n  }\n};\nMarker.ATTRS = {\n  path: null,\n  lineWidth: 1\n};\nUtil.extend(Marker, Shape);\nUtil.augment(Marker, {\n  type: 'marker',\n  canFill: true,\n  canStroke: true,\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      lineWidth: 1\n    };\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var r = attrs.radius;\n    var lineWidth = this.getHitLineWidth();\n    var halfWidth = lineWidth / 2 + r;\n    return {\n      minX: cx - halfWidth,\n      minY: cy - halfWidth,\n      maxX: cx + halfWidth,\n      maxY: cy + halfWidth\n    };\n  },\n  _getPath: function _getPath() {\n    var attrs = this._attrs;\n    var x = attrs.x;\n    var y = attrs.y;\n    var r = attrs.radius || attrs.r;\n    var symbol = attrs.symbol || 'circle';\n    var method;\n\n    if (Util.isFunction(symbol)) {\n      method = symbol;\n    } else {\n      method = Marker.Symbols[symbol];\n    }\n\n    return method(x, y, r);\n  },\n  createPath: function createPath(context) {\n    var segments = this._cfg.segments;\n\n    if (segments && !this._cfg.hasUpdate) {\n      context.beginPath();\n\n      for (var i = 0; i < segments.length; i++) {\n        segments[i].draw(context);\n      }\n\n      return;\n    }\n\n    var path = Format.parsePath(this._getPath());\n    context.beginPath();\n    var preSegment;\n    segments = [];\n\n    for (var _i = 0; _i < path.length; _i++) {\n      var item = path[_i];\n      preSegment = new PathSegment(item, preSegment, _i === path.length - 1);\n      segments.push(preSegment);\n      preSegment.draw(context);\n    }\n\n    this._cfg.segments = segments;\n    this._cfg.hasUpdate = false;\n  }\n});\nmodule.exports = Marker;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(81);\n\nvar SPACES = \"\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\";\nvar PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');\nvar PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments\n\nvar parsePathString = function parsePathString(pathString) {\n  if (!pathString) {\n    return null;\n  }\n\n  if (typeof pathString === typeof []) {\n    return pathString;\n  }\n\n  var paramCounts = {\n    a: 7,\n    c: 6,\n    o: 2,\n    h: 1,\n    l: 2,\n    m: 2,\n    r: 4,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    u: 3,\n    z: 0\n  };\n  var data = [];\n  String(pathString).replace(PATH_COMMAND, function (a, b, c) {\n    var params = [];\n    var name = b.toLowerCase();\n    c.replace(PATH_VALUES, function (a, b) {\n      b && params.push(+b);\n    });\n\n    if (name === 'm' && params.length > 2) {\n      data.push([b].concat(params.splice(0, 2)));\n      name = 'l';\n      b = b === 'm' ? 'l' : 'L';\n    }\n\n    if (name === 'o' && params.length === 1) {\n      data.push([b, params[0]]);\n    }\n\n    if (name === 'r') {\n      data.push([b].concat(params));\n    } else {\n      while (params.length >= paramCounts[name]) {\n        data.push([b].concat(params.splice(0, paramCounts[name])));\n\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    }\n  });\n  return data;\n}; // http://schepers.cc/getting-to-the-point\n\n\nvar catmullRom2bezier = function catmullRom2bezier(crp, z) {\n  var d = [];\n\n  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n    var p = [{\n      x: +crp[i - 2],\n      y: +crp[i - 1]\n    }, {\n      x: +crp[i],\n      y: +crp[i + 1]\n    }, {\n      x: +crp[i + 2],\n      y: +crp[i + 3]\n    }, {\n      x: +crp[i + 4],\n      y: +crp[i + 5]\n    }];\n\n    if (z) {\n      if (!i) {\n        p[0] = {\n          x: +crp[iLen - 2],\n          y: +crp[iLen - 1]\n        };\n      } else if (iLen - 4 === i) {\n        p[3] = {\n          x: +crp[0],\n          y: +crp[1]\n        };\n      } else if (iLen - 2 === i) {\n        p[2] = {\n          x: +crp[0],\n          y: +crp[1]\n        };\n        p[3] = {\n          x: +crp[2],\n          y: +crp[3]\n        };\n      }\n    } else {\n      if (iLen - 4 === i) {\n        p[3] = p[2];\n      } else if (!i) {\n        p[0] = {\n          x: +crp[i],\n          y: +crp[i + 1]\n        };\n      }\n    }\n\n    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);\n  }\n\n  return d;\n};\n\nvar ellipsePath = function ellipsePath(x, y, rx, ry, a) {\n  var res = [];\n\n  if (a === null && ry === null) {\n    ry = rx;\n  }\n\n  x = +x;\n  y = +y;\n  rx = +rx;\n  ry = +ry;\n\n  if (a !== null) {\n    var rad = Math.PI / 180;\n    var x1 = x + rx * Math.cos(-ry * rad);\n    var x2 = x + rx * Math.cos(-a * rad);\n    var y1 = y + rx * Math.sin(-ry * rad);\n    var y2 = y + rx * Math.sin(-a * rad);\n    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n  } else {\n    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\n  }\n\n  return res;\n};\n\nvar pathToAbsolute = function pathToAbsolute(pathArray) {\n  pathArray = parsePathString(pathArray);\n\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0;\n  var dots;\n\n  if (pathArray[0][0] === 'M') {\n    x = +pathArray[0][1];\n    y = +pathArray[0][2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n\n  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';\n\n  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n    res.push(r = []);\n    pa = pathArray[i];\n    pa0 = pa[0];\n\n    if (pa0 !== pa0.toUpperCase()) {\n      r[0] = pa0.toUpperCase();\n\n      switch (r[0]) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n\n        case 'R':\n          dots = [x, y].concat(pa.slice(1));\n\n          for (var j = 2, jj = dots.length; j < jj; j++) {\n            dots[j] = +dots[j] + x;\n            dots[++j] = +dots[j] + y;\n          }\n\n          res.pop();\n          res = res.concat(catmullRom2bezier(dots, crz));\n          break;\n\n        case 'O':\n          res.pop();\n          dots = ellipsePath(x, y, pa[1], pa[2]);\n          dots.push(dots[0]);\n          res = res.concat(dots);\n          break;\n\n        case 'U':\n          res.pop();\n          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n          r = ['U'].concat(res[res.length - 1].slice(-2));\n          break;\n\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          break;\n        // for lint\n\n        default:\n          for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {\n            r[_j] = +pa[_j] + (_j % 2 ? x : y);\n          }\n\n      }\n    } else if (pa0 === 'R') {\n      dots = [x, y].concat(pa.slice(1));\n      res.pop();\n      res = res.concat(catmullRom2bezier(dots, crz));\n      r = ['R'].concat(pa.slice(-2));\n    } else if (pa0 === 'O') {\n      res.pop();\n      dots = ellipsePath(x, y, pa[1], pa[2]);\n      dots.push(dots[0]);\n      res = res.concat(dots);\n    } else if (pa0 === 'U') {\n      res.pop();\n      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n      r = ['U'].concat(res[res.length - 1].slice(-2));\n    } else {\n      for (var k = 0, kk = pa.length; k < kk; k++) {\n        r[k] = pa[k];\n      }\n    }\n\n    pa0 = pa0.toUpperCase();\n\n    if (pa0 !== 'O') {\n      switch (r[0]) {\n        case 'Z':\n          x = +mx;\n          y = +my;\n          break;\n\n        case 'H':\n          x = r[1];\n          break;\n\n        case 'V':\n          y = r[1];\n          break;\n\n        case 'M':\n          mx = r[r.length - 2];\n          my = r[r.length - 1];\n          break;\n        // for lint\n\n        default:\n          x = r[r.length - 2];\n          y = r[r.length - 1];\n      }\n    }\n  }\n\n  return res;\n};\n\nvar l2c = function l2c(x1, y1, x2, y2) {\n  return [x1, y1, x2, y2, x2, y2];\n};\n\nvar q2c = function q2c(x1, y1, ax, ay, x2, y2) {\n  var _13 = 1 / 3;\n\n  var _23 = 2 / 3;\n\n  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n};\n\nvar a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  if (rx === ry) {\n    rx += 1;\n  }\n\n  var _120 = Math.PI * 120 / 180;\n\n  var rad = Math.PI / 180 * (+angle || 0);\n  var res = [];\n  var xy;\n  var f1;\n  var f2;\n  var cx;\n  var cy;\n\n  var rotate = function rotate(x, y, rad) {\n    var X = x * Math.cos(rad) - y * Math.sin(rad);\n    var Y = x * Math.sin(rad) + y * Math.cos(rad);\n    return {\n      x: X,\n      y: Y\n    };\n  };\n\n  if (!recursive) {\n    xy = rotate(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotate(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    if (x1 === x2 && y1 === y2) {\n      // 若弧的起始点和终点重叠则错开一点\n      x2 += 1;\n      y2 += 1;\n    } // const cos = Math.cos(Math.PI / 180 * angle);\n    // const sin = Math.sin(Math.PI / 180 * angle);\n\n\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    cx = k * rx * y / ry + (x1 + x2) / 2;\n    cy = k * -ry * x / rx + (y1 + y2) / 2;\n    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));\n    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1);\n  var s1 = Math.sin(f1);\n  var c2 = Math.cos(f2);\n  var s2 = Math.sin(f2);\n  var t = Math.tan(df / 4);\n  var hx = 4 / 3 * rx * t;\n  var hy = 4 / 3 * ry * t;\n  var m1 = [x1, y1];\n  var m2 = [x1 + hx * s1, y1 - hy * c1];\n  var m3 = [x2 + hx * s2, y2 - hy * c2];\n  var m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n\n  if (recursive) {\n    return [m2, m3, m4].concat(res);\n  }\n\n  res = [m2, m3, m4].concat(res).join().split(',');\n  var newres = [];\n\n  for (var i = 0, ii = res.length; i < ii; i++) {\n    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n  }\n\n  return newres;\n};\n\nvar pathTocurve = function pathTocurve(path, path2) {\n  var p = pathToAbsolute(path);\n  var p2 = path2 && pathToAbsolute(path2);\n  var attrs = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var attrs2 = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var pcoms1 = []; // path commands of original path p\n\n  var pcoms2 = []; // path commands of original path p2\n\n  var pfirst = ''; // temporary holder for original path command\n\n  var pcom = ''; // holder for previous path command of original path\n\n  var ii;\n\n  var processPath = function processPath(path, d, pcom) {\n    var nx, ny;\n\n    if (!path) {\n      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n    }\n\n    !(path[0] in {\n      T: 1,\n      Q: 1\n    }) && (d.qx = d.qy = null);\n\n    switch (path[0]) {\n      case 'M':\n        d.X = path[1];\n        d.Y = path[2];\n        break;\n\n      case 'A':\n        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n        break;\n\n      case 'S':\n        if (pcom === 'C' || pcom === 'S') {\n          // In \"S\" case we have to take into account, if the previous command is C/S.\n          nx = d.x * 2 - d.bx; // And reflect the previous\n\n          ny = d.y * 2 - d.by; // command's control point relative to the current point.\n        } else {\n          // or some else or nothing\n          nx = d.x;\n          ny = d.y;\n        }\n\n        path = ['C', nx, ny].concat(path.slice(1));\n        break;\n\n      case 'T':\n        if (pcom === 'Q' || pcom === 'T') {\n          // In \"T\" case we have to take into account, if the previous command is Q/T.\n          d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n          d.qy = d.y * 2 - d.qy; // to case \"S\".\n        } else {\n          // or something else or nothing\n          d.qx = d.x;\n          d.qy = d.y;\n        }\n\n        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n        break;\n\n      case 'Q':\n        d.qx = path[1];\n        d.qy = path[2];\n        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n        break;\n\n      case 'L':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\n        break;\n\n      case 'H':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\n        break;\n\n      case 'V':\n        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\n        break;\n\n      case 'Z':\n        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\n        break;\n\n      default:\n        break;\n    }\n\n    return path;\n  };\n\n  var fixArc = function fixArc(pp, i) {\n    if (pp[i].length > 7) {\n      pp[i].shift();\n      var pi = pp[i];\n\n      while (pi.length) {\n        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\n\n        p2 && (pcoms2[i] = 'A'); // the same as above\n\n        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n      }\n\n      pp.splice(i, 1);\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  var fixM = function fixM(path1, path2, a1, a2, i) {\n    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {\n      path2.splice(i, 0, ['M', a2.x, a2.y]);\n      a1.bx = 0;\n      a1.by = 0;\n      a1.x = path1[i][1];\n      a1.y = path1[i][2];\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  ii = Math.max(p.length, p2 && p2.length || 0);\n\n  for (var i = 0; i < ii; i++) {\n    p[i] && (pfirst = p[i][0]); // save current path command\n\n    if (pfirst !== 'C') {\n      // C is not saved yet, because it may be result of conversion\n      pcoms1[i] = pfirst; // Save current path command\n\n      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n    }\n\n    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command\n    // which may produce multiple C:s\n    // so we have to make sure that C is also C in original path\n\n    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n    if (p2) {\n      // the same procedures is done to p2\n      p2[i] && (pfirst = p2[i][0]);\n\n      if (pfirst !== 'C') {\n        pcoms2[i] = pfirst;\n        i && (pcom = pcoms2[i - 1]);\n      }\n\n      p2[i] = processPath(p2[i], attrs2, pcom);\n\n      if (pcoms2[i] !== 'A' && pfirst === 'C') {\n        pcoms2[i] = 'C';\n      }\n\n      fixArc(p2, i);\n    }\n\n    fixM(p, p2, attrs, attrs2, i);\n    fixM(p2, p, attrs2, attrs, i);\n    var seg = p[i];\n    var seg2 = p2 && p2[i];\n    var seglen = seg.length;\n    var seg2len = p2 && seg2.length;\n    attrs.x = seg[seglen - 2];\n    attrs.y = seg[seglen - 1];\n    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n    attrs2.x = p2 && seg2[seg2len - 2];\n    attrs2.y = p2 && seg2[seg2len - 1];\n  }\n\n  return p2 ? [p, p2] : p;\n};\n\nvar p2s = /,?([a-z]),?/gi;\n\nvar parsePathArray = function parsePathArray(path) {\n  return path.join(',').replace(p2s, '$1');\n};\n\nvar base3 = function base3(t, p1, p2, p3, p4) {\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;\n  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n  return t * t2 - 3 * p1 + 3 * p2;\n};\n\nvar bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n  if (z === null) {\n    z = 1;\n  }\n\n  z = z > 1 ? 1 : z < 0 ? 0 : z;\n  var z2 = z / 2;\n  var n = 12;\n  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];\n  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\n  var sum = 0;\n\n  for (var i = 0; i < n; i++) {\n    var ct = z2 * Tvalues[i] + z2;\n    var xbase = base3(ct, x1, x2, x3, x4);\n    var ybase = base3(ct, y1, y2, y3, y4);\n    var comb = xbase * xbase + ybase * ybase;\n    sum += Cvalues[i] * Math.sqrt(comb);\n  }\n\n  return z2 * sum;\n};\n\nvar curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var tvalues = [];\n  var bounds = [[], []];\n  var a;\n  var b;\n  var c;\n  var t;\n\n  for (var i = 0; i < 2; ++i) {\n    if (i === 0) {\n      b = 6 * x0 - 12 * x1 + 6 * x2;\n      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n      c = 3 * x1 - 3 * x0;\n    } else {\n      b = 6 * y0 - 12 * y1 + 6 * y2;\n      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n      c = 3 * y1 - 3 * y0;\n    }\n\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) < 1e-12) {\n        continue;\n      }\n\n      t = -c / b;\n\n      if (t > 0 && t < 1) {\n        tvalues.push(t);\n      }\n\n      continue;\n    }\n\n    var b2ac = b * b - 4 * c * a;\n    var sqrtb2ac = Math.sqrt(b2ac);\n\n    if (b2ac < 0) {\n      continue;\n    }\n\n    var t1 = (-b + sqrtb2ac) / (2 * a);\n\n    if (t1 > 0 && t1 < 1) {\n      tvalues.push(t1);\n    }\n\n    var t2 = (-b - sqrtb2ac) / (2 * a);\n\n    if (t2 > 0 && t2 < 1) {\n      tvalues.push(t2);\n    }\n  }\n\n  var j = tvalues.length;\n  var jlen = j;\n  var mt;\n\n  while (j--) {\n    t = tvalues[j];\n    mt = 1 - t;\n    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n  }\n\n  bounds[0][jlen] = x0;\n  bounds[1][jlen] = y0;\n  bounds[0][jlen + 1] = x3;\n  bounds[1][jlen + 1] = y3;\n  bounds[0].length = bounds[1].length = jlen + 2;\n  return {\n    min: {\n      x: Math.min.apply(0, bounds[0]),\n      y: Math.min.apply(0, bounds[1])\n    },\n    max: {\n      x: Math.max.apply(0, bounds[0]),\n      y: Math.max.apply(0, bounds[1])\n    }\n  };\n};\n\nvar intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {\n    return;\n  }\n\n  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  if (!denominator) {\n    return;\n  }\n\n  var px = nx / denominator;\n  var py = ny / denominator;\n  var px2 = +px.toFixed(2);\n  var py2 = +py.toFixed(2);\n\n  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {\n    return;\n  }\n\n  return {\n    x: px,\n    y: py\n  };\n};\n\nvar isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n};\n\nvar rectPath = function rectPath(x, y, w, h, r) {\n  if (r) {\n    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];\n  }\n\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\n  res.parsePathArray = parsePathArray;\n  return res;\n};\n\nvar box = function box(x, y, width, height) {\n  if (x === null) {\n    x = y = width = height = 0;\n  }\n\n  if (y === null) {\n    y = x.y;\n    width = x.width;\n    height = x.height;\n    x = x.x;\n  }\n\n  return {\n    x: x,\n    y: y,\n    width: width,\n    w: width,\n    height: height,\n    h: height,\n    x2: x + width,\n    y2: y + height,\n    cx: x + width / 2,\n    cy: y + height / 2,\n    r1: Math.min(width, height) / 2,\n    r2: Math.max(width, height) / 2,\n    r0: Math.sqrt(width * width + height * height) / 2,\n    path: rectPath(x, y, width, height),\n    vb: [x, y, width, height].join(' ')\n  };\n};\n\nvar isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {\n  bbox1 = box(bbox1);\n  bbox2 = box(bbox2);\n  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n};\n\nvar bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n  if (!Util.isArray(p1x)) {\n    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n  }\n\n  var bbox = curveDim.apply(null, p1x);\n  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\n};\n\nvar findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n  var t1 = 1 - t;\n  var t13 = Math.pow(t1, 3);\n  var t12 = Math.pow(t1, 2);\n  var t2 = t * t;\n  var t3 = t2 * t;\n  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;\n  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;\n  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);\n  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);\n  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);\n  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);\n  var ax = t1 * p1x + t * c1x;\n  var ay = t1 * p1y + t * c1y;\n  var cx = t1 * c2x + t * p2x;\n  var cy = t1 * c2y + t * p2y;\n  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);\n\n  return {\n    x: x,\n    y: y,\n    m: {\n      x: mx,\n      y: my\n    },\n    n: {\n      x: nx,\n      y: ny\n    },\n    start: {\n      x: ax,\n      y: ay\n    },\n    end: {\n      x: cx,\n      y: cy\n    },\n    alpha: alpha\n  };\n};\n\nvar interHelper = function interHelper(bez1, bez2, justCount) {\n  var bbox1 = bezierBBox(bez1);\n  var bbox2 = bezierBBox(bez2);\n\n  if (!isBBoxIntersect(bbox1, bbox2)) {\n    return justCount ? 0 : [];\n  }\n\n  var l1 = bezlen.apply(0, bez1);\n  var l2 = bezlen.apply(0, bez2);\n  var n1 = ~~(l1 / 8);\n  var n2 = ~~(l2 / 8);\n  var dots1 = [];\n  var dots2 = [];\n  var xy = {};\n  var res = justCount ? 0 : [];\n\n  for (var i = 0; i < n1 + 1; i++) {\n    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n    dots1.push({\n      x: d.x,\n      y: d.y,\n      t: i / n1\n    });\n  }\n\n  for (var _i = 0; _i < n2 + 1; _i++) {\n    var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));\n\n    dots2.push({\n      x: _d.x,\n      y: _d.y,\n      t: _i / n2\n    });\n  }\n\n  for (var _i2 = 0; _i2 < n1; _i2++) {\n    for (var j = 0; j < n2; j++) {\n      var di = dots1[_i2];\n      var di1 = dots1[_i2 + 1];\n      var dj = dots2[j];\n      var dj1 = dots2[j + 1];\n      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';\n      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';\n      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\n      if (is) {\n        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {\n          continue;\n        }\n\n        xy[is.x.toFixed(4)] = is.y.toFixed(4);\n        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);\n        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\n        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n          if (justCount) {\n            res++;\n          } else {\n            res.push({\n              x: is.x,\n              y: is.y,\n              t1: t1,\n              t2: t2\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return res;\n};\n\nvar interPathHelper = function interPathHelper(path1, path2, justCount) {\n  path1 = pathTocurve(path1);\n  path2 = pathTocurve(path2);\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  var x1m;\n  var y1m;\n  var x2m;\n  var y2m;\n  var bez1;\n  var bez2;\n  var res = justCount ? 0 : [];\n\n  for (var i = 0, ii = path1.length; i < ii; i++) {\n    var pi = path1[i];\n\n    if (pi[0] === 'M') {\n      x1 = x1m = pi[1];\n      y1 = y1m = pi[2];\n    } else {\n      if (pi[0] === 'C') {\n        bez1 = [x1, y1].concat(pi.slice(1));\n        x1 = bez1[6];\n        y1 = bez1[7];\n      } else {\n        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n        x1 = x1m;\n        y1 = y1m;\n      }\n\n      for (var j = 0, jj = path2.length; j < jj; j++) {\n        var pj = path2[j];\n\n        if (pj[0] === 'M') {\n          x2 = x2m = pj[1];\n          y2 = y2m = pj[2];\n        } else {\n          if (pj[0] === 'C') {\n            bez2 = [x2, y2].concat(pj.slice(1));\n            x2 = bez2[6];\n            y2 = bez2[7];\n          } else {\n            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n            x2 = x2m;\n            y2 = y2m;\n          }\n\n          var intr = interHelper(bez1, bez2, justCount);\n\n          if (justCount) {\n            res += intr;\n          } else {\n            for (var k = 0, kk = intr.length; k < kk; k++) {\n              intr[k].segment1 = i;\n              intr[k].segment2 = j;\n              intr[k].bez1 = bez1;\n              intr[k].bez2 = bez2;\n            }\n\n            res = res.concat(intr);\n          }\n        }\n      }\n    }\n  }\n\n  return res;\n};\n\nvar pathIntersection = function pathIntersection(path1, path2) {\n  return interPathHelper(path1, path2);\n};\n\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function recurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var middlePoints = [];\n\n      for (var i = 0; i < points.length - 1; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === points.length - 2) {\n          right.push(points[i + 1]);\n        }\n\n        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      recurse(middlePoints, t);\n    }\n  }\n\n  if (points.length) {\n    recurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n\nfunction splitCurve(start, end, count) {\n  var points = [[start[1], start[2]]];\n  count = count || 2;\n  var segments = [];\n\n  if (end[0] === 'A') {\n    points.push(end[6]);\n    points.push(end[7]);\n  } else if (end[0] === 'C') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n    points.push([end[5], end[6]]);\n  } else if (end[0] === 'S' || end[0] === 'Q') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n  } else {\n    points.push([end[1], end[2]]);\n  }\n\n  var leftSegments = points;\n  var t = 1 / count;\n\n  for (var i = 0; i < count - 1; i++) {\n    var rt = t / (1 - t * i);\n    var split = decasteljau(leftSegments, rt);\n    segments.push(split.left);\n    leftSegments = split.right;\n  }\n\n  segments.push(leftSegments);\n  var result = segments.map(function (segment) {\n    var cmd = [];\n\n    if (segment.length === 4) {\n      cmd.push('C');\n      cmd = cmd.concat(segment[2]);\n    }\n\n    if (segment.length >= 3) {\n      if (segment.length === 3) {\n        cmd.push('Q');\n      }\n\n      cmd = cmd.concat(segment[1]);\n    }\n\n    if (segment.length === 2) {\n      cmd.push('L');\n    }\n\n    cmd = cmd.concat(segment[segment.length - 1]);\n    return cmd;\n  });\n  return result;\n}\n\nvar splitSegment = function splitSegment(start, end, count) {\n  if (count === 1) {\n    return [[].concat(start)];\n  }\n\n  var segments = [];\n\n  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n    segments = segments.concat(splitCurve(start, end, count));\n  } else {\n    var temp = [].concat(start);\n\n    if (temp[0] === 'M') {\n      temp[0] = 'L';\n    }\n\n    for (var i = 0; i <= count - 1; i++) {\n      segments.push(temp);\n    }\n  }\n\n  return segments;\n};\n\nvar fillPath = function fillPath(source, target) {\n  if (source.length === 1) {\n    return source;\n  }\n\n  var sourceLen = source.length - 1;\n  var targetLen = target.length - 1;\n  var ratio = sourceLen / targetLen;\n  var segmentsToFill = [];\n\n  if (source.length === 1 && source[0][0] === 'M') {\n    for (var i = 0; i < targetLen - sourceLen; i++) {\n      source.push(source[0]);\n    }\n\n    return source;\n  }\n\n  for (var _i3 = 0; _i3 < targetLen; _i3++) {\n    var index = Math.floor(ratio * _i3);\n    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n  }\n\n  var filled = segmentsToFill.reduce(function (filled, count, i) {\n    if (i === sourceLen) {\n      return filled.concat(source[sourceLen]);\n    }\n\n    return filled.concat(splitSegment(source[i], source[i + 1], count));\n  }, []);\n  filled.unshift(source[0]);\n\n  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n    filled.push('Z');\n  }\n\n  return filled;\n};\n\nvar isEqual = function isEqual(obj1, obj2) {\n  if (obj1.length !== obj2.length) {\n    return false;\n  }\n\n  var result = true;\n  Util.each(obj1, function (item, i) {\n    if (item !== obj2[i]) {\n      result = false;\n      return false;\n    }\n  });\n  return result;\n};\n\nfunction getMinDiff(del, add, modify) {\n  var type = null;\n  var min = modify;\n\n  if (add < min) {\n    min = add;\n    type = 'add';\n  }\n\n  if (del < min) {\n    min = del;\n    type = 'del';\n  }\n\n  return {\n    type: type,\n    min: min\n  };\n}\n/*\n * https://en.wikipedia.org/wiki/Levenshtein_distance\n * 计算两条path的编辑距离\n */\n\n\nvar levenshteinDistance = function levenshteinDistance(source, target) {\n  var sourceLen = source.length;\n  var targetLen = target.length;\n  var sourceSegment, targetSegment;\n  var temp = 0;\n\n  if (sourceLen === 0 || targetLen === 0) {\n    return null;\n  }\n\n  var dist = [];\n\n  for (var i = 0; i <= sourceLen; i++) {\n    dist[i] = [];\n    dist[i][0] = {\n      min: i\n    };\n  }\n\n  for (var j = 0; j <= targetLen; j++) {\n    dist[0][j] = {\n      min: j\n    };\n  }\n\n  for (var _i4 = 1; _i4 <= sourceLen; _i4++) {\n    sourceSegment = source[_i4 - 1];\n\n    for (var _j2 = 1; _j2 <= targetLen; _j2++) {\n      targetSegment = target[_j2 - 1];\n\n      if (isEqual(sourceSegment, targetSegment)) {\n        temp = 0;\n      } else {\n        temp = 1;\n      }\n\n      var del = dist[_i4 - 1][_j2].min + 1;\n      var add = dist[_i4][_j2 - 1].min + 1;\n      var modify = dist[_i4 - 1][_j2 - 1].min + temp;\n      dist[_i4][_j2] = getMinDiff(del, add, modify);\n    }\n  }\n\n  return dist;\n};\n\nvar fillPathByDiff = function fillPathByDiff(source, target) {\n  var diffMatrix = levenshteinDistance(source, target);\n  var sourceLen = source.length;\n  var targetLen = target.length;\n  var changes = [];\n  var index = 1;\n  var minPos = 1; // 如果source和target不是完全不相等\n\n  if (diffMatrix[sourceLen][targetLen] !== sourceLen) {\n    // 获取从source到target所需改动\n    for (var i = 1; i <= sourceLen; i++) {\n      var min = diffMatrix[i][i].min;\n      minPos = i;\n\n      for (var j = index; j <= targetLen; j++) {\n        if (diffMatrix[i][j].min < min) {\n          min = diffMatrix[i][j].min;\n          minPos = j;\n        }\n      }\n\n      index = minPos;\n\n      if (diffMatrix[i][index].type) {\n        changes.push({\n          index: i - 1,\n          type: diffMatrix[i][index].type\n        });\n      }\n    } // 对source进行增删path\n\n\n    for (var _i5 = changes.length - 1; _i5 >= 0; _i5--) {\n      index = changes[_i5].index;\n\n      if (changes[_i5].type === 'add') {\n        source.splice(index, 0, [].concat(source[index]));\n      } else {\n        source.splice(index, 1);\n      }\n    }\n  } // source尾部补齐\n\n\n  sourceLen = source.length;\n  var diff = targetLen - sourceLen;\n\n  if (sourceLen < targetLen) {\n    for (var _i6 = 0; _i6 < diff; _i6++) {\n      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {\n        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);\n      } else {\n        source.push(source[sourceLen - 1]);\n      }\n\n      sourceLen += 1;\n    }\n  }\n\n  return source;\n}; // 将两个点均分成count个点\n\n\nfunction _splitPoints(points, former, count) {\n  var result = [].concat(points);\n  var index;\n  var t = 1 / (count + 1);\n\n  var formerEnd = _getSegmentPoints(former)[0];\n\n  for (var i = 1; i <= count; i++) {\n    t *= i;\n    index = Math.floor(points.length * t);\n\n    if (index === 0) {\n      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    } else {\n      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    }\n  }\n\n  return result;\n}\n/*\n * 抽取pathSegment中的关键点\n * M,L,A,Q,H,V一个端点\n * Q, S抽取一个端点，一个控制点\n * C抽取一个端点，两个控制点\n */\n\n\nfunction _getSegmentPoints(segment) {\n  var points = [];\n\n  switch (segment[0]) {\n    case 'M':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'L':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'A':\n      points.push([segment[6], segment[7]]);\n      break;\n\n    case 'Q':\n      points.push([segment[3], segment[4]]);\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'T':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'C':\n      points.push([segment[5], segment[6]]);\n      points.push([segment[1], segment[2]]);\n      points.push([segment[3], segment[4]]);\n      break;\n\n    case 'S':\n      points.push([segment[3], segment[4]]);\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'H':\n      points.push([segment[1], segment[1]]);\n      break;\n\n    case 'V':\n      points.push([segment[1], segment[1]]);\n      break;\n\n    default:\n  }\n\n  return points;\n}\n\nvar formatPath = function formatPath(fromPath, toPath) {\n  if (fromPath.length <= 1) {\n    return fromPath;\n  }\n\n  var points;\n\n  for (var i = 0; i < toPath.length; i++) {\n    if (fromPath[i][0] !== toPath[i][0]) {\n      // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造\n      points = _getSegmentPoints(fromPath[i]);\n\n      switch (toPath[i][0]) {\n        case 'M':\n          fromPath[i] = ['M'].concat(points[0]);\n          break;\n\n        case 'L':\n          fromPath[i] = ['L'].concat(points[0]);\n          break;\n\n        case 'A':\n          fromPath[i] = [].concat(toPath[i]);\n          fromPath[i][6] = points[0][0];\n          fromPath[i][7] = points[0][1];\n          break;\n\n        case 'Q':\n          if (points.length < 2) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 1);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        case 'T':\n          fromPath[i] = ['T'].concat(points[0]);\n          break;\n\n        case 'C':\n          if (points.length < 3) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 2);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        case 'S':\n          if (points.length < 2) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 1);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        default:\n          fromPath[i] = toPath[i];\n      }\n    }\n  }\n\n  return fromPath;\n};\n\nmodule.exports = {\n  parsePathString: parsePathString,\n  parsePathArray: parsePathArray,\n  pathTocurve: pathTocurve,\n  pathToAbsolute: pathToAbsolute,\n  catmullRomToBezier: catmullRom2bezier,\n  rectPath: rectPath,\n  fillPath: fillPath,\n  fillPathByDiff: fillPathByDiff,\n  formatPath: formatPath,\n  intersection: pathIntersection\n};\n\n/***/ }),\n/* 58 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = now;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Timer;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = timer;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = timerFlush;\nvar frame = 0,\n    // is an animation frame pending?\ntimeout = 0,\n    // is a timeout pending?\ninterval = 0,\n    // are any timers active?\npokeDelay = 1000,\n    // how frequently we check for clock skew\ntaskHead,\n    taskTail,\n    clockLast = 0,\n    clockNow = 0,\n    clockSkew = 0,\n    clock = typeof performance === \"object\" && performance.now ? performance : Date,\n    setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {\n  setTimeout(f, 17);\n};\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call = this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function (callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;else taskHead = this;\n      taskTail = this;\n    }\n\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function () {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction timer(callback, delay, time) {\n  var t = new Timer();\n  t.restart(callback, delay, time);\n  return t;\n}\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n\n  var t = taskHead,\n      e;\n\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(),\n      delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0,\n      t1 = taskHead,\n      t2,\n      time = Infinity;\n\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\n/***/ }),\n/* 59 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__rgb__ = __webpack_require__(119);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array__ = __webpack_require__(122);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__date__ = __webpack_require__(123);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__number__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__object__ = __webpack_require__(124);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__string__ = __webpack_require__(125);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constant__ = __webpack_require__(121);\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var t = typeof b,\n      c;\n  return b == null || t === \"boolean\" ? Object(__WEBPACK_IMPORTED_MODULE_7__constant__[\"a\" /* default */])(b) : (t === \"number\" ? __WEBPACK_IMPORTED_MODULE_4__number__[\"a\" /* default */] : t === \"string\" ? (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"a\" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1__rgb__[\"a\" /* default */]) : __WEBPACK_IMPORTED_MODULE_6__string__[\"a\" /* default */] : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__[\"a\" /* color */] ? __WEBPACK_IMPORTED_MODULE_1__rgb__[\"a\" /* default */] : b instanceof Date ? __WEBPACK_IMPORTED_MODULE_3__date__[\"a\" /* default */] : Array.isArray(b) ? __WEBPACK_IMPORTED_MODULE_2__array__[\"a\" /* default */] : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? __WEBPACK_IMPORTED_MODULE_5__object__[\"a\" /* default */] : __WEBPACK_IMPORTED_MODULE_4__number__[\"a\" /* default */])(a, b);\n});\n\n/***/ }),\n/* 60 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Color;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return darker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return brighter; });\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = color;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = rgbConvert;\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = rgb;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = Rgb;\n/* unused harmony export hslConvert */\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = hsl;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(61);\n\nfunction Color() {}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\",\n    reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\",\n    reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\",\n    reHex3 = /^#([0-9a-f]{3})$/,\n    reHex6 = /^#([0-9a-f]{6})$/,\n    reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\"),\n    reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\"),\n    reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\"),\n    reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\"),\n    reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\"),\n    reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\");\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Color, color, {\n  displayable: function () {\n    return this.rgb().displayable();\n  },\n  toString: function () {\n    return this.rgb() + \"\";\n  }\n});\nfunction color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00\n  ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb();\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Rgb, rgb, Object(__WEBPACK_IMPORTED_MODULE_0__define__[\"b\" /* extend */])(Color, {\n  brighter: function (k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function (k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function () {\n    return this;\n  },\n  displayable: function () {\n    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;\n  },\n  toString: function () {\n    var a = this.opacity;\n    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \" + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \" + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl();\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n\n  return new Hsl(h, s, l, o.opacity);\n}\nfunction hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Hsl, hsl, Object(__WEBPACK_IMPORTED_MODULE_0__define__[\"b\" /* extend */])(Color, {\n  brighter: function (k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function (k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function () {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);\n  },\n  displayable: function () {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;\n  }\n}));\n/* From FvD 13.37, CSS Color Module Level 3 */\n\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;\n}\n\n/***/ }),\n/* 61 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = extend;\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n});\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n\n  for (var key in definition) prototype[key] = definition[key];\n\n  return prototype;\n}\n\n/***/ }),\n/* 62 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = basis;\nfunction basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1,\n      t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;\n}\n/* harmony default export */ __webpack_exports__[\"b\"] = (function (values) {\n  var n = values.length - 1;\n  return function (t) {\n    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n});\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isArrayLike = __webpack_require__(13);\n\nvar filter = function filter(arr, func) {\n  if (!isArrayLike(arr)) {\n    return arr;\n  }\n\n  var result = [];\n  each(arr, function (value, index) {\n    if (func(value, index)) {\n      result.push(value);\n    }\n  });\n  return result;\n};\n\nmodule.exports = filter;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(5);\n\nvar isArray = __webpack_require__(4);\n\nvar each = __webpack_require__(2);\n\nmodule.exports = function valuesOfKey(data, name) {\n  var rst = [];\n  var tmpMap = {};\n\n  for (var i = 0; i < data.length; i++) {\n    var obj = data[i];\n    var value = obj[name];\n\n    if (!isNil(value)) {\n      if (!isArray(value)) {\n        value = [value];\n      }\n\n      each(value, function (val) {\n        if (!tmpMap[val]) {\n          rst.push(val);\n          tmpMap[val] = true;\n        }\n      });\n    }\n  }\n\n  return rst;\n};\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(16),\n    Group = _require.Group;\n\nvar _require2 = __webpack_require__(21),\n    Label = _require2.Label; // const visualCenter = require('@antv/component/lib/label/utils/visual-center');\n\n\nvar Global = __webpack_require__(7);\n\nvar Util = __webpack_require__(0);\n\nvar IGNORE_ARR = ['line', 'point', 'path'];\nvar ORIGIN = '_origin';\n\nfunction avg(arr) {\n  var sum = 0;\n  Util.each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n} // 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n\n\nfunction getCentroid(xs, ys) {\n  var i = -1,\n      x = 0,\n      y = 0;\n  var former,\n      current = xs.length - 1;\n  var diff,\n      k = 0;\n\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n\n  k *= 3;\n  return [x / k, y / k];\n}\n\nvar GeomLabels =\n/*#__PURE__*/\nfunction (_Group) {\n  _inheritsLoose(GeomLabels, _Group);\n\n  function GeomLabels() {\n    return _Group.apply(this, arguments) || this;\n  }\n\n  var _proto = GeomLabels.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      label: Global.label,\n\n      /**\n       * 用户传入的文本配置信息\n       * @type {Object}\n       */\n      labelCfg: null,\n\n      /**\n       * 所在的坐标系\n       * @type {Object}\n       */\n      coord: null,\n\n      /**\n       * 图表的类型\n       * @type {String}\n       */\n      geomType: null,\n      zIndex: 6\n    };\n  };\n\n  _proto._renderUI = function _renderUI() {\n    _Group.prototype._renderUI.call(this);\n\n    this.initLabelsCfg();\n    var labelsGroup = this.addGroup();\n    var lineGroup = this.addGroup({\n      elCls: 'x-line-group'\n    });\n    var labelRenderer = this.get('labelRenderer');\n    this.set('labelsGroup', labelsGroup);\n    this.set('lineGroup', lineGroup);\n    this.get('labelRenderer').set('group', labelsGroup);\n    labelRenderer.set('group', labelsGroup);\n    labelRenderer.set('lineGroup', lineGroup);\n  }; // 初始化labels的配置项\n\n\n  _proto.initLabelsCfg = function initLabelsCfg() {\n    var self = this;\n    var labelRenderer = new Label();\n    var labels = self.getDefaultLabelCfg();\n    var labelCfg = self.get('labelCfg'); // Util.merge(labels, labelCfg.cfg);\n\n    Util.deepMix(labels, labelCfg.globalCfg || labelCfg.cfg);\n    labelRenderer.set('config', false);\n\n    if (labels.labelLine) {\n      labelRenderer.set('labelLine', labels.labelLine);\n    }\n\n    labelRenderer.set('coord', self.get('coord'));\n    this.set('labelRenderer', labelRenderer);\n    self.set('label', labels);\n  };\n  /**\n   * @protected\n   * 默认的文本样式\n   * @return {Object} default label config\n   */\n\n\n  _proto.getDefaultLabelCfg = function getDefaultLabelCfg() {\n    var self = this;\n    var labelCfg = self.get('labelCfg').cfg || self.get('labelCfg').globalCfg;\n    var geomType = self.get('geomType');\n    var viewTheme = self.get('viewTheme') || Global;\n\n    if (geomType === 'polygon' || labelCfg && labelCfg.offset < 0 && Util.indexOf(IGNORE_ARR, geomType) === -1) {\n      return Util.deepMix({}, self.get('label'), viewTheme.innerLabels, labelCfg);\n    }\n\n    return Util.deepMix({}, self.get('label'), viewTheme.label, labelCfg);\n  };\n  /**\n   * @protected\n   * 获取labels\n   * @param {Array} points points\n   * @param {Array} shapes shapes\n   * @return {Array} label items\n   */\n\n\n  _proto.getLabelsItems = function getLabelsItems(points, shapes) {\n    var self = this;\n    var items = [];\n    var geom = self.get('geom');\n    var coord = self.get('coord');\n\n    self._getLabelCfgs(points, shapes);\n\n    var labelCfg = self.get('labelItemCfgs'); // 获取label相关的x，y的值，获取具体的x,y,防止存在数组\n\n    Util.each(points, function (point, i) {\n      var origin = point[ORIGIN];\n      var label = labelCfg[i];\n\n      if (!label) {\n        items.push(null);\n        return;\n      }\n\n      if (!Util.isArray(label.text)) {\n        label.text = [label.text];\n      }\n\n      var total = label.length;\n      Util.each(label.text, function (sub, subIndex) {\n        if (Util.isNil(sub) || sub === '') {\n          items.push(null);\n          return;\n        }\n\n        var obj = self.getLabelPoint(label, point, subIndex);\n        obj = Util.mix({}, label, obj);\n\n        if (!obj.textAlign) {\n          obj.textAlign = self.getLabelAlign(obj, subIndex, total);\n        }\n\n        if (geom) {\n          obj._id = geom._getShapeId(origin) + '-glabel-' + subIndex + '-' + obj.text;\n        }\n\n        obj.coord = coord;\n        items.push(obj);\n      });\n    });\n    return items;\n  };\n  /* /!*\n   * @protected\n   * 如果发生冲突则会调整文本的位置\n   * @param {Array} items 文本的集合\n   * @param {Array} shapes 关联形状\n   * @return {Array} adjusted items\n   *!/\n  adjustItems(items, shapes) {\n    // 多边形shape的label位于其可视中心\n    if (this.get('geomType') === 'polygon') {\n      let index,\n        shape,\n        path,\n        center,\n        points;\n      Util.each(items, (item, i) => {\n        if (!item) return;\n        shape = shapes[ i ];\n        path = shape.attr('path');\n        points = [[]];\n        index = 0;\n        path.forEach((segment, i) => {\n          if (segment[ 0 ] === 'z' || segment[ 0 ] === 'Z' && i !== path.length - 1) {\n            points.push([]);\n            index += 1;\n          }\n          if (segment.length === 3) {\n            points[ index ].push([ segment[ 1 ], segment[ 2 ] ]);\n          }\n        });\n        center = visualCenter(points);\n        item.x = center.x;\n        item.y = center.y;\n      });\n    }\n    return items;\n  }\n  */\n\n\n  _proto.adjustItems = function adjustItems(items) {\n    Util.each(items, function (item) {\n      if (!item) {\n        return;\n      }\n\n      if (item.offsetX) {\n        item.x += item.offsetX;\n      }\n\n      if (item.offsetY) {\n        item.y += item.offsetY;\n      }\n    });\n    return items;\n  };\n  /**\n   * drawing lines to labels\n   * @param  {Array} items labels\n   * @param  {Object} labelLine configuration for label lines\n   */\n\n\n  _proto.drawLines = function drawLines(items) {\n    var self = this;\n    Util.each(items, function (point) {\n      if (!point) {\n        return;\n      }\n\n      if (point.offset > 0) {\n        self.lineToLabel(point);\n      }\n    });\n  }; // 定义连接线\n\n\n  _proto.lineToLabel = function lineToLabel() {};\n  /**\n   * @protected\n   * 获取文本的位置信息\n   * @param {Array} labelCfg labels\n   * @param {Object} point point\n   * @param {Number} index index\n   * @return {Object} point\n   */\n\n\n  _proto.getLabelPoint = function getLabelPoint(labelCfg, point, index) {\n    var self = this;\n    var coord = self.get('coord');\n    var total = labelCfg.text.length;\n\n    function getDimValue(value, idx) {\n      if (Util.isArray(value)) {\n        if (labelCfg.text.length === 1) {\n          // 如果仅一个label,多个y,取最后一个y\n          if (value.length <= 2) {\n            value = value[value.length - 1]; // value = value[0];\n          } else {\n            value = avg(value);\n          }\n        } else {\n          value = value[idx];\n        }\n      }\n\n      return value;\n    }\n\n    var label = {\n      text: labelCfg.text[index]\n    }; // 多边形场景,多用于地图\n\n    if (point && this.get('geomType') === 'polygon') {\n      var centroid = getCentroid(point.x, point.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else {\n      label.x = getDimValue(point.x, index);\n      label.y = getDimValue(point.y, index);\n    } // get nearest point of the shape as the label line start point\n\n\n    if (point && point.nextPoints && (point.shape === 'funnel' || point.shape === 'pyramid')) {\n      var maxX = -Infinity;\n      point.nextPoints.forEach(function (p) {\n        p = coord.convert(p);\n\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n      });\n      label.x = (label.x + maxX) / 2;\n    } // sharp edge of the pyramid\n\n\n    if (point.shape === 'pyramid' && !point.nextPoints && point.points) {\n      point.points.forEach(function (p) {\n        p = coord.convert(p);\n\n        if (Util.isArray(p.x) && point.x.indexOf(p.x) === -1 || Util.isNumber(p.x) && point.x !== p.x) {\n          label.x = (label.x + p.x) / 2;\n        }\n      });\n    }\n\n    if (labelCfg.position) {\n      self.setLabelPosition(label, point, index, labelCfg.position);\n    }\n\n    var offsetPoint = self.getLabelOffset(labelCfg, index, total);\n\n    if (labelCfg.offsetX) {\n      offsetPoint.x += labelCfg.offsetX;\n    }\n\n    if (labelCfg.offsetY) {\n      offsetPoint.y += labelCfg.offsetY;\n    }\n\n    self.transLabelPoint(label);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = point.color;\n    return label;\n  };\n\n  _proto.setLabelPosition = function setLabelPosition() {};\n\n  _proto.transLabelPoint = function transLabelPoint(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var tmpPoint = coord.applyMatrix(point.x, point.y, 1);\n    point.x = tmpPoint[0];\n    point.y = tmpPoint[1];\n  };\n\n  _proto.getOffsetVector = function getOffsetVector(point) {\n    var self = this;\n    var offset = point.offset || 0;\n    var coord = self.get('coord');\n    var vector;\n\n    if (coord.isTransposed) {\n      // 如果x,y翻转，则偏移x\n      vector = coord.applyMatrix(offset, 0);\n    } else {\n      // 否则，偏转y\n      vector = coord.applyMatrix(0, offset);\n    }\n\n    return vector;\n  }; // 获取默认的偏移量\n\n\n  _proto.getDefaultOffset = function getDefaultOffset(point) {\n    var self = this;\n    var offset = 0;\n    var coord = self.get('coord');\n    var vector = self.getOffsetVector(point);\n\n    if (coord.isTransposed) {\n      // 如果x,y翻转，则偏移x\n      offset = vector[0];\n    } else {\n      // 否则，偏转y\n      offset = vector[1];\n    }\n\n    return offset;\n  }; // 获取文本的偏移位置，x,y\n\n\n  _proto.getLabelOffset = function getLabelOffset(point, index, total) {\n    var self = this;\n    var offset = self.getDefaultOffset(point);\n    var coord = self.get('coord');\n    var transposed = coord.isTransposed;\n    var yField = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[yField] = offset * factor;\n    } else {\n      offsetPoint[yField] = offset * factor * -1;\n    }\n\n    return offsetPoint;\n  };\n\n  _proto.getLabelAlign = function getLabelAlign(point, index, total) {\n    var self = this;\n    var align = 'center';\n    var coord = self.get('coord');\n\n    if (coord.isTransposed) {\n      var offset = self.getDefaultOffset(point); // var vector = coord.applyMatrix(offset,0);\n\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n\n    return align;\n  };\n\n  _proto._getLabelValue = function _getLabelValue(origin, scales) {\n    if (!Util.isArray(scales)) {\n      scales = [scales];\n    }\n\n    var text = [];\n    Util.each(scales, function (scale) {\n      var value = origin[scale.field];\n\n      if (Util.isArray(value)) {\n        var tmp = [];\n        Util.each(value, function (subVal) {\n          tmp.push(scale.getText(subVal));\n        });\n        value = tmp;\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (Util.isNil(value) || value === '') {\n        text.push(null);\n      }\n\n      text.push(value);\n    });\n    return text;\n  }; // 获取每个label的配置\n\n\n  _proto._getLabelCfgs = function _getLabelCfgs(points) {\n    var self = this;\n    var labelCfg = this.get('labelCfg');\n    var scales = labelCfg.scales;\n    var defaultCfg = this.get('label');\n    var cfgs = [];\n\n    if (labelCfg.globalCfg && labelCfg.globalCfg.type) {\n      self.set('type', labelCfg.globalCfg.type);\n    }\n\n    Util.each(points, function (point, i) {\n      var cfg = {};\n      var origin = point[ORIGIN];\n\n      var originText = self._getLabelValue(origin, scales);\n\n      if (labelCfg.callback) {\n        // callback中应使用原始数据，而不是数据字符串\n        var originValues = scales.map(function (scale) {\n          return origin[scale.field];\n        });\n        cfg = labelCfg.callback.apply(null, originValues);\n      }\n\n      if (!cfg && cfg !== 0) {\n        cfgs.push(null);\n        return;\n      }\n\n      if (Util.isString(cfg) || Util.isNumber(cfg)) {\n        cfg = {\n          text: cfg\n        };\n      } else {\n        cfg.text = cfg.content || originText[0];\n        delete cfg.content;\n      }\n\n      cfg = Util.mix({}, defaultCfg, labelCfg.globalCfg || {}, cfg); // 兼容旧的源数据写在item.point中\n\n      point.point = origin;\n\n      if (cfg.htmlTemplate) {\n        cfg.useHtml = true;\n        cfg.text = cfg.htmlTemplate.call(null, cfg.text, point, i);\n        delete cfg.htmlTemplate;\n      }\n\n      if (cfg.formatter) {\n        cfg.text = cfg.formatter.call(null, cfg.text, point, i);\n        delete cfg.formatter;\n      }\n\n      if (cfg.label) {\n        // 兼容有些直接写在labelCfg.label的配置\n        var label = cfg.label;\n        delete cfg.label;\n        cfg = Util.mix(cfg, label);\n      }\n\n      if (cfg.textStyle) {\n        // 兼容旧写法，globalCfg的offset优先级高\n        delete cfg.textStyle.offset;\n        var textStyle = cfg.textStyle;\n\n        if (Util.isFunction(textStyle)) {\n          cfg.textStyle = textStyle.call(null, cfg.text, point, i);\n        }\n      }\n\n      if (cfg.labelLine) {\n        cfg.labelLine = Util.mix({}, defaultCfg.labelLine, cfg.labelLine);\n      }\n\n      cfg.textStyle = Util.mix({}, defaultCfg.textStyle, cfg.textStyle);\n      delete cfg.items;\n      cfgs.push(cfg);\n    });\n    this.set('labelItemCfgs', cfgs);\n  };\n\n  _proto.showLabels = function showLabels(points, shapes) {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var items = self.getLabelsItems(points, shapes);\n    shapes = [].concat(shapes);\n    var type = self.get('type');\n    items = self.adjustItems(items, shapes);\n    self.drawLines(items);\n    labelRenderer.set('items', items.filter(function (item, i) {\n      if (!item) {\n        shapes.splice(i, 1);\n        return false;\n      }\n\n      return true;\n    }));\n\n    if (type) {\n      labelRenderer.set('shapes', shapes);\n      labelRenderer.set('type', type);\n      labelRenderer.set('points', points);\n    }\n\n    labelRenderer.set('canvas', this.get('canvas'));\n    labelRenderer.draw();\n  };\n\n  _proto.destroy = function destroy() {\n    this.get('labelRenderer').destroy(); // 清理文本\n\n    _Group.prototype.destroy.call(this);\n  };\n\n  return GeomLabels;\n}(Group); // Util.assign(GeomLabels.prototype, Labels.LabelslabelRenderer);\n\n\nmodule.exports = GeomLabels;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/**\n * @fileOverview Chart、View、Geometry 的基类\n * @author dxq613@gmail.com\n */\n\n\nvar EventEmitter = __webpack_require__(53);\n\nvar Util = __webpack_require__(3);\n\nvar Base =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inheritsLoose(Base, _EventEmitter);\n\n  var _proto = Base.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {};\n  };\n\n  function Base(cfg) {\n    var _this;\n\n    _this = _EventEmitter.call(this) || this;\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    var attrs = {\n      visible: true\n    };\n    var defaultCfg = self.getDefaultCfg();\n    self._attrs = attrs;\n    Util.deepMix(attrs, defaultCfg, cfg);\n    return _this;\n  }\n\n  _proto.get = function get(name) {\n    return this._attrs[name];\n  };\n\n  _proto.set = function set(name, value) {\n    this._attrs[name] = value;\n  };\n  /**\n   * @protected\n   * @param {Boolean} visible 是否可见\n   * 显示、隐藏\n   */\n\n\n  _proto.changeVisible = function changeVisible()\n  /* visible */\n  {};\n\n  _proto.destroy = function destroy() {\n    var self = this;\n    self._attrs = {};\n    self.removeAllListeners();\n    self.destroyed = true;\n  };\n\n  return Base;\n}(EventEmitter);\n\nmodule.exports = Base;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The base class of continuous legend\n * @author sima.zhang\n */\n\n\nvar Util = __webpack_require__(3);\n\nvar Legend = __webpack_require__(158);\n\nvar Slider = __webpack_require__(327);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar TRIGGER_WIDTH = 8;\nvar Event = Util.Event;\nvar Group = Util.Group;\n\nvar Continuous =\n/*#__PURE__*/\nfunction (_Legend) {\n  _inheritsLoose(Continuous, _Legend);\n\n  function Continuous() {\n    return _Legend.apply(this, arguments) || this;\n  }\n\n  var _proto = Continuous.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Legend.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'continuous-legend',\n\n      /**\n       * 子项\n       * @type {Array}\n       */\n      items: null,\n\n      /**\n       * 布局方式\n       * horizontal 水平\n       * vertical 垂直\n       * @type {String}\n       */\n      layout: 'vertical',\n\n      /**\n       * 宽度\n       * @type {Number}\n       */\n      width: 20,\n\n      /**\n       * 高度\n       * @type {Number}\n       */\n      height: 156,\n\n      /**\n       * 默认文本图形属性\n       * @type {ATTRS}\n       */\n      textStyle: {\n        fill: '#333',\n        textAlign: 'center',\n        textBaseline: 'middle',\n        stroke: '#fff',\n        lineWidth: 5,\n        fontFamily: FONT_FAMILY\n      },\n      hoverTextStyle: {\n        fill: 'rgba(0,0,0,0.25)'\n      },\n\n      /**\n       * 连续图例是否可滑动\n       * @type {Boolean}\n       */\n      slidable: true,\n\n      /**\n       * 两头滑块的样式\n       * @type {object}\n       */\n      triggerAttr: {\n        fill: '#fff',\n        // shadowOffsetX: -2,\n        // shadowOffsetY: 2,\n        shadowBlur: 10,\n        shadowColor: 'rgba(0,0,0,0.65)',\n        radius: 2\n      },\n\n      /**\n       * slider 的范围\n       * @type {array}}\n       */\n      _range: [0, 100],\n\n      /**\n       * 中间 bar 背景灰色\n       * @type {ATTRS}\n       */\n      middleBackgroundStyle: {\n        fill: '#D9D9D9'\n      },\n\n      /**\n       * 文本与图例间距\n       * @type {Number}\n       */\n      textOffset: 4,\n\n      /**\n       * line segment to seperate the unslidable slider blocks\n       * @type {object}\n       */\n      lineStyle: {\n        lineWidth: 1,\n        stroke: '#fff'\n      },\n\n      /**\n       * the pointer while activate the legend by mouse hovering or called by outside\n       * @type {object}\n       */\n      pointerStyle: {\n        // color: '#ccc',\n        fill: 'rgb(230, 230, 230)'\n      }\n    });\n  };\n\n  _proto._calStartPoint = function _calStartPoint() {\n    var start = {\n      x: 10,\n      y: this.get('titleGap') - TRIGGER_WIDTH\n    };\n    var titleShape = this.get('titleShape');\n\n    if (titleShape) {\n      var titleBox = titleShape.getBBox();\n      start.y += titleBox.height;\n    }\n\n    return start;\n  };\n\n  _proto.beforeRender = function beforeRender() {\n    var items = this.get('items');\n\n    if (!Util.isArray(items) || Util.isEmpty(items)) {\n      return;\n    }\n\n    _Legend.prototype.beforeRender.call(this);\n\n    this.set('firstItem', items[0]);\n    this.set('lastItem', items[items.length - 1]);\n  };\n\n  _proto._formatItemValue = function _formatItemValue(value) {\n    var formatter = this.get('formatter') || this.get('itemFormatter');\n\n    if (formatter) {\n      value = formatter.call(this, value);\n    }\n\n    return value;\n  };\n\n  _proto.render = function render() {\n    _Legend.prototype.render.call(this);\n\n    if (this.get('slidable')) {\n      this._renderSlider();\n    } else {\n      this._renderUnslidable();\n    }\n  };\n\n  _proto._renderSlider = function _renderSlider() {\n    var minHandleElement = new Group();\n    var maxHandleElement = new Group();\n    var backgroundElement = new Group();\n\n    var start = this._calStartPoint();\n\n    var group = this.get('group');\n    var slider = group.addGroup(Slider, {\n      minHandleElement: minHandleElement,\n      maxHandleElement: maxHandleElement,\n      backgroundElement: backgroundElement,\n      layout: this.get('layout'),\n      range: this.get('_range'),\n      width: this.get('width'),\n      height: this.get('height')\n    });\n    slider.translate(start.x, start.y);\n    this.set('slider', slider);\n\n    var shape = this._renderSliderShape();\n\n    shape.attr('clip', slider.get('middleHandleElement'));\n\n    this._renderTrigger();\n  }; // the middle bar\n\n\n  _proto._addMiddleBar = function _addMiddleBar(parent, name, attrs) {\n    // background of the middle bar\n    parent.addShape(name, {\n      attrs: Util.mix({}, attrs, this.get('middleBackgroundStyle'))\n    }); // frontground of the middle bar\n\n    return parent.addShape(name, {\n      attrs: attrs\n    });\n  };\n\n  _proto._renderTrigger = function _renderTrigger() {\n    var min = this.get('firstItem');\n    var max = this.get('lastItem');\n    var layout = this.get('layout');\n    var textStyle = this.get('textStyle');\n    var triggerAttr = this.get('triggerAttr');\n    var minBlockAttr = Util.mix({}, triggerAttr);\n    var maxBlockAttr = Util.mix({}, triggerAttr);\n    var minTextAttr = Util.mix({\n      text: this._formatItemValue(min.value) + ''\n    }, textStyle);\n    var maxTextAttr = Util.mix({\n      text: this._formatItemValue(max.value) + ''\n    }, textStyle);\n\n    if (layout === 'vertical') {\n      this._addVerticalTrigger('min', minBlockAttr, minTextAttr);\n\n      this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr);\n    } else {\n      this._addHorizontalTrigger('min', minBlockAttr, minTextAttr);\n\n      this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr);\n    }\n  };\n\n  _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr) {\n    var slider = this.get('slider');\n    var trigger = slider.get(type + 'HandleElement');\n    var width = this.get('width');\n    var button = trigger.addShape('rect', {\n      attrs: Util.mix({\n        x: width / 2 - TRIGGER_WIDTH - 2,\n        y: type === 'min' ? 0 : -TRIGGER_WIDTH,\n        width: 2 * TRIGGER_WIDTH + 2,\n        height: TRIGGER_WIDTH\n      }, blockAttr)\n    });\n    var text = trigger.addShape('text', {\n      attrs: Util.mix(textAttr, {\n        x: width + this.get('textOffset'),\n        y: type === 'max' ? -4 : 4,\n        textAlign: 'start',\n        lineHeight: 1,\n        textBaseline: 'middle'\n      })\n    });\n    var layout = this.get('layout');\n    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';\n    button.attr('cursor', trigerCursor);\n    text.attr('cursor', trigerCursor);\n    this.set(type + 'ButtonElement', button);\n    this.set(type + 'TextElement', text);\n  };\n\n  _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr) {\n    var slider = this.get('slider');\n    var trigger = slider.get(type + 'HandleElement');\n    var button = trigger.addShape('rect', {\n      attrs: Util.mix({\n        x: type === 'min' ? -TRIGGER_WIDTH : 0,\n        y: -TRIGGER_WIDTH - this.get('height') / 2,\n        width: TRIGGER_WIDTH,\n        height: 2 * TRIGGER_WIDTH\n      }, blockAttr)\n    });\n    var text = trigger.addShape('text', {\n      attrs: Util.mix(textAttr, {\n        x: type === 'min' ? -TRIGGER_WIDTH - 4 : TRIGGER_WIDTH + 4,\n        y: TRIGGER_WIDTH / 2 + this.get('textOffset') + 10,\n        textAlign: type === 'min' ? 'end' : 'start',\n        textBaseline: 'middle'\n      })\n    });\n    var layout = this.get('layout');\n    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';\n    button.attr('cursor', trigerCursor);\n    text.attr('cursor', trigerCursor);\n    this.set(type + 'ButtonElement', button);\n    this.set(type + 'TextElement', text);\n  };\n\n  _proto._bindEvents = function _bindEvents() {\n    var _this = this;\n\n    if (this.get('slidable')) {\n      var slider = this.get('slider');\n      slider.on('sliderchange', function (ev) {\n        var range = ev.range;\n\n        var firstItemValue = _this.get('firstItem').value;\n\n        var lastItemValue = _this.get('lastItem').value;\n\n        var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);\n        var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);\n\n        _this._updateElement(minValue, maxValue);\n\n        var itemFiltered = new Event('itemfilter', ev, true, true);\n        itemFiltered.range = [minValue, maxValue];\n\n        _this.emit('itemfilter', itemFiltered);\n      });\n    }\n\n    if (this.get('hoverable')) {\n      this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMouseMove'));\n      this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseLeave'));\n    }\n  }; // update the text of min and max trigger\n\n\n  _proto._updateElement = function _updateElement(min, max) {\n    var minTextElement = this.get('minTextElement');\n    var maxTextElement = this.get('maxTextElement');\n\n    if (max > 1) {\n      // 对于大于 1 的值，默认显示为整数\n      min = parseInt(min, 10);\n      max = parseInt(max, 10);\n    }\n\n    minTextElement.attr('text', this._formatItemValue(min) + '');\n    maxTextElement.attr('text', this._formatItemValue(max) + '');\n  };\n\n  _proto._onMouseLeave = function _onMouseLeave() {\n    var hoverPointer = this.get('group').findById('hoverPointer');\n    hoverPointer && hoverPointer.destroy();\n    var hoverText = this.get('group').findById('hoverText');\n    hoverText && hoverText.destroy();\n    this.get('canvas').draw();\n  }; // activate the legend while mouse moving\n\n\n  _proto._onMouseMove = function _onMouseMove(ev) {\n    var height = this.get('height');\n    var width = this.get('width');\n    var items = this.get('items');\n    var el = this.get('canvas').get('el');\n    var el_bbox = el.getBoundingClientRect();\n    var bbox = this.get('group').getBBox();\n    var value;\n\n    if (this.get('layout') === 'vertical') {\n      var valuePadding = 5;\n\n      if (this.get('type') === 'color-legend') {\n        valuePadding = 30;\n      }\n\n      var titleOffset = this.get('titleGap');\n      var titleShape = this.get('titleShape');\n      if (titleShape) titleOffset += titleShape.getBBox().maxY - titleShape.getBBox().minY;\n      var currentPage = ev.clientY || ev.event.clientY;\n      currentPage = currentPage - el_bbox.y - this.get('group').attr('matrix')[7] + bbox.y - valuePadding + titleOffset;\n      value = items[0].value + (1 - currentPage / height) * (items[items.length - 1].value - items[0].value);\n    } else {\n      var _currentPage = ev.clientX || ev.event.clientX;\n\n      _currentPage = _currentPage - el_bbox.x - this.get('group').attr('matrix')[6];\n      value = items[0].value + _currentPage / width * (items[items.length - 1].value - items[0].value);\n    }\n\n    value = value.toFixed(2);\n    this.activate(value);\n    this.emit('mousehover', {\n      value: value\n    });\n  }; // activated by mouse moving or being called\n\n\n  _proto.activate = function activate(value) {\n    if (!value) {\n      return;\n    }\n\n    var hoverPointer = this.get('group').findById('hoverPointer');\n    var hoverText = this.get('group').findById('hoverText');\n    var items = this.get('items');\n\n    if (value < items[0].value || value > items[items.length - 1].value) {\n      return;\n    }\n\n    var height = this.get('height');\n    var width = this.get('width');\n    var titleShape = this.get('titleShape');\n    var titleGap = this.get('titleGap');\n    var points = [];\n    var page = (value - items[0].value) / (items[items.length - 1].value - items[0].value);\n    var textStyle;\n\n    if (this.get('layout') === 'vertical') {\n      // revise the offset\n      var paddingY = 0,\n          paddingX = 0;\n\n      if (this.get('type') === 'color-legend') {\n        paddingY = titleGap;\n        if (titleShape) paddingY += titleShape.getBBox().height;\n      }\n\n      if (this.get('slidable')) {\n        if (this.get('type') === 'color-legend') {\n          paddingY -= 13;\n        } else {\n          paddingY = titleGap - 15;\n          if (titleShape) paddingY += titleShape.getBBox().height;\n        }\n\n        paddingX += 10;\n      }\n\n      page = (1 - page) * height;\n      points = [[paddingX, page + paddingY], [paddingX - 10, page + paddingY - 5], [paddingX - 10, page + paddingY + 5]];\n      textStyle = Util.mix({}, {\n        x: width + this.get('textOffset') / 2 + paddingX,\n        y: page + paddingY,\n        text: this._formatItemValue(value) + '' // 以字符串格式展示\n\n      }, this.get('textStyle'), {\n        textAlign: 'start'\n      });\n    } else {\n      var _paddingY = 0,\n          _paddingX = 0;\n\n      if (this.get('type') === 'color-legend') {\n        _paddingY = titleGap;\n        if (titleShape) _paddingY += titleShape.getBBox().height;\n      }\n\n      if (this.get('slidable')) {\n        if (this.get('type') === 'color-legend') {\n          // hoverPointer三角形的高\n          _paddingY -= 7;\n        } else {\n          _paddingY = titleGap;\n          if (!titleShape) _paddingY -= 7;\n        }\n\n        _paddingX += 10;\n      }\n\n      page *= width;\n      points = [[page + _paddingX, _paddingY], [page + _paddingX - 5, _paddingY - 10], [page + _paddingX + 5, _paddingY - 10]];\n      textStyle = Util.mix({}, {\n        x: page - 5,\n        y: height + this.get('textOffset') + _paddingY,\n        text: this._formatItemValue(value) + '' // 以字符串格式展示\n\n      }, this.get('textStyle'));\n    }\n\n    var hoverTextStyle = Util.mix(textStyle, this.get('hoverTextStyle'));\n\n    if (!hoverText) {\n      // mouse enter the legend, add hoverText\n      hoverText = this.get('group').addShape('text', {\n        attrs: hoverTextStyle\n      });\n      hoverText.set('id', 'hoverText');\n    } else {\n      // mouse move, update hoverText\n      hoverText.attr(hoverTextStyle);\n    }\n\n    if (!hoverPointer) {\n      // mouse enter the legend, add hoverPointer\n      hoverPointer = this.get('group').addShape('Polygon', {\n        attrs: Util.mix({\n          points: points\n        }, this.get('pointerStyle'))\n      });\n      hoverPointer.set('id', 'hoverPointer');\n    } else {\n      // mouse move, update hoverPointer\n      hoverPointer.attr(Util.mix({\n        points: points\n      }, this.get('pointerStyle')));\n    }\n\n    this.get('canvas').draw();\n  };\n\n  _proto.deactivate = function deactivate() {\n    var hoverPointer = this.get('group').findById('hoverPointer');\n    hoverPointer && hoverPointer.destroy();\n    var hoverText = this.get('group').findById('hoverText');\n    hoverText && hoverText.destroy();\n    this.get('canvas').draw();\n  };\n\n  return Continuous;\n}(Legend);\n\nmodule.exports = Continuous;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Component = __webpack_require__(66);\n\nvar Util = __webpack_require__(3);\n\nvar Tooltip =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Tooltip, _Component);\n\n  function Tooltip() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Tooltip.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Component.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * tooltip container\n       * @type {Dom / String}\n       */\n\n      /**\n       * 右下角坐标\n       * @type {Number}\n       */\n      x: 0,\n\n      /**\n       * y 右下角坐标\n       * @type {Number}\n       */\n      y: 0,\n\n      /**\n       * tooltip 记录项\n       * @type {Array}\n       */\n      items: null,\n\n      /**\n       * tooltip 标题\n       * @type {Array}\n       */\n      titleContent: null,\n\n      /**\n       * 是否展示 title\n       * @type {Boolean}\n       */\n      showTitle: true,\n\n      /**\n       * 视图范围\n       * @type {Object}\n       */\n      plotRange: null,\n\n      /**\n       * x轴上，移动到位置的偏移量\n       * @type {Number}\n       */\n      offset: 10,\n      // TODO:支持xy两个方向上的offset\n\n      /**\n       * 时间戳\n       * @type {Number}\n       */\n      timeStamp: 0,\n\n      /**\n       * 将 tooltip 展示在指定区域内\n       * @type {Boolean}\n       */\n      inPlot: true,\n\n      /**\n       * tooltip 辅助线配置\n       * @type {Object}\n       */\n      crosshairs: null\n    });\n  };\n\n  _proto.isContentChange = function isContentChange(title, items) {\n    var titleContent = this.get('titleContent');\n    var lastItems = this.get('items');\n    var isChanged = !(title === titleContent && lastItems.length === items.length);\n\n    if (!isChanged) {\n      Util.each(items, function (item, index) {\n        var preItem = lastItems[index];\n\n        for (var key in item) {\n          if (item.hasOwnProperty(key)) {\n            if (!Util.isObject(item[key]) && item[key] !== preItem[key]) {\n              isChanged = true;\n              break;\n            }\n          }\n        }\n\n        if (isChanged) {\n          return false;\n        }\n      });\n    }\n\n    return isChanged;\n  };\n\n  _proto.setContent = function setContent(title, items) {\n    var timeStamp = new Date().valueOf();\n    this.set('items', items);\n    this.set('titleContent', title);\n    this.set('timeStamp', timeStamp);\n    this.render();\n    return this;\n  };\n\n  _proto.setPosition = function setPosition(x, y) {\n    this.set('x', x);\n    this.set('y', y);\n  };\n\n  _proto.render = function render() {};\n\n  _proto.clear = function clear() {};\n\n  _proto.show = function show() {\n    this.set('visible', true);\n  };\n\n  _proto.hide = function hide() {\n    this.set('visible', false);\n  };\n\n  _proto.destroy = function destroy() {};\n\n  return Tooltip;\n}(Component);\n\nmodule.exports = Tooltip;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return root; });\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Selection;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__select__ = __webpack_require__(402);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectAll__ = __webpack_require__(403);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__filter__ = __webpack_require__(404);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__data__ = __webpack_require__(405);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__enter__ = __webpack_require__(382);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__exit__ = __webpack_require__(407);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__merge__ = __webpack_require__(408);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__order__ = __webpack_require__(409);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sort__ = __webpack_require__(410);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__call__ = __webpack_require__(411);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__nodes__ = __webpack_require__(412);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__node__ = __webpack_require__(413);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__size__ = __webpack_require__(414);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__empty__ = __webpack_require__(415);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__each__ = __webpack_require__(416);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__attr__ = __webpack_require__(417);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__style__ = __webpack_require__(384);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__property__ = __webpack_require__(418);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__classed__ = __webpack_require__(419);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__text__ = __webpack_require__(420);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__html__ = __webpack_require__(421);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__raise__ = __webpack_require__(422);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__lower__ = __webpack_require__(423);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__append__ = __webpack_require__(424);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__insert__ = __webpack_require__(425);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__remove__ = __webpack_require__(426);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__clone__ = __webpack_require__(427);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__datum__ = __webpack_require__(428);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__on__ = __webpack_require__(374);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__dispatch__ = __webpack_require__(429);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar root = [null];\nfunction Selection(groups, parents) {\n  this._groups = groups;\n  this._parents = parents;\n}\n\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\n\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: __WEBPACK_IMPORTED_MODULE_0__select__[\"a\" /* default */],\n  selectAll: __WEBPACK_IMPORTED_MODULE_1__selectAll__[\"a\" /* default */],\n  filter: __WEBPACK_IMPORTED_MODULE_2__filter__[\"a\" /* default */],\n  data: __WEBPACK_IMPORTED_MODULE_3__data__[\"a\" /* default */],\n  enter: __WEBPACK_IMPORTED_MODULE_4__enter__[\"b\" /* default */],\n  exit: __WEBPACK_IMPORTED_MODULE_5__exit__[\"a\" /* default */],\n  merge: __WEBPACK_IMPORTED_MODULE_6__merge__[\"a\" /* default */],\n  order: __WEBPACK_IMPORTED_MODULE_7__order__[\"a\" /* default */],\n  sort: __WEBPACK_IMPORTED_MODULE_8__sort__[\"a\" /* default */],\n  call: __WEBPACK_IMPORTED_MODULE_9__call__[\"a\" /* default */],\n  nodes: __WEBPACK_IMPORTED_MODULE_10__nodes__[\"a\" /* default */],\n  node: __WEBPACK_IMPORTED_MODULE_11__node__[\"a\" /* default */],\n  size: __WEBPACK_IMPORTED_MODULE_12__size__[\"a\" /* default */],\n  empty: __WEBPACK_IMPORTED_MODULE_13__empty__[\"a\" /* default */],\n  each: __WEBPACK_IMPORTED_MODULE_14__each__[\"a\" /* default */],\n  attr: __WEBPACK_IMPORTED_MODULE_15__attr__[\"a\" /* default */],\n  style: __WEBPACK_IMPORTED_MODULE_16__style__[\"a\" /* default */],\n  property: __WEBPACK_IMPORTED_MODULE_17__property__[\"a\" /* default */],\n  classed: __WEBPACK_IMPORTED_MODULE_18__classed__[\"a\" /* default */],\n  text: __WEBPACK_IMPORTED_MODULE_19__text__[\"a\" /* default */],\n  html: __WEBPACK_IMPORTED_MODULE_20__html__[\"a\" /* default */],\n  raise: __WEBPACK_IMPORTED_MODULE_21__raise__[\"a\" /* default */],\n  lower: __WEBPACK_IMPORTED_MODULE_22__lower__[\"a\" /* default */],\n  append: __WEBPACK_IMPORTED_MODULE_23__append__[\"a\" /* default */],\n  insert: __WEBPACK_IMPORTED_MODULE_24__insert__[\"a\" /* default */],\n  remove: __WEBPACK_IMPORTED_MODULE_25__remove__[\"a\" /* default */],\n  clone: __WEBPACK_IMPORTED_MODULE_26__clone__[\"a\" /* default */],\n  datum: __WEBPACK_IMPORTED_MODULE_27__datum__[\"a\" /* default */],\n  on: __WEBPACK_IMPORTED_MODULE_28__on__[\"b\" /* default */],\n  dispatch: __WEBPACK_IMPORTED_MODULE_29__dispatch__[\"a\" /* default */]\n};\n/* harmony default export */ __webpack_exports__[\"b\"] = (selection);\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export CREATED */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return SCHEDULED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return STARTING; });\n/* unused harmony export STARTED */\n/* unused harmony export RUNNING */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ENDING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ENDED; });\n/* harmony export (immutable) */ __webpack_exports__[\"g\"] = init;\n/* harmony export (immutable) */ __webpack_exports__[\"h\"] = set;\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = get;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_dispatch__ = __webpack_require__(438);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_timer__ = __webpack_require__(170);\n\n\nvar emptyOn = Object(__WEBPACK_IMPORTED_MODULE_0_d3_dispatch__[\"a\" /* dispatch */])(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n/* harmony default export */ __webpack_exports__[\"e\"] = (function (node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index,\n    // For context during callback.\n    group: group,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n});\nfunction init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\nfunction set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTING) throw new Error(\"too late; already started\");\n  return schedule;\n}\nfunction get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween; // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n\n  schedules[id] = self;\n  self.timer = Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__[\"timer\"])(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.\n\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.\n\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n\n      if (o.state === STARTED) return Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__[\"timeout\"])(start); // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n          o.state = ENDED;\n          o.timer.stop();\n          delete schedules[i];\n        }\n    } // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n\n\n    Object(__WEBPACK_IMPORTED_MODULE_1_d3_timer__[\"timeout\"])(function () {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    }); // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n\n    self.state = STARTED; // Initialize the tween, deleting null tween.\n\n    tween = new Array(n = self.tween.length);\n\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    } // Dispatch the end event.\n\n\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n\n\n    delete node.__transition;\n  }\n}\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 提取公共代码到util方法\n * @author dxq613@gmail.com\n */\nvar isString = __webpack_require__(10);\n\nvar isDate = __webpack_require__(80);\n\nmodule.exports = {\n  toTimeStamp: function toTimeStamp(value) {\n    if (isString(value)) {\n      if (value.indexOf('T') > 0) {\n        value = new Date(value).getTime();\n      } else {\n        value = new Date(value.replace(/-/ig, '/')).getTime();\n      }\n    }\n\n    if (isDate(value)) {\n      value = value.getTime();\n    }\n\n    return value;\n  }\n};\n\n/***/ }),\n/* 72 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_create__ = __webpack_require__(401);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_create__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_creator__ = __webpack_require__(360);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"creator\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_creator__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_local__ = __webpack_require__(430);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"local\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_local__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_matcher__ = __webpack_require__(381);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"matcher\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_matcher__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_mouse__ = __webpack_require__(431);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"mouse\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_mouse__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_namespace__ = __webpack_require__(370);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"namespace\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_namespace__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_namespaces__ = __webpack_require__(371);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"namespaces\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_namespaces__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_point__ = __webpack_require__(361);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"clientPoint\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_point__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_select__ = __webpack_require__(379);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"select\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_select__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_selectAll__ = __webpack_require__(432);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"selectAll\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_selectAll__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_selection_index__ = __webpack_require__(69);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"selection\", function() { return __WEBPACK_IMPORTED_MODULE_10__src_selection_index__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_selector__ = __webpack_require__(372);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"selector\", function() { return __WEBPACK_IMPORTED_MODULE_11__src_selector__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__ = __webpack_require__(380);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"selectorAll\", function() { return __WEBPACK_IMPORTED_MODULE_12__src_selectorAll__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_selection_style__ = __webpack_require__(384);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"style\", function() { return __WEBPACK_IMPORTED_MODULE_13__src_selection_style__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_touch__ = __webpack_require__(433);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"touch\", function() { return __WEBPACK_IMPORTED_MODULE_14__src_touch__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_touches__ = __webpack_require__(434);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"touches\", function() { return __WEBPACK_IMPORTED_MODULE_15__src_touches__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_window__ = __webpack_require__(373);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"window\", function() { return __WEBPACK_IMPORTED_MODULE_16__src_window__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_selection_on__ = __webpack_require__(374);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"event\", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"customEvent\", function() { return __WEBPACK_IMPORTED_MODULE_17__src_selection_on__[\"a\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Position: __webpack_require__(292),\n  Color: __webpack_require__(293),\n  Shape: __webpack_require__(294),\n  Size: __webpack_require__(295),\n  Opacity: __webpack_require__(296),\n  ColorUtil: __webpack_require__(149)\n};\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Scale entry, used to reference all the scales\n * @author dxq613@gmail.com\n */\nvar lowerFirst = __webpack_require__(75);\n\nvar Base = __webpack_require__(17);\n\nBase.Linear = __webpack_require__(33);\nBase.Identity = __webpack_require__(175);\nBase.Cat = __webpack_require__(77);\nBase.Time = __webpack_require__(176);\nBase.TimeCat = __webpack_require__(178);\nBase.Log = __webpack_require__(179);\nBase.Pow = __webpack_require__(180);\n\nvar _loop = function _loop(k) {\n  if (Base.hasOwnProperty(k)) {\n    var methodName = lowerFirst(k);\n\n    Base[methodName] = function (cfg) {\n      return new Base[k](cfg);\n    };\n  }\n};\n\nfor (var k in Base) {\n  _loop(k);\n}\n\nvar CAT_ARR = ['cat', 'timeCat'];\n\nBase.isCategory = function (type) {\n  return CAT_ARR.indexOf(type) >= 0;\n};\n\nmodule.exports = Base;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(23);\n\nvar lowerFirst = function lowerFirst(value) {\n  var str = toString(value);\n  return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\nmodule.exports = lowerFirst;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports) {\n\n/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = v * factor; // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n\n    if (index === -1) {\n      return Math.round(v);\n    }\n\n    var length = str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(17);\n\nvar catAuto = __webpack_require__(78);\n\nvar each = __webpack_require__(2);\n\nvar isNumber = __webpack_require__(9);\n\nvar isString = __webpack_require__(10);\n\nvar Category =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Category, _Base);\n\n  function Category() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Category.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    this.type = 'cat';\n    /**\n     * 是否分类度量\n     * @type {Boolean}\n     */\n\n    this.isCategory = true;\n    this.isRounding = true; // 是否进行取整操作\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.init = function init() {\n    var self = this;\n    var values = self.values;\n    var tickCount = self.tickCount;\n    each(values, function (v, i) {\n      values[i] = v.toString();\n    });\n\n    if (!self.ticks) {\n      var ticks = values;\n\n      if (tickCount) {\n        var temp = catAuto({\n          maxCount: tickCount,\n          data: values,\n          isRounding: self.isRounding\n        });\n        ticks = temp.ticks;\n      }\n\n      this.ticks = ticks;\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.getText = function getText(value) {\n    if (this.values.indexOf(value) === -1 && isNumber(value)) {\n      value = this.values[Math.round(value)];\n    }\n\n    return _Base.prototype.getText.call(this, value);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.translate = function translate(value) {\n    var index = this.values.indexOf(value);\n\n    if (index === -1 && isNumber(value)) {\n      index = value;\n    } else if (index === -1) {\n      index = NaN;\n    }\n\n    return index;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    var percent;\n\n    if (isString(value) || this.values.indexOf(value) !== -1) {\n      value = this.translate(value);\n    }\n\n    if (this.values.length > 1) {\n      percent = value / (this.values.length - 1);\n    } else {\n      percent = value;\n    }\n\n    return rangeMin + percent * (rangeMax - rangeMin);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.invert = function invert(value) {\n    if (isString(value)) {\n      // 如果已经是字符串\n      return value;\n    }\n\n    var min = this.rangeMin();\n    var max = this.rangeMax(); // 归一到 范围内\n\n    if (value < min) {\n      value = min;\n    }\n\n    if (value > max) {\n      value = max;\n    }\n\n    var percent = (value - min) / (max - min);\n    var index = Math.round(percent * (this.values.length - 1)) % this.values.length;\n    index = index || 0;\n    return this.values[index];\n  };\n\n  return Category;\n}(Base);\n\nBase.Cat = Category;\nmodule.exports = Category;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 计算分类的的坐标点\n * @author dxq613@gmail.com\n */\nvar each = __webpack_require__(2);\n\nvar MAX_COUNT = 8;\nvar SUB_COUNT = 4; // 控制个数不能过小\n\nfunction getSimpleArray(data) {\n  var arr = [];\n  each(data, function (sub) {\n    arr = arr.concat(sub);\n  });\n  return arr;\n}\n\nfunction getGreatestFactor(count, number) {\n  var i;\n\n  for (i = number; i > 0; i--) {\n    if (count % i === 0) {\n      break;\n    }\n  } // 如果是素数，没有可以整除的数字\n\n\n  if (i === 1) {\n    for (i = number; i > 0; i--) {\n      if ((count - 1) % i === 0) {\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nmodule.exports = function (info) {\n  var rst = {};\n  var ticks = [];\n  var isRounding = info.isRounding;\n  var categories = getSimpleArray(info.data);\n  var length = categories.length;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var tickCount;\n\n  if (isRounding) {\n    // 取整操作\n    tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount\n\n    if (tickCount === 2) {\n      tickCount = maxCount;\n    } else if (tickCount < maxCount - SUB_COUNT) {\n      tickCount = maxCount - SUB_COUNT;\n    }\n  } else {\n    tickCount = maxCount;\n  }\n\n  if (!isRounding && length <= tickCount + tickCount / 2) {\n    ticks = [].concat(categories);\n  } else {\n    var step = parseInt(length / (tickCount - 1), 10);\n    var groups = categories.map(function (e, i) {\n      return i % step === 0 ? categories.slice(i, i + step) : null;\n    }).filter(function (e) {\n      return e;\n    });\n\n    for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {\n      ticks.push(groups[i][0]);\n    }\n\n    if (categories.length) {\n      ticks.unshift(categories[0]);\n      var last = categories[length - 1];\n\n      if (ticks.indexOf(last) === -1) {\n        ticks.push(last);\n      }\n    }\n  }\n\n  rst.categories = categories;\n  rst.ticks = ticks;\n  return rst;\n};\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;(function (main) {\n  'use strict';\n  /**\n   * Parse or format dates\n   * @class fecha\n   */\n\n  var fecha = {};\n  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\n  var twoDigits = /\\d\\d?/;\n  var threeDigits = /\\d{3}/;\n  var fourDigits = /\\d{4}/;\n  var word = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n  var literal = /\\[([^]*?)\\]/gm;\n\n  var noop = function () {};\n\n  function shorten(arr, sLen) {\n    var newArr = [];\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      newArr.push(arr[i].substr(0, sLen));\n    }\n\n    return newArr;\n  }\n\n  function monthUpdate(arrName) {\n    return function (d, v, i18n) {\n      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());\n\n      if (~index) {\n        d.month = index;\n      }\n    };\n  }\n\n  function pad(val, len) {\n    val = String(val);\n    len = len || 2;\n\n    while (val.length < len) {\n      val = '0' + val;\n    }\n\n    return val;\n  }\n\n  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  var monthNamesShort = shorten(monthNames, 3);\n  var dayNamesShort = shorten(dayNames, 3);\n  fecha.i18n = {\n    dayNamesShort: dayNamesShort,\n    dayNames: dayNames,\n    monthNamesShort: monthNamesShort,\n    monthNames: monthNames,\n    amPm: ['am', 'pm'],\n    DoFn: function DoFn(D) {\n      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];\n    }\n  };\n  var formatFlags = {\n    D: function (dateObj) {\n      return dateObj.getDate();\n    },\n    DD: function (dateObj) {\n      return pad(dateObj.getDate());\n    },\n    Do: function (dateObj, i18n) {\n      return i18n.DoFn(dateObj.getDate());\n    },\n    d: function (dateObj) {\n      return dateObj.getDay();\n    },\n    dd: function (dateObj) {\n      return pad(dateObj.getDay());\n    },\n    ddd: function (dateObj, i18n) {\n      return i18n.dayNamesShort[dateObj.getDay()];\n    },\n    dddd: function (dateObj, i18n) {\n      return i18n.dayNames[dateObj.getDay()];\n    },\n    M: function (dateObj) {\n      return dateObj.getMonth() + 1;\n    },\n    MM: function (dateObj) {\n      return pad(dateObj.getMonth() + 1);\n    },\n    MMM: function (dateObj, i18n) {\n      return i18n.monthNamesShort[dateObj.getMonth()];\n    },\n    MMMM: function (dateObj, i18n) {\n      return i18n.monthNames[dateObj.getMonth()];\n    },\n    YY: function (dateObj) {\n      return String(dateObj.getFullYear()).substr(2);\n    },\n    YYYY: function (dateObj) {\n      return pad(dateObj.getFullYear(), 4);\n    },\n    h: function (dateObj) {\n      return dateObj.getHours() % 12 || 12;\n    },\n    hh: function (dateObj) {\n      return pad(dateObj.getHours() % 12 || 12);\n    },\n    H: function (dateObj) {\n      return dateObj.getHours();\n    },\n    HH: function (dateObj) {\n      return pad(dateObj.getHours());\n    },\n    m: function (dateObj) {\n      return dateObj.getMinutes();\n    },\n    mm: function (dateObj) {\n      return pad(dateObj.getMinutes());\n    },\n    s: function (dateObj) {\n      return dateObj.getSeconds();\n    },\n    ss: function (dateObj) {\n      return pad(dateObj.getSeconds());\n    },\n    S: function (dateObj) {\n      return Math.round(dateObj.getMilliseconds() / 100);\n    },\n    SS: function (dateObj) {\n      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n    },\n    SSS: function (dateObj) {\n      return pad(dateObj.getMilliseconds(), 3);\n    },\n    a: function (dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n    },\n    A: function (dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();\n    },\n    ZZ: function (dateObj) {\n      var o = dateObj.getTimezoneOffset();\n      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);\n    }\n  };\n  var parseFlags = {\n    D: [twoDigits, function (d, v) {\n      d.day = v;\n    }],\n    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {\n      d.day = parseInt(v, 10);\n    }],\n    M: [twoDigits, function (d, v) {\n      d.month = v - 1;\n    }],\n    YY: [twoDigits, function (d, v) {\n      var da = new Date(),\n          cent = +('' + da.getFullYear()).substr(0, 2);\n      d.year = '' + (v > 68 ? cent - 1 : cent) + v;\n    }],\n    h: [twoDigits, function (d, v) {\n      d.hour = v;\n    }],\n    m: [twoDigits, function (d, v) {\n      d.minute = v;\n    }],\n    s: [twoDigits, function (d, v) {\n      d.second = v;\n    }],\n    YYYY: [fourDigits, function (d, v) {\n      d.year = v;\n    }],\n    S: [/\\d/, function (d, v) {\n      d.millisecond = v * 100;\n    }],\n    SS: [/\\d{2}/, function (d, v) {\n      d.millisecond = v * 10;\n    }],\n    SSS: [threeDigits, function (d, v) {\n      d.millisecond = v;\n    }],\n    d: [twoDigits, noop],\n    ddd: [word, noop],\n    MMM: [word, monthUpdate('monthNamesShort')],\n    MMMM: [word, monthUpdate('monthNames')],\n    a: [word, function (d, v, i18n) {\n      var val = v.toLowerCase();\n\n      if (val === i18n.amPm[0]) {\n        d.isPm = false;\n      } else if (val === i18n.amPm[1]) {\n        d.isPm = true;\n      }\n    }],\n    ZZ: [/([\\+\\-]\\d\\d:?\\d\\d|Z)/, function (d, v) {\n      if (v === 'Z') v = '+00:00';\n      var parts = (v + '').match(/([\\+\\-]|\\d\\d)/gi),\n          minutes;\n\n      if (parts) {\n        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);\n        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;\n      }\n    }]\n  };\n  parseFlags.dd = parseFlags.d;\n  parseFlags.dddd = parseFlags.ddd;\n  parseFlags.DD = parseFlags.D;\n  parseFlags.mm = parseFlags.m;\n  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;\n  parseFlags.MM = parseFlags.M;\n  parseFlags.ss = parseFlags.s;\n  parseFlags.A = parseFlags.a; // Some common format strings\n\n  fecha.masks = {\n    default: 'ddd MMM DD YYYY HH:mm:ss',\n    shortDate: 'M/D/YY',\n    mediumDate: 'MMM D, YYYY',\n    longDate: 'MMMM D, YYYY',\n    fullDate: 'dddd, MMMM D, YYYY',\n    shortTime: 'HH:mm',\n    mediumTime: 'HH:mm:ss',\n    longTime: 'HH:mm:ss.SSS'\n  };\n  /***\n   * Format a date\n   * @method format\n   * @param {Date|number} dateObj\n   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n   */\n\n  fecha.format = function (dateObj, mask, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof dateObj === 'number') {\n      dateObj = new Date(dateObj);\n    }\n\n    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {\n      throw new Error('Invalid Date in fecha.format');\n    }\n\n    mask = fecha.masks[mask] || mask || fecha.masks['default'];\n    var literals = []; // Make literals inactive by replacing them with ??\n\n    mask = mask.replace(literal, function ($0, $1) {\n      literals.push($1);\n      return '??';\n    }); // Apply formatting rules\n\n    mask = mask.replace(token, function ($0) {\n      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);\n    }); // Inline literal values back into the formatted value\n\n    return mask.replace(/\\?\\?/g, function () {\n      return literals.shift();\n    });\n  };\n  /**\n   * Parse a date string into an object, changes - into /\n   * @method parse\n   * @param {string} dateStr Date string\n   * @param {string} format Date parse format\n   * @returns {Date|boolean}\n   */\n\n\n  fecha.parse = function (dateStr, format, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof format !== 'string') {\n      throw new Error('Invalid format in fecha.parse');\n    }\n\n    format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings\n    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n\n    if (dateStr.length > 1000) {\n      return false;\n    }\n\n    var isValid = true;\n    var dateInfo = {};\n    format.replace(token, function ($0) {\n      if (parseFlags[$0]) {\n        var info = parseFlags[$0];\n        var index = dateStr.search(info[0]);\n\n        if (!~index) {\n          isValid = false;\n        } else {\n          dateStr.replace(info[0], function (result) {\n            info[1](dateInfo, result, i18n);\n            dateStr = dateStr.substr(index + result.length);\n            return result;\n          });\n        }\n      }\n\n      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);\n    });\n\n    if (!isValid) {\n      return false;\n    }\n\n    var today = new Date();\n\n    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {\n      dateInfo.hour = +dateInfo.hour + 12;\n    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {\n      dateInfo.hour = 0;\n    }\n\n    var date;\n\n    if (dateInfo.timezoneOffset != null) {\n      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;\n      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));\n    } else {\n      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);\n    }\n\n    return date;\n  };\n  /* istanbul ignore next */\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = fecha;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return fecha;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this);\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(12);\n\nvar isDate = function isDate(value) {\n  return isType(value, 'Date');\n};\n\nmodule.exports = isDate;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  isFunction: __webpack_require__(11),\n  isObject: __webpack_require__(24),\n  isBoolean: __webpack_require__(82),\n  isNil: __webpack_require__(5),\n  isString: __webpack_require__(10),\n  isArray: __webpack_require__(4),\n  isNumber: __webpack_require__(9),\n  isEmpty: __webpack_require__(83),\n  // isBlank\n  uniqueId: __webpack_require__(86),\n  clone: __webpack_require__(46),\n  deepMix: __webpack_require__(47),\n  assign: __webpack_require__(8),\n  // simpleMix\n  merge: __webpack_require__(47),\n  // mix\n  upperFirst: __webpack_require__(87),\n  // ucfirst\n  each: __webpack_require__(2),\n  isEqual: __webpack_require__(49),\n  toArray: __webpack_require__(34),\n  extend: __webpack_require__(88),\n  augment: __webpack_require__(89),\n  remove: __webpack_require__(90),\n  isNumberEqual: __webpack_require__(35),\n  toRadian: __webpack_require__(91),\n  toDegree: __webpack_require__(92),\n  mod: __webpack_require__(93),\n  clamp: __webpack_require__(50),\n  createDom: __webpack_require__(94),\n  modifyCSS: __webpack_require__(95),\n  requestAnimationFrame: __webpack_require__(96),\n  getRatio: function getRatio() {\n    return window.devicePixelRatio ? window.devicePixelRatio : 2;\n  },\n  mat3: __webpack_require__(51),\n  vec2: __webpack_require__(97),\n  vec3: __webpack_require__(98),\n  transform: __webpack_require__(99)\n};\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否是布尔类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar isType = __webpack_require__(12);\n\nvar isBoolean = function isBoolean(value) {\n  return isType(value, 'Boolean');\n};\n\nmodule.exports = isBoolean;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(5);\n\nvar isArrayLike = __webpack_require__(13);\n\nvar getType = __webpack_require__(84);\n\nvar isPrototype = __webpack_require__(85);\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isEmpty(value) {\n  /**\n   * isEmpty(null) => true\n   * isEmpty() => true\n   * isEmpty(true) => true\n   * isEmpty(1) => true\n   * isEmpty([1, 2, 3]) => false\n   * isEmpty('abc') => false\n   * isEmpty({ a: 1 }) => false\n   */\n  if (isNil(value)) {\n    return true;\n  }\n\n  if (isArrayLike(value)) {\n    return !value.length;\n  }\n\n  var type = getType(value);\n\n  if (type === 'Map' || type === 'Set') {\n    return !value.size;\n  }\n\n  if (isPrototype(value)) {\n    return !Object.keys(value).length;\n  }\n\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isEmpty;\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nvar getType = function getType(value) {\n  return toString.call(value).replace(/^\\[object /, '').replace(/\\]$/, '');\n};\n\nmodule.exports = getType;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports) {\n\nvar objectProto = Object.prototype;\n\nvar isPrototype = function isPrototype(value) {\n  var Ctor = value && value.constructor;\n  var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;\n  return value === proto;\n};\n\nmodule.exports = isPrototype;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports) {\n\nvar uniqueId = function () {\n  var map = {};\n  return function (prefix) {\n    prefix = prefix || 'g';\n\n    if (!map[prefix]) {\n      map[prefix] = 1;\n    } else {\n      map[prefix] += 1;\n    }\n\n    return prefix + map[prefix];\n  };\n}();\n\nmodule.exports = uniqueId;\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(23);\n\nvar upperFirst = function upperFirst(value) {\n  var str = toString(value);\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nmodule.exports = upperFirst;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(11);\n\nvar mix = __webpack_require__(8);\n\nvar extend = function extend(subclass, superclass, overrides, staticOverrides) {\n  // 如果只提供父类构造函数，则自动生成子类构造函数\n  if (!isFunction(superclass)) {\n    overrides = superclass;\n    superclass = subclass;\n\n    subclass = function subclass() {};\n  }\n\n  var create = Object.create ? function (proto, c) {\n    return Object.create(proto, {\n      constructor: {\n        value: c\n      }\n    });\n  } : function (proto, c) {\n    function Tmp() {}\n\n    Tmp.prototype = proto;\n    var o = new Tmp();\n    o.constructor = c;\n    return o;\n  };\n  var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype\n\n  subclass.prototype = mix(superObj, subclass.prototype); // 指定子类的prototype\n\n  subclass.superclass = create(superclass.prototype, superclass);\n  mix(superObj, overrides);\n  mix(subclass, staticOverrides);\n  return subclass;\n};\n\nmodule.exports = extend;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(11);\n\nvar toArray = __webpack_require__(34);\n\nvar mix = __webpack_require__(8);\n\nvar augment = function augment(c) {\n  var args = toArray(arguments);\n\n  for (var i = 1; i < args.length; i++) {\n    var obj = args[i];\n\n    if (isFunction(obj)) {\n      obj = obj.prototype;\n    }\n\n    mix(c.prototype, obj);\n  }\n};\n\nmodule.exports = augment;\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports) {\n\nvar arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar slice = arrPrototype.slice;\n\nvar pull = function pull(arr) {\n  var values = slice.call(arguments, 1);\n\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n    var fromIndex = -1;\n\n    while ((fromIndex = indexOf.call(arr, value)) > -1) {\n      splice.call(arr, fromIndex, 1);\n    }\n  }\n\n  return arr;\n};\n\nmodule.exports = pull;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports) {\n\nvar RADIAN = Math.PI / 180;\n\nvar toRadian = function toRadian(degree) {\n  return RADIAN * degree;\n};\n\nmodule.exports = toRadian;\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports) {\n\nvar DEGREE = 180 / Math.PI;\n\nvar toDegree = function toDegree(radian) {\n  return DEGREE * radian;\n};\n\nmodule.exports = toDegree;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports) {\n\nvar mod = function mod(n, m) {\n  return (n % m + m) % m;\n};\n\nmodule.exports = mod;\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports) {\n\n/**\n * 创建DOM 节点\n * @param  {String} str Dom 字符串\n * @return {HTMLElement}  DOM 节点\n */\nvar TABLE = document.createElement('table');\nvar TABLE_TR = document.createElement('tr');\nvar FRAGMENT_REG = /^\\s*<(\\w+|!)[^>]*>/;\nvar CONTAINERS = {\n  tr: document.createElement('tbody'),\n  tbody: TABLE,\n  thead: TABLE,\n  tfoot: TABLE,\n  td: TABLE_TR,\n  th: TABLE_TR,\n  '*': document.createElement('div')\n};\n\nmodule.exports = function createDom(str) {\n  var name = FRAGMENT_REG.test(str) && RegExp.$1;\n\n  if (!(name in CONTAINERS)) {\n    name = '*';\n  }\n\n  var container = CONTAINERS[name];\n  str = str.replace(/(^\\s*)|(\\s*$)/g, '');\n  container.innerHTML = '' + str;\n  var dom = container.childNodes[0];\n  container.removeChild(dom);\n  return dom;\n};\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports) {\n\nmodule.exports = function modifyCSS(dom, css) {\n  if (dom) {\n    for (var key in css) {\n      if (css.hasOwnProperty(key)) {\n        dom.style[key] = css[key];\n      }\n    }\n  }\n\n  return dom;\n};\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports) {\n\nmodule.exports = function requestAnimationFrame(fn) {\n  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n    return setTimeout(fn, 16);\n  };\n\n  return method(fn);\n};\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar vec2 = __webpack_require__(183);\n\nvar clamp = __webpack_require__(50);\n\nvec2.angle = function (v1, v2) {\n  var theta = vec2.dot(v1, v2) / (vec2.length(v1) * vec2.length(v2));\n  return Math.acos(clamp(theta, -1, 1));\n};\n/**\n * 向量 v1 到 向量 v2 夹角的方向\n * @param  {Array} v1 向量\n * @param  {Array} v2 向量\n * @return {Boolean} >= 0 顺时针 < 0 逆时针\n */\n\n\nvec2.direction = function (v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n};\n\nvec2.angleTo = function (v1, v2, direct) {\n  var angle = vec2.angle(v1, v2);\n  var angleLargeThanPI = vec2.direction(v1, v2) >= 0;\n\n  if (direct) {\n    if (angleLargeThanPI) {\n      return Math.PI * 2 - angle;\n    }\n\n    return angle;\n  }\n\n  if (angleLargeThanPI) {\n    return angle;\n  }\n\n  return Math.PI * 2 - angle;\n};\n\nvec2.vertical = function (out, v, flag) {\n  if (flag) {\n    out[0] = v[1];\n    out[1] = -1 * v[0];\n  } else {\n    out[0] = -1 * v[1];\n    out[1] = v[0];\n  }\n\n  return out;\n};\n\nmodule.exports = vec2;\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar vec3 = __webpack_require__(184);\n\nmodule.exports = vec3;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar clone = __webpack_require__(46);\n\nvar each = __webpack_require__(2);\n\nvar mat3 = __webpack_require__(51);\n\nmodule.exports = function transform(m, ts) {\n  m = clone(m);\n  each(ts, function (t) {\n    switch (t[0]) {\n      case 't':\n        mat3.translate(m, m, [t[1], t[2]]);\n        break;\n\n      case 's':\n        mat3.scale(m, m, [t[1], t[2]]);\n        break;\n\n      case 'r':\n        mat3.rotate(m, m, t[1]);\n        break;\n\n      case 'm':\n        mat3.multiply(m, m, t[1]);\n        break;\n\n      default:\n        return false;\n    }\n  });\n  return m;\n};\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Event = function Event(type, event, bubbles, cancelable) {\n  this.type = type; // 事件类型\n\n  this.target = null; // 目标\n\n  this.currentTarget = null; // 当前目标\n\n  this.bubbles = bubbles; // 冒泡\n\n  this.cancelable = cancelable; // 是否能够阻止\n\n  this.timeStamp = new Date().getTime(); // 时间戳\n\n  this.defaultPrevented = false; // 阻止默认\n\n  this.propagationStopped = false; // 阻止冒泡\n\n  this.removed = false; // 是否被移除\n\n  this.event = event; // 触发的原生事件\n};\n\nUtil.augment(Event, {\n  preventDefault: function preventDefault() {\n    this.defaultPrevented = this.cancelable && true;\n  },\n  stopPropagation: function stopPropagation() {\n    this.propagationStopped = true;\n  },\n  remove: function remove() {\n    this.remove = true;\n  },\n  clone: function clone() {\n    return Util.clone(this);\n  },\n  toString: function toString() {\n    return '[Event (type=' + this.type + ')]';\n  }\n});\nmodule.exports = Event;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Element = __webpack_require__(102);\n\nvar Shape = __webpack_require__(188);\n\nvar SHAPE_MAP = {}; // 缓存图形类型\n\nvar INDEX = '_INDEX';\n\nfunction getComparer(compare) {\n  return function (left, right) {\n    var result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\n\nfunction find(children, x, y) {\n  var rst;\n\n  for (var i = children.length - 1; i >= 0; i--) {\n    var child = children[i];\n\n    if (child._cfg.visible && child._cfg.capture) {\n      if (child.isGroup) {\n        rst = child.getShape(x, y);\n      } else if (child.isHit(x, y)) {\n        rst = child;\n      }\n    }\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Group = function Group(cfg) {\n  Group.superclass.constructor.call(this, cfg);\n  this.set('children', []);\n  this.set('tobeRemoved', []);\n\n  this._beforeRenderUI();\n\n  this._renderUI();\n\n  this._bindUI();\n};\n\nfunction initClassCfgs(c) {\n  if (c._cfg || c === Group) {\n    return;\n  }\n\n  var superCon = c.superclass.constructor;\n\n  if (superCon && !superCon._cfg) {\n    initClassCfgs(superCon);\n  }\n\n  c._cfg = {};\n  Util.merge(c._cfg, superCon._cfg);\n  Util.merge(c._cfg, c.CFG);\n}\n\nUtil.extend(Group, Element);\nUtil.augment(Group, {\n  isGroup: true,\n  type: 'group',\n  canFill: true,\n  canStroke: true,\n  getDefaultCfg: function getDefaultCfg() {\n    initClassCfgs(this.constructor);\n    return Util.merge({}, this.constructor._cfg);\n  },\n  _beforeRenderUI: function _beforeRenderUI() {},\n  _renderUI: function _renderUI() {},\n  _bindUI: function _bindUI() {},\n  addShape: function addShape(type, cfg) {\n    var canvas = this.get('canvas');\n    cfg = cfg || {};\n    var shapeType = SHAPE_MAP[type];\n\n    if (!shapeType) {\n      shapeType = Util.upperFirst(type);\n      SHAPE_MAP[type] = shapeType;\n    }\n\n    if (cfg.attrs && canvas) {\n      var attrs = cfg.attrs;\n\n      if (type === 'text') {\n        // 临时解决\n        var topFontFamily = canvas.get('fontFamily');\n\n        if (topFontFamily) {\n          attrs.fontFamily = attrs.fontFamily ? attrs.fontFamily : topFontFamily;\n        }\n      }\n    }\n\n    cfg.canvas = canvas;\n    cfg.type = type;\n    var rst = new Shape[shapeType](cfg);\n    this.add(rst);\n    return rst;\n  },\n\n  /** 添加图组\n   * @param  {Function|Object|undefined} param 图组类\n   * @param  {Object} cfg 配置项\n   * @return {Object} rst 图组\n   */\n  addGroup: function addGroup(param, cfg) {\n    var canvas = this.get('canvas');\n    var rst;\n    cfg = Util.merge({}, cfg);\n\n    if (Util.isFunction(param)) {\n      if (cfg) {\n        cfg.canvas = canvas;\n        cfg.parent = this;\n        rst = new param(cfg);\n      } else {\n        rst = new param({\n          canvas: canvas,\n          parent: this\n        });\n      }\n\n      this.add(rst);\n    } else if (Util.isObject(param)) {\n      param.canvas = canvas;\n      rst = new Group(param);\n      this.add(rst);\n    } else if (param === undefined) {\n      rst = new Group();\n      this.add(rst);\n    } else {\n      return false;\n    }\n\n    return rst;\n  },\n\n  /** 绘制背景\n   * @param  {Array} padding 内边距\n   * @param  {Attrs} attrs 图形属性\n   * @param  {Shape} backShape 背景图形\n   * @return {Object} 背景层对象\n   */\n  renderBack: function renderBack(padding, attrs) {\n    var backShape = this.get('backShape');\n    var innerBox = this.getBBox(); // const parent = this.get('parent'); // getParent\n\n    Util.merge(attrs, {\n      x: innerBox.minX - padding[3],\n      y: innerBox.minY - padding[0],\n      width: innerBox.width + padding[1] + padding[3],\n      height: innerBox.height + padding[0] + padding[2]\n    });\n\n    if (backShape) {\n      backShape.attr(attrs);\n    } else {\n      backShape = this.addShape('rect', {\n        zIndex: -1,\n        attrs: attrs\n      });\n    }\n\n    this.set('backShape', backShape);\n    this.sort();\n    return backShape;\n  },\n  removeChild: function removeChild(item, destroy) {\n    if (arguments.length >= 2) {\n      if (this.contain(item)) {\n        item.remove(destroy);\n      }\n    } else {\n      if (arguments.length === 1) {\n        if (Util.isBoolean(item)) {\n          destroy = item;\n        } else {\n          if (this.contain(item)) {\n            item.remove(true);\n          }\n\n          return this;\n        }\n      }\n\n      if (arguments.length === 0) {\n        destroy = true;\n      }\n\n      Group.superclass.remove.call(this, destroy);\n    }\n\n    return this;\n  },\n\n  /**\n   * 向组中添加shape或者group\n   * @param {Object} items 图形或者分组\n   * @return {Object} group 本尊\n   */\n  add: function add(items) {\n    var self = this;\n    var children = self.get('children');\n\n    if (Util.isArray(items)) {\n      Util.each(items, function (item) {\n        var parent = item.get('parent');\n\n        if (parent) {\n          parent.removeChild(item, false);\n        }\n\n        self._setCfgProperty(item);\n      });\n      self._cfg.children = children.concat(items);\n    } else {\n      var item = items;\n      var parent = item.get('parent');\n\n      if (parent) {\n        parent.removeChild(item, false);\n      }\n\n      self._setCfgProperty(item);\n\n      children.push(item);\n    }\n\n    return self;\n  },\n  _setCfgProperty: function _setCfgProperty(item) {\n    var cfg = this._cfg;\n    item.set('parent', this);\n    item.set('canvas', cfg.canvas);\n\n    if (cfg.timeline) {\n      item.set('timeline', cfg.timeline);\n    }\n  },\n  contain: function contain(item) {\n    var children = this.get('children');\n    return children.indexOf(item) > -1;\n  },\n  getChildByIndex: function getChildByIndex(index) {\n    var children = this.get('children');\n    return children[index];\n  },\n  getFirst: function getFirst() {\n    return this.getChildByIndex(0);\n  },\n  getLast: function getLast() {\n    var lastIndex = this.get('children').length - 1;\n    return this.getChildByIndex(lastIndex);\n  },\n  getBBox: function getBBox() {\n    var self = this;\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var children = self.get('children');\n\n    if (children.length > 0) {\n      Util.each(children, function (child) {\n        if (child.get('visible')) {\n          if (child.isGroup && child.get('children').length === 0) {\n            return;\n          }\n\n          var _box = child.getBBox();\n\n          if (!_box) {\n            return true;\n          }\n\n          var leftTop = [_box.minX, _box.minY, 1];\n          var leftBottom = [_box.minX, _box.maxY, 1];\n          var rightTop = [_box.maxX, _box.minY, 1];\n          var rightBottom = [_box.maxX, _box.maxY, 1];\n          child.apply(leftTop);\n          child.apply(leftBottom);\n          child.apply(rightTop);\n          child.apply(rightBottom);\n          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);\n          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);\n          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);\n          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);\n\n          if (boxMinX < minX) {\n            minX = boxMinX;\n          }\n\n          if (boxMaxX > maxX) {\n            maxX = boxMaxX;\n          }\n\n          if (boxMinY < minY) {\n            minY = boxMinY;\n          }\n\n          if (boxMaxY > maxY) {\n            maxY = boxMaxY;\n          }\n        }\n      });\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n\n    var box = {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n    box.x = box.minX;\n    box.y = box.minY;\n    box.width = box.maxX - box.minX;\n    box.height = box.maxY - box.minY;\n    return box;\n  },\n  getCount: function getCount() {\n    return this.get('children').length;\n  },\n  sort: function sort() {\n    var children = this.get('children'); // 稳定排序\n\n    Util.each(children, function (child, index) {\n      child[INDEX] = index;\n      return child;\n    });\n    children.sort(getComparer(function (obj1, obj2) {\n      return obj1.get('zIndex') - obj2.get('zIndex');\n    }));\n    return this;\n  },\n  findById: function findById(id) {\n    return this.find(function (item) {\n      return item.get('id') === id;\n    });\n  },\n\n  /**\n   * 根据查找函数查找分组或者图形\n   * @param  {Function} fn 匹配函数\n   * @return {Canvas.Base} 分组或者图形\n   */\n  find: function find(fn) {\n    if (Util.isString(fn)) {\n      return this.findById(fn);\n    }\n\n    var children = this.get('children');\n    var rst = null;\n    Util.each(children, function (item) {\n      if (fn(item)) {\n        rst = item;\n      } else if (item.find) {\n        rst = item.find(fn);\n      }\n\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  },\n\n  /**\n   * @param  {Function} fn filter mathod\n   * @return {Array} all the matching shapes and groups\n   */\n  findAll: function findAll(fn) {\n    var children = this.get('children');\n    var rst = [];\n    var childRst = [];\n    Util.each(children, function (item) {\n      if (fn(item)) {\n        rst.push(item);\n      }\n\n      if (item.findAllBy) {\n        childRst = item.findAllBy(fn);\n        rst = rst.concat(childRst);\n      }\n    });\n    return rst;\n  },\n\n  /**\n   * @Deprecated\n   * @param  {Function} fn filter method\n   * @return {Object} found shape or group\n   */\n  findBy: function findBy(fn) {\n    var children = this.get('children');\n    var rst = null;\n    Util.each(children, function (item) {\n      if (fn(item)) {\n        rst = item;\n      } else if (item.findBy) {\n        rst = item.findBy(fn);\n      }\n\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  },\n\n  /**\n   * @Deprecated\n   * @param  {Function} fn filter mathod\n   * @return {Array} all the matching shapes and groups\n   */\n  findAllBy: function findAllBy(fn) {\n    var children = this.get('children');\n    var rst = [];\n    var childRst = [];\n    Util.each(children, function (item) {\n      if (fn(item)) {\n        rst.push(item);\n      }\n\n      if (item.findAllBy) {\n        childRst = item.findAllBy(fn);\n        rst = rst.concat(childRst);\n      }\n    });\n    return rst;\n  },\n  getShape: function getShape(x, y) {\n    var self = this;\n    var clip = self._attrs.clip;\n    var children = self._cfg.children;\n    var rst;\n\n    if (clip) {\n      var v = [x, y, 1];\n      clip.invert(v, self.get('canvas')); // 已经在外面转换\n\n      if (clip.isPointInPath(v[0], v[1])) {\n        rst = find(children, x, y);\n      }\n    } else {\n      rst = find(children, x, y);\n    }\n\n    return rst;\n  },\n  clearTotalMatrix: function clearTotalMatrix() {\n    var m = this.get('totalMatrix');\n\n    if (m) {\n      this.setSilent('totalMatrix', null);\n      var children = this._cfg.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        child.clearTotalMatrix();\n      }\n    }\n  },\n  clear: function clear(delayRemove) {\n    var children = this._cfg.children;\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      children[i].remove(true, delayRemove);\n    }\n\n    this._cfg.children = [];\n    return this;\n  },\n  destroy: function destroy() {\n    if (this.get('destroyed')) {\n      return;\n    }\n\n    this.clear();\n    Group.superclass.destroy.call(this);\n  },\n  clone: function clone() {\n    var self = this;\n    var children = self._cfg.children;\n    var clone = new Group();\n    Util.each(children, function (child) {\n      clone.add(child.clone());\n    });\n    return clone;\n  }\n});\nmodule.exports = Group;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Attribute = __webpack_require__(185);\n\nvar Transform = __webpack_require__(186);\n\nvar Animate = __webpack_require__(187);\n\nvar EventEmitter = __webpack_require__(53);\n\nvar Element = function Element(cfg) {\n  this._cfg = {\n    zIndex: 0,\n    capture: true,\n    visible: true,\n    destroyed: false\n  }; // 配置存放地\n\n  Util.assign(this._cfg, this.getDefaultCfg(), cfg); // Element.CFG不合并，提升性能 合并默认配置，用户配置->继承默认配置->Element默认配置\n\n  this.initAttrs(this._cfg.attrs); // 初始化绘图属性\n\n  this._cfg.attrs = {};\n  this.initTransform(); // 初始化变换\n\n  this.init(); // 类型初始化\n};\n\nElement.CFG = {\n  /**\n   * 唯一标示\n   * @type {Number}\n   */\n  id: null,\n\n  /**\n   * Z轴的层叠关系，Z值越大离用户越近\n   * @type {Number}\n   */\n  zIndex: 0,\n\n  /**\n   * Canvas对象\n   * @type: {Object}\n   */\n  canvas: null,\n\n  /**\n   * 父元素指针\n   * @type {Object}\n   */\n  parent: null,\n\n  /**\n   * 用来设置当前对象是否能被捕捉\n   * true 能\n   * false 不能\n   * 对象默认是都可以被捕捉的, 当capture为false时，group.getShape(x, y)方法无法获得该元素\n   * 通过将不必要捕捉的元素的该属性设置成false, 来提高捕捉性能\n   * @type {Boolean}\n   **/\n  capture: true,\n\n  /**\n   * 画布的上下文\n   * @type {Object}\n   */\n  context: null,\n\n  /**\n   * 是否显示\n   * @type {Boolean}\n   */\n  visible: true,\n\n  /**\n   * 是否被销毁\n   * @type: {Boolean}\n   */\n  destroyed: false\n};\nUtil.augment(Element, Attribute, Transform, EventEmitter, Animate, {\n  init: function init() {\n    this.setSilent('animable', true);\n    this.setSilent('animating', false); // 初始时不处于动画状态\n  },\n  getParent: function getParent() {\n    return this._cfg.parent;\n  },\n\n  /**\n   * 获取默认的配置信息\n   * @protected\n   * @return {Object} 默认的属性\n   */\n  getDefaultCfg: function getDefaultCfg() {\n    return {};\n  },\n  set: function set(name, value) {\n    if (name === 'zIndex' && this._beforeSetZIndex) {\n      this._beforeSetZIndex(value);\n    }\n\n    if (name === 'loading' && this._beforeSetLoading) {\n      this._beforeSetLoading(value);\n    }\n\n    this._cfg[name] = value;\n    return this;\n  },\n  // deprecated\n  setSilent: function setSilent(name, value) {\n    this._cfg[name] = value;\n  },\n  get: function get(name) {\n    return this._cfg[name];\n  },\n  show: function show() {\n    this._cfg.visible = true;\n    return this;\n  },\n  hide: function hide() {\n    this._cfg.visible = false;\n    return this;\n  },\n  remove: function remove(destroy, delayRemove) {\n    var cfg = this._cfg;\n    var parent = cfg.parent;\n    var el = cfg.el;\n\n    if (parent) {\n      Util.remove(parent.get('children'), this);\n    }\n\n    if (el) {\n      if (delayRemove) {\n        parent && parent._cfg.tobeRemoved.push(el);\n      } else {\n        el.parentNode.removeChild(el);\n      }\n    }\n\n    if (destroy || destroy === undefined) {\n      this.destroy();\n    }\n\n    return this;\n  },\n  destroy: function destroy() {\n    var destroyed = this.get('destroyed');\n\n    if (destroyed) {\n      return;\n    }\n\n    this._attrs = null;\n    this.removeEvent(); // 移除所有的事件\n\n    this._cfg = {\n      destroyed: true\n    };\n  },\n  toFront: function toFront() {\n    var cfg = this._cfg;\n    var parent = cfg.parent;\n\n    if (!parent) {\n      return;\n    }\n\n    var children = parent._cfg.children;\n    var el = cfg.el;\n    var index = children.indexOf(this);\n    children.splice(index, 1);\n    children.push(this);\n\n    if (el) {\n      el.parentNode.removeChild(el);\n      cfg.el = null;\n    }\n  },\n  toBack: function toBack() {\n    var cfg = this._cfg;\n    var parent = cfg.parent;\n\n    if (!parent) {\n      return;\n    }\n\n    var children = parent._cfg.children;\n    var el = cfg.el;\n    var index = children.indexOf(this);\n    children.splice(index, 1);\n    children.unshift(this);\n\n    if (el) {\n      var parentNode = el.parentNode;\n      parentNode.removeChild(el);\n      parentNode.insertBefore(el, parentNode.firstChild);\n    }\n  },\n  _beforeSetZIndex: function _beforeSetZIndex(zIndex) {\n    var parent = this._cfg.parent;\n    this._cfg.zIndex = zIndex;\n\n    if (!Util.isNil(parent)) {\n      parent.sort();\n    }\n\n    var el = this._cfg.el;\n\n    if (el) {\n      var children = parent._cfg.children;\n      var index = children.indexOf(this);\n      var parentNode = el.parentNode;\n      parentNode.removeChild(el);\n\n      if (index === children.length - 1) {\n        parentNode.appendChild(el);\n      } else {\n        parentNode.insertBefore(el, parentNode.childNodes[index]);\n      }\n    }\n\n    return zIndex;\n  },\n  _setAttrs: function _setAttrs(attrs) {\n    this.attr(attrs);\n    return attrs;\n  },\n  setZIndex: function setZIndex(zIndex) {\n    this._cfg.zIndex = zIndex;\n    return this._beforeSetZIndex(zIndex);\n  },\n  clone: function clone() {\n    return Util.clone(this);\n  },\n  getBBox: function getBBox() {}\n});\nmodule.exports = Element;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar vec2 = Util.vec2;\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n\nfunction quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, out) {\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var d1;\n  var v1;\n  var v2;\n\n  var _t;\n\n  var d2;\n  var i;\n  var EPSILON = 0.0001;\n  var v0 = [x, y];\n\n  for (_t = 0; _t < 1; _t += 0.05) {\n    v1 = [quadraticAt(x1, x2, x3, _t), quadraticAt(y1, y2, y3, _t)];\n    d1 = vec2.squaredDistance(v0, v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity;\n\n  for (i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval;\n    v1 = [quadraticAt(x1, x2, x3, prev), quadraticAt(y1, y2, y3, prev)];\n    d1 = vec2.squaredDistance(v0, v1);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      v2 = [quadraticAt(x1, x2, x3, next), quadraticAt(y1, y2, y3, next)];\n      d2 = vec2.squaredDistance(v0, v2);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  if (out) {\n    out.x = quadraticAt(x1, x2, x3, t);\n    out.y = quadraticAt(y1, y2, y3, t);\n  }\n\n  return Math.sqrt(d);\n}\n\nfunction quadraticExtrema(p0, p1, p2) {\n  var a = p0 + p2 - 2 * p1;\n\n  if (Util.isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n\n  var rst = (p0 - p1) / a;\n\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n\n  return [];\n}\n\nmodule.exports = {\n  at: quadraticAt,\n  projectPoint: function projectPoint(x1, y1, x2, y2, x3, y3, x, y) {\n    var rst = {};\n    quadraticProjectPoint(x1, y1, x2, y2, x3, y3, x, y, rst);\n    return rst;\n  },\n  pointDistance: quadraticProjectPoint,\n  extrema: quadraticExtrema\n};\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  xAt: function xAt(psi, rx, ry, cx, t) {\n    return rx * Math.cos(psi) * Math.cos(t) - ry * Math.sin(psi) * Math.sin(t) + cx;\n  },\n  yAt: function yAt(psi, rx, ry, cy, t) {\n    return rx * Math.sin(psi) * Math.cos(t) + ry * Math.cos(psi) * Math.sin(t) + cy;\n  },\n  xExtrema: function xExtrema(psi, rx, ry) {\n    return Math.atan(-ry / rx * Math.tan(psi));\n  },\n  yExtrema: function yExtrema(psi, rx, ry) {\n    return Math.atan(ry / (rx * Math.tan(psi)));\n  }\n};\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar ArcMath = __webpack_require__(37);\n\nvar Arrow = __webpack_require__(38);\n\nfunction _getArcX(x, radius, angle) {\n  return x + radius * Math.cos(angle);\n}\n\nfunction _getArcY(y, radius, angle) {\n  return y + radius * Math.sin(angle);\n}\n\nvar Arc = function Arc(cfg) {\n  Arc.superclass.constructor.call(this, cfg);\n};\n\nArc.ATTRS = {\n  x: 0,\n  y: 0,\n  r: 0,\n  startAngle: 0,\n  endAngle: 0,\n  clockwise: false,\n  lineWidth: 1,\n  startArrow: false,\n  endArrow: false\n};\nUtil.extend(Arc, Shape);\nUtil.augment(Arc, {\n  canStroke: true,\n  type: 'arc',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      r: 0,\n      startAngle: 0,\n      endAngle: 0,\n      clockwise: false,\n      lineWidth: 1,\n      startArrow: false,\n      endArrow: false\n    };\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        clockwise = attrs.clockwise;\n    var lineWidth = this.getHitLineWidth();\n    var halfWidth = lineWidth / 2;\n    var box = ArcMath.box(x, y, r, startAngle, endAngle, clockwise);\n    box.minX -= halfWidth;\n    box.minY -= halfWidth;\n    box.maxX += halfWidth;\n    box.maxY += halfWidth;\n    return box;\n  },\n  getStartTangent: function getStartTangent() {\n    var attrs = this._attrs;\n    var x = attrs.x,\n        y = attrs.y,\n        startAngle = attrs.startAngle,\n        r = attrs.r,\n        clockwise = attrs.clockwise;\n    var diff = Math.PI / 180;\n\n    if (clockwise) {\n      diff *= -1;\n    }\n\n    var result = [];\n\n    var x1 = _getArcX(x, r, startAngle + diff);\n\n    var y1 = _getArcY(y, r, startAngle + diff);\n\n    var x2 = _getArcX(x, r, startAngle);\n\n    var y2 = _getArcY(y, r, startAngle);\n\n    result.push([x1, y1]);\n    result.push([x2, y2]);\n    return result;\n  },\n  getEndTangent: function getEndTangent() {\n    var attrs = this._attrs;\n    var x = attrs.x,\n        y = attrs.y,\n        endAngle = attrs.endAngle,\n        r = attrs.r,\n        clockwise = attrs.clockwise;\n    var diff = Math.PI / 180;\n    var result = [];\n\n    if (clockwise) {\n      diff *= -1;\n    }\n\n    var x1 = _getArcX(x, r, endAngle + diff);\n\n    var y1 = _getArcY(y, r, endAngle + diff);\n\n    var x2 = _getArcX(x, r, endAngle);\n\n    var y2 = _getArcY(y, r, endAngle);\n\n    result.push([x2, y2]);\n    result.push([x1, y1]);\n    return result;\n  },\n  createPath: function createPath(context) {\n    var attrs = this._attrs;\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        clockwise = attrs.clockwise;\n    context = context || self.get('context');\n    context.beginPath();\n    context.arc(x, y, r, startAngle, endAngle, clockwise);\n  },\n  afterPath: function afterPath(context) {\n    var attrs = this._attrs;\n    context = context || this.get('context');\n\n    if (attrs.startArrow) {\n      var startPoints = this.getStartTangent();\n      Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);\n    }\n\n    if (attrs.endArrow) {\n      var endPoints = this.getEndTangent();\n      Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);\n    }\n  }\n});\nmodule.exports = Arc;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Circle = function Circle(cfg) {\n  Circle.superclass.constructor.call(this, cfg);\n};\n\nCircle.ATTRS = {\n  x: 0,\n  y: 0,\n  r: 0,\n  lineWidth: 1\n};\nUtil.extend(Circle, Shape);\nUtil.augment(Circle, {\n  canFill: true,\n  canStroke: true,\n  type: 'circle',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1\n    };\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var r = attrs.r;\n    var lineWidth = this.getHitLineWidth();\n    var halfWidth = lineWidth / 2 + r;\n    return {\n      minX: cx - halfWidth,\n      minY: cy - halfWidth,\n      maxX: cx + halfWidth,\n      maxY: cy + halfWidth\n    };\n  },\n  createPath: function createPath(context) {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var r = attrs.r;\n    context.beginPath();\n    context.arc(cx, cy, r, 0, Math.PI * 2, false);\n    context.closePath();\n  }\n});\nmodule.exports = Circle;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Dom = function Dom(cfg) {\n  Dom.superclass.constructor.call(this, cfg);\n};\n\nUtil.extend(Dom, Shape);\nUtil.augment(Dom, {\n  canFill: true,\n  canStroke: true,\n  type: 'dom',\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var lineWidth = this.getHitLineWidth();\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: x - halfWidth,\n      minY: y - halfWidth,\n      maxX: x + width + halfWidth,\n      maxY: y + height + halfWidth\n    };\n  }\n});\nmodule.exports = Dom;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Ellipse = function Ellipse(cfg) {\n  Ellipse.superclass.constructor.call(this, cfg);\n};\n\nEllipse.ATTRS = {\n  x: 0,\n  y: 0,\n  rx: 1,\n  ry: 1,\n  lineWidth: 1\n};\nUtil.extend(Ellipse, Shape);\nUtil.augment(Ellipse, {\n  canFill: true,\n  canStroke: true,\n  type: 'ellipse',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1\n    };\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx;\n    var ry = attrs.ry;\n    var lineWidth = this.getHitLineWidth();\n    var halfXWidth = rx + lineWidth / 2;\n    var halfYWidth = ry + lineWidth / 2;\n    return {\n      minX: cx - halfXWidth,\n      minY: cy - halfYWidth,\n      maxX: cx + halfXWidth,\n      maxY: cy + halfYWidth\n    };\n  },\n  createPath: function createPath(context) {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx;\n    var ry = attrs.ry;\n    context = context || self.get('context');\n    var r = rx > ry ? rx : ry;\n    var scaleX = rx > ry ? 1 : rx / ry;\n    var scaleY = rx > ry ? ry / rx : 1;\n    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    Util.mat3.scale(m, m, [scaleX, scaleY]);\n    Util.mat3.translate(m, m, [cx, cy]);\n    context.beginPath();\n    context.save();\n    context.transform(m[0], m[1], m[3], m[4], m[6], m[7]);\n    context.arc(0, 0, r, 0, Math.PI * 2);\n    context.restore();\n    context.closePath();\n  }\n});\nmodule.exports = Ellipse;\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar ArcMath = __webpack_require__(37);\n\nvar Fan = function Fan(cfg) {\n  Fan.superclass.constructor.call(this, cfg);\n};\n\nFan.ATTRS = {\n  x: 0,\n  y: 0,\n  rs: 0,\n  re: 0,\n  startAngle: 0,\n  endAngle: 0,\n  clockwise: false,\n  lineWidth: 1\n};\nUtil.extend(Fan, Shape);\nUtil.augment(Fan, {\n  canFill: true,\n  canStroke: true,\n  type: 'fan',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      clockwise: false,\n      lineWidth: 1,\n      rs: 0,\n      re: 0\n    };\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rs = attrs.rs;\n    var re = attrs.re;\n    var startAngle = attrs.startAngle;\n    var endAngle = attrs.endAngle;\n    var clockwise = attrs.clockwise;\n    var lineWidth = this.getHitLineWidth();\n    var boxs = ArcMath.box(cx, cy, rs, startAngle, endAngle, clockwise);\n    var boxe = ArcMath.box(cx, cy, re, startAngle, endAngle, clockwise);\n    var minX = Math.min(boxs.minX, boxe.minX);\n    var minY = Math.min(boxs.minY, boxe.minY);\n    var maxX = Math.max(boxs.maxX, boxe.maxX);\n    var maxY = Math.max(boxs.maxY, boxe.maxY);\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: minX - halfWidth,\n      minY: minY - halfWidth,\n      maxX: maxX + halfWidth,\n      maxY: maxY + halfWidth\n    };\n  },\n  createPath: function createPath(context) {\n    var attrs = this._attrs;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rs = attrs.rs;\n    var re = attrs.re;\n    var startAngle = attrs.startAngle;\n    var endAngle = attrs.endAngle;\n    var clockwise = attrs.clockwise;\n    var ssp = {\n      x: Math.cos(startAngle) * rs + cx,\n      y: Math.sin(startAngle) * rs + cy\n    };\n    var sep = {\n      x: Math.cos(startAngle) * re + cx,\n      y: Math.sin(startAngle) * re + cy\n    };\n    var esp = {\n      x: Math.cos(endAngle) * rs + cx,\n      y: Math.sin(endAngle) * rs + cy\n    };\n    context = context || self.get('context');\n    context.beginPath();\n    context.moveTo(ssp.x, ssp.y);\n    context.lineTo(sep.x, sep.y);\n    context.arc(cx, cy, re, startAngle, endAngle, clockwise);\n    context.lineTo(esp.x, esp.y);\n    context.arc(cx, cy, rs, endAngle, startAngle, !clockwise);\n    context.closePath();\n  }\n});\nmodule.exports = Fan;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar CImage = function CImage(cfg) {\n  CImage.superclass.constructor.call(this, cfg);\n};\n\nCImage.ATTRS = {\n  x: 0,\n  y: 0,\n  img: undefined,\n  width: 0,\n  height: 0,\n  sx: null,\n  sy: null,\n  swidth: null,\n  sheight: null\n};\nUtil.extend(CImage, Shape);\nUtil.augment(CImage, {\n  type: 'image',\n  isHitBox: function isHitBox() {\n    return false;\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n\n    if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {\n      this._setAttrImg();\n    }\n\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    return {\n      minX: x,\n      minY: y,\n      maxX: x + width,\n      maxY: y + height\n    };\n  },\n  _beforeSetLoading: function _beforeSetLoading(loading) {\n    var canvas = this.get('canvas');\n\n    if (loading === false && this.get('toDraw') === true) {\n      this._cfg.loading = false;\n      canvas.draw();\n    }\n\n    return loading;\n  },\n  _setAttrImg: function _setAttrImg() {\n    var self = this;\n    var attrs = self._attrs;\n    var img = attrs.img;\n\n    if (Util.isString(img)) {\n      var image = new Image();\n\n      image.onload = function () {\n        if (self.get('destroyed')) return false;\n        self.attr('imgSrc', img);\n        self.attr('img', image);\n        var callback = self.get('callback');\n\n        if (callback) {\n          callback.call(self);\n        }\n\n        self.set('loading', false);\n      };\n\n      image.src = img;\n      image.crossOrigin = 'Anonymous';\n      self.set('loading', true);\n    } else if (img instanceof Image) {\n      if (!attrs.width) {\n        self.attr('width', img.width);\n      }\n\n      if (!attrs.height) {\n        self.attr('height', img.height);\n      }\n\n      return img;\n    } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {\n      if (!attrs.width) {\n        self.attr('width', Number(img.getAttribute('width')));\n      }\n\n      if (!attrs.height) {\n        self.attr('height', Number(img.getAttribute('height')));\n      }\n\n      return img;\n    } else if (img instanceof ImageData) {\n      if (!attrs.width) {\n        self.attr('width', img.width);\n      }\n\n      if (!attrs.height) {\n        self.attr('height', img.height);\n      }\n\n      return img;\n    } else {\n      return null;\n    }\n  },\n  drawInner: function drawInner(context) {\n    if (this._cfg.hasUpdate) {\n      this._setAttrImg();\n    }\n\n    if (this.get('loading')) {\n      this.set('toDraw', true);\n      return;\n    }\n\n    this._drawImage(context);\n\n    this._cfg.hasUpdate = false;\n  },\n  _drawImage: function _drawImage(context) {\n    var attrs = this._attrs;\n    var x = attrs.x;\n    var y = attrs.y;\n    var image = attrs.img;\n    var width = attrs.width;\n    var height = attrs.height;\n    var sx = attrs.sx;\n    var sy = attrs.sy;\n    var swidth = attrs.swidth;\n    var sheight = attrs.sheight;\n    this.set('toDraw', false);\n    var img = image;\n\n    if (img instanceof ImageData) {\n      img = new Image();\n      img.src = image;\n    }\n\n    if (img instanceof Image || img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {\n      if (Util.isNil(sx) || Util.isNil(sy) || Util.isNil(swidth) || Util.isNil(sheight)) {\n        context.drawImage(img, x, y, width, height);\n        return;\n      }\n\n      if (!Util.isNil(sx) && !Util.isNil(sy) && !Util.isNil(swidth) && !Util.isNil(sheight)) {\n        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);\n        return;\n      }\n    }\n\n    return;\n  }\n});\nmodule.exports = CImage;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Arrow = __webpack_require__(38);\n\nvar LineMath = __webpack_require__(36);\n\nvar Line = function Line(cfg) {\n  Line.superclass.constructor.call(this, cfg);\n};\n\nLine.ATTRS = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  lineWidth: 1,\n  startArrow: false,\n  endArrow: false\n};\nUtil.extend(Line, Shape);\nUtil.augment(Line, {\n  canStroke: true,\n  type: 'line',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      startArrow: false,\n      endArrow: false\n    };\n  },\n  calculateBox: function calculateBox() {\n    var attrs = this._attrs;\n    var x1 = attrs.x1,\n        y1 = attrs.y1,\n        x2 = attrs.x2,\n        y2 = attrs.y2;\n    var lineWidth = this.getHitLineWidth();\n    return LineMath.box(x1, y1, x2, y2, lineWidth);\n  },\n  createPath: function createPath(context) {\n    var attrs = this._attrs;\n    var x1 = attrs.x1,\n        y1 = attrs.y1,\n        x2 = attrs.x2,\n        y2 = attrs.y2;\n    context = context || self.get('context');\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n  },\n  afterPath: function afterPath(context) {\n    var attrs = this._attrs;\n    var x1 = attrs.x1,\n        y1 = attrs.y1,\n        x2 = attrs.x2,\n        y2 = attrs.y2;\n    context = context || this.get('context');\n\n    if (attrs.startArrow) {\n      Arrow.addStartArrow(context, attrs, x2, y2, x1, y1);\n    }\n\n    if (attrs.endArrow) {\n      Arrow.addEndArrow(context, attrs, x1, y1, x2, y2);\n    }\n  },\n  getPoint: function getPoint(t) {\n    var attrs = this._attrs;\n    return {\n      x: LineMath.at(attrs.x1, attrs.x2, t),\n      y: LineMath.at(attrs.y1, attrs.y2, t)\n    };\n  }\n});\nmodule.exports = Line;\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar PathSegment = __webpack_require__(39);\n\nvar Format = __webpack_require__(27);\n\nvar Arrow = __webpack_require__(38);\n\nvar PathUtil = __webpack_require__(57);\n\nvar CubicMath = __webpack_require__(55);\n\nvar Path = function Path(cfg) {\n  Path.superclass.constructor.call(this, cfg);\n};\n\nPath.ATTRS = {\n  path: null,\n  lineWidth: 1,\n  startArrow: false,\n  endArrow: false\n};\nUtil.extend(Path, Shape);\nUtil.augment(Path, {\n  canFill: true,\n  canStroke: true,\n  type: 'path',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      startArrow: false,\n      endArrow: false\n    };\n  },\n  _afterSetAttrPath: function _afterSetAttrPath(path) {\n    var self = this;\n\n    if (Util.isNil(path)) {\n      self.setSilent('segments', null);\n      self.setSilent('box', undefined);\n      return;\n    }\n\n    var pathArray = Format.parsePath(path);\n    var preSegment;\n    var segments = [];\n\n    if (!Util.isArray(pathArray) || pathArray.length === 0 || pathArray[0][0] !== 'M' && pathArray[0][0] !== 'm') {\n      return;\n    }\n\n    var count = pathArray.length;\n\n    for (var i = 0; i < pathArray.length; i++) {\n      var item = pathArray[i];\n      preSegment = new PathSegment(item, preSegment, i === count - 1);\n      segments.push(preSegment);\n    }\n\n    self.setSilent('segments', segments);\n    self.setSilent('tCache', null);\n    self.setSilent('box', null);\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var segments = self.get('segments');\n\n    if (!segments) {\n      return null;\n    }\n\n    var lineWidth = this.getHitLineWidth();\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    Util.each(segments, function (segment) {\n      segment.getBBox(lineWidth);\n      var box = segment.box;\n\n      if (box) {\n        if (box.minX < minX) {\n          minX = box.minX;\n        }\n\n        if (box.maxX > maxX) {\n          maxX = box.maxX;\n        }\n\n        if (box.minY < minY) {\n          minY = box.minY;\n        }\n\n        if (box.maxY > maxY) {\n          maxY = box.maxY;\n        }\n      }\n    });\n\n    if (minX === Infinity || minY === Infinity) {\n      return {\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n      };\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  },\n  _setTcache: function _setTcache() {\n    var totalLength = 0;\n    var tempLength = 0;\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    var segmentN;\n    var l;\n    var curve = this._cfg.curve;\n\n    if (!curve) {\n      return;\n    }\n\n    Util.each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        totalLength += CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n      }\n    });\n    Util.each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicMath.len(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n        tempLength += segmentL;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this._cfg.tCache = tCache;\n  },\n  _calculateCurve: function _calculateCurve() {\n    var self = this;\n    var attrs = self._attrs;\n    var path = attrs.path;\n    this._cfg.curve = PathUtil.pathTocurve(path);\n  },\n  getStartTangent: function getStartTangent() {\n    var segments = this.get('segments');\n    var startPoint, endPoint, tangent, result;\n\n    if (segments.length > 1) {\n      startPoint = segments[0].endPoint;\n      endPoint = segments[1].endPoint;\n      tangent = segments[1].startTangent;\n      result = [];\n\n      if (Util.isFunction(tangent)) {\n        var v = tangent();\n        result.push([startPoint.x - v[0], startPoint.y - v[1]]);\n        result.push([startPoint.x, startPoint.y]);\n      } else {\n        result.push([endPoint.x, endPoint.y]);\n        result.push([startPoint.x, startPoint.y]);\n      }\n    }\n\n    return result;\n  },\n  getEndTangent: function getEndTangent() {\n    var segments = this.get('segments');\n    var segmentsLen = segments.length;\n    var startPoint, endPoint, tangent, result;\n\n    if (segmentsLen > 1) {\n      startPoint = segments[segmentsLen - 2].endPoint;\n      endPoint = segments[segmentsLen - 1].endPoint;\n      tangent = segments[segmentsLen - 1].endTangent;\n      result = [];\n\n      if (Util.isFunction(tangent)) {\n        var v = tangent();\n        result.push([endPoint.x - v[0], endPoint.y - v[1]]);\n        result.push([endPoint.x, endPoint.y]);\n      } else {\n        result.push([startPoint.x, startPoint.y]);\n        result.push([endPoint.x, endPoint.y]);\n      }\n    }\n\n    return result;\n  },\n  getPoint: function getPoint(t) {\n    var tCache = this._cfg.tCache;\n    var subt;\n    var index;\n\n    if (!tCache) {\n      this._calculateCurve();\n\n      this._setTcache();\n\n      tCache = this._cfg.tCache;\n    }\n\n    var curve = this._cfg.curve;\n\n    if (!tCache) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2]\n        };\n      }\n\n      return null;\n    }\n\n    Util.each(tCache, function (v, i) {\n      if (t >= v[0] && t <= v[1]) {\n        subt = (t - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    var seg = curve[index];\n\n    if (Util.isNil(seg) || Util.isNil(index)) {\n      return null;\n    }\n\n    var l = seg.length;\n    var nextSeg = curve[index + 1];\n    return {\n      x: CubicMath.at(seg[l - 2], nextSeg[1], nextSeg[3], nextSeg[5], 1 - subt),\n      y: CubicMath.at(seg[l - 1], nextSeg[2], nextSeg[4], nextSeg[6], 1 - subt)\n    };\n  },\n  createPath: function createPath(context) {\n    var self = this;\n    var segments = self.get('segments');\n\n    if (!Util.isArray(segments)) {\n      return;\n    }\n\n    context = context || self.get('context');\n    context.beginPath();\n    var segmentsLen = segments.length;\n\n    for (var i = 0; i < segmentsLen; i++) {\n      segments[i].draw(context);\n    }\n  },\n  afterPath: function afterPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var segments = self.get('segments');\n    var path = attrs.path;\n    context = context || self.get('context');\n\n    if (!Util.isArray(segments)) {\n      return;\n    }\n\n    if (segments.length === 1) {\n      return;\n    }\n\n    if (!attrs.startArrow && !attrs.endArrow) {\n      return;\n    }\n\n    if (path[path.length - 1] === 'z' || path[path.length - 1] === 'Z' || attrs.fill) {\n      // 闭合路径不绘制箭头\n      return;\n    }\n\n    var startPoints = self.getStartTangent();\n    Arrow.addStartArrow(context, attrs, startPoints[0][0], startPoints[0][1], startPoints[1][0], startPoints[1][1]);\n    var endPoints = self.getEndTangent();\n    Arrow.addEndArrow(context, attrs, endPoints[0][0], endPoints[0][1], endPoints[1][0], endPoints[1][1]);\n  }\n});\nmodule.exports = Path;\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Polygon = function Polygon(cfg) {\n  Polygon.superclass.constructor.call(this, cfg);\n};\n\nPolygon.ATTRS = {\n  points: null,\n  lineWidth: 1\n};\nUtil.extend(Polygon, Shape);\nUtil.augment(Polygon, {\n  canFill: true,\n  canStroke: true,\n  type: 'polygon',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1\n    };\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var points = attrs.points;\n    var lineWidth = this.getHitLineWidth();\n\n    if (!points || points.length === 0) {\n      return null;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n    Util.each(points, function (point) {\n      var x = point[0];\n      var y = point[1];\n\n      if (x < minX) {\n        minX = x;\n      }\n\n      if (x > maxX) {\n        maxX = x;\n      }\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n    });\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: minX - halfWidth,\n      minY: minY - halfWidth,\n      maxX: maxX + halfWidth,\n      maxY: maxY + halfWidth\n    };\n  },\n  createPath: function createPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var points = attrs.points;\n\n    if (points.length < 2) {\n      return;\n    }\n\n    context = context || self.get('context');\n    context.beginPath();\n    Util.each(points, function (point, index) {\n      if (index === 0) {\n        context.moveTo(point[0], point[1]);\n      } else {\n        context.lineTo(point[0], point[1]);\n      }\n    });\n    context.closePath();\n  }\n});\nmodule.exports = Polygon;\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar Arrow = __webpack_require__(38);\n\nvar LineMath = __webpack_require__(36);\n\nvar Polyline = function Polyline(cfg) {\n  Polyline.superclass.constructor.call(this, cfg);\n};\n\nPolyline.ATTRS = {\n  points: null,\n  lineWidth: 1,\n  startArrow: false,\n  endArrow: false,\n  tCache: null\n};\nUtil.extend(Polyline, Shape);\nUtil.augment(Polyline, {\n  canStroke: true,\n  type: 'polyline',\n  tCache: null,\n  // 缓存各点的t\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      startArrow: false,\n      endArrow: false\n    };\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var lineWidth = this.getHitLineWidth();\n    var points = attrs.points;\n\n    if (!points || points.length === 0) {\n      return null;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n    Util.each(points, function (point) {\n      var x = point[0];\n      var y = point[1];\n\n      if (x < minX) {\n        minX = x;\n      }\n\n      if (x > maxX) {\n        maxX = x;\n      }\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n    });\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: minX - halfWidth,\n      minY: minY - halfWidth,\n      maxX: maxX + halfWidth,\n      maxY: maxY + halfWidth\n    };\n  },\n  _setTcache: function _setTcache() {\n    var self = this;\n    var attrs = self._attrs;\n    var points = attrs.points;\n    var totalLength = 0;\n    var tempLength = 0;\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n\n    if (!points || points.length === 0) {\n      return;\n    }\n\n    Util.each(points, function (p, i) {\n      if (points[i + 1]) {\n        totalLength += LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n      }\n    });\n\n    if (totalLength <= 0) {\n      return;\n    }\n\n    Util.each(points, function (p, i) {\n      if (points[i + 1]) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = LineMath.len(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n        tempLength += segmentL;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.tCache = tCache;\n  },\n  createPath: function createPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var points = attrs.points;\n    var l;\n    var i;\n\n    if (points.length < 2) {\n      return;\n    }\n\n    context = context || self.get('context');\n    context.beginPath();\n    context.moveTo(points[0][0], points[0][1]);\n\n    for (i = 1, l = points.length - 1; i < l; i++) {\n      context.lineTo(points[i][0], points[i][1]);\n    }\n\n    context.lineTo(points[l][0], points[l][1]);\n  },\n  getStartTangent: function getStartTangent() {\n    var points = this.__attrs.points;\n    var result = [];\n    result.push([points[1][0], points[1][1]]);\n    result.push([points[0][0], points[0][1]]);\n    return result;\n  },\n  getEndTangent: function getEndTangent() {\n    var points = this.__attrs.points;\n    var l = points.length - 1;\n    var result = [];\n    result.push([points[l - 1][0], points[l - 1][1]]);\n    result.push([points[l][0], points[l][1]]);\n    return result;\n  },\n  afterPath: function afterPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var points = attrs.points;\n    var l = points.length - 1;\n    context = context || self.get('context');\n\n    if (attrs.startArrow) {\n      Arrow.addStartArrow(context, attrs, points[1][0], points[1][1], points[0][0], points[0][1]);\n    }\n\n    if (attrs.endArrow) {\n      Arrow.addEndArrow(context, attrs, points[l - 1][0], points[l - 1][1], points[l][0], points[l][1]);\n    }\n  },\n  getPoint: function getPoint(t) {\n    var attrs = this._attrs;\n    var points = attrs.points;\n    var tCache = this.tCache;\n    var subt;\n    var index;\n\n    if (!tCache) {\n      this._setTcache();\n\n      tCache = this.tCache;\n    }\n\n    Util.each(tCache, function (v, i) {\n      if (t >= v[0] && t <= v[1]) {\n        subt = (t - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    return {\n      x: LineMath.at(points[index][0], points[index + 1][0], subt),\n      y: LineMath.at(points[index][1], points[index + 1][1], subt)\n    };\n  }\n});\nmodule.exports = Polyline;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar _require = __webpack_require__(27),\n    parseRadius = _require.parseRadius;\n\nvar Shape = __webpack_require__(6);\n\nvar Rect = function Rect(cfg) {\n  Rect.superclass.constructor.call(this, cfg);\n};\n\nRect.ATTRS = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  radius: 0,\n  lineWidth: 1\n};\nUtil.extend(Rect, Shape);\nUtil.augment(Rect, {\n  canFill: true,\n  canStroke: true,\n  type: 'rect',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      radius: 0\n    };\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var lineWidth = this.getHitLineWidth();\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: x - halfWidth,\n      minY: y - halfWidth,\n      maxX: x + width + halfWidth,\n      maxY: y + height + halfWidth\n    };\n  },\n  createPath: function createPath(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var radius = attrs.radius;\n    context = context || self.get('context');\n    context.beginPath();\n\n    if (radius === 0) {\n      // 改成原生的rect方法\n      context.rect(x, y, width, height);\n    } else {\n      var r = parseRadius(radius);\n      context.moveTo(x + r.r1, y);\n      context.lineTo(x + width - r.r2, y);\n      r.r2 !== 0 && context.arc(x + width - r.r2, y + r.r2, r.r2, -Math.PI / 2, 0);\n      context.lineTo(x + width, y + height - r.r3);\n      r.r3 !== 0 && context.arc(x + width - r.r3, y + height - r.r3, r.r3, 0, Math.PI / 2);\n      context.lineTo(x + r.r4, y + height);\n      r.r4 !== 0 && context.arc(x + r.r4, y + height - r.r4, r.r4, Math.PI / 2, Math.PI);\n      context.lineTo(x, y + r.r1);\n      r.r1 !== 0 && context.arc(x + r.r1, y + r.r1, r.r1, Math.PI, Math.PI * 1.5);\n      context.closePath();\n    }\n  }\n});\nmodule.exports = Rect;\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Shape = __webpack_require__(6);\n\nvar CText = function CText(cfg) {\n  CText.superclass.constructor.call(this, cfg);\n};\n\nCText.ATTRS = {\n  x: 0,\n  y: 0,\n  text: null,\n  fontSize: 12,\n  fontFamily: 'sans-serif',\n  fontStyle: 'normal',\n  fontWeight: 'normal',\n  fontVariant: 'normal',\n  textAlign: 'start',\n  textBaseline: 'bottom',\n  lineHeight: null,\n  textArr: null\n};\nUtil.extend(CText, Shape);\nUtil.augment(CText, {\n  canFill: true,\n  canStroke: true,\n  type: 'text',\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {\n      lineWidth: 1,\n      lineCount: 1,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom'\n    };\n  },\n  initTransform: function initTransform() {\n    var fontSize = this._attrs.fontSize;\n\n    if (fontSize && +fontSize < 12) {\n      // 小于 12 像素的文本进行 scale 处理\n      this.transform([['t', -1 * this._attrs.x, -1 * this._attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', this._attrs.x, this._attrs.y]]);\n    }\n  },\n  _assembleFont: function _assembleFont() {\n    // var self = this;\n    var attrs = this._attrs;\n    var fontSize = attrs.fontSize;\n    var fontFamily = attrs.fontFamily;\n    var fontWeight = attrs.fontWeight;\n    var fontStyle = attrs.fontStyle; // self.attr('fontStyle');\n\n    var fontVariant = attrs.fontVariant; // self.attr('fontVariant');\n    // self.attr('font', [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' '));\n\n    attrs.font = [fontStyle, fontVariant, fontWeight, fontSize + 'px', fontFamily].join(' ');\n  },\n  _setAttrText: function _setAttrText() {\n    var attrs = this._attrs;\n    var text = attrs.text;\n    var textArr = null;\n\n    if (Util.isString(text) && text.indexOf('\\n') !== -1) {\n      textArr = text.split('\\n');\n      var lineCount = textArr.length;\n      attrs.lineCount = lineCount;\n    }\n\n    attrs.textArr = textArr;\n  },\n  _getTextHeight: function _getTextHeight() {\n    var attrs = this._attrs;\n    var lineCount = attrs.lineCount;\n    var fontSize = attrs.fontSize * 1;\n\n    if (lineCount > 1) {\n      var spaceingY = this._getSpaceingY();\n\n      return fontSize * lineCount + spaceingY * (lineCount - 1);\n    }\n\n    return fontSize;\n  },\n  isHitBox: function isHitBox() {\n    return false;\n  },\n  calculateBox: function calculateBox() {\n    var self = this;\n    var attrs = self._attrs;\n    var cfg = this._cfg;\n\n    if (!cfg.attrs || cfg.hasUpdate) {\n      this._assembleFont();\n\n      this._setAttrText();\n    }\n\n    if (!attrs.textArr) {\n      this._setAttrText();\n    }\n\n    var x = attrs.x;\n    var y = attrs.y;\n    var width = self.measureText(); // attrs.width\n\n    if (!width) {\n      // 如果width不存在，四点共其实点\n      return {\n        minX: x,\n        minY: y,\n        maxX: x,\n        maxY: y\n      };\n    }\n\n    var height = self._getTextHeight(); // attrs.height\n\n\n    var textAlign = attrs.textAlign;\n    var textBaseline = attrs.textBaseline;\n    var lineWidth = self.getHitLineWidth();\n    var point = {\n      x: x,\n      y: y - height\n    };\n\n    if (textAlign) {\n      if (textAlign === 'end' || textAlign === 'right') {\n        point.x -= width;\n      } else if (textAlign === 'center') {\n        point.x -= width / 2;\n      }\n    }\n\n    if (textBaseline) {\n      if (textBaseline === 'top') {\n        point.y += height;\n      } else if (textBaseline === 'middle') {\n        point.y += height / 2;\n      }\n    }\n\n    this.set('startPoint', point);\n    var halfWidth = lineWidth / 2;\n    return {\n      minX: point.x - halfWidth,\n      minY: point.y - halfWidth,\n      maxX: point.x + width + halfWidth,\n      maxY: point.y + height + halfWidth\n    };\n  },\n  _getSpaceingY: function _getSpaceingY() {\n    var attrs = this._attrs;\n    var lineHeight = attrs.lineHeight;\n    var fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  },\n  drawInner: function drawInner(context) {\n    var self = this;\n    var attrs = self._attrs;\n    var cfg = this._cfg;\n\n    if (!cfg.attrs || cfg.hasUpdate) {\n      this._assembleFont();\n\n      this._setAttrText();\n    }\n\n    context.font = attrs.font;\n    var text = attrs.text;\n\n    if (!text) {\n      return;\n    }\n\n    var textArr = attrs.textArr;\n    var x = attrs.x;\n    var y = attrs.y;\n    context.beginPath();\n\n    if (self.hasStroke()) {\n      var strokeOpacity = attrs.strokeOpacity;\n\n      if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n        context.globalAlpha = strokeOpacity;\n      }\n\n      if (textArr) {\n        self._drawTextArr(context, false);\n      } else {\n        context.strokeText(text, x, y);\n      }\n\n      context.globalAlpha = 1;\n    }\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n      }\n\n      if (textArr) {\n        self._drawTextArr(context, true);\n      } else {\n        context.fillText(text, x, y);\n      }\n    }\n\n    cfg.hasUpdate = false;\n  },\n  _drawTextArr: function _drawTextArr(context, fill) {\n    var textArr = this._attrs.textArr;\n    var textBaseline = this._attrs.textBaseline;\n    var fontSize = this._attrs.fontSize * 1;\n\n    var spaceingY = this._getSpaceingY();\n\n    var x = this._attrs.x;\n    var y = this._attrs.y;\n    var box = this.getBBox();\n    var height = box.maxY - box.minY;\n    var subY;\n    Util.each(textArr, function (subText, index) {\n      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;\n      if (textBaseline === 'top') subY += height - fontSize;\n\n      if (fill) {\n        context.fillText(subText, x, subY);\n      } else {\n        context.strokeText(subText, x, subY);\n      }\n    });\n  },\n  measureText: function measureText() {\n    var self = this;\n    var attrs = self._attrs;\n    var text = attrs.text;\n    var font = attrs.font;\n    var textArr = attrs.textArr;\n    var measureWidth;\n    var width = 0;\n    if (Util.isNil(text)) return undefined;\n    var context = document.createElement('canvas').getContext('2d');\n    context.save();\n    context.font = font;\n\n    if (textArr) {\n      Util.each(textArr, function (subText) {\n        measureWidth = context.measureText(subText).width;\n\n        if (width < measureWidth) {\n          width = measureWidth;\n        }\n\n        context.restore();\n      });\n    } else {\n      width = context.measureText(text).width;\n      context.restore();\n    }\n\n    return width;\n  }\n});\nmodule.exports = CText;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_value__ = __webpack_require__(59);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolate\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_value__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_array__ = __webpack_require__(122);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateArray\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_array__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_basis__ = __webpack_require__(62);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateBasis\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_basis__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__ = __webpack_require__(120);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateBasisClosed\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_basisClosed__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_date__ = __webpack_require__(123);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateDate\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_date__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_number__ = __webpack_require__(40);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateNumber\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_number__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_object__ = __webpack_require__(124);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateObject\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_object__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_round__ = __webpack_require__(205);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateRound\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_round__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_string__ = __webpack_require__(125);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateString\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_string__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_transform_index__ = __webpack_require__(206);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateTransformCss\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateTransformSvg\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_transform_index__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_zoom__ = __webpack_require__(209);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateZoom\", function() { return __WEBPACK_IMPORTED_MODULE_10__src_zoom__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_rgb__ = __webpack_require__(119);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateRgb\", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateRgbBasis\", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateRgbBasisClosed\", function() { return __WEBPACK_IMPORTED_MODULE_11__src_rgb__[\"c\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_hsl__ = __webpack_require__(210);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateHsl\", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateHslLong\", function() { return __WEBPACK_IMPORTED_MODULE_12__src_hsl__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_lab__ = __webpack_require__(211);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateLab\", function() { return __WEBPACK_IMPORTED_MODULE_13__src_lab__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_hcl__ = __webpack_require__(212);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateHcl\", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateHclLong\", function() { return __WEBPACK_IMPORTED_MODULE_14__src_hcl__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__ = __webpack_require__(213);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateCubehelix\", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolateCubehelixLong\", function() { return __WEBPACK_IMPORTED_MODULE_15__src_cubehelix__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_quantize__ = __webpack_require__(214);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"quantize\", function() { return __WEBPACK_IMPORTED_MODULE_16__src_quantize__[\"a\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return deg2rad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return rad2deg; });\nvar deg2rad = Math.PI / 180;\nvar rad2deg = 180 / Math.PI;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return rgbBasis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return rgbBasisClosed; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basis__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basisClosed__ = __webpack_require__(120);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color__ = __webpack_require__(28);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ((function rgbGamma(y) {\n  var color = Object(__WEBPACK_IMPORTED_MODULE_3__color__[\"b\" /* gamma */])(y);\n\n  function rgb(start, end) {\n    var r = color((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"f\" /* rgb */])(start)).r, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"f\" /* rgb */])(end)).r),\n        g = color(start.g, end.g),\n        b = color(start.b, end.b),\n        opacity = Object(__WEBPACK_IMPORTED_MODULE_3__color__[\"a\" /* default */])(start.opacity, end.opacity);\n    return function (t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb.gamma = rgbGamma;\n  return rgb;\n})(1));\n\nfunction rgbSpline(spline) {\n  return function (colors) {\n    var n = colors.length,\n        r = new Array(n),\n        g = new Array(n),\n        b = new Array(n),\n        i,\n        color;\n\n    for (i = 0; i < n; ++i) {\n      color = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"f\" /* rgb */])(colors[i]);\n      r[i] = color.r || 0;\n      g[i] = color.g || 0;\n      b[i] = color.b || 0;\n    }\n\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color.opacity = 1;\n    return function (t) {\n      color.r = r(t);\n      color.g = g(t);\n      color.b = b(t);\n      return color + \"\";\n    };\n  };\n}\n\nvar rgbBasis = rgbSpline(__WEBPACK_IMPORTED_MODULE_1__basis__[\"b\" /* default */]);\nvar rgbBasisClosed = rgbSpline(__WEBPACK_IMPORTED_MODULE_2__basisClosed__[\"a\" /* default */]);\n\n/***/ }),\n/* 120 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basis__ = __webpack_require__(62);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (values) {\n  var n = values.length;\n  return function (t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n        v0 = values[(i + n - 1) % n],\n        v1 = values[i % n],\n        v2 = values[(i + 1) % n],\n        v3 = values[(i + 2) % n];\n    return Object(__WEBPACK_IMPORTED_MODULE_0__basis__[\"a\" /* basis */])((t - i / n) * n, v0, v1, v2, v3);\n  };\n});\n\n/***/ }),\n/* 121 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (x) {\n  return function () {\n    return x;\n  };\n});\n\n/***/ }),\n/* 122 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(59);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(na),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = Object(__WEBPACK_IMPORTED_MODULE_0__value__[\"a\" /* default */])(a[i], b[i]);\n\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function (t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n\n    return c;\n  };\n});\n\n/***/ }),\n/* 123 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var d = new Date();\n  return a = +a, b -= a, function (t) {\n    return d.setTime(a + b * t), d;\n  };\n});\n\n/***/ }),\n/* 124 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__value__ = __webpack_require__(59);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var i = {},\n      c = {},\n      k;\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = Object(__WEBPACK_IMPORTED_MODULE_0__value__[\"a\" /* default */])(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function (t) {\n    for (k in i) c[k] = i[k](t);\n\n    return c;\n  };\n});\n\n/***/ }),\n/* 125 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(40);\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n    reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function () {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function (t) {\n    return b(t) + \"\";\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0,\n      // scan index for next number in b\n  am,\n      // current match in a\n  bm,\n      // current match in b\n  bs,\n      // string preceding current number in b, if any\n  i = -1,\n      // index in s\n  s = [],\n      // string constants and placeholders\n  q = []; // number interpolators\n  // Coerce inputs to strings.\n\n  a = a + \"\", b = b + \"\"; // Interpolate pairs of numbers in a & b.\n\n  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) {\n      // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n\n    if ((am = am[0]) === (bm = bm[0])) {\n      // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else {\n      // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({\n        i: i,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(am, bm)\n      });\n    }\n\n    bi = reB.lastIndex;\n  } // Add remains of b.\n\n\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  } // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n\n\n  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {\n    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n\n    return s.join(\"\");\n  });\n});\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Default animation configuration for geoms\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar Action = __webpack_require__(290);\n\nvar defaultAnimationCfg = {\n  appear: {\n    duration: 450,\n    easing: 'easeQuadOut'\n  },\n  // 初始入场动画配置\n  update: {\n    duration: 450,\n    easing: 'easeQuadInOut'\n  },\n  // 更新时发生变更的动画配置\n  enter: {\n    duration: 400,\n    easing: 'easeQuadInOut',\n    delay: 100\n  },\n  // 更新时新增元素的入场动画配置\n  leave: {\n    duration: 350,\n    easing: 'easeQuadIn' // 更新时销毁动画配置\n\n  }\n};\nvar Animate = {\n  line: {\n    appear: function appear() {\n      return Action.appear.clipIn;\n    },\n    enter: function enter() {\n      return Action.enter.clipIn;\n    },\n    leave: function leave() {\n      return Action.leave.lineWidthOut;\n    }\n  },\n  path: {\n    appear: function appear() {\n      return Action.appear.clipIn;\n    },\n    enter: function enter() {\n      return Action.enter.clipIn;\n    },\n    leave: function leave() {\n      return Action.leave.lineWidthOut;\n    }\n  },\n  area: {\n    appear: function appear() {\n      return Action.appear.clipIn;\n    },\n    enter: function enter() {\n      return Action.enter.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    cfg: {\n      appear: {\n        duration: 500,\n        easing: 'easeQuadOut'\n      },\n      update: {\n        duration: 450,\n        easing: 'easeQuadInOut'\n      },\n      enter: {\n        duration: 600,\n        delay: 150,\n        easing: 'easeQuadInOut'\n      },\n      leave: {\n        easing: 'easeQuadOut',\n        duration: 350\n      }\n    }\n  },\n  polygon: {\n    appear: function appear() {\n      return Action.appear.zoomIn;\n    },\n    enter: function enter() {\n      return Action.enter.zoomIn;\n    },\n    leave: function leave() {\n      return Action.leave.zoomOut;\n    }\n  },\n  edge: {\n    appear: function appear() {\n      return Action.appear.pathIn;\n    },\n    enter: function enter() {\n      return Action.enter.pathIn;\n    },\n    leave: function leave() {\n      return Action.leave.pathOut;\n    }\n  },\n  interval: {\n    appear: function appear(coord) {\n      var result;\n\n      if (coord.isPolar) {\n        result = Action.appear.zoomIn;\n\n        if (coord.isTransposed || coord.type === 'theta') {\n          result = Action.appear.fanIn;\n        }\n      } else if (coord.isRect) {\n        result = coord.isTransposed ? Action.appear.scaleInX : Action.appear.scaleInY;\n      } else {\n        result = Action.appear.zoomIn;\n      }\n\n      return result;\n    },\n    enter: function enter(coord) {\n      if (coord.isRect || coord.isTransposed || coord.type === 'theta') {\n        return Action.enter.fadeIn;\n      }\n\n      return Action.enter.zoomIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    update: function update(coord) {\n      if (coord.type === 'theta') {\n        return Action.update.fanIn;\n      }\n    }\n  },\n  point: {\n    appear: function appear() {\n      return Action.appear.zoomIn;\n    },\n    enter: function enter() {\n      return Action.enter.zoomIn;\n    },\n    leave: function leave() {\n      return Action.leave.zoomOut;\n    }\n  },\n  schema: {\n    appear: function appear() {\n      return Action.appear.clipIn;\n    },\n    enter: function enter() {\n      return Action.enter.clipIn;\n    },\n    leave: function leave() {\n      return Action.leave.lineWidthOut;\n    }\n  },\n  contour: null,\n  heatmap: null,\n  label: {\n    appear: function appear() {\n      return Action.appear.fadeIn;\n    },\n    enter: function enter() {\n      return Action.enter.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    cfg: {\n      appear: {\n        duration: 900\n      }\n    }\n  },\n  'axis-label': {\n    enter: function enter() {\n      return Action.appear.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    update: function update(coord) {\n      if (coord.isPolar) {\n        return Action.appear.fadeIn;\n      }\n    }\n  },\n  'axis-ticks': {\n    enter: function enter() {\n      return Action.appear.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    update: function update(coord) {\n      if (coord.isPolar) {\n        return Action.appear.fadeIn;\n      }\n    }\n  },\n  'axis-grid': {\n    enter: function enter() {\n      return Action.appear.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    update: function update(coord) {\n      if (coord.isPolar) {\n        return Action.appear.fadeIn;\n      }\n    }\n  },\n  'axis-grid-rect': {\n    enter: function enter() {\n      return Action.appear.fadeIn;\n    },\n    leave: function leave() {\n      return Action.leave.fadeOut;\n    },\n    update: function update() {\n      return Action.leave.fadeIn;\n    }\n  },\n  labelLine: {\n    appear: function appear() {\n      return Action.appear.pathIn;\n    },\n    enter: function enter() {\n      return Action.enter.pathIn;\n    },\n    leave: function leave() {\n      return Action.leave.pathOut;\n    }\n  }\n};\nAnimate.Action = Action;\nAnimate.defaultCfg = defaultAnimationCfg; // 获取动画\n\nAnimate.getAnimation = function (geomType, coord, animationType) {\n  var geomAnimateCfg = this[geomType];\n\n  if (geomAnimateCfg) {\n    var animation = geomAnimateCfg[animationType];\n\n    if (Util.isFunction(animation)) {\n      return animation(coord);\n    }\n  }\n\n  return false;\n}; // 获取动画配置\n\n\nAnimate.getAnimateCfg = function (geomType, animationType) {\n  var defaultCfg = defaultAnimationCfg[animationType];\n\n  if (this[geomType] && this[geomType].cfg && this[geomType].cfg[animationType]) {\n    return Util.deepMix({}, defaultCfg, this[geomType].cfg[animationType]);\n  }\n\n  return defaultCfg;\n}; // 注册动画\n\n\nAnimate.registerAnimation = function (animationType, animationName, animationFun) {\n  if (!this.Action[animationType]) {\n    this.Action[animationType] = {};\n  }\n\n  this.Action[animationType][animationName] = animationFun;\n};\n\nmodule.exports = Animate;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar mix = __webpack_require__(8); // collections\n\n\nvar DOMUtil = __webpack_require__(228);\n\nvar arrayUtil = __webpack_require__(237);\n\nvar eventUtil = __webpack_require__(248);\n\nvar formatUtil = __webpack_require__(251);\n\nvar mathUtil = __webpack_require__(255);\n\nvar matrixUtil = __webpack_require__(43);\n\nvar objectUtil = __webpack_require__(264);\n\nvar pathUtil = __webpack_require__(268);\n\nvar stringUtil = __webpack_require__(274);\n\nvar typeUtil = __webpack_require__(278);\n\nvar util = {\n  // collections\n  DOMUtil: DOMUtil,\n  DomUtil: DOMUtil,\n  MatrixUtil: matrixUtil,\n  PathUtil: pathUtil,\n  arrayUtil: arrayUtil,\n  domUtil: DOMUtil,\n  eventUtil: eventUtil,\n  formatUtil: formatUtil,\n  mathUtil: mathUtil,\n  matrixUtil: matrixUtil,\n  objectUtil: objectUtil,\n  stringUtil: stringUtil,\n  pathUtil: pathUtil,\n  typeUtil: typeUtil,\n  // others\n  augment: __webpack_require__(89),\n  clone: __webpack_require__(46),\n  debounce: __webpack_require__(284),\n  deepMix: __webpack_require__(47),\n  each: each,\n  extend: __webpack_require__(88),\n  filter: __webpack_require__(63),\n  group: __webpack_require__(144),\n  groupBy: __webpack_require__(146),\n  groupToMap: __webpack_require__(145),\n  indexOf: __webpack_require__(285),\n  isEmpty: __webpack_require__(83),\n  isEqual: __webpack_require__(49),\n  isEqualWith: __webpack_require__(286),\n  map: __webpack_require__(287),\n  mix: mix,\n  pick: __webpack_require__(288),\n  throttle: __webpack_require__(289),\n  toArray: __webpack_require__(34),\n  toString: __webpack_require__(23),\n  uniqueId: __webpack_require__(86)\n};\neach([DOMUtil, arrayUtil, eventUtil, formatUtil, mathUtil, matrixUtil, objectUtil, pathUtil, stringUtil, typeUtil], function (collection) {\n  mix(util, collection);\n});\nmodule.exports = util;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar keys = __webpack_require__(129);\n\nvar isNil = __webpack_require__(5);\n\nfunction isMatch(obj, attrs) {\n  var _keys = keys(attrs);\n\n  var length = _keys.length;\n  if (isNil(obj)) return !length;\n\n  for (var i = 0; i < length; i += 1) {\n    var key = _keys[i];\n\n    if (attrs[key] !== obj[key] || !(key in obj)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isMatch;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isFunction = __webpack_require__(11);\n\nvar keys = Object.keys ? function (obj) {\n  return Object.keys(obj);\n} : function (obj) {\n  var result = [];\n  each(obj, function (value, key) {\n    if (!(isFunction(obj) && key === 'prototype')) {\n      result.push(key);\n    }\n  });\n  return result;\n};\nmodule.exports = keys;\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(13);\n\nvar splice = Array.prototype.splice;\n\nvar pullAt = function pullAt(arr, indexes) {\n  if (!isArrayLike(arr)) {\n    return [];\n  }\n\n  var length = arr ? indexes.length : 0;\n  var last = length - 1;\n\n  while (length--) {\n    var previous = void 0;\n    var index = indexes[length];\n\n    if (length === last || index !== previous) {\n      previous = index;\n      splice.call(arr, index, 1);\n    }\n  }\n\n  return arr;\n};\n\nmodule.exports = pullAt;\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar contains = __webpack_require__(41);\n\nvar uniq = function uniq(arr) {\n  var resultArr = [];\n  each(arr, function (item) {\n    if (!contains(resultArr, item)) {\n      resultArr.push(item);\n    }\n  });\n  return resultArr;\n};\n\nmodule.exports = uniq;\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar isFunction = __webpack_require__(11);\n\nvar each = __webpack_require__(2);\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the maximum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * maxBy(objects, function(o) { return o.n; });\n * // => { 'n': 2 }\n *\n * maxBy(objects, 'n');\n * // => { 'n': 2 }\n */\n\n\nvar maxBy = function maxBy(arr, fn) {\n  if (!isArray(arr)) {\n    return undefined;\n  }\n\n  var max = arr[0];\n  var maxData = void 0;\n\n  if (isFunction(fn)) {\n    maxData = fn(arr[0]);\n  } else {\n    maxData = arr[0][fn];\n  }\n\n  var data = void 0;\n  each(arr, function (val) {\n    if (isFunction(fn)) {\n      data = fn(val);\n    } else {\n      data = val[fn];\n    }\n\n    if (data > maxData) {\n      max = val;\n      maxData = data;\n    }\n  });\n  return max;\n};\n\nmodule.exports = maxBy;\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports) {\n\nmodule.exports = parseInt;\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (obj, key) {\n  return obj.hasOwnProperty(key);\n};\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isFunction = __webpack_require__(11);\n\nvar values = Object.values ? function (obj) {\n  return Object.values(obj);\n} : function (obj) {\n  var result = [];\n  each(obj, function (value, key) {\n    if (!(isFunction(obj) && key === 'prototype')) {\n      result.push(value);\n    }\n  });\n  return result;\n};\nmodule.exports = values;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parsePathArray = __webpack_require__(137);\n\nmodule.exports = function rectPath(x, y, w, h, r) {\n  if (r) {\n    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];\n  }\n\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\n  res.parsePathArray = parsePathArray;\n  return res;\n};\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports) {\n\nvar p2s = /,?([a-z]),?/gi;\n\nmodule.exports = function parsePathArray(path) {\n  return path.join(',').replace(p2s, '$1');\n};\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pathToAbsolute = __webpack_require__(139);\n\nvar a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  if (rx === ry) {\n    rx += 1;\n  }\n\n  var _120 = Math.PI * 120 / 180;\n\n  var rad = Math.PI / 180 * (+angle || 0);\n  var res = [];\n  var xy = void 0;\n  var f1 = void 0;\n  var f2 = void 0;\n  var cx = void 0;\n  var cy = void 0;\n\n  var rotate = function rotate(x, y, rad) {\n    var X = x * Math.cos(rad) - y * Math.sin(rad);\n    var Y = x * Math.sin(rad) + y * Math.cos(rad);\n    return {\n      x: X,\n      y: Y\n    };\n  };\n\n  if (!recursive) {\n    xy = rotate(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotate(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    if (x1 === x2 && y1 === y2) {\n      // 若弧的起始点和终点重叠则错开一点\n      x2 += 1;\n      y2 += 1;\n    } // const cos = Math.cos(Math.PI / 180 * angle);\n    // const sin = Math.sin(Math.PI / 180 * angle);\n\n\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    cx = k * rx * y / ry + (x1 + x2) / 2;\n    cy = k * -ry * x / rx + (y1 + y2) / 2;\n    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));\n    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1);\n  var s1 = Math.sin(f1);\n  var c2 = Math.cos(f2);\n  var s2 = Math.sin(f2);\n  var t = Math.tan(df / 4);\n  var hx = 4 / 3 * rx * t;\n  var hy = 4 / 3 * ry * t;\n  var m1 = [x1, y1];\n  var m2 = [x1 + hx * s1, y1 - hy * c1];\n  var m3 = [x2 + hx * s2, y2 - hy * c2];\n  var m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n\n  if (recursive) {\n    return [m2, m3, m4].concat(res);\n  }\n\n  res = [m2, m3, m4].concat(res).join().split(',');\n  var newres = [];\n\n  for (var i = 0, ii = res.length; i < ii; i++) {\n    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n  }\n\n  return newres;\n};\n\nvar l2c = function l2c(x1, y1, x2, y2) {\n  return [x1, y1, x2, y2, x2, y2];\n};\n\nvar q2c = function q2c(x1, y1, ax, ay, x2, y2) {\n  var _13 = 1 / 3;\n\n  var _23 = 2 / 3;\n\n  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n};\n\nmodule.exports = function pathTocurve(path, path2) {\n  var p = pathToAbsolute(path);\n  var p2 = path2 && pathToAbsolute(path2);\n  var attrs = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var attrs2 = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var pcoms1 = []; // path commands of original path p\n\n  var pcoms2 = []; // path commands of original path p2\n\n  var pfirst = ''; // temporary holder for original path command\n\n  var pcom = ''; // holder for previous path command of original path\n\n  var ii = void 0;\n\n  var processPath = function processPath(path, d, pcom) {\n    var nx = void 0,\n        ny = void 0;\n\n    if (!path) {\n      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n    }\n\n    !(path[0] in {\n      T: 1,\n      Q: 1\n    }) && (d.qx = d.qy = null);\n\n    switch (path[0]) {\n      case 'M':\n        d.X = path[1];\n        d.Y = path[2];\n        break;\n\n      case 'A':\n        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n        break;\n\n      case 'S':\n        if (pcom === 'C' || pcom === 'S') {\n          // In \"S\" case we have to take into account, if the previous command is C/S.\n          nx = d.x * 2 - d.bx; // And reflect the previous\n\n          ny = d.y * 2 - d.by; // command's control point relative to the current point.\n        } else {\n          // or some else or nothing\n          nx = d.x;\n          ny = d.y;\n        }\n\n        path = ['C', nx, ny].concat(path.slice(1));\n        break;\n\n      case 'T':\n        if (pcom === 'Q' || pcom === 'T') {\n          // In \"T\" case we have to take into account, if the previous command is Q/T.\n          d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n          d.qy = d.y * 2 - d.qy; // to case \"S\".\n        } else {\n          // or something else or nothing\n          d.qx = d.x;\n          d.qy = d.y;\n        }\n\n        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n        break;\n\n      case 'Q':\n        d.qx = path[1];\n        d.qy = path[2];\n        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n        break;\n\n      case 'L':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\n        break;\n\n      case 'H':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\n        break;\n\n      case 'V':\n        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\n        break;\n\n      case 'Z':\n        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\n        break;\n\n      default:\n        break;\n    }\n\n    return path;\n  };\n\n  var fixArc = function fixArc(pp, i) {\n    if (pp[i].length > 7) {\n      pp[i].shift();\n      var pi = pp[i];\n\n      while (pi.length) {\n        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\n\n        p2 && (pcoms2[i] = 'A'); // the same as above\n\n        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n      }\n\n      pp.splice(i, 1);\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  var fixM = function fixM(path1, path2, a1, a2, i) {\n    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {\n      path2.splice(i, 0, ['M', a2.x, a2.y]);\n      a1.bx = 0;\n      a1.by = 0;\n      a1.x = path1[i][1];\n      a1.y = path1[i][2];\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  ii = Math.max(p.length, p2 && p2.length || 0);\n\n  for (var i = 0; i < ii; i++) {\n    p[i] && (pfirst = p[i][0]); // save current path command\n\n    if (pfirst !== 'C') {\n      // C is not saved yet, because it may be result of conversion\n      pcoms1[i] = pfirst; // Save current path command\n\n      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n    }\n\n    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command\n    // which may produce multiple C:s\n    // so we have to make sure that C is also C in original path\n\n    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n    if (p2) {\n      // the same procedures is done to p2\n      p2[i] && (pfirst = p2[i][0]);\n\n      if (pfirst !== 'C') {\n        pcoms2[i] = pfirst;\n        i && (pcom = pcoms2[i - 1]);\n      }\n\n      p2[i] = processPath(p2[i], attrs2, pcom);\n\n      if (pcoms2[i] !== 'A' && pfirst === 'C') {\n        pcoms2[i] = 'C';\n      }\n\n      fixArc(p2, i);\n    }\n\n    fixM(p, p2, attrs, attrs2, i);\n    fixM(p2, p, attrs2, attrs, i);\n    var seg = p[i];\n    var seg2 = p2 && p2[i];\n    var seglen = seg.length;\n    var seg2len = p2 && seg2.length;\n    attrs.x = seg[seglen - 2];\n    attrs.y = seg[seglen - 1];\n    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n    attrs2.x = p2 && seg2[seg2len - 2];\n    attrs2.y = p2 && seg2[seg2len - 1];\n  }\n\n  return p2 ? [p, p2] : p;\n};\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parsePathString = __webpack_require__(140);\n\nvar catmullRom2bezier = __webpack_require__(141);\n\nfunction ellipsePath(x, y, rx, ry, a) {\n  var res = [];\n\n  if (a === null && ry === null) {\n    ry = rx;\n  }\n\n  x = +x;\n  y = +y;\n  rx = +rx;\n  ry = +ry;\n\n  if (a !== null) {\n    var rad = Math.PI / 180;\n    var x1 = x + rx * Math.cos(-ry * rad);\n    var x2 = x + rx * Math.cos(-a * rad);\n    var y1 = y + rx * Math.sin(-ry * rad);\n    var y2 = y + rx * Math.sin(-a * rad);\n    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n  } else {\n    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\n  }\n\n  return res;\n}\n\nmodule.exports = function pathToAbsolute(pathArray) {\n  pathArray = parsePathString(pathArray);\n\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0 = void 0;\n  var dots = void 0;\n\n  if (pathArray[0][0] === 'M') {\n    x = +pathArray[0][1];\n    y = +pathArray[0][2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n\n  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';\n\n  for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n    res.push(r = []);\n    pa = pathArray[i];\n    pa0 = pa[0];\n\n    if (pa0 !== pa0.toUpperCase()) {\n      r[0] = pa0.toUpperCase();\n\n      switch (r[0]) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n\n        case 'R':\n          dots = [x, y].concat(pa.slice(1));\n\n          for (var j = 2, jj = dots.length; j < jj; j++) {\n            dots[j] = +dots[j] + x;\n            dots[++j] = +dots[j] + y;\n          }\n\n          res.pop();\n          res = res.concat(catmullRom2bezier(dots, crz));\n          break;\n\n        case 'O':\n          res.pop();\n          dots = ellipsePath(x, y, pa[1], pa[2]);\n          dots.push(dots[0]);\n          res = res.concat(dots);\n          break;\n\n        case 'U':\n          res.pop();\n          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n          r = ['U'].concat(res[res.length - 1].slice(-2));\n          break;\n\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          break;\n        // for lint\n\n        default:\n          for (var _j = 1, _jj = pa.length; _j < _jj; _j++) {\n            r[_j] = +pa[_j] + (_j % 2 ? x : y);\n          }\n\n      }\n    } else if (pa0 === 'R') {\n      dots = [x, y].concat(pa.slice(1));\n      res.pop();\n      res = res.concat(catmullRom2bezier(dots, crz));\n      r = ['R'].concat(pa.slice(-2));\n    } else if (pa0 === 'O') {\n      res.pop();\n      dots = ellipsePath(x, y, pa[1], pa[2]);\n      dots.push(dots[0]);\n      res = res.concat(dots);\n    } else if (pa0 === 'U') {\n      res.pop();\n      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n      r = ['U'].concat(res[res.length - 1].slice(-2));\n    } else {\n      for (var k = 0, kk = pa.length; k < kk; k++) {\n        r[k] = pa[k];\n      }\n    }\n\n    pa0 = pa0.toUpperCase();\n\n    if (pa0 !== 'O') {\n      switch (r[0]) {\n        case 'Z':\n          x = +mx;\n          y = +my;\n          break;\n\n        case 'H':\n          x = r[1];\n          break;\n\n        case 'V':\n          y = r[1];\n          break;\n\n        case 'M':\n          mx = r[r.length - 2];\n          my = r[r.length - 1];\n          break;\n        // for lint\n\n        default:\n          x = r[r.length - 2];\n          y = r[r.length - 1];\n      }\n    }\n  }\n\n  return res;\n};\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar SPACES = '\\t\\n\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029';\nvar PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');\nvar PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments\n\nmodule.exports = function parsePathString(pathString) {\n  if (!pathString) {\n    return null;\n  }\n\n  if ((typeof pathString === 'undefined' ? 'undefined' : _typeof(pathString)) === _typeof([])) {\n    return pathString;\n  }\n\n  var paramCounts = {\n    a: 7,\n    c: 6,\n    o: 2,\n    h: 1,\n    l: 2,\n    m: 2,\n    r: 4,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    u: 3,\n    z: 0\n  };\n  var data = [];\n  String(pathString).replace(PATH_COMMAND, function (a, b, c) {\n    var params = [];\n    var name = b.toLowerCase();\n    c.replace(PATH_VALUES, function (a, b) {\n      b && params.push(+b);\n    });\n\n    if (name === 'm' && params.length > 2) {\n      data.push([b].concat(params.splice(0, 2)));\n      name = 'l';\n      b = b === 'm' ? 'l' : 'L';\n    }\n\n    if (name === 'o' && params.length === 1) {\n      data.push([b, params[0]]);\n    }\n\n    if (name === 'r') {\n      data.push([b].concat(params));\n    } else {\n      while (params.length >= paramCounts[name]) {\n        data.push([b].concat(params.splice(0, paramCounts[name])));\n\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    }\n  });\n  return data;\n};\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports) {\n\n// http://schepers.cc/getting-to-the-point\nmodule.exports = function catmullRom2bezier(crp, z) {\n  var d = [];\n\n  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n    var p = [{\n      x: +crp[i - 2],\n      y: +crp[i - 1]\n    }, {\n      x: +crp[i],\n      y: +crp[i + 1]\n    }, {\n      x: +crp[i + 2],\n      y: +crp[i + 3]\n    }, {\n      x: +crp[i + 4],\n      y: +crp[i + 5]\n    }];\n\n    if (z) {\n      if (!i) {\n        p[0] = {\n          x: +crp[iLen - 2],\n          y: +crp[iLen - 1]\n        };\n      } else if (iLen - 4 === i) {\n        p[3] = {\n          x: +crp[0],\n          y: +crp[1]\n        };\n      } else if (iLen - 2 === i) {\n        p[2] = {\n          x: +crp[0],\n          y: +crp[1]\n        };\n        p[3] = {\n          x: +crp[2],\n          y: +crp[3]\n        };\n      }\n    } else {\n      if (iLen - 4 === i) {\n        p[3] = p[2];\n      } else if (!i) {\n        p[0] = {\n          x: +crp[i],\n          y: +crp[i + 1]\n        };\n      }\n    }\n\n    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);\n  }\n\n  return d;\n};\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(23);\n\nvar lowerCase = function lowerCase(str) {\n  return toString(str).toLowerCase();\n};\n\nmodule.exports = lowerCase;\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(23);\n\nvar upperCase = function upperCase(str) {\n  return toString(str).toUpperCase();\n};\n\nmodule.exports = upperCase;\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar groupToMap = __webpack_require__(145);\n\nvar group = function group(data, condition) {\n  if (!condition) {\n    return [data];\n  }\n\n  var groups = groupToMap(data, condition);\n  var array = [];\n\n  for (var i in groups) {\n    array.push(groups[i]);\n  }\n\n  return array;\n};\n\nmodule.exports = group;\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(11);\n\nvar isArray = __webpack_require__(4);\n\nvar groupBy = __webpack_require__(146);\n\nvar groupToMap = function groupToMap(data, condition) {\n  if (!condition) {\n    return {\n      0: data\n    };\n  }\n\n  if (!isFunction(condition)) {\n    var paramsCondition = isArray(condition) ? condition : condition.replace(/\\s+/g, '').split('*');\n\n    condition = function condition(row) {\n      var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序\n\n      for (var i = 0, l = paramsCondition.length; i < l; i++) {\n        unique += row[paramsCondition[i]] && row[paramsCondition[i]].toString();\n      }\n\n      return unique;\n    };\n  }\n\n  var groups = groupBy(data, condition);\n  return groups;\n};\n\nmodule.exports = groupToMap;\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isArray = __webpack_require__(4);\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar groupBy = function groupBy(data, condition) {\n  if (!condition || !isArray(data)) {\n    return data;\n  }\n\n  var result = {};\n  var key = null;\n  each(data, function (item) {\n    key = condition(item);\n\n    if (hasOwnProperty.call(result, key)) {\n      result[key].push(item);\n    } else {\n      result[key] = [item];\n    }\n  });\n  return result;\n};\n\nmodule.exports = groupBy;\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview G2 图表的入口文件\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar View = __webpack_require__(291);\n\nvar G = __webpack_require__(16);\n\nvar Canvas = G.Canvas;\nvar DomUtil = Util.DomUtil;\n\nvar Global = __webpack_require__(7);\n\nvar Plot = __webpack_require__(356);\n\nvar Controller = __webpack_require__(165);\n\nvar mergeBBox = __webpack_require__(167);\n\nvar bboxOfBackPlot = __webpack_require__(166);\n\nvar plotRange2BBox = __webpack_require__(168);\n\nvar AUTO_STR = 'auto';\n\nfunction _isScaleExist(scales, compareScale) {\n  var flag = false;\n  Util.each(scales, function (scale) {\n    var scaleValues = [].concat(scale.values);\n    var compareScaleValues = [].concat(compareScale.values);\n\n    if (scale.type === compareScale.type && scale.field === compareScale.field && scaleValues.sort().toString() === compareScaleValues.sort().toString()) {\n      flag = true;\n      return;\n    }\n  });\n  return flag;\n}\n\nfunction isEqualArray(arr1, arr2) {\n  return Util.isEqualWith(arr1, arr2, function (v1, v2) {\n    return v1 === v2;\n  });\n}\n/**\n * 图表的入口\n * @class Chart\n */\n\n\nvar Chart =\n/*#__PURE__*/\nfunction (_View) {\n  _inheritsLoose(Chart, _View);\n\n  function Chart() {\n    return _View.apply(this, arguments) || this;\n  }\n\n  var _proto = Chart.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var viewCfg = _View.prototype.getDefaultCfg.call(this);\n\n    return Util.mix(viewCfg, {\n      id: null,\n      forceFit: false,\n      container: null,\n      wrapperEl: null,\n      canvas: null,\n      width: 500,\n      height: 500,\n      pixelRatio: null,\n      backPlot: null,\n      frontPlot: null,\n      plotBackground: null,\n      padding: Global.plotCfg.padding,\n      background: null,\n      autoPaddingAppend: 5,\n      limitInPlot: false,\n      renderer: Global.renderer,\n      // renderer: 'svg',\n      views: []\n    });\n  };\n\n  _proto.init = function init() {\n    var self = this;\n    var viewTheme = self.get('viewTheme');\n\n    self._initCanvas();\n\n    self._initPlot();\n\n    self._initEvents();\n\n    _View.prototype.init.call(this);\n\n    var tooltipController = new Controller.Tooltip({\n      chart: self,\n      viewTheme: viewTheme,\n      options: {}\n    });\n    self.set('tooltipController', tooltipController);\n    var legendController = new Controller.Legend({\n      chart: self,\n      viewTheme: viewTheme\n    });\n    self.set('legendController', legendController);\n    self.set('_id', 'chart'); // 防止同用户设定的 id 同名\n\n    self.emit('afterinit'); // 初始化完毕\n  };\n\n  _proto._isAutoPadding = function _isAutoPadding() {\n    var padding = this.get('padding');\n\n    if (Util.isArray(padding)) {\n      return padding.indexOf(AUTO_STR) !== -1;\n    }\n\n    return padding === AUTO_STR;\n  };\n\n  _proto._getAutoPadding = function _getAutoPadding() {\n    var padding = this.get('padding'); // 图例在最前面的一层\n\n    var frontPlot = this.get('frontPlot');\n    var frontBBox = frontPlot.getBBox(); // 坐标轴在最后面的一层\n\n    var backPlot = this.get('backPlot');\n    var backBBox = bboxOfBackPlot(backPlot, plotRange2BBox(this.get('plotRange')));\n    var box = mergeBBox(frontBBox, backBBox);\n    var outter = [0 - box.minY, // 上面超出的部分\n    box.maxX - this.get('width'), // 右边超出的部分\n    box.maxY - this.get('height'), // 下边超出的部分\n    0 - box.minX]; // 如果原始的 padding 内部存在 'auto' 则替换对应的边\n\n    var autoPadding = Util.toAllPadding(padding);\n\n    for (var i = 0; i < autoPadding.length; i++) {\n      if (autoPadding[i] === AUTO_STR) {\n        var tmp = Math.max(0, outter[i]);\n        autoPadding[i] = tmp + this.get('autoPaddingAppend');\n      }\n    }\n\n    return autoPadding;\n  }; // 初始化画布\n\n\n  _proto._initCanvas = function _initCanvas() {\n    var container = this.get('container');\n    var id = this.get('id'); // 如果未设置 container 使用 ID, 兼容 2.x 版本\n\n    if (!container && id) {\n      container = id;\n      this.set('container', id);\n    }\n\n    var width = this.get('width');\n    var height = this.get('height');\n\n    if (Util.isString(container)) {\n      container = document.getElementById(container);\n\n      if (!container) {\n        throw new Error('Please specify the container for the chart!');\n      }\n\n      this.set('container', container);\n    }\n\n    var wrapperEl = DomUtil.createDom('<div style=\"position:relative;\"></div>');\n    container.appendChild(wrapperEl);\n    this.set('wrapperEl', wrapperEl);\n\n    if (this.get('forceFit')) {\n      width = DomUtil.getWidth(container, width);\n      this.set('width', width);\n    }\n\n    var renderer = this.get('renderer');\n    var canvas = new Canvas({\n      containerDOM: wrapperEl,\n      width: width,\n      height: height,\n      // NOTICE: 有问题找青湳\n      pixelRatio: renderer === 'svg' ? 1 : this.get('pixelRatio'),\n      renderer: renderer\n    });\n    this.set('canvas', canvas);\n  }; // 初始化绘图区间\n\n\n  _proto._initPlot = function _initPlot() {\n    var self = this;\n\n    self._initPlotBack(); // 最底层的是背景相关的 group\n\n\n    var canvas = self.get('canvas');\n    var backPlot = canvas.addGroup({\n      zIndex: 1\n    }); // 图表最后面的容器\n\n    var plotContainer = canvas.addGroup({\n      zIndex: 0\n    }); // 图表所在的容器\n\n    var frontPlot = canvas.addGroup({\n      zIndex: 3\n    }); // 图表前面的容器\n\n    self.set('backPlot', backPlot);\n    self.set('middlePlot', plotContainer);\n    self.set('frontPlot', frontPlot);\n  }; // 初始化背景\n\n\n  _proto._initPlotBack = function _initPlotBack() {\n    var self = this;\n    var canvas = self.get('canvas');\n    var viewTheme = self.get('viewTheme');\n    var plot = canvas.addGroup(Plot, {\n      padding: this.get('padding'),\n      plotBackground: Util.mix({}, viewTheme.plotBackground, self.get('plotBackground')),\n      background: Util.mix({}, viewTheme.background, self.get('background'))\n    });\n    self.set('plot', plot);\n    self.set('plotRange', plot.get('plotRange'));\n  };\n\n  _proto._initEvents = function _initEvents() {\n    if (this.get('forceFit')) {\n      window.addEventListener('resize', Util.wrapBehavior(this, '_initForceFitEvent'));\n    }\n  };\n\n  _proto._initForceFitEvent = function _initForceFitEvent() {\n    var timer = setTimeout(Util.wrapBehavior(this, 'forceFit'), 200);\n    clearTimeout(this.get('resizeTimer'));\n    this.set('resizeTimer', timer);\n  }; // 绘制图例\n\n\n  _proto._renderLegends = function _renderLegends() {\n    var options = this.get('options');\n    var legendOptions = options.legends;\n\n    if (Util.isNil(legendOptions) || legendOptions !== false) {\n      // 没有关闭图例\n      var legendController = this.get('legendController');\n      legendController.options = legendOptions || {};\n      legendController.plotRange = this.get('plotRange');\n\n      if (legendOptions && legendOptions.custom) {\n        // 用户自定义图例\n        legendController.addCustomLegend();\n      } else {\n        var geoms = this.getAllGeoms();\n        var scales = [];\n        Util.each(geoms, function (geom) {\n          var view = geom.get('view');\n          var attrs = geom.getAttrsForLegend();\n          Util.each(attrs, function (attr) {\n            var type = attr.type;\n            var scale = attr.getScale(type);\n\n            if (scale.field && scale.type !== 'identity' && !_isScaleExist(scales, scale)) {\n              scales.push(scale);\n              var filteredValues = view.getFilteredOutValues(scale.field);\n              legendController.addLegend(scale, attr, geom, filteredValues);\n            }\n          });\n        }); // 双轴的情况\n\n        var yScales = this.getYScales();\n\n        if (scales.length === 0 && yScales.length > 1) {\n          legendController.addMixedLegend(yScales, geoms);\n        }\n      }\n\n      legendController.alignLegends();\n    }\n  }; // 绘制 tooltip\n\n\n  _proto._renderTooltips = function _renderTooltips() {\n    var options = this.get('options');\n\n    if (Util.isNil(options.tooltip) || options.tooltip !== false) {\n      // 用户没有关闭 tooltip\n      var tooltipController = this.get('tooltipController');\n      tooltipController.options = options.tooltip || {};\n      tooltipController.renderTooltip();\n    }\n  };\n  /**\n   * 获取所有的几何标记\n   * @return {Array} 所有的几何标记\n   */\n\n\n  _proto.getAllGeoms = function getAllGeoms() {\n    var geoms = [];\n    geoms = geoms.concat(this.get('geoms'));\n    var views = this.get('views');\n    Util.each(views, function (view) {\n      geoms = geoms.concat(view.get('geoms'));\n    });\n    return geoms;\n  };\n  /**\n   * 自适应宽度\n   * @chainable\n   * @return {Chart} 图表对象\n   */\n\n\n  _proto.forceFit = function forceFit() {\n    var self = this;\n\n    if (!self || self.destroyed) {\n      return;\n    }\n\n    var container = self.get('container');\n    var oldWidth = self.get('width');\n    var width = DomUtil.getWidth(container, oldWidth);\n\n    if (width !== 0 && width !== oldWidth) {\n      var height = self.get('height');\n      self.changeSize(width, height);\n    }\n\n    return self;\n  };\n\n  _proto.resetPlot = function resetPlot() {\n    var plot = this.get('plot');\n    var padding = this.get('padding');\n\n    if (!isEqualArray(padding, plot.get('padding'))) {\n      // 重置 padding，仅当padding 发生更改\n      plot.set('padding', padding);\n      plot.repaint();\n    }\n  };\n  /**\n   * 改变大小\n   * @param  {Number} width  图表宽度\n   * @param  {Number} height 图表高度\n   * @return {Chart} 图表对象\n   */\n\n\n  _proto.changeSize = function changeSize(width, height) {\n    var self = this;\n    var canvas = self.get('canvas');\n    canvas.changeSize(width, height);\n    var plot = this.get('plot');\n    self.set('width', width);\n    self.set('height', height); // change size 时重新计算边框\n\n    plot.repaint(); // 保持边框不变，防止自动 padding 时绘制多遍\n\n    this.set('keepPadding', true);\n    self.repaint();\n    this.set('keepPadding', false);\n    this.emit('afterchangesize');\n    return self;\n  };\n  /**\n   * 改变宽度\n   * @param  {Number} width  图表宽度\n   * @return {Chart} 图表对象\n   */\n\n\n  _proto.changeWidth = function changeWidth(width) {\n    return this.changeSize(width, this.get('height'));\n  };\n  /**\n   * 改变宽度\n   * @param  {Number} height  图表高度\n   * @return {Chart} 图表对象\n   */\n\n\n  _proto.changeHeight = function changeHeight(height) {\n    return this.changeSize(this.get('width'), height);\n  };\n  /**\n   * 创建一个视图\n   * @param  {Object} cfg 视图的配置项\n   * @return {View} 视图对象\n   */\n\n\n  _proto.view = function view(cfg) {\n    cfg = cfg || {};\n    cfg.theme = this.get('theme');\n    cfg.parent = this;\n    cfg.backPlot = this.get('backPlot');\n    cfg.middlePlot = this.get('middlePlot');\n    cfg.frontPlot = this.get('frontPlot');\n    cfg.canvas = this.get('canvas');\n\n    if (Util.isNil(cfg.animate)) {\n      cfg.animate = this.get('animate');\n    }\n\n    cfg.options = Util.mix({}, this._getSharedOptions(), cfg.options);\n    var view = new View(cfg);\n    view.set('_id', 'view' + this.get('views').length); // 标识 ID，防止同用户设定的 id 重名\n\n    this.get('views').push(view);\n    this.emit('addview', {\n      view: view\n    });\n    return view;\n  }; // isShapeInView() {\n  //   return true;\n  // }\n\n\n  _proto.removeView = function removeView(view) {\n    var views = this.get('views');\n    Util.Array.remove(views, view);\n    view.destroy();\n  };\n\n  _proto._getSharedOptions = function _getSharedOptions() {\n    var options = this.get('options');\n    var sharedOptions = {};\n    Util.each(['scales', 'coord', 'axes'], function (name) {\n      sharedOptions[name] = Util.cloneDeep(options[name]);\n    });\n    return sharedOptions;\n  };\n  /**\n   * @override\n   * 当前chart 的范围\n   */\n\n\n  _proto.getViewRegion = function getViewRegion() {\n    var plotRange = this.get('plotRange');\n    return {\n      start: plotRange.bl,\n      end: plotRange.tr\n    };\n  };\n  /**\n   * 设置图例配置信息\n   * @param  {String|Object} field 字段名\n   * @param  {Object} [cfg] 图例的配置项\n   * @return {Chart} 当前的图表对象\n   */\n\n\n  _proto.legend = function legend(field, cfg) {\n    var options = this.get('options');\n\n    if (!options.legends) {\n      options.legends = {};\n    }\n\n    var legends = {};\n\n    if (field === false) {\n      options.legends = false;\n    } else if (Util.isObject(field)) {\n      legends = field;\n    } else if (Util.isString(field)) {\n      legends[field] = cfg;\n    } else {\n      legends = cfg;\n    }\n\n    Util.mix(options.legends, legends);\n    return this;\n  };\n  /**\n   * 设置提示信息\n   * @param  {String|Object} visible 是否可见\n   * @param  {Object} [cfg] 提示信息的配置项\n   * @return {Chart} 当前的图表对象\n   */\n\n\n  _proto.tooltip = function tooltip(visible, cfg) {\n    var options = this.get('options');\n\n    if (!options.tooltip) {\n      options.tooltip = {};\n    }\n\n    if (visible === false) {\n      options.tooltip = false;\n    } else if (Util.isObject(visible)) {\n      Util.mix(options.tooltip, visible);\n    } else {\n      Util.mix(options.tooltip, cfg);\n    }\n\n    return this;\n  };\n  /**\n   * 清空图表\n   * @return {Chart} 当前的图表对象\n   */\n\n\n  _proto.clear = function clear() {\n    this.emit('beforeclear');\n    var views = this.get('views');\n\n    while (views.length > 0) {\n      var view = views.shift();\n      view.destroy();\n    }\n\n    _View.prototype.clear.call(this);\n\n    var canvas = this.get('canvas');\n    this.resetPlot();\n    canvas.draw();\n    this.emit('afterclear');\n    return this;\n  };\n\n  _proto.clearInner = function clearInner() {\n    var views = this.get('views');\n    Util.each(views, function (view) {\n      view.clearInner();\n    });\n    var tooltipController = this.get('tooltipController');\n    tooltipController && tooltipController.clear();\n\n    if (!this.get('keepLegend')) {\n      var legendController = this.get('legendController');\n      legendController && legendController.clear();\n    }\n\n    _View.prototype.clearInner.call(this);\n  }; // chart 除了view 上绘制的组件外，还会绘制图例和 tooltip\n\n\n  _proto.drawComponents = function drawComponents() {\n    _View.prototype.drawComponents.call(this); // 一般是点击图例时，仅仅隐藏某些选项，而不销毁图例\n\n\n    if (!this.get('keepLegend')) {\n      this._renderLegends(); // 渲染图例\n\n    }\n  };\n  /**\n   * 绘制图表\n   * @override\n   */\n\n\n  _proto.render = function render() {\n    var self = this; // 需要自动计算边框，则重新设置\n\n    if (!self.get('keepPadding') && self._isAutoPadding()) {\n      self.beforeRender(); // 初始化各个 view 和 绘制\n\n      self.drawComponents();\n\n      var autoPadding = self._getAutoPadding();\n\n      var plot = self.get('plot'); // 在计算出来的边框不一致的情况，重新改变边框\n\n      if (!isEqualArray(plot.get('padding'), autoPadding)) {\n        plot.set('padding', autoPadding);\n        plot.repaint();\n      }\n    }\n\n    var middlePlot = self.get('middlePlot');\n\n    if (self.get('limitInPlot') && !middlePlot.attr('clip')) {\n      var clip = Util.getClipByRange(self.get('plotRange')); // TODO Polar coord\n\n      middlePlot.attr('clip', clip); // clip.attr('fill', 'grey');\n      // clip.attr('opacity', 0.5);\n      // middlePlot.add(clip);\n    }\n\n    _View.prototype.render.call(this);\n\n    self._renderTooltips(); // 渲染 tooltip\n\n  };\n\n  _proto.repaint = function repaint() {\n    // 重绘时需要判定当前的 padding 是否发生过改变，如果发生过改变进行调整\n    // 需要判定是否使用了自动 padding\n    if (!this.get('keepPadding')) {\n      this.resetPlot();\n    }\n\n    _View.prototype.repaint.call(this);\n  };\n  /**\n   * @override\n   * 显示或者隐藏\n   */\n\n\n  _proto.changeVisible = function changeVisible(visible) {\n    var wrapperEl = this.get('wrapperEl');\n    var visibleStr = visible ? '' : 'none';\n    wrapperEl.style.display = visibleStr;\n  };\n  /**\n   * 返回图表的 dataUrl 用于生成图片\n   * @return {String} dataUrl 路径\n   */\n\n\n  _proto.toDataURL = function toDataURL() {\n    var chart = this;\n    var canvas = chart.get('canvas');\n    var renderer = chart.get('renderer');\n    var canvasDom = canvas.get('el');\n    var dataURL = '';\n\n    if (renderer === 'svg') {\n      var clone = canvasDom.cloneNode(true);\n      var svgDocType = document.implementation.createDocumentType('svg', '-//W3C//DTD SVG 1.1//EN', 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd');\n      var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);\n      svgDoc.replaceChild(clone, svgDoc.documentElement);\n      var svgData = new XMLSerializer().serializeToString(svgDoc);\n      dataURL = 'data:image/svg+xml;charset=utf8,' + encodeURIComponent(svgData);\n    } else if (renderer === 'canvas') {\n      dataURL = canvasDom.toDataURL('image/png');\n    }\n\n    return dataURL;\n  };\n  /**\n   * 图表导出功能\n   * @param  {String} [name] 图片的名称，默认为 chart(.png|.svg)\n   */\n\n\n  _proto.downloadImage = function downloadImage(name) {\n    var chart = this;\n    var link = document.createElement('a');\n    var renderer = chart.get('renderer');\n    var filename = (name || 'chart') + (renderer === 'svg' ? '.svg' : '.png');\n    var canvas = chart.get('canvas');\n    canvas.get('timeline').stopAllAnimations();\n    setTimeout(function () {\n      var dataURL = chart.toDataURL();\n\n      if (window.Blob && window.URL && renderer !== 'svg') {\n        var arr = dataURL.split(',');\n        var mime = arr[0].match(/:(.*?);/)[1];\n        var bstr = atob(arr[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blobObj = new Blob([u8arr], {\n          type: mime\n        });\n\n        if (window.navigator.msSaveBlob) {\n          window.navigator.msSaveBlob(blobObj, filename);\n        } else {\n          link.addEventListener('click', function () {\n            link.download = filename;\n            link.href = window.URL.createObjectURL(blobObj);\n          });\n        }\n      } else {\n        link.addEventListener('click', function () {\n          link.download = filename;\n          link.href = dataURL;\n        });\n      }\n\n      var e = document.createEvent('MouseEvents');\n      e.initEvent('click', false, false);\n      link.dispatchEvent(e);\n    }, 16);\n  };\n  /**\n   * 根据坐标点显示对应的 tooltip\n   * @param  {Object} point 画布上的点\n   * @return {Chart}       返回 chart 实例\n   */\n\n\n  _proto.showTooltip = function showTooltip(point) {\n    var views = this.getViewsByPoint(point);\n\n    if (views.length) {\n      var tooltipController = this.get('tooltipController');\n      tooltipController.showTooltip(point, views);\n    }\n\n    return this;\n  };\n  /**\n   * 隐藏 tooltip\n  * @return {Chart}       返回 chart 实例\n   */\n\n\n  _proto.hideTooltip = function hideTooltip() {\n    var tooltipController = this.get('tooltipController');\n    tooltipController.hideTooltip();\n    return this;\n  };\n  /**\n   * 根据传入的画布坐标，获取该处的 tooltip 上的记录信息\n   * @param  {Object} point 画布坐标点\n   * @return {Array}       返回结果\n   */\n\n\n  _proto.getTooltipItems = function getTooltipItems(point) {\n    var self = this;\n    var views = self.getViewsByPoint(point);\n    var rst = [];\n    Util.each(views, function (view) {\n      var geoms = view.get('geoms');\n      Util.each(geoms, function (geom) {\n        var dataArray = geom.get('dataArray');\n        var items = [];\n        Util.each(dataArray, function (data) {\n          var tmpPoint = geom.findPoint(point, data);\n\n          if (tmpPoint) {\n            var subItems = geom.getTipItems(tmpPoint);\n            items = items.concat(subItems);\n          }\n        });\n        rst = rst.concat(items);\n      });\n    });\n    return rst;\n  };\n  /**\n   * @override\n   * 销毁图表\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.emit('beforedestroy');\n    clearTimeout(this.get('resizeTimer'));\n    var canvas = this.get('canvas');\n    var wrapperEl = this.get('wrapperEl');\n    wrapperEl.parentNode.removeChild(wrapperEl);\n\n    _View.prototype.destroy.call(this);\n\n    canvas.destroy();\n    window.removeEventListener('resize', Util.getWrapBehavior(this, '_initForceFitEvent'));\n    this.emit('afterdestroy');\n  };\n\n  return Chart;\n}(View);\n\nmodule.exports = Chart;\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview Chart、View、Geometry 的基类\n * @author dxq613@gmail.com\n */\nvar EventEmitter = __webpack_require__(53);\n\nvar Util = __webpack_require__(0);\n\nvar Base =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inheritsLoose(Base, _EventEmitter);\n\n  var _proto = Base.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {};\n  };\n\n  function Base(cfg) {\n    var _this;\n\n    _this = _EventEmitter.call(this) || this;\n    var attrs = {\n      visible: true\n    };\n\n    var defaultCfg = _this.getDefaultCfg();\n\n    _this._attrs = attrs;\n    Util.assign(attrs, defaultCfg, cfg);\n    return _this;\n  }\n\n  _proto.get = function get(name) {\n    return this._attrs[name];\n  };\n\n  _proto.set = function set(name, value) {\n    this._attrs[name] = value;\n  };\n\n  _proto.show = function show() {\n    var visible = this.get('visible');\n\n    if (!visible) {\n      this.set('visible', true);\n      this.changeVisible(true);\n    }\n  };\n\n  _proto.hide = function hide() {\n    var visible = this.get('visible');\n\n    if (visible) {\n      this.set('visible', false);\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * @protected\n   * @param {Boolean} visible 是否可见\n   * 显示、隐藏\n   */\n\n\n  _proto.changeVisible = function changeVisible()\n  /* visible */\n  {};\n\n  _proto.destroy = function destroy() {\n    this._attrs = {};\n    this.removeAllListeners();\n    this.destroyed = true;\n  };\n\n  return Base;\n}(EventEmitter);\n\nmodule.exports = Base;\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 颜色计算的辅助方法\n * @author dxq613@gmail.com\n */\nvar isNumber = __webpack_require__(9);\n\nvar isString = __webpack_require__(10);\n\nvar each = __webpack_require__(2); // const RGB_REG = /rgb\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/;\n\n\nvar RGB_REG = /rgba?\\(([\\s.,0-9]+)\\)/; // 创建辅助 tag 取颜色\n\nfunction createTmp() {\n  var i = document.createElement('i');\n  i.title = 'Web Colour Picker';\n  i.style.display = 'none';\n  document.body.appendChild(i);\n  return i;\n} // 获取颜色之间的插值\n\n\nfunction getValue(start, end, percent, index) {\n  var value = start[index] + (end[index] - start[index]) * percent;\n  return value;\n} // 数组转换成颜色\n\n\nfunction arr2rgb(arr) {\n  return '#' + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);\n} // 将数值从 0-255 转换成16进制字符串\n\n\nfunction toHex(value) {\n  value = Math.round(value);\n  value = value.toString(16);\n\n  if (value.length === 1) {\n    value = '0' + value;\n  }\n\n  return value;\n}\n\nfunction calColor(colors, percent) {\n  if (isNaN(percent) || !isNumber(percent) || percent < 0) {\n    percent = 0;\n  }\n\n  if (percent > 1) {\n    percent = 1;\n  }\n\n  var steps = colors.length - 1;\n  var step = Math.floor(steps * percent);\n  var left = steps * percent - step;\n  var start = colors[step];\n  var end = step === steps ? start : colors[step + 1];\n  var rgb = arr2rgb([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);\n  return rgb;\n} // rgb 颜色转换成数组\n\n\nfunction rgb2arr(str) {\n  var arr = [];\n  arr.push(parseInt(str.substr(1, 2), 16));\n  arr.push(parseInt(str.substr(3, 2), 16));\n  arr.push(parseInt(str.substr(5, 2), 16));\n  return arr;\n}\n\nvar colorCache = {};\nvar iEl = null;\nvar ColorUtil = {\n  /**\n   * 将颜色转换到 rgb 的格式\n   * @param  {String} color 颜色\n   * @return {String} 将颜色转换到 '#ffffff' 的格式\n   */\n  toRGB: function toRGB(color) {\n    // 如果已经是 rgb的格式\n    if (color[0] === '#' && color.length === 7) {\n      return color;\n    }\n\n    if (!iEl) {\n      // 防止防止在页头报错\n      iEl = createTmp();\n    }\n\n    var rst;\n\n    if (colorCache[color]) {\n      rst = colorCache[color];\n    } else {\n      iEl.style.color = color;\n      rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');\n      var matchs = RGB_REG.exec(rst);\n      var cArray = matchs[1].split(/\\s*,\\s*/);\n      rst = arr2rgb(cArray);\n      colorCache[color] = rst;\n    }\n\n    return rst;\n  },\n  rgb2arr: rgb2arr,\n\n  /**\n   * 获取渐变函数\n   * @param  {Array} colors 多个颜色\n   * @return {String} 颜色值\n   */\n  gradient: function gradient(colors) {\n    var points = [];\n\n    if (isString(colors)) {\n      colors = colors.split('-');\n    }\n\n    each(colors, function (color) {\n      if (color.indexOf('#') === -1) {\n        color = ColorUtil.toRGB(color);\n      }\n\n      points.push(rgb2arr(color));\n    });\n    return function (percent) {\n      return calColor(points, percent);\n    };\n  }\n};\nmodule.exports = ColorUtil;\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DEFAULT_Y = 0; // 默认的y的值\n\nvar each = __webpack_require__(2);\n\nvar ArrayUtil = {\n  values: __webpack_require__(64)\n};\nmodule.exports = {\n  /**\n   * 对应的维度是否可以调整\n   * @protected\n   * @param  {String}  dimName 可以调整的维度 x,y\n   * @return {Boolean} 是否可以调整\n   */\n  isAdjust: function isAdjust(dimName) {\n    return this.adjustNames.indexOf(dimName) >= 0;\n  },\n\n  /**\n   * @protected\n   * 获取可调整度量对应的值\n   * @param  {Frame} mergeData 数据\n   * @return {Object} 值的映射\n   */\n  _getDimValues: function _getDimValues(mergeData) {\n    var self = this;\n    var valuesMap = {};\n    var dims = [];\n\n    if (self.xField && self.isAdjust('x')) {\n      dims.push(self.xField);\n    }\n\n    if (self.yField && self.isAdjust('y')) {\n      dims.push(self.yField);\n    }\n\n    each(dims, function (dim) {\n      var values = ArrayUtil.values(mergeData, dim);\n      values.sort(function (v1, v2) {\n        return v1 - v2;\n      });\n      valuesMap[dim] = values;\n    });\n\n    if (!self.yField && self.isAdjust('y')) {\n      // 只有一维的情况下,同时调整y\n      var dim = 'y';\n      var values = [DEFAULT_Y, 1]; // 默认分布在y轴的 0.1 与 0.2 之间\n\n      valuesMap[dim] = values;\n    }\n\n    return valuesMap;\n  },\n  adjustData: function adjustData(dataArray, mergeData) {\n    var self = this;\n\n    var valuesMap = self._getDimValues(mergeData);\n\n    each(dataArray, function (data, index) {\n      // 遍历所有数据集合\n      each(valuesMap, function (values, dim) {\n        // 根据不同的度量分别调整位置\n        self.adjustDim(dim, values, data, dataArray.length, index);\n      });\n    });\n  },\n  getAdjustRange: function getAdjustRange(dim, key, values) {\n    var self = this;\n    var index = values.indexOf(key);\n    var length = values.length;\n    var pre;\n    var next;\n\n    if (!self.yField && self.isAdjust('y')) {\n      pre = 0;\n      next = 1;\n    } else if (length > 1) {\n      pre = index === 0 ? values[0] : values[index - 1];\n      next = index === length - 1 ? values[length - 1] : values[index + 1];\n\n      if (index !== 0) {\n        pre += (key - pre) / 2;\n      } else {\n        pre -= (next - key) / 2;\n      }\n\n      if (index !== length - 1) {\n        next -= (next - key) / 2;\n      } else {\n        next += (key - values[length - 2]) / 2;\n      }\n    } else {\n      pre = key === 0 ? 0 : key - 0.5;\n      next = key === 0 ? 1 : key + 0.5;\n    }\n\n    return {\n      pre: pre,\n      next: next\n    };\n  },\n\n  /**\n   * 对数据进行分组\n   * @param  {Array} data 数据\n   * @param  {String} dim 分组的字段\n   * @return {Object}  分组的键值对映射\n   */\n  groupData: function groupData(data, dim) {\n    var groups = {};\n    each(data, function (record) {\n      var value = record[dim];\n\n      if (value === undefined) {\n        value = record[dim] = DEFAULT_Y;\n      }\n\n      if (!groups[value]) {\n        groups[value] = [];\n      }\n\n      groups[value].push(record);\n    });\n    return groups;\n  }\n};\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Theme entry\n * @author sima.zhang\n */\nvar Theme = {\n  default: __webpack_require__(152),\n  dark: __webpack_require__(304)\n};\nmodule.exports = Theme;\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports) {\n\nvar _html, _tooltip;\n\n/**\n * @fileOverview G2 3.0 default theme\n * @author sima.zhang\n */\nvar DEFAULT_COLOR = '#1890FF';\nvar COLOR_PLATE_8 = ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'];\nvar COLOR_PLATE_16 = ['#1890FF', '#41D9C7', '#2FC25B', '#FACC14', '#E6965C', '#223273', '#7564CC', '#8543E0', '#5C8EE6', '#13C2C2', '#5CA3E6', '#3436C7', '#B381E6', '#F04864', '#D598D9'];\nvar COLOR_PLATE_24 = ['#1890FF', '#66B5FF', '#41D9C7', '#2FC25B', '#6EDB8F', '#9AE65C', '#FACC14', '#E6965C', '#57AD71', '#223273', '#738AE6', '#7564CC', '#8543E0', '#A877ED', '#5C8EE6', '#13C2C2', '#70E0E0', '#5CA3E6', '#3436C7', '#8082FF', '#DD81E6', '#F04864', '#FA7D92', '#D598D9'];\nvar COLOR_PIE = ['#1890FF', '#13C2C2', '#2FC25B', '#FACC14', '#F04864', '#8543E0', '#3436C7', '#223273'];\nvar COLOR_PIE_16 = ['#1890FF', '#73C9E6', '#13C2C2', '#6CD9B3', '#2FC25B', '#9DD96C', '#FACC14', '#E6965C', '#F04864', '#D66BCA', '#8543E0', '#8E77ED', '#3436C7', '#737EE6', '#223273', '#7EA2E6'];\nvar FONT_FAMILY = '\"-apple-system\", BlinkMacSystemFont, \"Segoe UI\", Roboto,\"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\",SimSun, \"sans-serif\"'; // tooltip 相关 dom 的 css 类名\n\nvar TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';\nvar TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';\nvar TOOLTIP_LIST_CLASS = 'g2-tooltip-list';\nvar TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';\nvar TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';\nvar TOOLTIP_VALUE_CLASS = 'g2-tooltip-value'; // html 渲染的 legend 相关 dom 的 css 类型\n\nvar LEGEND_CONTAINER_CLASS = 'g2-legend';\nvar LEGEND_TITLE_CLASS = 'g2-legend-title';\nvar LEGEND_LIST_CLASS = 'g2-legend-list';\nvar LEGEND_LIST_ITEM_CLASS = 'g2-legend-list-item';\nvar LEGEND_MARKER_CLASS = 'g2-legend-marker';\nvar Theme = {\n  defaultColor: DEFAULT_COLOR,\n  // 默认主题色\n  plotCfg: {\n    padding: [20, 20, 95, 80]\n  },\n  fontFamily: FONT_FAMILY,\n  defaultLegendPosition: 'bottom',\n  // 默认图例的展示位置\n  colors: COLOR_PLATE_8,\n  colors_16: COLOR_PLATE_16,\n  colors_24: COLOR_PLATE_24,\n  colors_pie: COLOR_PIE,\n  colors_pie_16: COLOR_PIE_16,\n  shapes: {\n    point: ['hollowCircle', 'hollowSquare', 'hollowDiamond', 'hollowBowtie', 'hollowTriangle', 'hollowHexagon', 'cross', 'tick', 'plus', 'hyphen', 'line'],\n    line: ['line', 'dash', 'dot'],\n    area: ['area']\n  },\n  sizes: [1, 10],\n  opacities: [0.1, 0.9],\n  axis: {\n    top: {\n      // zIndex: 1, // 默认上下方向的坐标轴位于左右坐标轴的上方\n      position: 'top',\n      title: null,\n      label: {\n        offset: 16,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          lineHeight: 16,\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        },\n        autoRotate: true\n      },\n      line: {\n        lineWidth: 1,\n        stroke: '#BFBFBF'\n      },\n      tickLine: {\n        lineWidth: 1,\n        stroke: '#BFBFBF',\n        length: 4,\n        alignWithLabel: true\n      }\n    },\n    bottom: {\n      position: 'bottom',\n      title: null,\n      label: {\n        offset: 16,\n        autoRotate: true,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          lineHeight: 16,\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        }\n      },\n      line: {\n        lineWidth: 1,\n        stroke: '#BFBFBF'\n      },\n      tickLine: {\n        lineWidth: 1,\n        stroke: '#BFBFBF',\n        length: 4,\n        alignWithLabel: true\n      }\n    },\n    left: {\n      position: 'left',\n      title: null,\n      label: {\n        offset: 8,\n        autoRotate: true,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          lineHeight: 16,\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        }\n      },\n      line: null,\n      tickLine: null,\n      grid: {\n        zIndex: -1,\n        lineStyle: {\n          stroke: '#E9E9E9',\n          lineWidth: 1,\n          lineDash: [3, 3]\n        },\n        hideFirstLine: true\n      }\n    },\n    right: {\n      position: 'right',\n      title: null,\n      label: {\n        offset: 8,\n        autoRotate: true,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          lineHeight: 16,\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        }\n      },\n      line: null,\n      tickLine: null,\n      grid: {\n        lineStyle: {\n          stroke: '#E9E9E9',\n          lineWidth: 1,\n          lineDash: [3, 3]\n        },\n        hideFirstLine: true\n      }\n    },\n    circle: {\n      zIndex: 1,\n      title: null,\n      label: {\n        offset: 8,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          lineHeight: 16,\n          fontFamily: FONT_FAMILY\n        }\n      },\n      line: {\n        lineWidth: 1,\n        stroke: '#BFBFBF'\n      },\n      tickLine: {\n        lineWidth: 1,\n        stroke: '#BFBFBF',\n        length: 4,\n        alignWithLabel: true\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#E9E9E9',\n          lineWidth: 1,\n          lineDash: [3, 3]\n        },\n        hideFirstLine: true\n      }\n    },\n    radius: {\n      zIndex: 0,\n      label: {\n        offset: 12,\n        textStyle: {\n          fill: '#545454',\n          fontSize: 12,\n          textBaseline: 'middle',\n          lineHeight: 16,\n          fontFamily: FONT_FAMILY\n        }\n      },\n      line: {\n        lineWidth: 1,\n        stroke: '#BFBFBF'\n      },\n      tickLine: {\n        lineWidth: 1,\n        stroke: '#BFBFBF',\n        length: 4,\n        alignWithLabel: true\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#E9E9E9',\n          lineWidth: 1,\n          lineDash: [3, 3]\n        },\n        type: 'circle'\n      }\n    },\n    helix: {\n      grid: null,\n      label: null,\n      title: null,\n      line: {\n        lineWidth: 1,\n        stroke: '#BFBFBF'\n      },\n      tickLine: {\n        lineWidth: 1,\n        length: 4,\n        stroke: '#BFBFBF',\n        alignWithLabel: true\n      }\n    }\n  },\n  label: {\n    offset: 20,\n    textStyle: {\n      fill: '#545454',\n      fontSize: 12,\n      textBaseline: 'middle',\n      fontFamily: FONT_FAMILY\n    }\n  },\n  treemapLabels: {\n    offset: 10,\n    textStyle: {\n      fill: '#fff',\n      fontSize: 12,\n      textBaseline: 'top',\n      fontStyle: 'bold',\n      fontFamily: FONT_FAMILY\n    }\n  },\n  innerLabels: {\n    textStyle: {\n      fill: '#fff',\n      fontSize: 12,\n      textBaseline: 'middle',\n      fontFamily: FONT_FAMILY\n    }\n  },\n  // 在theta坐标系下的饼图文本内部的样式\n  thetaLabels: {\n    labelHeight: 14,\n    offset: 30 // 在theta坐标系下的饼图文本的样式\n\n  },\n  legend: {\n    right: {\n      position: 'right',\n      layout: 'vertical',\n      itemMarginBottom: 8,\n      // layout 为 vertical 时各个图例项的间距\n      width: 16,\n      height: 156,\n      title: null,\n      legendStyle: {\n        LIST_CLASS: {\n          textAlign: 'left'\n        }\n      },\n      textStyle: {\n        fill: '#8C8C8C',\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n        lineHeight: 0,\n        fontFamily: FONT_FAMILY\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    left: {\n      position: 'left',\n      layout: 'vertical',\n      itemMarginBottom: 8,\n      width: 16,\n      height: 156,\n      title: null,\n      textStyle: {\n        fill: '#8C8C8C',\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n        lineHeight: 20,\n        fontFamily: FONT_FAMILY\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    top: {\n      position: 'top',\n      offset: [0, 6],\n      layout: 'horizontal',\n      title: null,\n      itemGap: 10,\n      width: 156,\n      height: 16,\n      textStyle: {\n        fill: '#8C8C8C',\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n        lineHeight: 20,\n        fontFamily: FONT_FAMILY\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    bottom: {\n      position: 'bottom',\n      offset: [0, 6],\n      layout: 'horizontal',\n      title: null,\n      itemGap: 10,\n      width: 156,\n      height: 16,\n      textStyle: {\n        fill: '#8C8C8C',\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n        lineHeight: 20,\n        fontFamily: FONT_FAMILY\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    // 定义 html 渲染图例的样式\n    html: (_html = {}, _html[\"\" + LEGEND_CONTAINER_CLASS] = {\n      height: 'auto',\n      width: 'auto',\n      position: 'absolute',\n      overflow: 'auto',\n      fontSize: '12px',\n      fontFamily: FONT_FAMILY,\n      lineHeight: '20px',\n      color: '#8C8C8C'\n    }, _html[\"\" + LEGEND_TITLE_CLASS] = {\n      marginBottom: '4px'\n    }, _html[\"\" + LEGEND_LIST_CLASS] = {\n      listStyleType: 'none',\n      margin: 0,\n      padding: 0\n    }, _html[\"\" + LEGEND_LIST_ITEM_CLASS] = {\n      cursor: 'pointer',\n      marginBottom: '5px',\n      marginRight: '24px'\n    }, _html[\"\" + LEGEND_MARKER_CLASS] = {\n      width: '9px',\n      height: '9px',\n      borderRadius: '50%',\n      display: 'inline-block',\n      marginRight: '8px',\n      verticalAlign: 'middle'\n    }, _html),\n    // 不能滑动的连续图例样式\n    gradient: {\n      textStyle: {\n        fill: '#8C8C8C',\n        fontSize: 12,\n        textAlign: 'center',\n        textBaseline: 'middle',\n        lineHeight: 20,\n        fontFamily: FONT_FAMILY\n      },\n      // 图例项文本的样式\n      lineStyle: {\n        lineWidth: 1,\n        stroke: '#fff'\n      },\n      unCheckColor: '#bfbfbf'\n    },\n    margin: [0, 5, 24, 5],\n    // 图例跟四个边的坐标轴、绘图区域的间距\n    legendMargin: 24 // 图例之间的间距\n\n  },\n  tooltip: (_tooltip = {\n    useHtml: true,\n    crosshairs: false,\n    offset: 15\n  }, _tooltip[\"\" + TOOLTIP_CONTAINER_CLASS] = {\n    position: 'absolute',\n    visibility: 'hidden',\n    // @2018-07-25 by blue.lb 这里去掉浮动，火狐上存在样式错位\n    // whiteSpace: 'nowrap',\n    zIndex: 8,\n    transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',\n    backgroundColor: 'rgba(255, 255, 255, 0.9)',\n    boxShadow: '0px 0px 10px #aeaeae',\n    borderRadius: '3px',\n    color: 'rgb(87, 87, 87)',\n    fontSize: '12px',\n    fontFamily: FONT_FAMILY,\n    lineHeight: '20px',\n    padding: '10px 10px 6px 10px'\n  }, _tooltip[\"\" + TOOLTIP_TITLE_CLASS] = {\n    marginBottom: '4px'\n  }, _tooltip[\"\" + TOOLTIP_LIST_CLASS] = {\n    margin: 0,\n    listStyleType: 'none',\n    padding: 0\n  }, _tooltip[\"\" + TOOLTIP_LIST_ITEM_CLASS] = {\n    marginBottom: '4px'\n  }, _tooltip[\"\" + TOOLTIP_MARKER_CLASS] = {\n    width: '5px',\n    height: '5px',\n    borderRadius: '50%',\n    display: 'inline-block',\n    marginRight: '8px'\n  }, _tooltip[\"\" + TOOLTIP_VALUE_CLASS] = {\n    display: 'inline-block',\n    float: 'right',\n    marginLeft: '30px'\n  }, _tooltip),\n  tooltipMarker: {\n    symbol: function symbol(x, y, r) {\n      return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];\n    },\n    stroke: '#fff',\n    shadowBlur: 10,\n    shadowOffsetX: 0,\n    shadowOffSetY: 0,\n    shadowColor: 'rgba(0,0,0,0.09)',\n    lineWidth: 2,\n    radius: 4\n  },\n  // 提示信息在折线图、区域图上形成点的样式\n  tooltipCrosshairsRect: {\n    type: 'rect',\n    rectStyle: {\n      fill: '#CCD6EC',\n      opacity: 0.3\n    }\n  },\n  // tooltip 辅助背景框样式\n  tooltipCrosshairsLine: {\n    lineStyle: {\n      stroke: 'rgba(0, 0, 0, 0.25)',\n      lineWidth: 1\n    }\n  },\n  shape: {\n    point: {\n      lineWidth: 1,\n      fill: DEFAULT_COLOR,\n      radius: 4\n    },\n    hollowPoint: {\n      fill: '#fff',\n      lineWidth: 1,\n      stroke: DEFAULT_COLOR,\n      radius: 3\n    },\n    interval: {\n      lineWidth: 0,\n      fill: DEFAULT_COLOR,\n      fillOpacity: 0.85\n    },\n    hollowInterval: {\n      fill: '#fff',\n      stroke: DEFAULT_COLOR,\n      fillOpacity: 0,\n      lineWidth: 2\n    },\n    area: {\n      lineWidth: 0,\n      fill: DEFAULT_COLOR,\n      fillOpacity: 0.6\n    },\n    polygon: {\n      lineWidth: 0,\n      fill: DEFAULT_COLOR,\n      fillOpacity: 1\n    },\n    hollowPolygon: {\n      fill: '#fff',\n      stroke: DEFAULT_COLOR,\n      fillOpacity: 0,\n      lineWidth: 2\n    },\n    hollowArea: {\n      fill: '#fff',\n      stroke: DEFAULT_COLOR,\n      fillOpacity: 0,\n      lineWidth: 2\n    },\n    line: {\n      stroke: DEFAULT_COLOR,\n      lineWidth: 2,\n      fill: null\n    },\n    edge: {\n      stroke: DEFAULT_COLOR,\n      lineWidth: 1,\n      fill: null\n    },\n    schema: {\n      stroke: DEFAULT_COLOR,\n      lineWidth: 1,\n      fill: null\n    }\n  },\n  guide: {\n    line: {\n      lineStyle: {\n        stroke: 'rgba(0, 0, 0, .65)',\n        lineDash: [2, 2],\n        lineWidth: 1\n      },\n      text: {\n        position: 'start',\n        autoRotate: true,\n        style: {\n          fill: 'rgba(0, 0, 0, .45)',\n          fontSize: 12,\n          textAlign: 'start',\n          fontFamily: FONT_FAMILY,\n          textBaseline: 'bottom'\n        }\n      }\n    },\n    text: {\n      style: {\n        fill: 'rgba(0,0,0,.5)',\n        fontSize: 12,\n        textBaseline: 'middle',\n        textAlign: 'start',\n        fontFamily: FONT_FAMILY\n      }\n    },\n    region: {\n      style: {\n        lineWidth: 0,\n        // 辅助框的边框宽度\n        fill: '#000',\n        // 辅助框填充的颜色\n        fillOpacity: 0.04 // 辅助框的背景透明度\n        // 辅助框的图形样式属性\n\n      }\n    },\n    html: {\n      alignX: 'middle',\n      alignY: 'middle'\n    },\n    dataRegion: {\n      style: {\n        region: {\n          lineWidth: 0,\n          fill: '#000000',\n          opacity: 0.04\n        },\n        text: {\n          textAlign: 'center',\n          textBaseline: 'bottom',\n          fontSize: 12,\n          fill: 'rgba(0, 0, 0, .65)'\n        }\n      }\n    },\n    dataMarker: {\n      top: true,\n      style: {\n        point: {\n          r: 3,\n          fill: '#FFFFFF',\n          stroke: '#1890FF',\n          lineWidth: 2\n        },\n        line: {\n          stroke: '#A3B1BF',\n          lineWidth: 1\n        },\n        text: {\n          fill: 'rgba(0, 0, 0, .65)',\n          opacity: 1,\n          fontSize: 12,\n          textAlign: 'start'\n        }\n      },\n      display: {\n        point: true,\n        line: true,\n        text: true\n      },\n      lineLength: 20,\n      direction: 'upward',\n      autoAdjust: true\n    }\n  },\n  pixelRatio: null\n};\nmodule.exports = Theme;\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(25),\n    Group = _require.Group;\n\nvar Util = __webpack_require__(3);\n\nvar Grid =\n/*#__PURE__*/\nfunction (_Group) {\n  _inheritsLoose(Grid, _Group);\n\n  function Grid() {\n    return _Group.apply(this, arguments) || this;\n  }\n\n  var _proto = Grid.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    // const cfg = super.getDefaultCfg();\n    return {\n      zIndex: 1,\n\n      /**\n       * 栅格线的类型\n       *  - line 不封闭的线\n       *  - polygon 封闭的多边形\n       * @type {String}\n       */\n      type: 'line',\n\n      /**\n       * 线的样式配置\n       * @type {Object}\n       */\n      lineStyle: null,\n\n      /**\n       * 线集合的配置\n       * @type {Array}\n       */\n      items: null,\n\n      /**\n       * 为网格设置交替的背景色，指定一个值则先渲染奇数层，两个值则交替渲染\n       * @type {String | Array}\n       */\n      alternateColor: null,\n      matrix: null,\n\n      /**\n       * 是否隐藏第一条网格线，默认为 false\n       * @type {Boolean}\n       */\n      hideFirstLine: false,\n\n      /**\n       * 是否隐藏最后一条网格线，默认为 false\n       * @type {Boolean}\n       */\n      hideLastLine: false,\n\n      /**\n       * 0基线不在轴线上时，是否强调0基线\n       * @type {Boolean}\n       */\n      hightLightZero: false,\n\n      /**\n       * 0基线样式\n       * @type {Object}\n       */\n      zeroLineStyle: {\n        stroke: '#595959',\n        lineDash: [0, 0]\n      }\n    };\n  };\n\n  _proto._renderUI = function _renderUI() {\n    _Group.prototype._renderUI.call(this);\n\n    this._drawLines();\n  };\n\n  _proto._drawLines = function _drawLines() {\n    var self = this;\n    var lineStyle = self.get('lineStyle');\n    var items = self.get('items');\n\n    if (items && items.length) {\n      self._precessItems(items);\n\n      self._drawGridLines(items, lineStyle);\n    }\n  };\n\n  _proto._precessItems = function _precessItems(items) {\n    var self = this;\n    var preItem;\n    Util.each(items, function (item, index) {\n      if (preItem && self.get('alternateColor')) {\n        self._drawAlternativeBg(item, preItem, index);\n      }\n\n      preItem = item;\n    });\n  };\n\n  _proto._drawGridLines = function _drawGridLines(items, lineStyle) {\n    var self = this;\n    var type = this.get('type');\n    var gridLine;\n    var path;\n    var cfg;\n    var points;\n    var itemsLength = items.length;\n\n    if (type === 'line' || type === 'polygon') {\n      Util.each(items, function (item, idx) {\n        if (self.get('hideFirstLine') && idx === 0) {\n          // 不展示第一条网格线\n          return;\n        }\n\n        if (self.get('hideLastLine') && idx === itemsLength - 1) {\n          // 不展示最后一条网格线\n          return;\n        }\n\n        points = item.points;\n        path = [];\n\n        if (type === 'line') {\n          path.push(['M', points[0].x, points[0].y]);\n          path.push(['L', points[points.length - 1].x, points[points.length - 1].y]);\n        } else {\n          Util.each(points, function (point, index) {\n            if (index === 0) {\n              path.push(['M', point.x, point.y]);\n            } else {\n              path.push(['L', point.x, point.y]);\n            }\n          });\n        }\n\n        if (self._drawZeroLine(type, idx)) {\n          cfg = Util.mix({}, self.get('zeroLineStyle'), {\n            path: path\n          });\n        } else {\n          cfg = Util.mix({}, lineStyle, {\n            path: path\n          });\n        }\n\n        gridLine = self.addShape('path', {\n          attrs: cfg\n        });\n        gridLine.name = 'axis-grid';\n        gridLine._id = item._id;\n        gridLine.set('coord', self.get('coord'));\n        self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));\n      });\n    } else {\n      Util.each(items, function (item, idx) {\n        if (self.get('hideFirstLine') && idx === 0) {\n          // 不展示第一条网格线\n          return;\n        }\n\n        if (self.get('hideLastLine') && idx === itemsLength - 1) {\n          // 不展示最后一条网格线\n          return;\n        }\n\n        points = item.points;\n        path = [];\n        Util.each(points, function (point, index) {\n          var radius = point.radius;\n\n          if (index === 0) {\n            path.push(['M', point.x, point.y]);\n          } else {\n            path.push(['A', radius, radius, 0, 0, point.flag, point.x, point.y]);\n          }\n        });\n        cfg = Util.mix({}, lineStyle, {\n          path: path\n        });\n        gridLine = self.addShape('path', {\n          attrs: cfg\n        });\n        gridLine.name = 'axis-grid';\n        gridLine._id = item._id;\n        gridLine.set('coord', self.get('coord'));\n        self.get('appendInfo') && gridLine.setSilent('appendInfo', self.get('appendInfo'));\n      });\n    }\n  };\n\n  _proto._drawZeroLine = function _drawZeroLine(type, idx) {\n    var self = this;\n    var tickValues = self.get('tickValues');\n\n    if (type === 'line' && tickValues) {\n      if (tickValues[idx] === 0 && self.get('hightLightZero')) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  _proto._drawAlternativeBg = function _drawAlternativeBg(item, preItem, index) {\n    var self = this;\n    var alternateColor = self.get('alternateColor');\n    var attrs;\n    var oddColor;\n    var evenColor;\n\n    if (Util.isString(alternateColor)) {\n      oddColor = alternateColor;\n    } else if (Util.isArray(alternateColor)) {\n      oddColor = alternateColor[0];\n      evenColor = alternateColor[1];\n    }\n\n    if (index % 2 === 0) {\n      if (evenColor) {\n        attrs = self._getBackItem(preItem.points, item.points, evenColor);\n      }\n    } else if (oddColor) {\n      attrs = self._getBackItem(preItem.points, item.points, oddColor);\n    }\n\n    var shape = self.addShape('Path', {\n      attrs: attrs\n    });\n    shape.name = 'axis-grid-rect';\n    shape._id = item._id && item._id.replace('grid', 'grid-rect');\n    shape.set('coord', self.get('coord'));\n    self.get('appendInfo') && shape.setSilent('appendInfo', self.get('appendInfo'));\n  };\n\n  _proto._getBackItem = function _getBackItem(start, end, bgColor) {\n    var path = [];\n    var type = this.get('type');\n\n    if (type === 'line') {\n      path.push(['M', start[0].x, start[0].y]);\n      path.push(['L', start[start.length - 1].x, start[start.length - 1].y]);\n      path.push(['L', end[end.length - 1].x, end[end.length - 1].y]);\n      path.push(['L', end[0].x, end[0].y]);\n      path.push(['Z']);\n    } else if (type === 'polygon') {\n      Util.each(start, function (subItem, index) {\n        if (index === 0) {\n          path.push(['M', subItem.x, subItem.y]);\n        } else {\n          path.push(['L', subItem.x, subItem.y]);\n        }\n      });\n\n      for (var i = end.length - 1; i >= 0; i--) {\n        path.push(['L', end[i].x, end[i].y]);\n      }\n\n      path.push(['Z']);\n    } else {\n      var flag = start[0].flag;\n      Util.each(start, function (subItem, index) {\n        var radius = subItem.radius;\n\n        if (index === 0) {\n          path.push(['M', subItem.x, subItem.y]);\n        } else {\n          path.push(['A', radius, radius, 0, 0, subItem.flag, subItem.x, subItem.y]);\n        }\n      });\n\n      for (var j = end.length - 1; j >= 0; j--) {\n        var endSubItem = end[j];\n        var endRadius = endSubItem.radius;\n\n        if (j === end.length - 1) {\n          path.push(['M', endSubItem.x, endSubItem.y]);\n        } else {\n          path.push(['A', endRadius, endRadius, 0, 0, flag === 1 ? 0 : 1, endSubItem.x, endSubItem.y]);\n        }\n      }\n    }\n\n    return {\n      fill: bgColor,\n      path: path\n    };\n  };\n\n  return Grid;\n}(Group);\n\nmodule.exports = Grid;\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar DomUtil = Util.DomUtil;\n\nvar Component = __webpack_require__(32);\n\nvar positionAdjust = __webpack_require__(307);\n\nvar spirialAdjust = __webpack_require__(308);\n\nvar bboxAdjust = __webpack_require__(309);\n\nvar LAYOUTS = {\n  scatter: positionAdjust,\n  map: spirialAdjust,\n  treemap: bboxAdjust\n};\n\nvar Label =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Label, _Component);\n\n  function Label() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Label.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Component.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'label',\n\n      /**\n       * label类型\n       * @type {(String)}\n       */\n      type: 'default',\n\n      /**\n       * 默认文本样式\n       * @type {Array}\n       */\n      textStyle: null,\n\n      /**\n       * 文本显示格式化回调函数\n       * @type {Function}\n       */\n      formatter: null,\n\n      /**\n       * 显示的文本集合\n       * @type {Array}\n       */\n      items: null,\n\n      /**\n       * 是否使用html渲染label\n       * @type {String}\n       */\n      useHtml: false,\n\n      /**\n       * html 渲染时用的容器的模板，必须存在 class = \"g-labels\"\n       * @type {String}\n       */\n      containerTpl: '<div class=\"g-labels\" style=\"position:absolute;top:0;left:0;\"></div>',\n\n      /**\n       * html 渲染时单个 label 的模板，必须存在 class = \"g-label\"\n       * @type {String}\n       */\n      itemTpl: '<div class=\"g-label\" style=\"position:absolute;\">{text}</div>',\n\n      /**\n       * label牵引线定义\n       * @type {String || Object}\n       */\n      labelLine: false,\n\n      /**\n       * label牵引线容器\n       * @type Object\n       */\n      lineGroup: null,\n\n      /**\n       * 需添加label的shape\n       * @type Object\n       */\n      shapes: null,\n\n      /**\n       * 默认为true。为false时指定直接用items渲染文本，不进行config\n       * @type Object\n       */\n      config: true,\n\n      /**\n       * 是否进行拾取\n       * @type Object\n       */\n      capture: true\n    });\n  };\n  /*\n   * 清空label容器\n   */\n\n\n  _proto.clear = function clear() {\n    var group = this.get('group');\n    var container = this.get('container');\n\n    if (group && !group.get('destroyed')) {\n      group.clear();\n    }\n\n    if (container) {\n      container.innerHTML = '';\n    }\n\n    _Component.prototype.clear.call(this);\n  };\n  /**\n   * 销毁group\n   */\n\n\n  _proto.destroy = function destroy() {\n    var group = this.get('group');\n    var container = this.get('container');\n\n    if (!group.destroy) {\n      group.destroy();\n    }\n\n    if (container) {\n      container.innerHTML = '';\n    }\n  };\n  /**\n   * label绘制全过程\n   */\n\n\n  _proto.render = function render() {\n    this.clear();\n\n    this._init();\n\n    this.beforeDraw();\n    this.draw();\n    this.afterDraw();\n  };\n\n  _proto._dryDraw = function _dryDraw() {\n    var self = this;\n    var items = self.get('items');\n    var children = self.getLabels();\n    var count = children.length;\n    Util.each(items, function (item, index) {\n      if (index < count) {\n        var label = children[index];\n        self.changeLabel(label, item);\n      } else {\n        var labelShape = self._addLabel(item, index);\n\n        if (labelShape) {\n          labelShape._id = item._id;\n          labelShape.set('coord', item.coord);\n        }\n      }\n    });\n\n    for (var i = count - 1; i >= items.length; i--) {\n      children[i].remove();\n    }\n\n    self._adjustLabels();\n\n    if (self.get('labelLine') || !self.get('config')) {\n      self.drawLines();\n    }\n  };\n  /**\n   * 更新label\n   * 1. 将items与group中的children对比，更新/新增/删除labels\n   * 2. labels布局优化\n   * 3. 画label连接线\n   * 4. 绘制到画布\n   */\n\n\n  _proto.draw = function draw() {\n    this._dryDraw();\n\n    this.get('canvas').draw();\n  };\n  /*\n   * 更新label\n   * oldLabel shape或label dom\n   * newLabel label data\n   * index items中的下标\n   */\n\n\n  _proto.changeLabel = function changeLabel(oldLabel, newLabel) {\n    if (!oldLabel) {\n      return;\n    }\n\n    if (oldLabel.tagName) {\n      var node = this._createDom(newLabel);\n\n      oldLabel.innerHTML = node.innerHTML;\n\n      this._setCustomPosition(newLabel, oldLabel);\n    } else {\n      oldLabel._id = newLabel._id;\n      oldLabel.attr('text', newLabel.text);\n\n      if (oldLabel.attr('x') !== newLabel.x || oldLabel.attr('y') !== newLabel.y) {\n        oldLabel.resetMatrix();\n\n        if (newLabel.textStyle.rotate) {\n          oldLabel.rotateAtStart(newLabel.textStyle.rotate);\n          delete newLabel.textStyle.rotate;\n        }\n\n        oldLabel.attr(newLabel);\n      }\n    }\n  };\n  /**\n   * 显示label\n   */\n\n\n  _proto.show = function show() {\n    var group = this.get('group');\n    var container = this.get('container');\n\n    if (group) {\n      group.show();\n    }\n\n    if (container) {\n      container.style.opacity = 1;\n    }\n  };\n  /**\n   * 隐藏label\n   */\n\n\n  _proto.hide = function hide() {\n    var group = this.get('group');\n    var container = this.get('container');\n\n    if (group) {\n      group.hide();\n    }\n\n    if (container) {\n      container.style.opacity = 0;\n    }\n  };\n  /**\n   * 画label连接线\n   */\n\n\n  _proto.drawLines = function drawLines() {\n    var self = this;\n    var lineStyle = self.get('labelLine');\n\n    if (typeof lineStyle === 'boolean') {\n      self.set('labelLine', {});\n    }\n\n    var lineGroup = self.get('lineGroup');\n\n    if (!lineGroup || lineGroup.get('destroyed')) {\n      lineGroup = self.get('group').addGroup({\n        elCls: 'x-line-group'\n      });\n      self.set('lineGroup', lineGroup);\n    } else {\n      lineGroup.clear();\n    }\n\n    Util.each(self.get('items'), function (label) {\n      self.lineToLabel(label, lineGroup);\n    });\n  };\n\n  _proto.lineToLabel = function lineToLabel(label, lineGroup) {\n    var self = this;\n\n    if (!self.get('config') && !label.labelLine) {\n      return;\n    }\n\n    var lineStyle = label.labelLine || self.get('labelLine');\n    var capture = typeof label.capture === 'undefined' ? self.get('capture') : label.capture;\n    var path = lineStyle.path;\n\n    if (path && Util.isFunction(lineStyle.path)) {\n      path = lineStyle.path(label);\n    }\n\n    if (!path) {\n      var start = label.start || {\n        x: label.x - label._offset.x,\n        y: label.y - label._offset.y\n      };\n      path = [['M', start.x, start.y], ['L', label.x, label.y]];\n    }\n\n    var stroke = label.color;\n\n    if (!stroke) {\n      if (label.textStyle && label.textStyle.fill) {\n        stroke = label.textStyle.fill;\n      } else {\n        stroke = '#000';\n      }\n    }\n\n    var lineShape = lineGroup.addShape('path', {\n      attrs: Util.mix({\n        path: path,\n        fill: null,\n        stroke: stroke\n      }, lineStyle),\n      capture: capture\n    }); // label 对应线的动画关闭\n\n    lineShape.name = self.get('name'); // generate labelLine id according to label id\n\n    lineShape._id = label._id && label._id.replace('glabel', 'glabelline');\n    lineShape.set('coord', self.get('coord'));\n  }; // 根据type对label布局\n\n\n  _proto._adjustLabels = function _adjustLabels() {\n    var self = this;\n    var type = self.get('type');\n    var labels = self.getLabels();\n    var shapes = self.get('shapes');\n    var layout = LAYOUTS[type];\n\n    if (type === 'default' || !layout) {\n      return;\n    }\n\n    layout(labels, shapes);\n  };\n  /**\n   * 获取当前所有label实例\n   * @return {Array} 当前label实例\n   */\n\n\n  _proto.getLabels = function getLabels() {\n    var container = this.get('container');\n\n    if (container) {\n      return Util.toArray(container.childNodes);\n    }\n\n    return this.get('group').get('children');\n  }; // 先计算label的所有配置项，然后生成label实例\n\n\n  _proto._addLabel = function _addLabel(item, index) {\n    var cfg = item;\n\n    if (this.get('config')) {\n      cfg = this._getLabelCfg(item, index);\n    }\n\n    return this._createText(cfg);\n  };\n\n  _proto._getLabelCfg = function _getLabelCfg(item, index) {\n    var textStyle = this.get('textStyle') || {};\n    var formatter = this.get('formatter');\n    var htmlTemplate = this.get('htmlTemplate');\n\n    if (!Util.isObject(item)) {\n      var tmp = item;\n      item = {};\n      item.text = tmp;\n    }\n\n    if (Util.isFunction(textStyle)) {\n      textStyle = textStyle(item.text, item, index);\n    }\n\n    if (formatter) {\n      item.text = formatter(item.text, item, index);\n    }\n\n    if (htmlTemplate) {\n      item.useHtml = true;\n\n      if (Util.isFunction(htmlTemplate)) {\n        item.text = htmlTemplate(item.text, item, index);\n      }\n    }\n\n    if (Util.isNil(item.text)) {\n      item.text = '';\n    }\n\n    item.text = item.text + ''; // ? 为什么转换为字符串\n\n    var cfg = Util.mix({}, item, {\n      textStyle: textStyle\n    }, {\n      x: item.x || 0,\n      y: item.y || 0\n    });\n    return cfg;\n  };\n  /**\n   * label初始化，主要针对html容器\n   */\n\n\n  _proto._init = function _init() {\n    if (!this.get('group')) {\n      var group = this.get('canvas').addGroup({\n        id: 'label-group'\n      });\n      this.set('group', group);\n    }\n  };\n\n  _proto.initHtmlContainer = function initHtmlContainer() {\n    var container = this.get('container');\n\n    if (!container) {\n      var containerTpl = this.get('containerTpl');\n      var wrapper = this.get('canvas').get('el').parentNode;\n      container = DomUtil.createDom(containerTpl);\n      wrapper.style.position = 'relative';\n      wrapper.appendChild(container);\n      this.set('container', container);\n    } else if (Util.isString(container)) {\n      container = document.getElementById(container);\n\n      if (container) {\n        this.set('container', container);\n      }\n    }\n\n    return container;\n  }; // 分html dom和G shape两种情况生成label实例\n\n\n  _proto._createText = function _createText(cfg) {\n    var container = this.get('container');\n    var capture = typeof cfg.capture === 'undefined' ? this.get('capture') : cfg.capture;\n    var labelShape;\n\n    if (cfg.useHtml || cfg.htmlTemplate) {\n      if (!container) {\n        container = this.initHtmlContainer();\n      }\n\n      var node = this._createDom(cfg);\n\n      container.appendChild(node);\n\n      this._setCustomPosition(cfg, node);\n    } else {\n      var name = this.get('name');\n      var origin = cfg.point;\n      var group = this.get('group');\n      delete cfg.point; // 临时解决，否则影响动画\n\n      var rotate = cfg.rotate; // textStyle中的rotate虽然可以正常画出，但是在做动画的时候可能会导致动画异常。移出，在定义好shape后通过transform实现效果。\n\n      if (cfg.textStyle) {\n        if (cfg.textStyle.rotate) {\n          rotate = cfg.textStyle.rotate;\n          delete cfg.textStyle.rotate;\n        }\n\n        cfg = Util.mix({\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          text: cfg.text\n        }, cfg.textStyle);\n      }\n\n      labelShape = group.addShape('text', {\n        attrs: cfg,\n        capture: capture\n      });\n\n      if (rotate) {\n        // rotate是用角度定义的，转换为弧度\n        if (Math.abs(rotate) > Math.PI * 2) {\n          rotate = rotate / 180 * Math.PI;\n        }\n\n        labelShape.transform([['t', -cfg.x, -cfg.y], ['r', rotate], ['t', cfg.x, cfg.y]]);\n      }\n\n      labelShape.setSilent('origin', origin || cfg);\n      labelShape.name = name; // 用于事件标注\n\n      this.get('appendInfo') && labelShape.setSilent('appendInfo', this.get('appendInfo'));\n      return labelShape;\n    }\n  };\n\n  _proto._createDom = function _createDom(cfg) {\n    var itemTpl = this.get('itemTpl');\n    var str = Util.substitute(itemTpl, {\n      text: cfg.text\n    });\n    return DomUtil.createDom(str);\n  }; // 根据文本对齐方式确定dom位置\n\n\n  _proto._setCustomPosition = function _setCustomPosition(cfg, htmlDom) {\n    var textAlign = cfg.textAlign || 'left';\n    var top = cfg.y;\n    var left = cfg.x;\n    var width = DomUtil.getOuterWidth(htmlDom);\n    var height = DomUtil.getOuterHeight(htmlDom);\n    top = top - height / 2;\n\n    if (textAlign === 'center') {\n      left = left - width / 2;\n    } else if (textAlign === 'right') {\n      left = left - width;\n    }\n\n    htmlDom.style.top = parseInt(top, 10) + 'px';\n    htmlDom.style.left = parseInt(left, 10) + 'px';\n  };\n\n  return Label;\n}(Component);\n\nmodule.exports = Label;\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports) {\n\nvar Greedy =\n/*#__PURE__*/\nfunction () {\n  function Greedy() {\n    this.bitmap = [];\n  }\n\n  var _proto = Greedy.prototype;\n\n  _proto.hasGap = function hasGap(bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.floor(bbox.minX);\n    var maxX = Math.ceil(bbox.maxX);\n    var minY = Math.floor(bbox.minY);\n    var maxY = Math.ceil(bbox.maxY) - 1;\n\n    for (var i = minX; i < maxX; i++) {\n      if (!bitmap[i]) {\n        bitmap[i] = [];\n        continue;\n      }\n\n      if (i === minX || i === maxX - 1) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n\n    return hasGap;\n  };\n\n  _proto.fillGap = function fillGap(bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.floor(bbox.minX);\n    var maxX = Math.ceil(bbox.maxX) - 1;\n    var minY = Math.floor(bbox.minY);\n    var maxY = Math.ceil(bbox.maxY) - 1;\n\n    for (var i = minX; i <= maxX; i++) {\n      for (var j = minY; j < maxY; j += 8) {\n        if (!bitmap[i]) {\n          bitmap[i] = [];\n        }\n\n        bitmap[i][j] = true;\n      }\n\n      bitmap[i][maxY] = true;\n    }\n\n    for (var _i = minY; _i <= maxY; _i++) {\n      bitmap[minX][_i] = true;\n      bitmap[maxX][_i] = true;\n    }\n  };\n\n  return Greedy;\n}();\n\nmodule.exports = Greedy;\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(3);\n\nmodule.exports = {\n  getFirstScale: function getFirstScale(scales) {\n    var firstScale;\n    Util.each(scales, function (scale) {\n      if (scale) {\n        firstScale = scale;\n        return false;\n      }\n    });\n    return firstScale;\n  }\n};\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Legend = __webpack_require__(158);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY; // const DomUtil = Util.DomUtil;\n\n\nvar Event = Util.Event;\nvar Group = Util.Group; // const Global = require('../../global');\n// const CONTAINER_CLASS = 'g2-legend';\n\nfunction findItem(items, refer) {\n  var rst = null;\n  var value = refer instanceof Group || refer.name === 'legendGroup' ? refer.get('value') : refer;\n  Util.each(items, function (item) {\n    if (item.value === value) {\n      rst = item;\n      return false;\n    }\n  });\n  return rst;\n}\n\nfunction findShapeByName(group, name) {\n  return group.findBy(function (node) {\n    return node.name === name;\n  });\n}\n\nvar Category =\n/*#__PURE__*/\nfunction (_Legend) {\n  _inheritsLoose(Category, _Legend);\n\n  function Category() {\n    return _Legend.apply(this, arguments) || this;\n  }\n\n  var _proto = Category.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Legend.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * type标识\n       * @type {String}\n       */\n      type: 'category-legend',\n\n      /**\n       * 子项集合\n       * @type {Array}\n       */\n      items: null,\n\n      /**\n       * TODO：rename\n       * 图例项水平方向的间距\n       * @type {Number}\n       */\n      itemGap: 5,\n\n      /**\n       * TODO：rename\n       * 图例项垂直方向的间距\n       * @type {Number}\n       */\n      itemMarginBottom: 8,\n\n      /**\n       * 图例项图组\n       * @type {Group}\n       */\n      itemsGroup: null,\n\n      /**\n       * 布局方式： horizontal，vertical\n       * @type {String}\n       */\n      layout: 'horizontal',\n\n      /**\n       * 是否允许全部取消，默认 false，即必须保留一个被选中\n       * @type {Boolean}\n       */\n      allowAllCanceled: false,\n\n      /**\n       * 边框内边距\n       * @type {Array}\n       */\n      backPadding: [0, 0, 0, 0],\n\n      /**\n       * 图例项取消选中的颜色\n       * @type {String}\n       */\n      unCheckColor: '#ccc',\n\n      /**\n       * 图例背景层属性设置\n       * @type {Obejct}\n       */\n      background: {\n        fill: '#fff',\n        fillOpacity: 0\n      },\n\n      /**\n       * 图例项的宽度，当图例有很多图例项，并且用户想要这些图例项在同一平面内垂直对齐，此时这个属性可帮用户实现此效果\n       * @type {Number}\n       */\n      itemWidth: null,\n\n      /**\n       * 图例文字样式\n       * @type {ATTRS}\n       */\n      textStyle: {\n        fill: '#333',\n        fontSize: 12,\n        textAlign: 'start',\n        textBaseline: 'middle',\n        fontFamily: FONT_FAMILY\n      },\n\n      /**\n       * marker 和文字的距离\n       * @type {Number}\n       */\n      _wordSpaceing: 8,\n\n      /**\n       * 图例项是否可点击，默认为 true\n       * @type {Boolean}\n       */\n      clickable: true,\n\n      /**\n       * TODO: rename\n       * 图例项的选择模式，多选和单选 multiple、single\n       * @type {String}\n       */\n      selectedMode: 'multiple',\n\n      /**\n       * 图例项的顺序是否要逆序，默认为 false\n       * @type {Boolean}\n       */\n      reversed: false,\n\n      /**\n       * 是否自动换行\n       * @type {Boolean}\n       */\n      autoWrap: true,\n\n      /**\n       * 是否以增加 border 的方式高亮 hover 的 item。若为 false ，则降低其他 item 的透明度。\n       * @type {Boolean}\n       */\n      highlight: false,\n\n      /**\n       * 非highlight方式下，鼠标hover到legend样式\n       * @type {Number}\n       */\n      activeOpacity: 0.7,\n\n      /**\n       * 非highlight方式下，非鼠标hover到的legend样式\n       * @type {Number}\n       */\n      inactiveOpacity: 1\n    });\n  }; // rendering\n\n\n  _proto.render = function render() {\n    _Legend.prototype.render.call(this);\n\n    this._renderItems();\n\n    this.get('autoWrap') && this._adjustItems(); // 默认自动换行\n  }; // user iteraction\n\n\n  _proto._bindEvents = function _bindEvents() {\n    if (this.get('hoverable')) {\n      this.get('group').on('mousemove', Util.wrapBehavior(this, '_onMousemove'));\n      this.get('group').on('mouseleave', Util.wrapBehavior(this, '_onMouseleave'));\n    }\n\n    if (this.get('clickable')) {\n      this.get('group').on('click', Util.wrapBehavior(this, '_onClick'));\n    }\n  }; // return the target's parent legend object\n\n\n  _proto._getLegendItem = function _getLegendItem(target) {\n    var item = target.get('parent');\n\n    if (item && item.name === 'legendGroup') {\n      return item;\n    }\n\n    return null;\n  }; // activate an item by reduce the opacity of other items.\n  // it is reserved for bi-direction interaction between charts / graph and legend\n\n\n  _proto.activate = function activate(value) {\n    var _this = this;\n\n    var self = this;\n    var itemsGroup = self.get('itemsGroup');\n    var children = itemsGroup.get('children');\n    var markerItem = void 0;\n    children.forEach(function (child) {\n      markerItem = findShapeByName(child, 'legend-marker');\n      if (!markerItem) return;\n      var checked = child.get('checked');\n\n      if (_this.get('highlight')) {\n        // change stroke color\n        if (child.get('value') === value && checked) {\n          markerItem.attr('stroke', '#333');\n        } else {\n          markerItem.attr('stroke', null);\n        }\n      } else {\n        // change opacity\n        if (child.get('value') === value) {\n          markerItem.attr('fillOpacity', self.get('activeOpacity'));\n        }\n      }\n    });\n    this.get('canvas').draw();\n    return;\n  }; // restore the opacity of items\n  // it is reserved for bi-direction interaction between charts / graph and legend\n\n\n  _proto.deactivate = function deactivate() {\n    var _this2 = this;\n\n    var self = this;\n    var itemsGroup = self.get('itemsGroup');\n    var children = itemsGroup.get('children');\n    var markerItem = void 0;\n    var unCheckColor = this.get('unCheckColor');\n    children.forEach(function (child) {\n      markerItem = findShapeByName(child, 'legend-marker');\n      if (!markerItem) return;\n\n      if (_this2.get('highlight')) {\n        var oriStroke = markerItem.get('oriStroke');\n        var checked = child.get('checked');\n        if (oriStroke && !checked) oriStroke = unCheckColor;else oriStroke = '';\n        markerItem.attr('stroke', oriStroke);\n      } else {\n        markerItem.attr('fillOpacity', self.get('inactiveOpacity'));\n      }\n    });\n    this.get('canvas').draw();\n    return;\n  }; // mouse move listener of an item\n  // when mouse over an item, reduce the opacity of the other items.\n\n\n  _proto._onMousemove = function _onMousemove(ev) {\n    var item = this._getLegendItem(ev.currentTarget);\n\n    if (item && item.get('checked')) {\n      var items = this.get('items');\n      var itemhover = new Event('itemhover', ev, true, true);\n      itemhover.item = findItem(items, item);\n      itemhover.checked = item.get('checked');\n      itemhover.currentTarget = ev.currentTarget; // change the opacity of other items\n\n      this.deactivate();\n      this.activate(item.get('value'));\n      this.emit('itemhover', itemhover);\n    } else {\n      this.deactivate();\n      this.emit('itemunhover', ev);\n    }\n\n    this.get('canvas').draw();\n    return;\n  }; // mouse leave listener of an item\n\n\n  _proto._onMouseleave = function _onMouseleave(ev) {\n    this.deactivate();\n    this.get('canvas').draw();\n    this.emit('itemunhover', ev);\n    return;\n  }; // the click listener of an item\n\n\n  _proto._onClick = function _onClick(ev) {\n    var clickedItem = this._getLegendItem(ev.currentTarget);\n\n    var items = this.get('items');\n\n    if (clickedItem && !clickedItem.get('destroyed')) {\n      var checked = clickedItem.get('checked');\n      var mode = this.get('selectedMode');\n      var item = findItem(items, clickedItem);\n      var itemclick = new Event('itemclick', ev, true, true);\n      itemclick.item = item;\n      itemclick.currentTarget = clickedItem;\n      itemclick.appendInfo = ev.currentTarget.get('appendInfo');\n      itemclick.checked = mode === 'single' ? true : !checked;\n\n      if (!this.get('allowAllCanceled') && checked && this.getCheckedCount() === 1) {\n        this.emit('clicklastitem', itemclick);\n        return;\n      }\n\n      var unCheckColor = this.get('unCheckColor');\n      var checkColor = this.get('textStyle').fill;\n      var markerItem = void 0;\n      var textItem = void 0;\n      var legendItem = void 0;\n\n      if (mode === 'single') {\n        var itemsGroup = this.get('itemsGroup');\n        var children = itemsGroup.get('children');\n        Util.each(children, function (child) {\n          markerItem = findShapeByName(child, 'legend-marker');\n          textItem = findShapeByName(child, 'legend-text');\n          legendItem = findShapeByName(child, 'legend-item');\n\n          if (child !== clickedItem) {\n            if (markerItem.attr('fill')) {\n              markerItem.attr('fill', unCheckColor);\n            }\n\n            if (markerItem.attr('stroke')) {\n              markerItem.attr('stroke', unCheckColor);\n            }\n\n            textItem.attr('fill', unCheckColor);\n            markerItem.setSilent('checked', false);\n            textItem.setSilent('checked', false);\n            legendItem.setSilent('checked', false);\n            child.setSilent('checked', false);\n          } else {\n            if (markerItem.attr('fill')) {\n              item && item.marker && markerItem.attr('fill', item.marker.fill);\n            }\n\n            if (markerItem.attr('stroke')) {\n              item && item.marker && markerItem.attr('stroke', item.marker.stroke);\n            }\n\n            textItem.attr('fill', checkColor);\n            markerItem.setSilent('checked', true);\n            textItem.setSilent('checked', true);\n            legendItem.setSilent('checked', true);\n            child.setSilent('checked', true);\n          }\n        });\n      } else {\n        markerItem = findShapeByName(clickedItem, 'legend-marker');\n        textItem = findShapeByName(clickedItem, 'legend-text');\n        legendItem = findShapeByName(clickedItem, 'legend-item');\n\n        if (markerItem.attr('fill')) {\n          item && item.marker && markerItem.attr('fill', checked ? unCheckColor : item.marker.fill);\n        }\n\n        if (markerItem.attr('stroke')) {\n          item && item.marker && markerItem.attr('stroke', checked ? unCheckColor : item.marker.stroke);\n        }\n\n        textItem.attr('fill', checked ? unCheckColor : checkColor);\n        clickedItem.setSilent('checked', !checked);\n        markerItem.setSilent('checked', !checked);\n        textItem.setSilent('checked', !checked);\n        legendItem.setSilent('checked', !checked);\n      }\n\n      this.emit('itemclick', itemclick);\n    }\n\n    this.get('canvas').draw();\n    return;\n  }; // render the items\n\n\n  _proto._renderItems = function _renderItems() {\n    var _this3 = this;\n\n    var items = this.get('items');\n\n    if (this.get('reversed')) {\n      items.reverse();\n    }\n\n    Util.each(items, function (item, index) {\n      _this3._addItem(item, index);\n    });\n\n    if (this.get('highlight')) {\n      var itemsGroup = this.get('itemsGroup');\n      var children = itemsGroup.get('children');\n      var markerItem = void 0;\n      children.forEach(function (child) {\n        markerItem = findShapeByName(child, 'legend-marker');\n        var oriStroke = markerItem.get('oriStroke');\n\n        if (!oriStroke) {\n          if (markerItem.attr('stroke')) markerItem.set('oriStroke', markerItem.attr('stroke'));else markerItem.set('oriStroke', '');\n        }\n      });\n    }\n  }; // format the item value\n\n\n  _proto._formatItemValue = function _formatItemValue(value) {\n    var formatter = this.get('formatter') || this.get('itemFormatter');\n\n    if (formatter) {\n      value = formatter.call(this, value);\n    }\n\n    return value;\n  }; // find x of next item\n\n\n  _proto._getNextX = function _getNextX() {\n    var layout = this.get('layout');\n    var itemGap = this.get('itemGap');\n    var itemsGroup = this.get('itemsGroup');\n    var itemWidth = this.get('itemWidth');\n    var children = itemsGroup.get('children');\n    var nextX = 0;\n\n    if (layout === 'horizontal') {\n      // 水平布局\n      Util.each(children, function (v) {\n        nextX += (itemWidth ? itemWidth : v.getBBox().width) + itemGap;\n      });\n    }\n\n    return nextX;\n  }; // find y of next item\n\n\n  _proto._getNextY = function _getNextY() {\n    var itemMarginBottom = this.get('itemMarginBottom');\n    var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;\n    var layout = this.get('layout');\n    var itemsGroup = this.get('itemsGroup');\n    var titleShape = this.get('titleShape');\n    var children = itemsGroup.get('children');\n    var nextY = titleGap;\n\n    if (titleShape) {\n      nextY += titleShape.getBBox().height;\n    }\n\n    if (layout === 'vertical') {\n      // 竖直布局\n      Util.each(children, function (v) {\n        nextY += v.getBBox().height + itemMarginBottom;\n      });\n    }\n\n    return nextY;\n  }; // add an item to the canvas\n\n\n  _proto._addItem = function _addItem(item) {\n    var itemsGroup = this.get('itemsGroup');\n\n    var x = this._getNextX();\n\n    var y = this._getNextY();\n\n    var unCheckColor = this.get('unCheckColor');\n    var itemGroup = itemsGroup.addGroup({\n      x: x,\n      y: y,\n      value: item.value,\n      checked: item.checked\n    }); // @2018-10-20 by blue.lb 需要设置viewId，否则在emit的时候，parent获取不到viewId\n\n    itemGroup.set('viewId', this.get('viewId'));\n    var textStyle = this.get('textStyle');\n    var wordSpace = this.get('_wordSpaceing');\n    var startX = 0;\n\n    if (item.marker) {\n      // 如果有marker添加marker\n      var markerAttrs = Util.mix({}, item.marker, {\n        x: item.marker.radius + x,\n        y: y\n      });\n\n      if (!item.checked) {\n        if (markerAttrs.fill) {\n          markerAttrs.fill = unCheckColor;\n        }\n\n        if (markerAttrs.stroke) {\n          markerAttrs.stroke = unCheckColor;\n        }\n      }\n\n      var markerShape = itemGroup.addShape('marker', {\n        type: 'marker',\n        attrs: markerAttrs\n      });\n      markerShape.attr('cursor', 'pointer');\n      markerShape.name = 'legend-marker';\n      startX += markerShape.getBBox().width + wordSpace;\n    }\n\n    var textAttrs = Util.mix({}, {\n      fill: '#333',\n      fontSize: 12,\n      textAlign: 'start',\n      textBaseline: 'middle',\n      fontFamily: FONT_FAMILY\n    }, textStyle, {\n      x: startX + x,\n      y: y,\n      text: this._formatItemValue(item.value)\n    });\n\n    if (!item.checked) {\n      Util.mix(textAttrs, {\n        fill: unCheckColor\n      });\n    }\n\n    var textShape = itemGroup.addShape('text', {\n      attrs: textAttrs\n    });\n    textShape.attr('cursor', 'pointer');\n    textShape.name = 'legend-text';\n    this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 添加一个包围矩形，用于事件支持\n\n    var bbox = itemGroup.getBBox();\n    var itemWidth = this.get('itemWidth');\n    var wrapperShape = itemGroup.addShape('rect', {\n      attrs: {\n        x: x,\n        y: y - bbox.height / 2,\n        fill: '#fff',\n        fillOpacity: 0,\n        width: itemWidth || bbox.width,\n        height: bbox.height\n      }\n    });\n    wrapperShape.attr('cursor', 'pointer');\n    wrapperShape.setSilent('origin', item); // 保存图例项相关的数据，便于事件操作\n\n    wrapperShape.name = 'legend-item';\n    this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));\n    itemGroup.name = 'legendGroup';\n    return itemGroup;\n  }; // auto break the line for horizontal layout\n\n\n  _proto._adjustHorizontal = function _adjustHorizontal() {\n    var itemsGroup = this.get('itemsGroup');\n    var children = itemsGroup.get('children');\n    var maxLength = this.get('maxLength');\n    var itemGap = this.get('itemGap');\n    var itemMarginBottom = this.get('itemMarginBottom');\n    var titleGap = this.get('titleShape') ? this.get('titleGap') : 0;\n    var row = 0;\n    var rowLength = 0;\n    var width = void 0;\n    var height = void 0;\n    var box = void 0;\n    var itemWidth = this.get('itemWidth');\n\n    if (itemsGroup.getBBox().width > maxLength) {\n      Util.each(children, function (child) {\n        box = child.getBBox();\n        width = itemWidth || box.width;\n        height = box.height + itemMarginBottom;\n\n        if (maxLength - rowLength < width) {\n          row++;\n          rowLength = 0;\n        }\n\n        child.move(rowLength, row * height + titleGap);\n        rowLength += width + itemGap;\n      });\n    }\n\n    return;\n  }; // auto break the column for vertical layout\n\n\n  _proto._adjustVertical = function _adjustVertical() {\n    var itemsGroup = this.get('itemsGroup');\n    var titleShape = this.get('titleShape');\n    var children = itemsGroup.get('children');\n    var maxLength = this.get('maxLength'); // 垂直布局，则 maxLength 代表容器的高度\n\n    var itemGap = this.get('itemGap');\n    var itemMarginBottom = this.get('itemMarginBottom');\n    var titleGap = this.get('titleGap');\n    var titleHeight = titleShape ? titleShape.getBBox().height + titleGap : 0;\n    var itemWidth = this.get('itemWidth');\n    var colLength = titleHeight;\n    var width = void 0;\n    var height = void 0;\n    var box = void 0;\n    var maxItemWidth = 0;\n    var totalLength = 0;\n\n    if (itemsGroup.getBBox().height > maxLength) {\n      Util.each(children, function (v) {\n        box = v.getBBox();\n        width = box.width;\n        height = box.height;\n\n        if (itemWidth) {\n          maxItemWidth = itemWidth + itemGap;\n        } else if (width > maxItemWidth) {\n          maxItemWidth = width + itemGap;\n        }\n\n        if (maxLength - colLength < height) {\n          colLength = titleHeight;\n          totalLength += maxItemWidth;\n          v.move(totalLength, titleHeight);\n        } else {\n          v.move(totalLength, colLength);\n        }\n\n        colLength += height + itemMarginBottom;\n      });\n    }\n\n    return;\n  }; // automatically break the line / column while the width / height exceeds maxLength\n\n\n  _proto._adjustItems = function _adjustItems() {\n    var layout = this.get('layout');\n\n    if (layout === 'horizontal') {\n      this._adjustHorizontal();\n    } else {\n      this._adjustVertical();\n    }\n  };\n\n  _proto.getWidth = function getWidth() {\n    return _Legend.prototype.getWidth.call(this);\n  };\n\n  _proto.getHeight = function getHeight() {\n    return _Legend.prototype.getHeight.call(this);\n  };\n\n  _proto.move = function move(x, y) {\n    _Legend.prototype.move.call(this, x, y);\n  };\n\n  return Category;\n}(Legend);\n\nmodule.exports = Category;\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Component = __webpack_require__(32);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar Legend =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Legend, _Component);\n\n  var _proto = Legend.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * Group 容器\n       * @type {Object}\n       */\n      container: null,\n\n      /**\n       * 图例标题配置\n       * @type {Object}\n       */\n      title: null,\n\n      /**\n       * 图例项文本格式化\n       * @type {Function}\n       */\n      formatter: null,\n\n      /**\n       * 鼠标 hover 到图例上的默认交互是否开启\n       * @type {Boolean}\n       */\n      hoverable: true,\n\n      /**\n       * TODO：rename\n       * 图例标题距离图例项的距离\n       * @type {Number}\n       */\n      titleGap: 15,\n\n      /**\n       * legend 相对于 container 的位置\n       * @type {Array}\n       */\n      position: [0, 0],\n\n      /**\n       * legend 在 position 位置上的偏移量\n       * @type {Array}\n       */\n      offset: [0, 0],\n\n      /**\n       * legend 在 position 位置上沿 x 轴的偏移量。若同时设置了 offset 和 offsetX， 以 offsetX 为准\n       * @type {Number}\n       */\n      offsetX: null,\n\n      /**\n       * legend 在 position 位置上沿 y 轴的偏移量。若同时设置了 offset 和 offsetY， 以 offsetY 为准\n       * @type {Number}\n       */\n      offsetY: null\n    };\n  };\n\n  function Legend(cfg) {\n    var _this;\n\n    _this = _Component.call(this, cfg) || this;\n\n    _this._init();\n\n    _this.beforeRender();\n\n    _this.render();\n\n    _this._adjustPositionOffset();\n\n    _this._bindEvents();\n\n    return _this;\n  }\n\n  _proto._init = function _init() {\n    var group = this.get('group');\n    var container = this.get('container');\n    this.set('canvas', container.get('canvas'));\n    var position = this.get('position');\n    if (!group) group = container.addGroup({\n      x: 0 - position[0],\n      y: 0 - position[1]\n    });\n    this.set('group', group);\n  };\n\n  _proto._adjustPositionOffset = function _adjustPositionOffset() {\n    var position = this.get('position');\n    var offset = this.get('offset');\n    var offsetX = this.get('offsetX');\n    var offsetY = this.get('offsetY');\n\n    if (!Util.isArray(offset)) {\n      var layout = this.get('layout');\n      offset = layout === 'vertical' ? [offset, 0] : [0, offset];\n    }\n\n    if (offsetX) offset[0] = offsetX;\n    if (offsetY) offset[1] = offsetY;\n    var bbox = this.get('group').getBBox();\n    this.move(-bbox.minX + position[0] + offset[0], -bbox.minY + position[1] + offset[1]);\n  };\n\n  _proto.beforeRender = function beforeRender() {\n    var group = this.get('group');\n    var itemsGroup = group.addGroup();\n    this.set('itemsGroup', itemsGroup);\n  };\n\n  _proto.render = function render() {\n    this._renderTitle();\n  }; // render the title of the legend\n\n\n  _proto._renderTitle = function _renderTitle() {\n    var title = this.get('title');\n    var titleGap = this.get('titleGap');\n    titleGap = titleGap || 0;\n\n    if (title && title.text) {\n      var group = this.get('group');\n      var titleShape = group.addShape('text', {\n        attrs: Util.mix({\n          x: 0,\n          y: 0 - titleGap,\n          fill: '#333',\n          textBaseline: 'middle',\n          fontFamily: FONT_FAMILY\n        }, title)\n      });\n      titleShape.name = 'legend-title';\n      this.get('appendInfo') && titleShape.setSilent('appendInfo', this.get('appendInfo'));\n      this.set('titleShape', titleShape);\n    }\n  }; // return the count of checked items\n\n\n  _proto.getCheckedCount = function getCheckedCount() {\n    var itemsGroup = this.get('itemsGroup');\n    var items = itemsGroup.get('children');\n    var checkedArr = Util.filter(items, function (item) {\n      return item.get('checked');\n    });\n    return checkedArr.length;\n  }; // set items for the legend\n\n\n  _proto.setItems = function setItems(items) {\n    this.set('items', items);\n    this.clear();\n    this.render();\n  }; // add an item into the legend\n\n\n  _proto.addItem = function addItem(item) {\n    var items = this.get('items');\n    items.push(item);\n    this.clear();\n    this.render();\n  }; // clear all the items of the legend\n\n\n  _proto.clear = function clear() {\n    var itemsGroup = this.get('itemsGroup');\n    itemsGroup.clear();\n    var group = this.get('group');\n    group.clear();\n    this.beforeRender();\n  }; // destroy the legend\n\n\n  _proto.destroy = function destroy() {\n    var group = this.get('group');\n    group.destroy();\n    this._attrs = {};\n    this.removeAllListeners();\n    this.destroyed = true;\n  }; // return the width of the legend\n\n\n  _proto.getWidth = function getWidth() {\n    var bbox = this.get('group').getBBox();\n    return bbox.width;\n  }; // return the height of the legend\n\n\n  _proto.getHeight = function getHeight() {\n    var bbox = this.get('group').getBBox();\n    return bbox.height;\n  };\n\n  _proto.move = function move(x, y) {\n    this.get('group').move(x, y);\n  };\n\n  _proto.draw = function draw() {\n    this.get('canvas').draw();\n  };\n\n  return Legend;\n}(Component);\n\nmodule.exports = Legend;\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Category = __webpack_require__(157);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar DomUtil = Util.DomUtil;\nvar Group = Util.Group;\nvar CONTAINER_CLASS = 'g2-legend';\nvar TITLE_CLASS = 'g2-legend-title';\nvar LIST_CLASS = 'g2-legend-list';\nvar ITEM_CLASS = 'g2-legend-list-item';\nvar TEXT_CLASS = 'g2-legend-text';\nvar MARKER_CLASS = 'g2-legend-marker'; // find a dom node from the chidren of the node with className.\n\nfunction findNodeByClass(node, className) {\n  return node.getElementsByClassName(className)[0];\n}\n\nfunction getParentNode(node, className) {\n  var nodeClass = node.className;\n\n  if (Util.isNil(nodeClass)) {\n    return node;\n  }\n\n  nodeClass = nodeClass.split(' ');\n\n  if (nodeClass.indexOf(className) > -1) {\n    return node;\n  }\n\n  if (node.parentNode) {\n    if (node.parentNode.className === CONTAINER_CLASS) {\n      return node.parentNode;\n    }\n\n    return getParentNode(node.parentNode, className);\n  }\n\n  return null;\n}\n\nfunction findItem(items, refer) {\n  var rst = null;\n  var value = refer instanceof Group ? refer.get('value') : refer;\n  Util.each(items, function (item) {\n    if (item.value === value) {\n      rst = item;\n      return false;\n    }\n  });\n  return rst;\n}\n\nvar CatHtml =\n/*#__PURE__*/\nfunction (_Category) {\n  _inheritsLoose(CatHtml, _Category);\n\n  function CatHtml() {\n    return _Category.apply(this, arguments) || this;\n  }\n\n  var _proto = CatHtml.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Category.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * type 标识\n       * @type {String}\n       */\n      type: 'category-legend',\n\n      /**\n       * html 容器\n       * @type {DOM}\n       */\n      container: null,\n\n      /**\n       * 使用html时的外层模板\n       * @type {String}\n       */\n      containerTpl: '<div class=\"' + CONTAINER_CLASS + '\">' + '<h4 class=\"' + TITLE_CLASS + '\"></h4>' + '<ul class=\"' + LIST_CLASS + '\"></ul>' + '</div>',\n\n      /**\n       * html 模板\n       * @type {String|Function}\n       */\n      itemTpl: '<li class=\"' + ITEM_CLASS + ' item-{index} {checked}\" data-color=\"{originColor}\" data-value=\"{originValue}\">' + '<i class=\"' + MARKER_CLASS + '\" style=\"background-color:{color};\"></i>' + '<span class=\"' + TEXT_CLASS + '\">{value}</span></li>',\n\n      /**\n       * html style\n       * @type {Attrs}\n       */\n      legendStyle: {},\n\n      /**\n       * 图例文字样式\n       * @type {ATTRS}\n       */\n      textStyle: {\n        fill: '#333',\n        fontSize: 12,\n        textAlign: 'middle',\n        textBaseline: 'top',\n        fontFamily: FONT_FAMILY\n      },\n\n      /**\n       * 当文本太长时是否进行缩略\n       * @type {Boolean}\n       */\n      abridgeText: false,\n\n      /**\n       * abridgeText 为 true 时，鼠标放置在 item 上时显示全称的悬浮 div 的 html 模板\n       * @type {String}\n       */\n      tipTpl: '<div class=\"textTip\"></div>',\n\n      /**\n       * abridgeText 为 true 时，鼠标放置在 item 上时显示全称的悬浮 div 的样式\n       * @type {Attrs}\n       */\n      tipStyle: {\n        display: 'none',\n        fontSize: '12px',\n        backgroundColor: '#fff',\n        position: 'absolute',\n        width: 'auto',\n        height: 'auto',\n        padding: '3px',\n        boxShadow: '2px 2px 5px #888'\n      },\n\n      /**\n       * useHtml 为 true 时生效，用于自动定位\n       * @type {[type]}\n       */\n      autoPosition: true\n    });\n  };\n\n  _proto._init = function _init() {\n    return;\n  };\n\n  _proto.beforeRender = function beforeRender() {\n    return;\n  };\n\n  _proto.render = function render() {\n    this._renderHTML();\n  }; // user interaction\n\n\n  _proto._bindEvents = function _bindEvents() {\n    var _this = this;\n\n    var legendWrapper = this.get('legendWrapper');\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);\n\n    if (this.get('hoverable')) {\n      itemListDom.onmousemove = function (ev) {\n        return _this._onMousemove(ev);\n      };\n\n      itemListDom.onmouseout = function (ev) {\n        return _this._onMouseleave(ev);\n      };\n    }\n\n    if (this.get('clickable')) {\n      itemListDom.onclick = function (ev) {\n        return _this._onClick(ev);\n      };\n    }\n  }; // mouse move listener of an item\n  // when mouse over an item, reduce the opacity of the other items.\n\n\n  _proto._onMousemove = function _onMousemove(ev) {\n    var items = this.get('items');\n    var target = ev.target;\n    var targetClass = target.className;\n    targetClass = targetClass.split(' ');\n\n    if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {\n      return;\n    }\n\n    var parentDom = getParentNode(target, ITEM_CLASS);\n    var hoveredItem = findItem(items, parentDom.getAttribute('data-value'));\n\n    if (hoveredItem) {\n      // change the opacity of other items\n      this.deactivate();\n      this.activate(parentDom.getAttribute('data-value'));\n      this.emit('itemhover', {\n        item: hoveredItem,\n        currentTarget: parentDom,\n        checked: hoveredItem.checked\n      });\n    } else if (!hoveredItem) {\n      // restore the opacity of all the items\n      this.deactivate();\n      this.emit('itemunhover', ev);\n    }\n\n    return;\n  }; // mouse leave listener of an item\n\n\n  _proto._onMouseleave = function _onMouseleave(ev) {\n    // restore the opacity of all the items when mouse leave\n    this.deactivate();\n    this.emit('itemunhover', ev);\n    return;\n  }; // the click listener of an item\n\n\n  _proto._onClick = function _onClick(ev) {\n    var _this2 = this;\n\n    var legendWrapper = this.get('legendWrapper');\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);\n    var unCheckedColor = this.get('unCheckColor');\n    var items = this.get('items');\n    var mode = this.get('selectedMode');\n    var childNodes = itemListDom.childNodes;\n    var target = ev.target;\n    var targetClass = target.className;\n    targetClass = targetClass.split(' ');\n\n    if (targetClass.indexOf(CONTAINER_CLASS) > -1 || targetClass.indexOf(LIST_CLASS) > -1) {\n      return;\n    }\n\n    var parentDom = getParentNode(target, ITEM_CLASS);\n    var textDom = findNodeByClass(parentDom, TEXT_CLASS);\n    var markerDom = findNodeByClass(parentDom, MARKER_CLASS);\n    var clickedItem = findItem(items, parentDom.getAttribute('data-value'));\n\n    if (!clickedItem) {\n      return;\n    }\n\n    var domClass = parentDom.className;\n    var originColor = parentDom.getAttribute('data-color');\n\n    if (mode === 'single') {\n      // 单选模式\n      // update checked status\n      clickedItem.checked = true; // 其他图例项全部置灰\n\n      Util.each(childNodes, function (child) {\n        if (child !== parentDom) {\n          var childMarkerDom = findNodeByClass(child, MARKER_CLASS);\n          childMarkerDom.style.backgroundColor = unCheckedColor;\n          child.className = child.className.replace('checked', 'unChecked');\n          child.style.color = unCheckedColor;\n          var childItem = findItem(items, child.getAttribute('data-value'));\n          childItem.checked = false;\n        } else {\n          if (textDom) {\n            textDom.style.color = _this2.get('textStyle').fill;\n          }\n\n          if (markerDom) {\n            markerDom.style.backgroundColor = originColor;\n          }\n\n          parentDom.className = domClass.replace('unChecked', 'checked');\n        }\n      });\n    } else {\n      // 混合模式\n      var clickedItemChecked = domClass.indexOf('checked') !== -1; // domClass.includes('checked');\n\n      var count = 0;\n      Util.each(childNodes, function (child) {\n        if (child.className.indexOf('checked') !== -1) {\n          // .includes('checked')\n          count++;\n        }\n      });\n\n      if (!this.get('allowAllCanceled') && clickedItemChecked && count === 1) {\n        this.emit('clicklastitem', {\n          item: clickedItem,\n          currentTarget: parentDom,\n          checked: mode === 'single' ? true : clickedItem.checked\n        });\n        return;\n      } // 在判断最后一个图例后再更新checked状态，防止点击最后一个图例item时图例样式没有变化但是checked状态改变了 fix #422\n\n\n      clickedItem.checked = !clickedItem.checked;\n\n      if (clickedItemChecked) {\n        if (markerDom) {\n          markerDom.style.backgroundColor = unCheckedColor;\n        }\n\n        parentDom.className = domClass.replace('checked', 'unChecked');\n        parentDom.style.color = unCheckedColor;\n      } else {\n        if (markerDom) {\n          markerDom.style.backgroundColor = originColor;\n        }\n\n        parentDom.className = domClass.replace('unChecked', 'checked');\n        parentDom.style.color = this.get('textStyle').fill;\n      }\n    }\n\n    this.emit('itemclick', {\n      item: clickedItem,\n      currentTarget: parentDom,\n      checked: mode === 'single' ? true : clickedItem.checked\n    });\n    return;\n  }; // activate an item by reduce the opacity of other items.\n  // it is reserved for bi-direction interaction between charts / graph and legend\n\n\n  _proto.activate = function activate(value) {\n    var _this3 = this;\n\n    var self = this;\n    var items = self.get('items');\n    var item = findItem(items, value);\n    var legendWrapper = self.get('legendWrapper');\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);\n    var childNodes = itemListDom.childNodes;\n    childNodes.forEach(function (child) {\n      var childMarkerDom = findNodeByClass(child, MARKER_CLASS);\n      var childItem = findItem(items, child.getAttribute('data-value'));\n\n      if (_this3.get('highlight')) {\n        if (childItem === item && childItem.checked) {\n          childMarkerDom.style.border = '1px solid #333';\n          return;\n        }\n      } else {\n        if (childItem === item) {\n          childMarkerDom.style.opacity = self.get('activeOpacity');\n        } else {\n          if (childItem.checked) childMarkerDom.style.opacity = self.get('inactiveOpacity');\n        }\n      } // if (childItem !== item && childItem.checked) {\n      //   if (this.get('highlight')) {\n      //     childMarkerDom.style.border = '1px solid #fff';\n      //   } else childMarkerDom.style.opacity = 0.5;\n      // } else {\n      //   if (this.get('highlight')) {\n      //     childMarkerDom.style.border = '1px solid #333';\n      //   } else childMarkerDom.style.opacity = 1;\n      // }\n\n    });\n    return;\n  }; // restore the opacity of items\n  // it is reserved for bi-direction interaction between charts / graph and legend\n\n\n  _proto.deactivate = function deactivate() {\n    var _this4 = this;\n\n    var self = this;\n    var legendWrapper = self.get('legendWrapper');\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);\n    var childNodes = itemListDom.childNodes;\n    childNodes.forEach(function (child) {\n      var childMarkerDom = findNodeByClass(child, MARKER_CLASS);\n\n      if (_this4.get('highlight')) {\n        childMarkerDom.style.border = '1px solid #fff';\n      } else {\n        childMarkerDom.style.opacity = self.get('inactiveOpacity');\n      }\n    });\n    return;\n  };\n\n  _proto._renderHTML = function _renderHTML() {\n    var _this5 = this; // const canvas = this.get('canvas');\n\n\n    var container = this.get('container'); // const outterNode = container.parentNode;\n\n    var title = this.get('title');\n    var containerTpl = this.get('containerTpl');\n    var legendWrapper = DomUtil.createDom(containerTpl);\n    var titleDom = findNodeByClass(legendWrapper, TITLE_CLASS);\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS); // ul\n\n    var unCheckedColor = this.get('unCheckColor');\n    var LEGEND_STYLE = Util.deepMix({}, {\n      CONTAINER_CLASS: {\n        height: 'auto',\n        width: 'auto',\n        position: 'absolute',\n        overflowY: 'auto',\n        fontSize: '12px',\n        fontFamily: FONT_FAMILY,\n        lineHeight: '20px',\n        color: '#8C8C8C'\n      },\n      TITLE_CLASS: {\n        marginBottom: this.get('titleGap') + 'px',\n        fontSize: '12px',\n        color: '#333',\n        // 默认样式\n        textBaseline: 'middle',\n        fontFamily: FONT_FAMILY\n      },\n      LIST_CLASS: {\n        listStyleType: 'none',\n        margin: 0,\n        padding: 0,\n        textAlign: 'center'\n      },\n      LIST_ITEM_CLASS: {\n        cursor: 'pointer',\n        marginBottom: '5px',\n        marginRight: '24px'\n      },\n      MARKER_CLASS: {\n        width: '9px',\n        height: '9px',\n        borderRadius: '50%',\n        display: 'inline-block',\n        marginRight: '4px',\n        verticalAlign: 'middle'\n      }\n    }, this.get('legendStyle')); // fix：IE 9 兼容问题，先加入 legendWrapper\n    // let container = this.get('container');\n\n    if (/^\\#/.test(container) || typeof container === 'string' && container.constructor === String) {\n      // 如果传入 dom 节点的 id\n      var id = container.replace('#', '');\n      container = document.getElementById(id);\n      container.appendChild(legendWrapper);\n    } else {\n      var _position = this.get('position');\n\n      var rangeStyle = {};\n\n      if (_position === 'left' || _position === 'right') {\n        rangeStyle = {\n          maxHeight: (this.get('maxLength') || container.offsetHeight) + 'px'\n        };\n      } else {\n        rangeStyle = {\n          maxWidth: (this.get('maxLength') || container.offsetWidth) + 'px'\n        };\n      }\n\n      DomUtil.modifyCSS(legendWrapper, Util.mix({}, LEGEND_STYLE.CONTAINER_CLASS, rangeStyle, this.get(CONTAINER_CLASS)));\n      container.appendChild(legendWrapper);\n    }\n\n    DomUtil.modifyCSS(itemListDom, Util.mix({}, LEGEND_STYLE.LIST_CLASS, this.get(LIST_CLASS))); // render title\n\n    if (titleDom) {\n      if (title && title.text) {\n        titleDom.innerHTML = title.text;\n        DomUtil.modifyCSS(titleDom, Util.mix({}, LEGEND_STYLE.TITLE_CLASS, this.get(TITLE_CLASS), title));\n      } else {\n        legendWrapper.removeChild(titleDom);\n      }\n    } // 开始渲染图例项\n\n\n    var items = this.get('items');\n    var itemTpl = this.get('itemTpl');\n    var position = this.get('position');\n    var layout = this.get('layout');\n    var itemDisplay = position === 'right' || position === 'left' || layout === 'vertical' ? 'block' : 'inline-block';\n    var itemStyle = Util.mix({}, LEGEND_STYLE.LIST_ITEM_CLASS, {\n      display: itemDisplay\n    }, this.get(ITEM_CLASS));\n    var markerStyle = Util.mix({}, LEGEND_STYLE.MARKER_CLASS, this.get(MARKER_CLASS));\n    Util.each(items, function (item, index) {\n      var checked = item.checked;\n\n      var value = _this5._formatItemValue(item.value);\n\n      var markerColor = item.marker.fill || item.marker.stroke;\n      var color = checked ? markerColor : unCheckedColor;\n      var domStr;\n\n      if (Util.isFunction(itemTpl)) {\n        domStr = itemTpl(value, color, checked, index);\n      } else {\n        domStr = itemTpl;\n      }\n\n      var itemDiv = Util.substitute(domStr, Util.mix({}, item, {\n        index: index,\n        checked: checked ? 'checked' : 'unChecked',\n        value: value,\n        color: color,\n        originColor: markerColor,\n        // @2018-07-09 by blue.lb 修复如果legend值中存在双引号\"时, 导致的无法点击触发legend正常操作bug\n        originValue: item.value.replace(/\\\"/g, '&quot;')\n      })); // li\n\n      var itemDom = DomUtil.createDom(itemDiv);\n      itemDom.style.color = _this5.get('textStyle').fill;\n      var markerDom = findNodeByClass(itemDom, MARKER_CLASS);\n      var textDom = findNodeByClass(itemDom, TEXT_CLASS);\n      DomUtil.modifyCSS(itemDom, itemStyle);\n      markerDom && DomUtil.modifyCSS(markerDom, markerStyle); // textDom && DomUtil.modifyCSS(textDom, this.get('textStyle'));\n\n      if (!checked) {\n        itemDom.style.color = unCheckedColor;\n\n        if (markerDom) {\n          markerDom.style.backgroundColor = unCheckedColor;\n        }\n      }\n\n      itemListDom.appendChild(itemDom); // abridge the text if the width of the text exceeds the width of the item\n\n      if (_this5.get('abridgeText')) {\n        var text = value; // const itemWidth = parseFloat(this.get(ITEM_CLASS).width.substr(0, this.get(ITEM_CLASS).width.length - 2));\n\n        var itemWidth = itemDom.offsetWidth;\n\n        var fs = _this5.get('textStyle').fontSize;\n\n        if (isNaN(fs)) {\n          // 6.5pt = 6.5 * 1/72 * 96 = 8.6px\n          if (fs.indexOf('pt') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2)) * 1 / 72 * 96;else if (fs.indexOf('px') !== -1) fs = parseFloat(fs.substr(0, fs.length - 2));\n        }\n\n        var textWidth = fs * text.length;\n        var letterNum = Math.floor(itemWidth / fs);\n\n        if (itemWidth < 2 * fs) {\n          // unable to contain '...'\n          text = '';\n        } else if (itemWidth < textWidth) {\n          // replace the tail as '...\n          if (letterNum > 1) text = text.substr(0, letterNum - 1) + '...';\n        }\n\n        textDom.innerText = text; // show the text tip while mouse hovering an item\n\n        itemDom.addEventListener('mouseover', function () {\n          var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');\n          tipDom.style.display = 'block';\n          tipDom.style.left = itemDom.offsetLeft + itemDom.offsetWidth + 'px';\n          tipDom.style.top = itemDom.offsetTop + 15 + 'px';\n          tipDom.innerText = value;\n        }); // hide the text tip while mouse leave the item\n\n        itemDom.addEventListener('mouseout', function () {\n          var tipDom = findNodeByClass(legendWrapper.parentNode, 'textTip');\n          tipDom.style.display = 'none';\n        });\n      }\n    }); // append the tip div as a brother node of legend dom\n\n    if (this.get('abridgeText')) {\n      var tipTpl = this.get('tipTpl');\n      var tipDom = DomUtil.createDom(tipTpl);\n      var tipDomStyle = this.get('tipStyle');\n      DomUtil.modifyCSS(tipDom, tipDomStyle);\n      legendWrapper.parentNode.appendChild(tipDom); // hide the tip while mouse entering the tip dom\n\n      tipDom.addEventListener('mouseover', function () {\n        tipDom.style.display = 'none';\n      });\n    }\n\n    this.set('legendWrapper', legendWrapper);\n  };\n\n  _proto._adjustPositionOffset = function _adjustPositionOffset() {\n    var position = this.get('position');\n    var offset = this.get('offset');\n    var offsetX = this.get('offsetX');\n    var offsetY = this.get('offsetY');\n    if (offsetX) offset[0] = offsetX;\n    if (offsetY) offset[1] = offsetY;\n    var legendWrapper = this.get('legendWrapper');\n    legendWrapper.style.left = position[0] + 'px';\n    legendWrapper.style.top = position[1] + 'px';\n    legendWrapper.style.marginLeft = offset[0] + 'px';\n    legendWrapper.style.marginTop = offset[1] + 'px';\n  };\n\n  _proto.getWidth = function getWidth() {\n    return DomUtil.getOuterWidth(this.get('legendWrapper'));\n  };\n\n  _proto.getHeight = function getHeight() {\n    return DomUtil.getOuterHeight(this.get('legendWrapper'));\n  };\n\n  _proto.move = function move(x, y) {\n    if (!/^\\#/.test(this.get('container'))) {\n      DomUtil.modifyCSS(this.get('legendWrapper'), {\n        left: x + 'px',\n        top: y + 'px'\n      });\n      this.set('x', x);\n      this.set('y', y);\n    } else {\n      _Category.prototype.move.call(this, x, y);\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    var legendWrapper = this.get('legendWrapper');\n\n    if (legendWrapper && legendWrapper.parentNode) {\n      legendWrapper.parentNode.removeChild(legendWrapper);\n    }\n  };\n\n  return CatHtml;\n}(Category);\n\nmodule.exports = CatHtml;\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Component = __webpack_require__(32);\n\nvar Util = __webpack_require__(3);\n\nvar Crosshair =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Crosshair, _Component);\n\n  var _proto = Crosshair.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Component.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n        * crosshair的类型\n        * @type {String}\n        */\n      type: null,\n\n      /**\n       * 画在哪层视图\n       * @type {G-Element}\n       */\n      plot: null,\n\n      /**\n       * x轴上，移动到位置的偏移量\n       * @type {Number}\n       */\n      plotRange: null,\n\n      /**\n       * 默认rect crosshair样式\n       * @type {Object}\n       */\n      rectStyle: {\n        fill: '#CCD6EC',\n        opacity: 0.3\n      },\n\n      /**\n        * 默认line crosshair样式\n        * @type {Object}\n        */\n      lineStyle: {\n        stroke: 'rgba(0, 0, 0, 0.25)',\n        lineWidth: 1\n      },\n      isTransposed: false\n    });\n  };\n\n  function Crosshair(cfg) {\n    var _this;\n\n    _this = _Component.call(this, cfg) || this;\n\n    _this._init_();\n\n    _this.render();\n\n    return _this;\n  }\n\n  _proto._init_ = function _init_() {\n    var self = this;\n    var plot = self.get('plot');\n    var group;\n\n    if (self.type === 'rect') {\n      group = plot.addGroup({\n        zIndex: 0\n      });\n    } else {\n      group = plot.addGroup();\n    }\n\n    this.set('container', group);\n  };\n\n  _proto._addLineShape = function _addLineShape(attrs, type) {\n    var container = this.get('container');\n    var shape = container.addShape('line', {\n      capture: false,\n      attrs: attrs\n    }); // shape.hide();\n\n    this.set('crossLineShape' + type, shape);\n    return shape;\n  };\n\n  _proto._renderHorizontalLine = function _renderHorizontalLine(canvas, plotRange) {\n    var style = Util.mix(this.get('lineStyle'), this.get('style'));\n    var attrs = Util.mix({\n      x1: plotRange ? plotRange.bl.x : canvas.get('width'),\n      y1: 0,\n      x2: plotRange ? plotRange.br.x : 0,\n      y2: 0\n    }, style);\n\n    this._addLineShape(attrs, 'X');\n  };\n\n  _proto._renderVerticalLine = function _renderVerticalLine(canvas, plotRange) {\n    var style = Util.mix(this.get('lineStyle'), this.get('style'));\n    var attrs = Util.mix({\n      x1: 0,\n      y1: plotRange ? plotRange.bl.y : canvas.get('height'),\n      x2: 0,\n      y2: plotRange ? plotRange.tl.y : 0\n    }, style);\n\n    this._addLineShape(attrs, 'Y');\n  };\n\n  _proto._renderBackground = function _renderBackground(canvas, plotRange) {\n    var style = Util.mix(this.get('rectStyle'), this.get('style'));\n    var container = this.get('container');\n    var attrs = Util.mix({\n      x: plotRange ? plotRange.tl.x : 0,\n      y: plotRange ? plotRange.tl.y : canvas.get('height'),\n      width: plotRange ? plotRange.br.x - plotRange.bl.x : canvas.get('width'),\n      height: plotRange ? Math.abs(plotRange.tl.y - plotRange.bl.y) : canvas.get('height')\n    }, style);\n    var shape = container.addShape('rect', {\n      attrs: attrs,\n      capture: false\n    }); // shape.hide();\n\n    this.set('crosshairsRectShape', shape);\n    return shape;\n  };\n\n  _proto._updateRectShape = function _updateRectShape(items) {\n    var offset;\n    var crosshairsRectShape = this.get('crosshairsRectShape');\n    var isTransposed = this.get('isTransposed');\n    var firstItem = items[0];\n    var lastItem = items[items.length - 1];\n    var dim = isTransposed ? 'y' : 'x';\n    var attr = isTransposed ? 'height' : 'width';\n    var startDim = firstItem[dim];\n\n    if (items.length > 1 && firstItem[dim] > lastItem[dim]) {\n      startDim = lastItem[dim];\n    }\n\n    if (this.get('width')) {\n      // 用户定义了 width\n      crosshairsRectShape.attr(dim, startDim - this.get('crosshairs').width / 2);\n      crosshairsRectShape.attr(attr, this.get('width'));\n    } else {\n      if (Util.isArray(firstItem.point[dim]) && !firstItem.size) {\n        // 直方图\n        var width = firstItem.point[dim][1] - firstItem.point[dim][0];\n        crosshairsRectShape.attr(dim, firstItem.point[dim][0]);\n        crosshairsRectShape.attr(attr, width);\n      } else {\n        offset = 3 * firstItem.size / 4;\n        crosshairsRectShape.attr(dim, startDim - offset);\n\n        if (items.length === 1) {\n          crosshairsRectShape.attr(attr, 3 * firstItem.size / 2);\n        } else {\n          crosshairsRectShape.attr(attr, Math.abs(lastItem[dim] - firstItem[dim]) + 2 * offset);\n        }\n      }\n    }\n  };\n\n  _proto.render = function render() {\n    var canvas = this.get('canvas');\n    var plotRange = this.get('plotRange');\n    var isTransposed = this.get('isTransposed');\n    this.clear();\n\n    switch (this.get('type')) {\n      case 'x':\n        this._renderHorizontalLine(canvas, plotRange);\n\n        break;\n\n      case 'y':\n        this._renderVerticalLine(canvas, plotRange);\n\n        break;\n\n      case 'cross':\n        this._renderHorizontalLine(canvas, plotRange);\n\n        this._renderVerticalLine(canvas, plotRange);\n\n        break;\n\n      case 'rect':\n        this._renderBackground(canvas, plotRange);\n\n        break;\n\n      default:\n        isTransposed ? this._renderHorizontalLine(canvas, plotRange) : this._renderVerticalLine(canvas, plotRange);\n    }\n  };\n\n  _proto.show = function show() {\n    var container = this.get('container');\n\n    _Component.prototype.show.call(this);\n\n    container.show();\n  };\n\n  _proto.hide = function hide() {\n    var container = this.get('container');\n\n    _Component.prototype.hide.call(this);\n\n    container.hide();\n  };\n\n  _proto.clear = function clear() {\n    var container = this.get('container');\n    this.set('crossLineShapeX', null);\n    this.set('crossLineShapeY', null);\n    this.set('crosshairsRectShape', null);\n\n    _Component.prototype.clear.call(this);\n\n    container.clear();\n  };\n\n  _proto.destroy = function destroy() {\n    var container = this.get('container');\n\n    _Component.prototype.destroy.call(this);\n\n    container.remove();\n  };\n\n  _proto.setPosition = function setPosition(x, y, items) {\n    var crossLineShapeX = this.get('crossLineShapeX');\n    var crossLineShapeY = this.get('crossLineShapeY');\n    var crosshairsRectShape = this.get('crosshairsRectShape');\n\n    if (crossLineShapeY && !crossLineShapeY.get('destroyed')) {\n      // 第一次进入时，画布需要单独绘制，所以需要先设定corss的位置\n      crossLineShapeY.move(x, 0);\n    }\n\n    if (crossLineShapeX && !crossLineShapeX.get('destroyed')) {\n      crossLineShapeX.move(0, y);\n    }\n\n    if (crosshairsRectShape && !crosshairsRectShape.get('destroyed')) {\n      this._updateRectShape(items);\n    }\n  };\n\n  return Crosshair;\n}(Component);\n\nmodule.exports = Crosshair;\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports) {\n\nvar GAP = 20;\nvar PositionMixin = {\n  _calcTooltipPosition: function _calcTooltipPosition(x, y, position, containerWidth, containerHeight, target) {\n    var rectWidth = 0;\n    var rectHeight = 0;\n    var gap = 20;\n\n    if (target) {\n      var rect = target.getBBox();\n      rectWidth = rect.width;\n      rectHeight = rect.height;\n      x = rect.x;\n      y = rect.y;\n      gap = 5;\n    }\n\n    switch (position) {\n      case 'inside':\n        x = x + rectWidth / 2 - containerWidth / 2;\n        y = y + rectHeight / 2 - containerHeight / 2;\n        break;\n\n      case 'top':\n        x = x + rectWidth / 2 - containerWidth / 2;\n        y = y - containerHeight - gap;\n        break;\n\n      case 'left':\n        x = x - containerWidth - gap;\n        y = y + rectHeight / 2 - containerHeight / 2;\n        break;\n\n      case 'right':\n        x = x + rectWidth + gap;\n        y = y + rectHeight / 2 - containerHeight / 2;\n        break;\n\n      case 'bottom':\n      default:\n        x = x + rectWidth / 2 - containerWidth / 2;\n        y = y + rectHeight + gap;\n        break;\n    }\n\n    return [x, y];\n  },\n  _constraintPositionInBoundary: function _constraintPositionInBoundary(x, y, width, height, viewWidth, viewHeight) {\n    if (x + width + GAP > viewWidth) {\n      x -= width + GAP;\n      x = x < 0 ? 0 : x;\n    } else if (x + GAP < 0) {\n      x = GAP;\n    } else {\n      x += GAP;\n    }\n\n    if (y + height + GAP > viewHeight) {\n      y -= height + GAP;\n      y = y < 0 ? 0 : y;\n    } else if (y + GAP < 0) {\n      y = GAP;\n    } else {\n      y += GAP;\n    }\n\n    return [x, y];\n  },\n  _constraintPositionInPlot: function _constraintPositionInPlot(x, y, width, height, plotRange, onlyHorizontal) {\n    if (x + width > plotRange.tr.x) {\n      x -= width + 2 * GAP;\n    }\n\n    if (x < plotRange.tl.x) {\n      x = plotRange.tl.x;\n    }\n\n    if (!onlyHorizontal) {\n      if (y + height > plotRange.bl.y) {\n        y -= height + 2 * GAP;\n      }\n\n      if (y < plotRange.tl.y) {\n        y = plotRange.tl.y;\n      }\n    }\n\n    return [x, y];\n  }\n};\nmodule.exports = PositionMixin;\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(3);\n\nvar MarkerGroupMixin = {\n  setMarkers: function setMarkers(markerItems, markerCfg) {\n    var self = this;\n    var markerGroup = self.get('markerGroup');\n    var frontPlot = self.get('frontPlot');\n\n    if (!markerGroup) {\n      markerGroup = frontPlot.addGroup({\n        zIndex: 1,\n        capture: false // 不进行拾取\n\n      });\n      self.set('markerGroup', markerGroup);\n    } else {\n      markerGroup.clear();\n    }\n\n    Util.each(markerItems, function (item) {\n      markerGroup.addShape('marker', {\n        color: item.color,\n        attrs: Util.mix({\n          fill: item.color,\n          symbol: 'circle',\n          shadowColor: item.color\n        }, markerCfg, {\n          x: item.x,\n          y: item.y\n        })\n      });\n    });\n    this.set('markerItems', markerItems);\n  },\n  clearMarkers: function clearMarkers() {\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.clear();\n  }\n};\nmodule.exports = MarkerGroupMixin;\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar G = __webpack_require__(25);\n\nvar Crosshair = __webpack_require__(160);\n\nvar MarkerGroupMixin = __webpack_require__(162);\n\nvar PositionMixin = __webpack_require__(161);\n\nvar Tooltip = __webpack_require__(68);\n\nvar Util = __webpack_require__(3);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar DomUtil = Util.DomUtil;\nvar MatrixUtil = Util.MatrixUtil;\n\nvar CanvasTooltip =\n/*#__PURE__*/\nfunction (_Tooltip) {\n  _inheritsLoose(CanvasTooltip, _Tooltip);\n\n  var _proto = CanvasTooltip.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Tooltip.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 默认背景板样式\n       * @type {Object}\n       */\n      boardStyle: {\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100,\n        fill: 'rgba(255, 255, 255, 0.9)',\n        radius: 4,\n        stroke: '#e2e2e2',\n        lineWidth: 1\n      },\n\n      /**\n       * 默认title样式\n       * @type {Object}\n       */\n      titleStyle: {\n        fontFamily: FONT_FAMILY,\n        text: '',\n        textBaseline: 'top',\n        fontSize: 12,\n        fill: 'rgb(87, 87, 87)',\n        lineHeight: 20,\n        padding: 20\n      },\n\n      /**\n       * 默认marker样式\n       * @type {Object}\n       */\n      markerStyle: {\n        radius: 4\n      },\n\n      /**\n       * 默认name样式\n       * @type {Object}\n       */\n      nameStyle: {\n        fontFamily: FONT_FAMILY,\n        fontSize: 12,\n        fill: 'rgb(87, 87, 87)',\n        textBaseline: 'middle',\n        textAlign: 'start',\n        padding: 8\n      },\n\n      /**\n       * 默认value样式\n       * @type {Object}\n       */\n      valueStyle: {\n        fontFamily: FONT_FAMILY,\n        fontSize: 12,\n        fill: 'rgb(87, 87, 87)',\n        textBaseline: 'middle',\n        textAlign: 'start',\n        padding: 30\n      },\n\n      /**\n       * 默认padding值\n       * @type {Object}\n       */\n      padding: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n      },\n\n      /**\n       * 默认item之间的gap\n       * @type {Number}\n       */\n      itemGap: 10,\n\n      /**\n       * 默认tooltip位置移动动画的时长\n       * @type {Number}\n       */\n      animationDuration: 200\n    });\n  };\n\n  function CanvasTooltip(cfg) {\n    var _this;\n\n    _this = _Tooltip.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), PositionMixin);\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), MarkerGroupMixin); // crosshair\n\n    var crosshair = _this.get('crosshairs');\n\n    if (crosshair) {\n      var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');\n      var crosshairGroup = new Crosshair(Util.mix({\n        plot: plot,\n        plotRange: _this.get('plotRange'),\n        canvas: _this.get('canvas')\n      }, _this.get('crosshairs')));\n      crosshairGroup.hide();\n\n      _this.set('crosshairGroup', crosshairGroup);\n    }\n\n    _this._init_();\n\n    if (_this.get('items')) {\n      _this.render();\n    }\n\n    return _this;\n  }\n\n  _proto._init_ = function _init_() {\n    var self = this;\n    var padding = self.get('padding');\n    var parent = self.get('frontPlot'); // marker group\n\n    var markerGroup = parent.addGroup({\n      capture: false\n    });\n    self.set('markerGroup', markerGroup); // container\n\n    var container = parent.addGroup();\n    container.hide();\n    self.set('container', container); // board\n\n    var board = container.addShape('rect', {\n      attrs: Util.mix({}, self.get('boardStyle'))\n    });\n    self.set('board', board); // title\n\n    var titleStyle = self.get('titleStyle');\n\n    if (self.get('showTitle')) {\n      var titleShape = container.addShape('text', {\n        attrs: Util.mix({\n          x: padding.left,\n          y: padding.top\n        }, titleStyle)\n      });\n      self.set('titleShape', titleShape);\n      titleShape.name = 'tooltip-title';\n    } // items\n\n\n    var itemsGroup = container.addGroup();\n    itemsGroup.move(padding.left, padding.top + titleStyle.lineHeight + titleStyle.padding);\n    self.set('itemsGroup', itemsGroup);\n  };\n\n  _proto.render = function render() {\n    var self = this;\n    self.clear();\n    var container = self.get('container');\n    var board = self.get('board');\n    var showTitle = self.get('showTitle');\n    var titleContent = self.get('titleContent');\n    var titleShape = this.get('titleShape');\n    var itemsGroup = this.get('itemsGroup');\n    var items = self.get('items');\n    var padding = self.get('padding');\n\n    if (titleShape && showTitle) {\n      titleShape.attr('text', titleContent);\n    }\n\n    if (itemsGroup) {\n      var itemGap = self.get('itemGap');\n      var x = 0;\n      var y = 0;\n      Util.each(items, function (item) {\n        var itemGroup = self._addItem(item);\n\n        itemGroup.move(x, y);\n        itemsGroup.add(itemGroup);\n        var itemHeight = itemGroup.getBBox().height;\n        y += itemHeight + itemGap;\n      });\n    } // update board based on bbox\n\n\n    var bbox = container.getBBox();\n    var width = bbox.width + padding.right;\n    var height = bbox.height + padding.bottom;\n    board.attr('width', width);\n    board.attr('height', height); // align value text to right\n\n    self._alignToRight(width);\n  };\n\n  _proto.clear = function clear() {\n    var titleShape = this.get('titleShape');\n    var itemsGroup = this.get('itemsGroup');\n    var board = this.get('board');\n    titleShape.text = '';\n    itemsGroup.clear();\n    board.attr('width', 0);\n    board.attr('height', 0);\n  };\n\n  _proto.show = function show() {\n    var container = this.get('container');\n    container.show();\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.show();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.show();\n\n    _Tooltip.prototype.show.call(this);\n\n    this.get('canvas').draw();\n  };\n\n  _proto.hide = function hide() {\n    var container = this.get('container');\n    container.hide();\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.hide();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.hide();\n\n    _Tooltip.prototype.hide.call(this);\n\n    this.get('canvas').draw();\n  };\n\n  _proto.destroy = function destroy() {\n    var container = this.get('container');\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.destroy();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.remove();\n\n    _Tooltip.prototype.destroy.call(this);\n\n    container.remove();\n  };\n\n  _proto.setPosition = function setPosition(x, y, target) {\n    var container = this.get('container');\n    var outterNode = this.get('canvas').get('el');\n    var viewWidth = DomUtil.getWidth(outterNode);\n    var viewHeight = DomUtil.getHeight(outterNode);\n    var bbox = container.getBBox();\n    var containerWidth = bbox.width;\n    var containerHeight = bbox.height;\n    var endx = x;\n    var endy = y;\n    var position;\n\n    if (this.get('position')) {\n      var _containerWidth = bbox.width;\n      var _containerHeight = bbox.height;\n      position = this._calcTooltipPosition(x, y, this.get('position'), _containerWidth, _containerHeight, target);\n      x = position[0];\n      y = position[1];\n    } else {\n      position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);\n      x = position[0];\n      y = position[1];\n    }\n\n    if (this.get('inPlot')) {\n      // tooltip 必须限制在绘图区域内\n      var plotRange = this.get('plotRange');\n      position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));\n      x = position[0];\n      y = position[1];\n    }\n\n    var markerItems = this.get('markerItems');\n\n    if (!Util.isEmpty(markerItems)) {\n      endx = markerItems[0].x;\n      endy = markerItems[0].y;\n    }\n\n    var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);\n    container.stopAnimate();\n    container.animate({\n      matrix: mat\n    }, this.get('animationDuration'));\n    var crosshairGroup = this.get('crosshairGroup');\n\n    if (crosshairGroup) {\n      var items = this.get('items');\n      crosshairGroup.setPosition(endx, endy, items);\n    }\n\n    _Tooltip.prototype.setPosition.call(this, x, y);\n  };\n\n  _proto._addItem = function _addItem(item) {\n    var group = new G.Group();\n    var markerRadius = this.get('markerStyle').radius; // marker\n\n    if (item.marker) {\n      var markerAttrs = Util.mix({}, item.marker, {\n        x: item.marker.radius / 2,\n        y: 0\n      });\n      group.addShape('marker', {\n        attrs: markerAttrs\n      });\n      markerRadius = item.marker.radius;\n    } // name\n\n\n    var nameStyle = this.get('nameStyle');\n    group.addShape('text', {\n      attrs: Util.mix({\n        x: markerRadius + nameStyle.padding,\n        y: 0,\n        text: item.name\n      }, nameStyle)\n    }); // value\n\n    var valueStyle = this.get('valueStyle');\n    group.addShape('text', {\n      attrs: Util.mix({\n        x: group.getBBox().width + valueStyle.padding,\n        y: 0,\n        text: item.value\n      }, valueStyle)\n    });\n    return group;\n  };\n\n  _proto._alignToRight = function _alignToRight(width) {\n    var _this2 = this;\n\n    var itemsGroup = this.get('itemsGroup');\n    var groups = itemsGroup.get('children');\n    Util.each(groups, function (g) {\n      var children = g.get('children');\n      var valueText = children[2];\n      var w = valueText.getBBox().width;\n      var x = width - w - _this2.get('padding').right * 2;\n      valueText.attr('x', x);\n    });\n  };\n\n  return CanvasTooltip;\n}(Tooltip);\n\nmodule.exports = CanvasTooltip;\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Labels = __webpack_require__(65);\n\nvar PathUtil = __webpack_require__(22);\n\nvar Util = __webpack_require__(0);\n\nvar PolarLabels =\n/*#__PURE__*/\nfunction (_Labels) {\n  _inheritsLoose(PolarLabels, _Labels);\n\n  function PolarLabels() {\n    return _Labels.apply(this, arguments) || this;\n  }\n\n  var _proto = PolarLabels.prototype;\n\n  _proto.getPointRauis = function getPointRauis(coord, point) {\n    return PathUtil.getPointRadius(coord, point);\n  };\n\n  _proto.getCirclePoint = function getCirclePoint(angle, offset, point) {\n    var self = this;\n    var coord = self.get('coord');\n    var center = coord.getCenter();\n\n    var labelEmit = self._isEmitLabels();\n\n    var r = self.getPointRauis(coord, point);\n\n    if (r === 0) {\n      return null;\n    }\n\n    if (coord.isTransposed && r > offset && !labelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      angle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(angle),\n      y: center.y + r * Math.sin(angle),\n      angle: angle,\n      r: r\n    };\n  };\n\n  _proto.getArcPoint = function getArcPoint(point, index) {\n    var self = this;\n    var outerPoint; // 圆弧上的中点\n    // var coord = self.get('coord');\n\n    index = index || 0;\n\n    if (Util.isArray(point.x) || Util.isArray(point.y)) {\n      outerPoint = {\n        x: Util.isArray(point.x) ? point.x[index] : point.x,\n        y: Util.isArray(point.y) ? point.y[index] : point.y\n      };\n    } else {\n      outerPoint = point;\n    }\n\n    self.transLabelPoint(outerPoint);\n    return outerPoint;\n  }; // 获取点所在的角度\n\n\n  _proto.getPointAngle = function getPointAngle(point) {\n    var self = this;\n    var coord = self.get('coord');\n    return PathUtil.getPointAngle(coord, point);\n  }; // 获取中心的位置\n\n\n  _proto.getMiddlePoint = function getMiddlePoint(points) {\n    var self = this;\n    var coord = self.get('coord');\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    Util.each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coord.convert(middlePoint);\n    return middlePoint;\n  }; // 是否居中\n\n\n  _proto._isToMiddle = function _isToMiddle(point) {\n    return point.x.length > 2;\n  };\n  /**\n   * @protected\n   * 获取文本的位置信息\n   * @param {Array} label labels\n   * @param {Object} point point\n   * @param {Number} index index\n   * @return {Object} point\n   */\n\n\n  _proto.getLabelPoint = function getLabelPoint(label, point, index) {\n    var self = this;\n    var text = label.text[index];\n    var factor = 1;\n    var arcPoint;\n\n    if (self._isToMiddle(point)) {\n      arcPoint = self.getMiddlePoint(point.points);\n    } else {\n      if (label.text.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n\n      arcPoint = self.getArcPoint(point, index);\n    }\n\n    var offset = self.getDefaultOffset(label);\n    offset = offset * factor;\n    var middleAngle = self.getPointAngle(arcPoint);\n    var labelPoint = self.getCirclePoint(middleAngle, offset, arcPoint);\n\n    if (!labelPoint) {\n      labelPoint = {\n        text: ''\n      };\n    } else {\n      labelPoint.text = text;\n      labelPoint.angle = middleAngle;\n      labelPoint.color = point.color;\n    }\n\n    if (label.autoRotate || typeof label.autoRotate === 'undefined') {\n      var rotate = labelPoint.textStyle ? labelPoint.textStyle.rotate : null;\n\n      if (!rotate) {\n        rotate = labelPoint.rotate || self.getLabelRotate(middleAngle, offset, point);\n      }\n\n      labelPoint.rotate = rotate;\n    }\n\n    labelPoint.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPoint;\n  };\n\n  _proto._isEmitLabels = function _isEmitLabels() {\n    var labels = this.get('label');\n    return labels.labelEmit;\n  };\n  /**\n   * @protected\n   * 获取文本旋转的方向\n   * @param {Number} angle angle\n   * @return {Number} angle\n   */\n\n\n  _proto.getLabelRotate = function getLabelRotate(angle) {\n    var self = this;\n    var rotate;\n    rotate = angle * 180 / Math.PI;\n    rotate += 90;\n\n    if (self._isEmitLabels()) {\n      rotate -= 90;\n    }\n\n    if (rotate) {\n      if (rotate > 90) {\n        rotate = rotate - 180;\n      } else if (rotate < -90) {\n        rotate = rotate + 180;\n      }\n    }\n\n    return rotate / 180 * Math.PI;\n  }; // override\n\n\n  _proto.getLabelAlign = function getLabelAlign(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var align;\n\n    if (self._isEmitLabels()) {\n      if (point.angle <= Math.PI / 2 && point.angle > -Math.PI / 2) {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    } else if (!coord.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coord.getCenter();\n      var offset = self.getDefaultOffset(point);\n\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        if (offset > 0) {\n          align = 'left';\n        } else {\n          align = 'right';\n        }\n      } else {\n        if (offset > 0) {\n          align = 'right';\n        } else {\n          align = 'left';\n        }\n      }\n    }\n\n    return align;\n  };\n\n  return PolarLabels;\n}(Labels);\n\nmodule.exports = PolarLabels;\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Scale: __webpack_require__(341),\n  Coord: __webpack_require__(342),\n  Axis: __webpack_require__(347),\n  Guide: __webpack_require__(348),\n  Legend: __webpack_require__(351),\n  Tooltip: __webpack_require__(353),\n  Event: __webpack_require__(354)\n};\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar G = __webpack_require__(16);\n\nvar Util = __webpack_require__(0);\n\nvar mergeBBox = __webpack_require__(167);\n\nfunction applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n  Util.vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n}\n\nfunction getTitleBBox(title) {\n  var bbox = title.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  };\n  var matrix = title.attr('matrix');\n  leftTop = applyMatrix(leftTop, matrix);\n  rightBottom = applyMatrix(rightBottom, matrix);\n  return {\n    minX: leftTop.x,\n    minY: leftTop.y,\n    maxX: rightBottom.x,\n    maxY: rightBottom.y\n  };\n}\n\nmodule.exports = function BBoxOfBackPlot(backPlot, defaultBBox) {\n  var bbox = defaultBBox;\n  Util.each(backPlot.get('children'), function (element) {\n    if (element instanceof G.Group || element instanceof G.Path) {\n      bbox = mergeBBox(bbox, element.getBBox());\n    } else if (element instanceof G.Text) {\n      // title\n      var elementBBox = getTitleBBox(element);\n      var dx = Math.abs(elementBBox.maxX - elementBBox.minX);\n      var dy = Math.abs(elementBBox.maxY - elementBBox.minY);\n\n      if (dx < dy) {\n        bbox = mergeBBox(bbox, Util.mix(bbox, {\n          minX: bbox.minX - dx,\n          maxX: bbox.maxX + dx\n        }));\n      } else {\n        bbox = mergeBBox(bbox, Util.mix(bbox, {\n          minY: bbox.minY - dy,\n          maxY: bbox.maxY + dy\n        }));\n      }\n    }\n  });\n  return bbox;\n};\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports) {\n\nmodule.exports = function mergeBBox(box1, box2) {\n  return {\n    minX: Math.min(box1.minX, box2.minX),\n    minY: Math.min(box1.minY, box2.minY),\n    maxX: Math.max(box1.maxX, box2.maxX),\n    maxY: Math.max(box1.maxY, box2.maxY)\n  };\n};\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports) {\n\nmodule.exports = function plotRange2BBox(plotRange) {\n  return {\n    minX: plotRange.tl.x,\n    minY: plotRange.tl.y,\n    maxX: plotRange.br.x,\n    maxY: plotRange.br.y\n  };\n};\n\n/***/ }),\n/* 169 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Transition;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = transition;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = newId;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attr__ = __webpack_require__(441);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attrTween__ = __webpack_require__(442);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__delay__ = __webpack_require__(443);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__duration__ = __webpack_require__(444);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ease__ = __webpack_require__(445);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__filter__ = __webpack_require__(446);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__merge__ = __webpack_require__(447);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__on__ = __webpack_require__(448);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__remove__ = __webpack_require__(449);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__select__ = __webpack_require__(450);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__selectAll__ = __webpack_require__(451);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__selection__ = __webpack_require__(452);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__style__ = __webpack_require__(453);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__styleTween__ = __webpack_require__(454);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__text__ = __webpack_require__(455);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__transition__ = __webpack_require__(456);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__tween__ = __webpack_require__(362);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar id = 0;\nfunction Transition(groups, parents, name, id) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id;\n}\nfunction transition(name) {\n  return Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selection\"])().transition(name);\n}\nfunction newId() {\n  return ++id;\n}\nvar selection_prototype = __WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selection\"].prototype;\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: __WEBPACK_IMPORTED_MODULE_10__select__[\"a\" /* default */],\n  selectAll: __WEBPACK_IMPORTED_MODULE_11__selectAll__[\"a\" /* default */],\n  filter: __WEBPACK_IMPORTED_MODULE_6__filter__[\"a\" /* default */],\n  merge: __WEBPACK_IMPORTED_MODULE_7__merge__[\"a\" /* default */],\n  selection: __WEBPACK_IMPORTED_MODULE_12__selection__[\"a\" /* default */],\n  transition: __WEBPACK_IMPORTED_MODULE_16__transition__[\"a\" /* default */],\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: __WEBPACK_IMPORTED_MODULE_8__on__[\"a\" /* default */],\n  attr: __WEBPACK_IMPORTED_MODULE_1__attr__[\"a\" /* default */],\n  attrTween: __WEBPACK_IMPORTED_MODULE_2__attrTween__[\"a\" /* default */],\n  style: __WEBPACK_IMPORTED_MODULE_13__style__[\"a\" /* default */],\n  styleTween: __WEBPACK_IMPORTED_MODULE_14__styleTween__[\"a\" /* default */],\n  text: __WEBPACK_IMPORTED_MODULE_15__text__[\"a\" /* default */],\n  remove: __WEBPACK_IMPORTED_MODULE_9__remove__[\"a\" /* default */],\n  tween: __WEBPACK_IMPORTED_MODULE_17__tween__[\"a\" /* default */],\n  delay: __WEBPACK_IMPORTED_MODULE_3__delay__[\"a\" /* default */],\n  duration: __WEBPACK_IMPORTED_MODULE_4__duration__[\"a\" /* default */],\n  ease: __WEBPACK_IMPORTED_MODULE_5__ease__[\"a\" /* default */]\n};\n\n/***/ }),\n/* 170 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_timer__ = __webpack_require__(58);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"now\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"timer\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"timerFlush\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_timer__[\"d\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_timeout__ = __webpack_require__(191);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"timeout\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_timeout__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_interval__ = __webpack_require__(192);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interval\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_interval__[\"a\"]; });\n\n\n\n\n/***/ }),\n/* 171 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar DomUtil = Util.DomUtil;\nvar EVENT_TYPES = ['start', 'process', 'end', 'reset'];\n\nvar Interaction =\n/*#__PURE__*/\nfunction () {\n  var _proto = Interaction.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      startEvent: 'mousedown',\n      processEvent: 'mousemove',\n      endEvent: 'mouseup',\n      resetEvent: 'dblclick'\n    };\n  };\n\n  _proto._start = function _start(ev) {\n    var me = this;\n    me.preStart && me.preStart(ev);\n    me.start(ev);\n    me.onStart && me.onStart(ev);\n  };\n\n  _proto._process = function _process(ev) {\n    var me = this;\n    me.preProcess && me.preProcess(ev);\n    me.process(ev);\n    me.onProcess && me.onProcess(ev);\n  };\n\n  _proto._end = function _end(ev) {\n    var me = this;\n    me.preEnd && me.preEnd(ev);\n    me.end(ev);\n    me.onEnd && me.onEnd(ev);\n  };\n\n  _proto._reset = function _reset(ev) {\n    var me = this;\n    me.preReset && me.preReset(ev);\n    me.reset(ev);\n    me.onReset && me.onReset(ev);\n  };\n\n  _proto.start = function start() {// TODO override\n  };\n\n  _proto.process = function process() {// TODO override\n  };\n\n  _proto.end = function end() {// TODO override\n  };\n\n  _proto.reset = function reset() {// TODO override\n  };\n\n  function Interaction(cfg, view) {\n    var me = this;\n    var defaultCfg = me.getDefaultCfg();\n    Util.assign(me, defaultCfg, cfg);\n    me.view = me.chart = view;\n    me.canvas = view.get('canvas');\n\n    me._bindEvents();\n  }\n\n  _proto._bindEvents = function _bindEvents() {\n    var me = this;\n    var canvas = me.canvas;\n    var canvasDOM = canvas.get('canvasDOM');\n\n    me._clearEvents();\n\n    Util.each(EVENT_TYPES, function (type) {\n      var ucType = Util.upperFirst(type);\n      me[\"_on\" + ucType + \"Listener\"] = DomUtil.addEventListener(canvasDOM, me[type + \"Event\"], Util.wrapBehavior(me, \"_\" + type));\n    });\n  };\n\n  _proto._clearEvents = function _clearEvents() {\n    var me = this;\n    Util.each(EVENT_TYPES, function (type) {\n      var listenerName = \"_on\" + Util.upperFirst(type) + \"Listener\";\n      me[listenerName] && me[listenerName].remove();\n    });\n  };\n\n  _proto.destroy = function destroy() {\n    this._clearEvents();\n  };\n\n  return Interaction;\n}();\n\nmodule.exports = Interaction;\n\n/***/ }),\n/* 172 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Scale = __webpack_require__(74);\n\nvar G = __webpack_require__(16);\n\nvar Animate = __webpack_require__(126);\n\nvar Chart = __webpack_require__(147);\n\nvar Global = __webpack_require__(7);\n\nvar Shape = __webpack_require__(18);\n\nvar Util = __webpack_require__(0);\n\nvar G2 = {\n  // version\n  version: Global.version,\n  // visual encoding\n  Animate: Animate,\n  Chart: Chart,\n  Global: Global,\n  Scale: Scale,\n  Shape: Shape,\n  Util: Util,\n  // render engine\n  G: G,\n  DomUtil: Util.DomUtil,\n  MatrixUtil: Util.MatrixUtil,\n  PathUtil: Util.PathUtil\n}; // G2.track = function(enable) {\n//   Global.trackable = enable;\n// };\n// require('./track');\n\nG2.track = function () {\n  console.warn('G2 tracks nothing ;-)');\n}; // 保证两个版本共存\n\n\nif (typeof window !== 'undefined') {\n  if (window.G2) {\n    console.warn(\"There are multiple versions of G2. Version \" + G2.version + \"'s reference is 'window.G2_3'\");\n  } else {\n    window.G2 = G2;\n  }\n}\n\nmodule.exports = G2;\n\n/***/ }),\n/* 173 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_linear__ = __webpack_require__(193);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeLinear\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_linear__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_quad__ = __webpack_require__(194);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeQuad\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeQuadIn\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeQuadOut\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeQuadInOut\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_quad__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_cubic__ = __webpack_require__(195);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCubic\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCubicIn\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCubicOut\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCubicInOut\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_cubic__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_poly__ = __webpack_require__(196);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easePoly\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easePolyIn\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easePolyOut\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easePolyInOut\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_poly__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_sin__ = __webpack_require__(197);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeSin\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeSinIn\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeSinOut\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeSinInOut\", function() { return __WEBPACK_IMPORTED_MODULE_4__src_sin__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_exp__ = __webpack_require__(198);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeExp\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeExpIn\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeExpOut\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeExpInOut\", function() { return __WEBPACK_IMPORTED_MODULE_5__src_exp__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_circle__ = __webpack_require__(199);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCircle\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCircleIn\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCircleOut\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeCircleInOut\", function() { return __WEBPACK_IMPORTED_MODULE_6__src_circle__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_bounce__ = __webpack_require__(200);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBounce\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBounceIn\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBounceOut\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBounceInOut\", function() { return __WEBPACK_IMPORTED_MODULE_7__src_bounce__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_back__ = __webpack_require__(201);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBack\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBackIn\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBackOut\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeBackInOut\", function() { return __WEBPACK_IMPORTED_MODULE_8__src_back__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_elastic__ = __webpack_require__(202);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeElastic\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeElasticIn\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeElasticOut\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"easeElasticInOut\", function() { return __WEBPACK_IMPORTED_MODULE_9__src_elastic__[\"b\"]; });\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 自动计算数字坐标轴\n * @author dxq613@gmail.com\n */\nvar isNil = __webpack_require__(5);\n\nvar isNumber = __webpack_require__(9);\n\nvar AutoUtil = __webpack_require__(76);\n\nvar MIN_COUNT = 5;\nvar MAX_COUNT = 7;\nvar SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];\nvar SNAP_ARRAY = [0, 1, 2, 4, 5, 10];\n\nmodule.exports = function (info) {\n  var min = info.min;\n  var max = info.max;\n  var interval = info.interval;\n  var minTickInterval = info.minTickInterval;\n  var ticks = [];\n  var minCount = info.minCount || MIN_COUNT;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var isFixedCount = minCount === maxCount; // 是否限定死了个数\n\n  var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值\n\n  var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值\n\n  var avgCount = (minCount + maxCount) / 2;\n  var count = avgCount; // 用户传入的逼近数组\n\n  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分\n\n  if (min === minLimit && max === maxLimit && isFixedCount) {\n    interval = (max - min) / (count - 1);\n  }\n\n  if (isNil(min)) {\n    min = 0;\n  }\n\n  if (isNil(max)) {\n    max = 0;\n  }\n\n  if (max === min) {\n    if (min === 0) {\n      max = 1;\n    } else {\n      if (min > 0) {\n        min = 0;\n      } else {\n        max = 0;\n      }\n    }\n\n    if (max - min < 5 && !interval && max - min >= 1) {\n      interval = 1;\n    }\n  }\n\n  if (isNil(interval)) {\n    // 计算间距\n    var temp = (max - min) / (avgCount - 1);\n    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');\n\n    if (maxCount !== minCount) {\n      count = parseInt((max - min) / interval, 10);\n\n      if (count > maxCount) {\n        count = maxCount;\n      }\n\n      if (count < minCount) {\n        count = minCount;\n      } // 不确定tick的个数时，使得tick偏小\n\n\n      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');\n    }\n  } // interval should not be less than minTickInterval\n\n\n  if (isNumber(minTickInterval) && interval < minTickInterval) {\n    interval = minTickInterval;\n  }\n\n  if (info.interval || maxCount !== minCount) {\n    // 校正 max 和 min\n    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近\n\n    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近\n\n    count = Math.round((max - min) / interval);\n    min = AutoUtil.fixedBase(min, interval);\n    max = AutoUtil.fixedBase(max, interval);\n  } else {\n    avgCount = parseInt(avgCount, 10); // 取整\n\n    var avg = (max + min) / 2;\n    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');\n    var sideCount = Math.floor((avgCount - 2) / 2);\n    var maxTick = avgTick + sideCount * interval;\n    var minTick;\n\n    if (avgCount % 2 === 0) {\n      minTick = avgTick - sideCount * interval;\n    } else {\n      minTick = avgTick - (sideCount + 1) * interval;\n    }\n\n    if (maxTick < max) {\n      maxTick = maxTick + interval;\n    }\n\n    if (minTick > min) {\n      minTick = minTick - interval;\n    }\n\n    max = AutoUtil.fixedBase(maxTick, interval);\n    min = AutoUtil.fixedBase(minTick, interval);\n  }\n\n  max = Math.min(max, maxLimit);\n  min = Math.max(min, minLimit);\n  ticks.push(min);\n\n  for (var i = 1; i < count; i++) {\n    var tickValue = AutoUtil.fixedBase(interval * i + min, interval);\n\n    if (tickValue < max) {\n      ticks.push(tickValue);\n    }\n  }\n\n  if (ticks[ticks.length - 1] < max) {\n    ticks.push(max);\n  }\n\n  return {\n    min: min,\n    max: max,\n    interval: interval,\n    count: count,\n    ticks: ticks\n  };\n};\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(17);\n\nvar isNumber = __webpack_require__(9);\n\nvar Identity =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Identity, _Base);\n\n  function Identity() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Identity.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    this.isIdentity = true;\n    this.type = 'identity';\n    /**\n     * 常量值\n     * @type {*}\n     */\n\n    this.value = null;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.getText = function getText() {\n    return this.value.toString();\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    if (this.value !== value && isNumber(value)) {\n      return value;\n    }\n\n    return this.range[0];\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.invert = function invert() {\n    return this.value;\n  };\n\n  return Identity;\n}(Base);\n\nBase.Identity = Identity;\nmodule.exports = Identity;\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The measurement of linear data scale function\n * @author dxq613@gmail.com\n */\n\n\nvar fecha = __webpack_require__(79);\n\nvar each = __webpack_require__(2);\n\nvar isNil = __webpack_require__(5);\n\nvar isString = __webpack_require__(10);\n\nvar Base = __webpack_require__(17);\n\nvar Linear = __webpack_require__(33);\n\nvar timeAuto = __webpack_require__(177);\n\nvar TimeUtil = __webpack_require__(71);\n/**\n * 时间度量的构造函数\n * @class Scale.Time\n */\n\n\nvar Time =\n/*#__PURE__*/\nfunction (_Linear) {\n  _inheritsLoose(Time, _Linear);\n\n  function Time() {\n    return _Linear.apply(this, arguments) || this;\n  }\n\n  var _proto = Time.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Linear.prototype._initDefaultCfg.call(this);\n\n    this.type = 'time';\n    this.mask = 'YYYY-MM-DD';\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.init = function init() {\n    var self = this;\n    var values = self.values;\n\n    if (values && values.length) {\n      // 重新计算最大最小值\n      var timeStamps = [];\n      var min = Infinity; // 最小值\n\n      var secondMin = min; // 次小值\n\n      var max = 0; // 使用一个循环，计算min,max,secondMin\n\n      each(values, function (v) {\n        var timeStamp = self._toTimeStamp(v);\n\n        if (isNaN(timeStamp)) {\n          throw new TypeError(\"Invalid Time: \" + v);\n        }\n\n        if (min > timeStamp) {\n          secondMin = min;\n          min = timeStamp;\n        } else if (secondMin > timeStamp) {\n          secondMin = timeStamp;\n        }\n\n        if (max < timeStamp) {\n          max = timeStamp;\n        }\n\n        timeStamps.push(timeStamp);\n      }); // 存在多个值时，设置最小间距\n\n      if (values.length > 1) {\n        self.minTickInterval = secondMin - min;\n      }\n\n      if (isNil(self.min) || self._toTimeStamp(self.min) > min) {\n        self.min = min;\n      }\n\n      if (isNil(self.max) || self._toTimeStamp(self.max) < max) {\n        self.max = max;\n      }\n    }\n\n    _Linear.prototype.init.call(this);\n  };\n\n  _proto.calculateTicks = function calculateTicks() {\n    var self = this;\n    var min = self.min;\n    var max = self.max;\n    var count = self.tickCount;\n    var interval = self.tickInterval;\n    var tmp = timeAuto({\n      min: min,\n      max: max,\n      minCount: count,\n      maxCount: count,\n      interval: interval,\n      minInterval: self.minTickInterval\n    });\n    return tmp.ticks;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.getText = function getText(value) {\n    var formatter = this.formatter;\n    value = this.translate(value);\n    value = formatter ? formatter(value) : fecha.format(value, this.mask);\n    return value;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    if (isString(value)) {\n      value = this.translate(value);\n    }\n\n    return _Linear.prototype.scale.call(this, value);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.translate = function translate(value) {\n    return this._toTimeStamp(value);\n  }; // 将时间转换为时间戳\n\n\n  _proto._toTimeStamp = function _toTimeStamp(value) {\n    return TimeUtil.toTimeStamp(value);\n  };\n\n  return Time;\n}(Linear);\n\nBase.Time = Time;\nmodule.exports = Time;\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 计算时间坐标轴\n * @author dxq613@gmail.com\n */\nvar AutoUtil = __webpack_require__(76);\n\nvar isNil = __webpack_require__(5);\n\nvar MAX_COUNT = 6;\nvar SNAP_ARRAY = [1, 2, 4, 6, 8, 12];\nvar MINUTE_MS = 60 * 1000;\nvar HOUR_MS = 3600 * 1000;\nvar DAY_MS = 24 * 3600 * 1000;\n\nfunction getYear(date) {\n  return new Date(date).getFullYear();\n}\n\nfunction createYear(year) {\n  return new Date(year, 0, 1).getTime();\n}\n\nfunction getMonth(date) {\n  return new Date(date).getMonth();\n}\n\nfunction diffMonth(min, max) {\n  var minYear = getYear(min);\n  var maxYear = getYear(max);\n  var minMonth = getMonth(min);\n  var maxMonth = getMonth(max);\n  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;\n}\n\nfunction creatMonth(year, month) {\n  return new Date(year, month, 1).getTime();\n}\n\nfunction diffDay(min, max) {\n  return Math.ceil((max - min) / DAY_MS);\n}\n\nfunction diffHour(min, max) {\n  return Math.ceil((max - min) / HOUR_MS);\n}\n\nfunction diffMinus(min, max) {\n  return Math.ceil((max - min) / (60 * 1000));\n}\n\nmodule.exports = function (info) {\n  var minInterval = info.minInterval;\n  var ticks = [];\n  var min = info.min;\n  var max = info.max;\n  var interval = info.interval;\n  var count; // 如果最大值和最小值相等，则设置最大值大于最小值一天\n\n  if (max === min) {\n    max = min + DAY_MS;\n  } // 计算间距\n\n\n  if (isNil(interval)) {\n    var innerTime = max - min;\n    var dms = DAY_MS; // 天代表的秒\n\n    var yms = 365 * dms; // 年代表的秒\n\n    interval = parseInt(innerTime / (info.maxCount || MAX_COUNT), 10);\n\n    if (minInterval && minInterval > interval) {\n      interval = minInterval;\n    }\n\n    var yfactor = interval / yms;\n    var minYear = getYear(min); // 大于半年\n\n    if (yfactor > 0.51) {\n      var year = Math.ceil(yfactor); // interval = year * yms;\n\n      var maxYear = getYear(max);\n\n      for (var i = minYear; i <= maxYear + year; i = i + year) {\n        ticks.push(createYear(i));\n      }\n\n      interval = null;\n    } else if (yfactor > 0.0834) {\n      // 大于一个月\n      var month = Math.ceil(yfactor / 0.0834);\n      var mmMoth = getMonth(min);\n      var dMonths = diffMonth(min, max);\n\n      for (var _i = 0; _i <= dMonths + month; _i = _i + month) {\n        ticks.push(creatMonth(minYear, _i + mmMoth));\n      }\n\n      interval = null;\n    } else if (interval > dms * 0.5) {\n      // 大于一天\n      var date = new Date(min);\n\n      var _year = date.getFullYear();\n\n      var _month = date.getMonth(min);\n\n      var mday = date.getDate();\n      var day = Math.ceil(interval / dms);\n      var ddays = diffDay(min, max);\n      interval = day * dms;\n\n      for (var _i2 = 0; _i2 < ddays + day; _i2 = _i2 + day) {\n        ticks.push(new Date(_year, _month, mday + _i2).getTime());\n      }\n    } else if (interval > HOUR_MS) {\n      // 大于一个小时\n      var _date = new Date(min);\n\n      var _year2 = _date.getFullYear();\n\n      var _month2 = _date.getMonth(min);\n\n      var _day = _date.getDate();\n\n      var hour = _date.getHours();\n\n      var hours = AutoUtil.snapTo(SNAP_ARRAY, Math.ceil(interval / HOUR_MS));\n      var dHours = diffHour(min, max);\n      interval = hours * HOUR_MS;\n\n      for (var _i3 = 0; _i3 <= dHours + hours; _i3 = _i3 + hours) {\n        ticks.push(new Date(_year2, _month2, _day, hour + _i3).getTime());\n      }\n    } else if (interval > MINUTE_MS) {\n      // 最小单位是分钟\n      var dMinus = diffMinus(min, max);\n      var minutes = Math.ceil(interval / MINUTE_MS);\n      interval = minutes * MINUTE_MS;\n\n      for (var _i4 = 0; _i4 <= dMinus + minutes; _i4 = _i4 + minutes) {\n        ticks.push(min + _i4 * MINUTE_MS);\n      }\n    } else {\n      if (interval < 1000) {\n        interval = 1000;\n      }\n\n      min = Math.floor(min / 1000) * 1000;\n      var dSeconds = Math.ceil((max - min) / 1000);\n      var seconds = Math.ceil(interval / 1000);\n      interval = seconds * 1000;\n\n      for (var _i5 = 0; _i5 < dSeconds + seconds; _i5 = _i5 + seconds) {\n        ticks.push(min + _i5 * 1000);\n      }\n    }\n  }\n\n  if (!ticks.length) {\n    min = Math.floor(min / 1000) * 1000;\n    max = Math.ceil(max / 1000) * 1000;\n    count = (max - min) / interval;\n\n    for (var _i6 = 0; _i6 <= count; _i6++) {\n      ticks.push(AutoUtil.fixedBase(interval * _i6 + min, interval));\n    }\n  }\n\n  return {\n    max: max,\n    min: min,\n    interval: interval,\n    ticks: ticks,\n    count: ticks.length\n  };\n};\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview 时间数据作为分类类型\n * @author dxq613@gmail.com\n */\n\n\nvar Base = __webpack_require__(17);\n\nvar Category = __webpack_require__(77);\n\nvar fecha = __webpack_require__(79);\n\nvar catAuto = __webpack_require__(78);\n\nvar TimeUtil = __webpack_require__(71);\n\nvar each = __webpack_require__(2);\n\nvar isNumber = __webpack_require__(9);\n\nvar isObject = __webpack_require__(24);\n\nvar isString = __webpack_require__(10);\n/**\n * 度量的构造函数\n * @class Scale.TimeCategory\n */\n\n\nvar TimeCategory =\n/*#__PURE__*/\nfunction (_Category) {\n  _inheritsLoose(TimeCategory, _Category);\n\n  function TimeCategory() {\n    return _Category.apply(this, arguments) || this;\n  }\n\n  var _proto = TimeCategory.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Category.prototype._initDefaultCfg.call(this);\n\n    this.type = 'timeCat';\n    /**\n     * 是否需要排序，默认进行排序\n     * @type {Boolean}\n     */\n\n    this.sortable = true;\n    this.tickCount = 5;\n    /**\n     * 时间格式化\n     * @type {String}\n     */\n\n    this.mask = 'YYYY-MM-DD';\n  };\n\n  _proto.init = function init() {\n    var self = this;\n    var values = this.values; // 针对时间分类类型，会将时间统一转换为时间戳\n\n    each(values, function (v, i) {\n      values[i] = self._toTimeStamp(v);\n    });\n\n    if (this.sortable) {\n      // 允许排序\n      values.sort(function (v1, v2) {\n        return v1 - v2;\n      });\n    }\n\n    if (!self.ticks) {\n      self.ticks = this.calculateTicks();\n    }\n  };\n  /**\n   * 计算 ticks\n   * @return {array} 返回 ticks 数组\n   */\n\n\n  _proto.calculateTicks = function calculateTicks() {\n    var self = this;\n    var count = self.tickCount;\n    var ticks;\n\n    if (count) {\n      var temp = catAuto({\n        maxCount: count,\n        data: self.values,\n        isRounding: self.isRounding\n      });\n      ticks = temp.ticks;\n    } else {\n      ticks = self.values;\n    }\n\n    return ticks;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.translate = function translate(value) {\n    value = this._toTimeStamp(value);\n    var index = this.values.indexOf(value);\n\n    if (index === -1) {\n      if (isNumber(value) && value < this.values.length) {\n        index = value;\n      } else {\n        index = NaN;\n      }\n    }\n\n    return index;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    var index = this.translate(value);\n    var percent;\n\n    if (this.values.length === 1 || isNaN(index)) {\n      // is index is NAN should not be set as 0\n      percent = index;\n    } else if (index > -1) {\n      percent = index / (this.values.length - 1);\n    } else {\n      percent = 0;\n    }\n\n    return rangeMin + percent * (rangeMax - rangeMin);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.getText = function getText(value) {\n    var result = '';\n    var index = this.translate(value);\n\n    if (index > -1) {\n      result = this.values[index];\n    } else {\n      result = value;\n    }\n\n    var formatter = this.formatter;\n    result = parseInt(result, 10);\n    result = formatter ? formatter(result) : fecha.format(result, this.mask);\n    return result;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.getTicks = function getTicks() {\n    var self = this;\n    var ticks = this.ticks;\n    var rst = [];\n    each(ticks, function (tick) {\n      var obj;\n\n      if (isObject(tick)) {\n        obj = tick;\n      } else {\n        obj = {\n          text: isString(tick) ? tick : self.getText(tick),\n          value: self.scale(tick),\n          tickValue: tick // 用于坐标轴上文本动画时确定前后帧的对应关系\n\n        };\n      }\n\n      rst.push(obj);\n    });\n    return rst;\n  }; // 将时间转换为时间戳\n\n\n  _proto._toTimeStamp = function _toTimeStamp(value) {\n    return TimeUtil.toTimeStamp(value);\n  };\n\n  return TimeCategory;\n}(Category);\n\nBase.TimeCat = TimeCategory;\nmodule.exports = TimeCategory;\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview 使用度量，进行log转换\n * @author dxq613@gmail.com\n */\n\n\nvar each = __webpack_require__(2);\n\nvar Base = __webpack_require__(17);\n\nvar Linear = __webpack_require__(33); // 计算log\n\n\nfunction log(a, b) {\n  if (a === 1) {\n    return 1;\n  }\n\n  return Math.log(b) / Math.log(a);\n}\n/**\n * 度量的log计算\n * @class Scale.Log\n */\n\n\nvar Log =\n/*#__PURE__*/\nfunction (_Linear) {\n  _inheritsLoose(Log, _Linear);\n\n  function Log() {\n    return _Linear.apply(this, arguments) || this;\n  }\n\n  var _proto = Log.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Linear.prototype._initDefaultCfg.call(this);\n\n    this.type = 'log';\n    /**\n     * @override\n     * log 的坐标点的个数控制在10个以下\n     * @type {Number}\n     */\n\n    this.tickCount = 10;\n    /**\n     * 进行log计算的基数\n     * @type {Number}\n     */\n\n    this.base = 2; // 最小的tick，仅内部使用\n\n    this._minTick = null;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.calculateTicks = function calculateTicks() {\n    var self = this;\n    var base = self.base;\n    var minTick;\n\n    if (self.min < 0) {\n      throw new Error('The minimum value must be greater than zero!');\n    }\n\n    var maxTick = log(base, self.max);\n\n    if (self.min > 0) {\n      minTick = Math.floor(log(base, self.min));\n    } else {\n      var values = self.values;\n      var positiveMin = self.max; // 查找大于0的第一个值, 如果都小于0，默认为1\n\n      each(values, function (value) {\n        if (value > 0 && value < positiveMin) {\n          positiveMin = value;\n        }\n      });\n\n      if (positiveMin === self.max) {\n        positiveMin = self.max / base;\n      }\n\n      if (positiveMin > 1) {\n        positiveMin = 1;\n      }\n\n      minTick = Math.floor(log(base, positiveMin));\n      self._minTick = minTick;\n      self.positiveMin = positiveMin;\n    }\n\n    var count = maxTick - minTick;\n    var tickCount = self.tickCount;\n    var avg = Math.ceil(count / tickCount);\n    var ticks = [];\n\n    for (var i = minTick; i < maxTick + avg; i = i + avg) {\n      ticks.push(Math.pow(base, i));\n    }\n\n    if (self.min === 0) {\n      ticks.unshift(0);\n    }\n\n    return ticks;\n  }; // 获取度量计算时，value占的定义域百分比\n\n\n  _proto._getScalePercent = function _getScalePercent(value) {\n    var max = this.max;\n    var min = this.min;\n\n    if (max === min) {\n      return 0;\n    } // 如果值小于等于0，则按照0处理\n\n\n    if (value <= 0) {\n      return 0;\n    }\n\n    var base = this.base;\n    var positiveMin = this.positiveMin; // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示\n\n    if (positiveMin) {\n      min = positiveMin * 1 / base;\n    }\n\n    var percent; // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例\n\n    if (value < positiveMin) {\n      percent = value / positiveMin / (log(base, max) - log(base, min));\n    } else {\n      percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));\n    }\n\n    return percent;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    var percent = this._getScalePercent(value);\n\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    return rangeMin + percent * (rangeMax - rangeMin);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.invert = function invert(value) {\n    var base = this.base;\n    var max = log(base, this.max);\n    var rangeMin = this.rangeMin();\n    var range = this.rangeMax() - rangeMin;\n    var min;\n    var positiveMin = this.positiveMin;\n\n    if (positiveMin) {\n      if (value === 0) {\n        return 0;\n      }\n\n      min = log(base, positiveMin / base);\n      var appendPercent = 1 / (max - min) * range; // 0 到 positiveMin的占比\n\n      if (value < appendPercent) {\n        // 落到 0 - positiveMin 之间\n        return value / appendPercent * positiveMin;\n      }\n    } else {\n      min = log(base, this.min);\n    }\n\n    var percent = (value - rangeMin) / range;\n    var tmp = percent * (max - min) + min;\n    return Math.pow(base, tmp);\n  };\n\n  return Log;\n}(Linear);\n\nBase.Log = Log;\nmodule.exports = Log;\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview 使用pow进行度量计算\n * @author dxq613@gmail.com\n */\n\n\nvar Base = __webpack_require__(17);\n\nvar Linear = __webpack_require__(33); // 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n\n\nfunction calBase(a, b) {\n  var e = Math.E;\n  var value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n\n  return value;\n}\n/**\n * 度量的Pow计算\n * @class Scale.Log\n */\n\n\nvar Pow =\n/*#__PURE__*/\nfunction (_Linear) {\n  _inheritsLoose(Pow, _Linear);\n\n  function Pow() {\n    return _Linear.apply(this, arguments) || this;\n  }\n\n  var _proto = Pow.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Linear.prototype._initDefaultCfg.call(this);\n\n    this.type = 'pow';\n    /**\n     * @override\n     * pow 的坐标点的个数控制在10个以下\n     * @type {Number}\n     */\n\n    this.tickCount = 10;\n    /**\n     * 进行pow计算的基数\n     * @type {Number}\n     */\n\n    this.exponent = 2;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.calculateTicks = function calculateTicks() {\n    var self = this;\n    var exponent = self.exponent;\n    var min;\n    var max = Math.ceil(calBase(exponent, self.max));\n\n    if (self.min >= 0) {\n      min = Math.floor(calBase(exponent, self.min));\n    } else {\n      min = 0;\n    }\n\n    if (min > max) {\n      var tmp = max;\n      max = min;\n      min = tmp;\n    }\n\n    var count = max - min;\n    var tickCount = self.tickCount;\n    var avg = Math.ceil(count / tickCount);\n    var ticks = [];\n\n    for (var i = min; i < max + avg; i = i + avg) {\n      ticks.push(Math.pow(i, exponent));\n    }\n\n    return ticks;\n  }; // 获取度量计算时，value占的定义域百分比\n\n\n  _proto._getScalePercent = function _getScalePercent(value) {\n    var max = this.max;\n    var min = this.min;\n\n    if (max === min) {\n      return 0;\n    }\n\n    var exponent = this.exponent;\n    var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));\n    return percent;\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.scale = function scale(value) {\n    var percent = this._getScalePercent(value);\n\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    return rangeMin + percent * (rangeMax - rangeMin);\n  };\n  /**\n   * @override\n   */\n\n\n  _proto.invert = function invert(value) {\n    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());\n    var exponent = this.exponent;\n    var max = calBase(exponent, this.max);\n    var min = calBase(exponent, this.min);\n    var tmp = percent * (max - min) + min;\n    return Math.pow(tmp, exponent);\n  };\n\n  return Pow;\n}(Linear);\n\nBase.Pow = Pow;\nmodule.exports = Pow;\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Event = __webpack_require__(100);\n\nvar Group = __webpack_require__(101);\n\nvar Timeline = __webpack_require__(190);\n\nvar renderers = __webpack_require__(215);\n\nvar Canvas = function Canvas(cfg) {\n  Canvas.superclass.constructor.call(this, cfg);\n};\n\nCanvas.CFG = {\n  eventEnable: true,\n\n  /**\n   * 像素宽度\n   * @type {Number}\n   */\n  width: null,\n\n  /**\n   * 像素高度\n   * @type {Number}\n   */\n  height: null,\n\n  /**\n   * 画布宽度\n   * @type {Number}\n   */\n  widthCanvas: null,\n\n  /**\n   * 画布高度\n   * @type {Number}\n   */\n  heightCanvas: null,\n\n  /**\n   * CSS宽\n   * @type {String}\n   */\n  widthStyle: null,\n\n  /**\n   * CSS高\n   * @type {String}\n   */\n  heightStyle: null,\n\n  /**\n   * 容器DOM\n   * @type {Object}\n   */\n  containerDOM: null,\n\n  /**\n   * 当前Canvas的DOM\n   * @type {Object}\n   */\n  canvasDOM: null,\n\n  /**\n   * 屏幕像素比\n   * @type {Number}\n   */\n  pixelRatio: null,\n\n  /**\n   * 渲染器，默认是canvas\n   * @type {String}\n   */\n  renderer: 'canvas'\n};\nUtil.extend(Canvas, Group);\nUtil.augment(Canvas, {\n  init: function init() {\n    Canvas.superclass.init.call(this);\n\n    this._setGlobalParam();\n\n    this._setContainer();\n\n    this._initPainter();\n\n    this._scale();\n\n    if (this.get('eventEnable')) {\n      this._registEvents();\n    }\n  },\n  getEmitter: function getEmitter(element, event) {\n    if (element) {\n      if (Util.isEmpty(element._getEvents())) {\n        var parent = element.get('parent');\n\n        if (parent && !event.propagationStopped) {\n          return this.getEmitter(parent, event);\n        }\n      } else {\n        return element;\n      }\n    }\n  },\n  _getEventObj: function _getEventObj(type, e, point, target) {\n    var event = new Event(type, e, true, true);\n    event.x = point.x;\n    event.y = point.y;\n    event.clientX = e.clientX;\n    event.clientY = e.clientY;\n    event.currentTarget = target;\n    event.target = target;\n    return event;\n  },\n  _triggerEvent: function _triggerEvent(type, e) {\n    var point = this.getPointByClient(e.clientX, e.clientY);\n    var shape = this.getShape(point.x, point.y, e);\n    var el = this.get('el');\n    var emitObj;\n\n    if (type === 'mousemove') {\n      var preShape = this.get('preShape');\n\n      if (preShape && preShape !== shape) {\n        var mouseleave = this._getEventObj('mouseleave', e, point, preShape);\n\n        emitObj = this.getEmitter(preShape, e);\n        emitObj && emitObj.emit('mouseleave', mouseleave);\n        el.style.cursor = 'default';\n      }\n\n      if (shape) {\n        var mousemove = this._getEventObj('mousemove', e, point, shape);\n\n        emitObj = this.getEmitter(shape, e);\n        emitObj && emitObj.emit('mousemove', mousemove);\n\n        if (preShape !== shape) {\n          var mouseenter = this._getEventObj('mouseenter', e, point, shape);\n\n          emitObj && emitObj.emit('mouseenter', mouseenter, e);\n        }\n      } else {\n        var canvasmousemove = this._getEventObj('mousemove', e, point, this);\n\n        this.emit('mousemove', canvasmousemove);\n      }\n\n      this.set('preShape', shape);\n    } else {\n      var event = this._getEventObj(type, e, point, shape || this);\n\n      emitObj = this.getEmitter(shape, e);\n\n      if (emitObj && emitObj !== this) {\n        emitObj.emit(type, event);\n      }\n\n      this.emit(type, event);\n    }\n\n    if (shape && !shape.get('destroyed')) {\n      el.style.cursor = shape.attr('cursor') || 'default';\n    }\n  },\n  _registEvents: function _registEvents() {\n    var self = this;\n    var el = self.get('el');\n    var events = ['mouseout', 'mouseover', 'mousemove', 'mousedown', 'mouseleave', 'mouseup', 'click', 'dblclick'];\n    Util.each(events, function (event) {\n      el.addEventListener(event, function (e) {\n        self._triggerEvent(event, e);\n      }, false);\n    }); // special cases\n\n    el.addEventListener('touchstart', function (e) {\n      if (!Util.isEmpty(e.touches)) {\n        self._triggerEvent('touchstart', e.touches[0]);\n      }\n    }, false);\n    el.addEventListener('touchmove', function (e) {\n      if (!Util.isEmpty(e.touches)) {\n        self._triggerEvent('touchmove', e.touches[0]);\n      }\n    }, false);\n    el.addEventListener('touchend', function (e) {\n      if (!Util.isEmpty(e.changedTouches)) {\n        self._triggerEvent('touchend', e.changedTouches[0]);\n      }\n    }, false);\n  },\n  _scale: function _scale() {\n    if (this._cfg.renderType !== 'svg') {\n      var pixelRatio = this.get('pixelRatio');\n      this.scale(pixelRatio, pixelRatio);\n    }\n  },\n  _setGlobalParam: function _setGlobalParam() {\n    var renderType = this.get('renderer') || 'canvas';\n\n    if (renderType === 'svg') {\n      this.set('pixelRatio', 1);\n    } else if (!this.get('pixelRatio')) {\n      this.set('pixelRatio', Util.getRatio());\n    }\n\n    this._cfg.renderType = renderType;\n    var renderer = renderers[renderType];\n    this._cfg.renderer = renderer;\n    this._cfg.canvas = this;\n    var timeline = new Timeline(this);\n    this._cfg.timeline = timeline;\n  },\n  _setContainer: function _setContainer() {\n    var containerId = this.get('containerId');\n    var containerDOM = this.get('containerDOM');\n\n    if (!containerDOM) {\n      containerDOM = document.getElementById(containerId);\n      this.set('containerDOM', containerDOM);\n    }\n\n    Util.modifyCSS(containerDOM, {\n      position: 'relative'\n    });\n  },\n  _initPainter: function _initPainter() {\n    var containerDOM = this.get('containerDOM');\n    var painter = new this._cfg.renderer.painter(containerDOM);\n    this._cfg.painter = painter;\n    this._cfg.canvasDOM = this._cfg.el = painter.canvas;\n    this.changeSize(this.get('width'), this.get('height'));\n  },\n  _resize: function _resize() {\n    var canvasDOM = this.get('canvasDOM');\n    var widthCanvas = this.get('widthCanvas');\n    var heightCanvas = this.get('heightCanvas');\n    var widthStyle = this.get('widthStyle');\n    var heightStyle = this.get('heightStyle');\n    canvasDOM.style.width = widthStyle;\n    canvasDOM.style.height = heightStyle;\n    canvasDOM.setAttribute('width', widthCanvas);\n    canvasDOM.setAttribute('height', heightCanvas);\n  },\n  getWidth: function getWidth() {\n    var pixelRatio = this.get('pixelRatio');\n    var width = this.get('width');\n    return width * pixelRatio;\n  },\n  getHeight: function getHeight() {\n    var pixelRatio = this.get('pixelRatio');\n    var height = this.get('height');\n    return height * pixelRatio;\n  },\n  changeSize: function changeSize(width, height) {\n    var pixelRatio = this.get('pixelRatio');\n    var widthCanvas = width * pixelRatio;\n    var heightCanvas = height * pixelRatio;\n    this.set('widthCanvas', widthCanvas);\n    this.set('heightCanvas', heightCanvas);\n    this.set('widthStyle', width + 'px');\n    this.set('heightStyle', height + 'px');\n    this.set('width', width);\n    this.set('height', height);\n\n    this._resize();\n  },\n\n  /**\n   * 将窗口坐标转变成 canvas 坐标\n   * @param  {Number} clientX 窗口x坐标\n   * @param  {Number} clientY 窗口y坐标\n   * @return {Object} canvas坐标\n   */\n  getPointByClient: function getPointByClient(clientX, clientY) {\n    var el = this.get('el');\n    var pixelRatio = this.get('pixelRatio') || 1;\n    var bbox = el.getBoundingClientRect();\n    return {\n      x: (clientX - bbox.left) * pixelRatio,\n      y: (clientY - bbox.top) * pixelRatio\n    };\n  },\n  getClientByPoint: function getClientByPoint(x, y) {\n    var el = this.get('el');\n    var bbox = el.getBoundingClientRect();\n    var pixelRatio = this.get('pixelRatio') || 1;\n    return {\n      clientX: x / pixelRatio + bbox.left,\n      clientY: y / pixelRatio + bbox.top\n    };\n  },\n  draw: function draw() {\n    this._cfg.painter.draw(this);\n  },\n  getShape: function getShape(x, y, e) {\n    if (arguments.length === 3 && this._cfg.renderer.getShape) {\n      return this._cfg.renderer.getShape.call(this, x, y, e);\n    }\n\n    return Canvas.superclass.getShape.call(this, x, y);\n  },\n  getRenderer: function getRenderer() {\n    return this._cfg.renderType;\n  },\n  _drawSync: function _drawSync() {\n    this._cfg.painter.drawSync(this);\n  },\n  destroy: function destroy() {\n    var cfg = this._cfg;\n    var containerDOM = cfg.containerDOM;\n    var canvasDOM = cfg.canvasDOM;\n\n    if (canvasDOM && containerDOM) {\n      containerDOM.removeChild(canvasDOM);\n    }\n\n    cfg.timeline.stop();\n    Canvas.superclass.destroy.call(this);\n  }\n});\nmodule.exports = Canvas;\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sub = exports.mul = undefined;\nexports.create = create;\nexports.fromMat4 = fromMat4;\nexports.clone = clone;\nexports.copy = copy;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.identity = identity;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.fromTranslation = fromTranslation;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.fromMat2d = fromMat2d;\nexports.fromQuat = fromQuat;\nexports.normalFromMat4 = normalFromMat4;\nexports.projection = projection;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(52);\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\n\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\n\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\n\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\n\n\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\n\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n\n;\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\n\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\n\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\n\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\n\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\n\n\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\n\nfunction str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\n\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\n\nvar mul = exports.mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nvar sub = exports.sub = subtract;\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.length = length;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.random = random;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.transformMat3 = transformMat3;\nexports.transformMat4 = transformMat4;\nexports.rotate = rotate;\nexports.angle = angle;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(52);\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\n\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\n\nfunction fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\n\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\n\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\n\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\n\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\n\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\n\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\n\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\n\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\n\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\n\n\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n  }\n\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\n\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\n\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\n\n\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {vec2} a The vec2 point to rotate\n * @param {vec2} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec2} out\n */\n\n\nfunction rotate(out, a, b, c) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(c),\n      cosC = Math.cos(c); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {vec2} a The first operand\n * @param {vec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1];\n  var len1 = x1 * x1 + y1 * y1;\n\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n\n  var len2 = x2 * x2 + y2 * y2;\n\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\n\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\n\nvar len = exports.len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nvar sub = exports.sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nvar mul = exports.mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nvar div = exports.div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nvar dist = exports.dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nvar sqrDist = exports.sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nvar sqrLen = exports.sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = exports.forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i = void 0,\n        l = void 0;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.length = length;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.hermite = hermite;\nexports.bezier = bezier;\nexports.random = random;\nexports.transformMat4 = transformMat4;\nexports.transformMat3 = transformMat3;\nexports.transformQuat = transformQuat;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.angle = angle;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(52);\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\n\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\n\nfunction fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\n\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\n\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\n\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\n\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\n\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\n\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n  }\n\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\n\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\n\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\n\n\nfunction rotateX(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\n\n\nfunction rotateY(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\n\n\nfunction rotateZ(out, a, b, c) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\n\nfunction angle(a, b) {\n  var tempA = fromValues(a[0], a[1], a[2]);\n  var tempB = fromValues(b[0], b[1], b[2]);\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n  var cosine = dot(tempA, tempB);\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\n\nfunction str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\n\nvar sub = exports.sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar mul = exports.mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar div = exports.div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar dist = exports.dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar sqrDist = exports.sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar len = exports.len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar sqrLen = exports.sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = exports.forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i = void 0,\n        l = void 0;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nmodule.exports = {\n  canFill: false,\n  canStroke: false,\n  initAttrs: function initAttrs(attrs) {\n    this._attrs = {\n      opacity: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n    };\n    this.attr(Util.assign(this.getDefaultAttrs(), attrs));\n    return this;\n  },\n  getDefaultAttrs: function getDefaultAttrs() {\n    return {};\n  },\n\n  /**\n   * 设置或者设置属性，有以下 4 种情形：\n   *   - name 不存在, 则返回属性集合\n   *   - name 为字符串，value 为空，获取属性值\n   *   - name 为字符串，value 不为空，设置属性值，返回 this\n   *   - name 为键值对，value 为空，设置属性值\n   *\n   * @param  {String | Object} name  属性名\n   * @param  {*} value 属性值\n   * @return {*} 属性值\n   */\n  attr: function attr(name, value) {\n    var self = this;\n\n    if (arguments.length === 0) {\n      return self._attrs;\n    }\n\n    if (Util.isObject(name)) {\n      // self._attrs = Util.deepMix(self._attrs, name);\n      for (var k in name) {\n        this._setAttr(k, name[k]);\n      }\n\n      self.clearBBox();\n      this._cfg.hasUpdate = true;\n      return self;\n    }\n\n    if (arguments.length === 2) {\n      this._setAttr(name, value);\n\n      self.clearBBox();\n      this._cfg.hasUpdate = true;\n      return self;\n    }\n\n    return self._attrs[name];\n  },\n  _setAttr: function _setAttr(name, value) {\n    var self = this;\n    var attrs = this._attrs;\n    attrs[name] = value;\n\n    if (name === 'fill' || name === 'stroke') {\n      attrs[name + 'Style'] = value;\n      return;\n    }\n\n    if (name === 'opacity') {\n      attrs.globalAlpha = value;\n      return;\n    }\n\n    if (name === 'clip' && value) {\n      self._setClip(value);\n\n      return;\n    }\n\n    if (name === 'path' && self._afterSetAttrPath) {\n      self._afterSetAttrPath(value);\n\n      return;\n    }\n\n    if (name === 'transform') {\n      self.transform(value);\n      return;\n    }\n\n    if (name === 'rotate') {\n      self.rotateAtStart(value);\n    }\n  },\n  clearBBox: function clearBBox() {\n    this.setSilent('box', null);\n  },\n  hasFill: function hasFill() {\n    return this.canFill && this._attrs.fillStyle;\n  },\n  hasStroke: function hasStroke() {\n    return this.canStroke && this._attrs.strokeStyle;\n  },\n  _setClip: function _setClip(item) {\n    item._cfg.renderer = this._cfg.renderer;\n    item._cfg.canvas = this._cfg.canvas;\n    item._cfg.parent = this._cfg.parent;\n\n    item.hasFill = function () {\n      return true;\n    };\n  }\n};\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1); // 是否未改变\n\n\nfunction isUnchanged(m) {\n  return m[0] === 1 && m[1] === 0 && m[3] === 0 && m[4] === 1 && m[6] === 0 && m[7] === 0;\n} // 是否仅仅是scale\n\n\nfunction isScale(m) {\n  return m[1] === 0 && m[3] === 0 && m[6] === 0 && m[7] === 0;\n}\n\nfunction multiple(m1, m2) {\n  if (!isUnchanged(m2)) {\n    if (isScale(m2)) {\n      m1[0] *= m2[0];\n      m1[4] *= m2[4];\n    } else {\n      Util.mat3.multiply(m1, m1, m2);\n    }\n  }\n}\n\nmodule.exports = {\n  initTransform: function initTransform() {},\n  resetMatrix: function resetMatrix() {\n    this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n  },\n  translate: function translate(tx, ty) {\n    var matrix = this._attrs.matrix;\n    Util.mat3.translate(matrix, matrix, [tx, ty]);\n    this.clearTotalMatrix();\n    this.attr('matrix', matrix);\n    return this;\n  },\n  rotate: function rotate(radian) {\n    var matrix = this._attrs.matrix;\n    Util.mat3.rotate(matrix, matrix, radian);\n    this.clearTotalMatrix();\n    this.attr('matrix', matrix);\n    return this;\n  },\n  scale: function scale(s1, s2) {\n    var matrix = this._attrs.matrix;\n    Util.mat3.scale(matrix, matrix, [s1, s2]);\n    this.clearTotalMatrix();\n    this.attr('matrix', matrix);\n    return this;\n  },\n  rotateAtStart: function rotateAtStart(rotate) {\n    var x = this._attrs.x || this._cfg.attrs.x;\n    var y = this._attrs.y || this._cfg.attrs.y;\n\n    if (Math.abs(rotate) > Math.PI * 2) {\n      rotate = rotate / 180 * Math.PI;\n    }\n\n    return this.transform([['t', -x, -y], ['r', rotate], ['t', x, y]]);\n  },\n  move: function move(x, y) {\n    var cx = this.get('x') || 0; // 当前的x\n\n    var cy = this.get('y') || 0; // 当前的y\n\n    this.translate(x - cx, y - cy);\n    this.set('x', x);\n    this.set('y', y);\n    return this;\n  },\n  transform: function transform(ts) {\n    var self = this;\n    var matrix = this._attrs.matrix;\n    Util.each(ts, function (t) {\n      switch (t[0]) {\n        case 't':\n          self.translate(t[1], t[2]);\n          break;\n\n        case 's':\n          self.scale(t[1], t[2]);\n          break;\n\n        case 'r':\n          self.rotate(t[1]);\n          break;\n\n        case 'm':\n          self.attr('matrix', Util.mat3.multiply([], matrix, t[1]));\n          self.clearTotalMatrix();\n          break;\n\n        default:\n          break;\n      }\n    });\n    return self;\n  },\n  setTransform: function setTransform(ts) {\n    this.attr('matrix', [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n    return this.transform(ts);\n  },\n  getMatrix: function getMatrix() {\n    return this.attr('matrix');\n  },\n  setMatrix: function setMatrix(m) {\n    this.attr('matrix', m);\n    this.clearTotalMatrix();\n    return this;\n  },\n  apply: function apply(v, root) {\n    var m;\n\n    if (root) {\n      m = this._getMatrixByRoot(root);\n    } else {\n      m = this.attr('matrix');\n    }\n\n    Util.vec3.transformMat3(v, v, m);\n    return this;\n  },\n  // 获取到达指定根节点的矩阵\n  _getMatrixByRoot: function _getMatrixByRoot(root) {\n    var self = this;\n    root = root || self;\n    var parent = self;\n    var parents = [];\n\n    while (parent !== root) {\n      parents.unshift(parent);\n      parent = parent.get('parent');\n    }\n\n    parents.unshift(parent);\n    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    Util.each(parents, function (child) {\n      Util.mat3.multiply(m, child.attr('matrix'), m);\n    });\n    return m;\n  },\n\n  /**\n   * 应用到当前元素上的总的矩阵\n   * @return {Matrix} 矩阵\n   */\n  getTotalMatrix: function getTotalMatrix() {\n    var m = this._cfg.totalMatrix;\n\n    if (!m) {\n      m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      var parent = this._cfg.parent;\n\n      if (parent) {\n        var pm = parent.getTotalMatrix();\n        multiple(m, pm);\n      }\n\n      multiple(m, this.attr('matrix'));\n      this._cfg.totalMatrix = m;\n    }\n\n    return m;\n  },\n  // 清除当前的矩阵\n  clearTotalMatrix: function clearTotalMatrix() {// this._cfg.totalMatrix = null;\n  },\n  invert: function invert(v) {\n    var m = this.getTotalMatrix(); // 单精屏幕下大多数矩阵没变化\n\n    if (isScale(m)) {\n      v[0] /= m[0];\n      v[1] /= m[4];\n    } else {\n      var inm = Util.mat3.invert([], m);\n\n      if (inm) {\n        Util.vec3.transformMat3(v, v, inm);\n      }\n    }\n\n    return this;\n  },\n  resetTransform: function resetTransform(context) {\n    var mo = this.attr('matrix'); // 不改变时\n\n    if (!isUnchanged(mo)) {\n      context.transform(mo[0], mo[1], mo[3], mo[4], mo[6], mo[7]);\n    }\n  }\n};\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar ReservedProps = {\n  delay: 'delay',\n  rotate: 'rotate'\n};\nvar colorRalaredProps = {\n  fill: 'fill',\n  stroke: 'stroke',\n  fillStyle: 'fillStyle',\n  strokeStyle: 'strokeStyle'\n};\n\nfunction getFromAttrs(toAttrs, shape) {\n  var rst = {};\n  var attrs = shape._attrs;\n\n  for (var k in toAttrs.attrs) {\n    rst[k] = attrs[k];\n  }\n\n  return rst;\n}\n\nfunction getFormatProps(props, shape) {\n  var rst = {\n    matrix: null,\n    attrs: {}\n  };\n  var attrs = shape._attrs;\n\n  for (var k in props) {\n    if (k === 'transform') {\n      rst.matrix = Util.transform(shape.getMatrix(), props[k]);\n    } else if (k === 'rotate') {\n      rst.matrix = Util.transform(shape.getMatrix(), [['r', props[k]]]);\n    } else if (k === 'matrix') {\n      rst.matrix = props[k];\n    } else if (colorRalaredProps[k] && /^[r,R,L,l]{1}[\\s]*\\(/.test(props[k])) {\n      // 渐变色不支持动画\n      continue;\n    } else if (!ReservedProps[k] && attrs[k] !== props[k]) {\n      rst.attrs[k] = props[k];\n    }\n  }\n\n  return rst;\n}\n\nfunction checkExistedAttrs(animators, animator) {\n  var delay = animator.delay;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  Util.each(animator.toAttrs, function (v, k) {\n    Util.each(animators, function (animator) {\n      if (delay < animator.startTime + animator.duration) {\n        if (hasOwnProperty.call(animator.toAttrs, k)) {\n          delete animator.toAttrs[k];\n          delete animator.fromAttrs[k];\n        }\n      }\n    });\n  });\n\n  if (animator.toMatrix) {\n    Util.each(animators, function (animator) {\n      if (delay < animator.startTime + animator.duration && animator.toMatrix) {\n        delete animator.toMatrix;\n      }\n    });\n  }\n\n  return animators;\n}\n\nmodule.exports = {\n  /**\n   * 执行动画\n   * @param  {Object}   toProps  动画最终状态\n   * @param  {Number}   duration 动画执行时间\n   * @param  {String}   easing   动画缓动效果\n   * @param  {Function} callback 动画执行后的回调\n   * @param  {Number}   delay    动画延迟时间\n   */\n  animate: function animate(toProps, duration, easing, callback, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    var self = this;\n    self.set('animating', true);\n    var timeline = self.get('timeline');\n\n    if (!timeline) {\n      timeline = self.get('canvas').get('timeline');\n      self.setSilent('timeline', timeline);\n    }\n\n    var animators = self.get('animators') || []; // 初始化tick\n\n    if (!timeline._timer) {\n      timeline.initTimer();\n    }\n\n    if (Util.isNumber(callback)) {\n      delay = callback;\n      callback = null;\n    }\n\n    if (Util.isFunction(easing)) {\n      callback = easing;\n      easing = 'easeLinear';\n    } else {\n      easing = easing ? easing : 'easeLinear';\n    }\n\n    var formatProps = getFormatProps(toProps, self); // 记录动画属性\n\n    var animator = {\n      fromAttrs: getFromAttrs(formatProps, self),\n      toAttrs: formatProps.attrs,\n      fromMatrix: Util.clone(self.getMatrix()),\n      toMatrix: formatProps.matrix,\n      duration: duration,\n      easing: easing,\n      callback: callback,\n      delay: delay,\n      startTime: timeline.getTime(),\n      id: Util.uniqueId()\n    }; // 如果动画队列中已经有这个图形了\n\n    if (animators.length > 0) {\n      // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中\n      animators = checkExistedAttrs(animators, animator);\n    } else {\n      // 否则将图形添加到队列\n      timeline.addAnimator(self);\n    }\n\n    animators.push(animator);\n    self.setSilent('animators', animators);\n    self.setSilent('pause', {\n      isPaused: false\n    });\n  },\n  stopAnimate: function stopAnimate() {\n    var _this = this;\n\n    var animators = this.get('animators'); // 将动画执行到最后一帧，执行回调\n\n    Util.each(animators, function (animator) {\n      _this.attr(animator.toAttrs);\n\n      if (animator.toMatrix) {\n        _this.attr('matrix', animator.toMatrix);\n      }\n\n      if (animator.callback) {\n        animator.callback();\n      }\n    });\n    this.setSilent('animating', false);\n    this.setSilent('animators', []);\n  },\n  pauseAnimate: function pauseAnimate() {\n    var self = this;\n    var timeline = self.get('timeline'); // 记录下是在什么时候暂停的\n\n    self.setSilent('pause', {\n      isPaused: true,\n      pauseTime: timeline.getTime()\n    });\n    return self;\n  },\n  resumeAnimate: function resumeAnimate() {\n    var self = this;\n    var timeline = self.get('timeline');\n    var current = timeline.getTime();\n    var animators = self.get('animators');\n    var pauseTime = self.get('pause').pauseTime; // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后\n\n    Util.each(animators, function (animator) {\n      animator.startTime = animator.startTime + (current - pauseTime);\n      animator._paused = false;\n      animator._pauseTime = null;\n    });\n    self.setSilent('pause', {\n      isPaused: false\n    });\n    self.setSilent('animators', animators);\n    return self;\n  }\n};\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Shape = __webpack_require__(6);\n\nShape.Arc = __webpack_require__(105);\nShape.Circle = __webpack_require__(106);\nShape.Dom = __webpack_require__(107);\nShape.Ellipse = __webpack_require__(108);\nShape.Fan = __webpack_require__(109);\nShape.Image = __webpack_require__(110);\nShape.Line = __webpack_require__(111);\nShape.Marker = __webpack_require__(56);\nShape.Path = __webpack_require__(112);\nShape.Polygon = __webpack_require__(113);\nShape.Polyline = __webpack_require__(114);\nShape.Rect = __webpack_require__(115);\nShape.Text = __webpack_require__(116);\nmodule.exports = Shape;\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar Inside = __webpack_require__(54);\n\nvar mathUtl = {\n  arc: __webpack_require__(37),\n  ellipse: __webpack_require__(104),\n  line: __webpack_require__(36)\n};\nvar canvas = Util.createDom('<canvas width=\"500\" height=\"500\"></canvas>');\nvar context = canvas.getContext('2d');\n\nfunction isPointInPathByContext(x, y, ctx) {\n  ctx.createPath(context);\n  return context.isPointInPath(x, y);\n}\n\nvar arc = function arc(x, y) {\n  var attrs = this._attrs;\n  var cx = attrs.x;\n  var cy = attrs.y;\n  var r = attrs.r,\n      startAngle = attrs.startAngle,\n      endAngle = attrs.endAngle,\n      clockwise = attrs.clockwise;\n  var lineWidth = this.getHitLineWidth();\n\n  if (this.hasStroke()) {\n    return Inside.arcline(cx, cy, r, startAngle, endAngle, clockwise, lineWidth, x, y);\n  }\n\n  return false;\n};\n\nvar circle = function circle(x, y) {\n  var attrs = this._attrs;\n  var cx = attrs.x;\n  var cy = attrs.y;\n  var r = attrs.r;\n  var lineWidth = this.getHitLineWidth();\n  var fill = this.hasFill();\n  var stroke = this.hasStroke();\n\n  if (fill && stroke) {\n    return Inside.circle(cx, cy, r, x, y) || Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);\n  }\n\n  if (fill) {\n    return Inside.circle(cx, cy, r, x, y);\n  }\n\n  if (stroke) {\n    return Inside.arcline(cx, cy, r, 0, Math.PI * 2, false, lineWidth, x, y);\n  }\n\n  return false;\n};\n\nvar ellipse = function ellipse(x, y) {\n  var attrs = this._attrs;\n  var fill = this.hasFill();\n  var stroke = this.hasStroke();\n  var cx = attrs.x;\n  var cy = attrs.y;\n  var rx = attrs.rx;\n  var ry = attrs.ry;\n  var lineWidth = this.getHitLineWidth();\n  var r = rx > ry ? rx : ry;\n  var scaleX = rx > ry ? 1 : rx / ry;\n  var scaleY = rx > ry ? ry / rx : 1;\n  var p = [x, y, 1];\n  var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  Util.mat3.scale(m, m, [scaleX, scaleY]);\n  Util.mat3.translate(m, m, [cx, cy]);\n  var inm = Util.mat3.invert([], m);\n  Util.vec3.transformMat3(p, p, inm);\n\n  if (fill && stroke) {\n    return Inside.circle(0, 0, r, p[0], p[1]) || Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);\n  }\n\n  if (fill) {\n    return Inside.circle(0, 0, r, p[0], p[1]);\n  }\n\n  if (stroke) {\n    return Inside.arcline(0, 0, r, 0, Math.PI * 2, false, lineWidth, p[0], p[1]);\n  }\n\n  return false;\n};\n\nvar fan = function fan(x, y) {\n  var self = this;\n  var fill = self.hasFill();\n  var stroke = self.hasStroke();\n  var attrs = self._attrs;\n  var cx = attrs.x;\n  var cy = attrs.y;\n  var rs = attrs.rs;\n  var re = attrs.re;\n  var startAngle = attrs.startAngle;\n  var endAngle = attrs.endAngle;\n  var clockwise = attrs.clockwise;\n  var v1 = [1, 0];\n  var subv = [x - cx, y - cy];\n  var angle = Util.vec2.angleTo(v1, subv);\n\n  function _isPointInFill() {\n    var angle1 = mathUtl.arc.nearAngle(angle, startAngle, endAngle, clockwise);\n\n    if (Util.isNumberEqual(angle, angle1)) {\n      var ls = Util.vec2.squaredLength(subv);\n\n      if (rs * rs <= ls && ls <= re * re) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function _isPointInStroke() {\n    var lineWidth = self.getHitLineWidth();\n    var ssp = {\n      x: Math.cos(startAngle) * rs + cx,\n      y: Math.sin(startAngle) * rs + cy\n    };\n    var sep = {\n      x: Math.cos(startAngle) * re + cx,\n      y: Math.sin(startAngle) * re + cy\n    };\n    var esp = {\n      x: Math.cos(endAngle) * rs + cx,\n      y: Math.sin(endAngle) * rs + cy\n    };\n    var eep = {\n      x: Math.cos(endAngle) * re + cx,\n      y: Math.sin(endAngle) * re + cy\n    };\n\n    if (Inside.line(ssp.x, ssp.y, sep.x, sep.y, lineWidth, x, y)) {\n      return true;\n    }\n\n    if (Inside.line(esp.x, esp.y, eep.x, eep.y, lineWidth, x, y)) {\n      return true;\n    }\n\n    if (Inside.arcline(cx, cy, rs, startAngle, endAngle, clockwise, lineWidth, x, y)) {\n      return true;\n    }\n\n    if (Inside.arcline(cx, cy, re, startAngle, endAngle, clockwise, lineWidth, x, y)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (fill && stroke) {\n    return _isPointInFill() || _isPointInStroke();\n  }\n\n  if (fill) {\n    return _isPointInFill();\n  }\n\n  if (stroke) {\n    return _isPointInStroke();\n  }\n\n  return false;\n};\n\nvar image = function image(x, y) {\n  var attrs = this._attrs;\n\n  if (this.get('toDraw') || !attrs.img) {\n    return false;\n  }\n\n  if (!this._cfg.attrs || this._cfg.attrs.img !== attrs.img) {\n    this._setAttrImg();\n  }\n\n  var rx = attrs.x;\n  var ry = attrs.y;\n  var width = attrs.width;\n  var height = attrs.height;\n  return Inside.rect(rx, ry, width, height, x, y);\n};\n\nvar line = function line(x, y) {\n  var attrs = this._attrs;\n  var x1 = attrs.x1,\n      y1 = attrs.y1,\n      x2 = attrs.x2,\n      y2 = attrs.y2;\n  var lineWidth = this.getHitLineWidth();\n\n  if (this.hasStroke()) {\n    return Inside.line(x1, y1, x2, y2, lineWidth, x, y);\n  }\n\n  return false;\n};\n\nvar path = function path(x, y) {\n  var self = this;\n  var segments = self.get('segments');\n  var fill = self.hasFill();\n  var stroke = self.hasStroke();\n\n  function _isPointInStroke() {\n    if (!Util.isEmpty(segments)) {\n      var lineWidth = self.getHitLineWidth();\n\n      for (var i = 0, l = segments.length; i < l; i++) {\n        if (segments[i].isInside(x, y, lineWidth)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }\n\n  if (fill && stroke) {\n    return isPointInPathByContext(x, y, self) || _isPointInStroke();\n  }\n\n  if (fill) {\n    return isPointInPathByContext(x, y, self);\n  }\n\n  if (stroke) {\n    return _isPointInStroke();\n  }\n\n  return false;\n};\n\nvar polygon = function polygon(x, y) {\n  var self = this;\n  var fill = self.hasFill();\n  var stroke = self.hasStroke();\n\n  function _isPointInStroke() {\n    var attrs = self._attrs;\n    var points = attrs.points;\n\n    if (points.length < 2) {\n      return false;\n    }\n\n    var lineWidth = self.getHitLineWidth();\n    var outPoints = points.slice(0);\n\n    if (points.length >= 3) {\n      outPoints.push(points[0]);\n    }\n\n    return Inside.polyline(outPoints, lineWidth, x, y);\n  }\n\n  if (fill && stroke) {\n    return isPointInPathByContext(x, y, self) || _isPointInStroke();\n  }\n\n  if (fill) {\n    return isPointInPathByContext(x, y, self);\n  }\n\n  if (stroke) {\n    return _isPointInStroke();\n  }\n\n  return false;\n};\n\nvar marker = function marker(x, y) {\n  var attrs = this._attrs;\n  var cx = attrs.x;\n  var cy = attrs.y;\n  var r = attrs.radius || attrs.r;\n  var lineWidth = this.getHitLineWidth();\n  return Inside.circle(cx, cy, r + lineWidth / 2, x, y);\n};\n\nvar polyline = function polyline(x, y) {\n  var self = this;\n  var attrs = self._attrs;\n\n  if (self.hasStroke()) {\n    var points = attrs.points;\n\n    if (points.length < 2) {\n      return false;\n    }\n\n    var lineWidth = attrs.lineWidth;\n    return Inside.polyline(points, lineWidth, x, y);\n  }\n\n  return false;\n};\n\nvar rect = function rect(x, y) {\n  var self = this;\n  var fill = self.hasFill();\n  var stroke = self.hasStroke();\n\n  function _isPointInStroke() {\n    var attrs = self._attrs;\n    var rx = attrs.x;\n    var ry = attrs.y;\n    var width = attrs.width;\n    var height = attrs.height;\n    var radius = attrs.radius;\n    var lineWidth = self.getHitLineWidth();\n\n    if (radius === 0) {\n      var halfWidth = lineWidth / 2;\n      return Inside.line(rx - halfWidth, ry, rx + width + halfWidth, ry, lineWidth, x, y) || Inside.line(rx + width, ry - halfWidth, rx + width, ry + height + halfWidth, lineWidth, x, y) || Inside.line(rx + width + halfWidth, ry + height, rx - halfWidth, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height + halfWidth, rx, ry - halfWidth, lineWidth, x, y);\n    }\n\n    return Inside.line(rx + radius, ry, rx + width - radius, ry, lineWidth, x, y) || Inside.line(rx + width, ry + radius, rx + width, ry + height - radius, lineWidth, x, y) || Inside.line(rx + width - radius, ry + height, rx + radius, ry + height, lineWidth, x, y) || Inside.line(rx, ry + height - radius, rx, ry + radius, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + radius, radius, 1.5 * Math.PI, 2 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + width - radius, ry + height - radius, radius, 0, 0.5 * Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + height - radius, radius, 0.5 * Math.PI, Math.PI, false, lineWidth, x, y) || Inside.arcline(rx + radius, ry + radius, radius, Math.PI, 1.5 * Math.PI, false, lineWidth, x, y);\n  }\n\n  if (fill && stroke) {\n    return isPointInPathByContext(x, y, self) || _isPointInStroke();\n  }\n\n  if (fill) {\n    return isPointInPathByContext(x, y, self);\n  }\n\n  if (stroke) {\n    return _isPointInStroke();\n  }\n\n  return false;\n};\n\nvar text = function text(x, y) {\n  var self = this;\n  var box = self.getBBox();\n\n  if (self.hasFill() || self.hasStroke()) {\n    return Inside.box(box.minX, box.maxX, box.minY, box.maxY, x, y);\n  }\n};\n\nvar dom = function dom(x, y) {\n  if (!this._cfg.el) {\n    return false;\n  }\n\n  var box = this._cfg.el.getBBox();\n\n  return Inside.box(box.x, box.x + box.width, box.y, box.y + box.height, x, y);\n};\n\nvar shapes = {\n  arc: arc,\n  circle: circle,\n  dom: dom,\n  ellipse: ellipse,\n  fan: fan,\n  image: image,\n  line: line,\n  path: path,\n  marker: marker,\n  polygon: polygon,\n  polyline: polyline,\n  rect: rect,\n  text: text\n};\nmodule.exports = {\n  isPointInPath: function isPointInPath(x, y) {\n    var shape = shapes[this.type];\n\n    if (shape) {\n      return shape.call(this, x, y);\n    }\n\n    return false;\n  }\n};\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar PathUtil = __webpack_require__(57);\n\nvar d3Timer = __webpack_require__(170);\n\nvar d3Ease = __webpack_require__(173);\n\nvar _require = __webpack_require__(117),\n    interpolate = _require.interpolate,\n    interpolateArray = _require.interpolateArray; // 目前整体动画只需要数值和数组的差值计算\n\n\nvar Timeline = function Timeline(canvas) {\n  // 待执行动画的队列\n  this._animators = []; // 当前时间\n\n  this._current = 0; // 计时器实例\n\n  this._timer = null; // 画布\n\n  this.canvas = canvas;\n};\n\nfunction _update(self, animator, ratio) {\n  var cProps = {}; // 此刻属性\n\n  var toAttrs = animator.toAttrs;\n  var fromAttrs = animator.fromAttrs;\n  var toMatrix = animator.toMatrix;\n\n  if (self.get('destroyed')) {\n    return;\n  }\n\n  var interf; //  差值函数\n\n  for (var k in toAttrs) {\n    if (!Util.isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        var toPath = toAttrs[k];\n        var fromPath = fromAttrs[k];\n\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animator.fromAttrs.path = fromPath;\n          animator.toAttrs.path = toPath;\n        } else if (!animator.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animator.fromAttrs.path = fromPath;\n          animator.toAttrs.path = toPath;\n          animator.pathFormatted = true;\n        }\n\n        cProps[k] = [];\n\n        for (var i = 0; i < toPath.length; i++) {\n          var toPathPoint = toPath[i];\n          var fromPathPoint = fromPath[i];\n          var cPathPoint = [];\n\n          for (var j = 0; j < toPathPoint.length; j++) {\n            if (Util.isNumber(toPathPoint[j]) && fromPathPoint && Util.isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n\n          cProps[k].push(cPathPoint);\n        }\n      } else {\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n\n  if (toMatrix) {\n    var mf = interpolateArray(animator.fromMatrix, toMatrix);\n    var cM = mf(ratio);\n    self.setMatrix(cM);\n  }\n\n  self.attr(cProps);\n}\n\nfunction update(shape, animator, elapsed) {\n  var startTime = animator.startTime; // 如果还没有开始执行或暂停，先不更新\n\n  if (elapsed < startTime + animator.delay || animator.isPaused) {\n    return false;\n  }\n\n  var ratio;\n  var duration = animator.duration;\n  var easing = animator.easing; // 已执行时间\n\n  elapsed = elapsed - startTime - animator.delay;\n\n  if (animator.toAttrs.repeat) {\n    ratio = elapsed % duration / duration;\n    ratio = d3Ease[easing](ratio);\n  } else {\n    ratio = elapsed / duration;\n\n    if (ratio < 1) {\n      ratio = d3Ease[easing](ratio);\n    } else {\n      shape.attr(animator.toAttrs);\n\n      if (animator.toMatrix) {\n        shape.setMatrix(animator.toMatrix);\n      }\n\n      return true;\n    }\n  }\n\n  _update(shape, animator, ratio);\n\n  return false;\n}\n\nUtil.augment(Timeline, {\n  initTimer: function initTimer() {\n    var _this = this;\n\n    var self = this;\n    var isFinished = false;\n    var shape, animators, animator;\n    self._timer = d3Timer.timer(function (elapsed) {\n      self._current = elapsed;\n\n      if (_this._animators.length > 0) {\n        for (var i = _this._animators.length - 1; i >= 0; i--) {\n          shape = _this._animators[i];\n\n          if (shape.get('destroyed')) {\n            // 如果已经被销毁，直接移出队列\n            self.removeAnimator(i);\n            continue;\n          }\n\n          if (!shape.get('pause').isPaused) {\n            animators = shape.get('animators');\n\n            for (var j = animators.length - 1; j >= 0; j--) {\n              animator = animators[j];\n              isFinished = update(shape, animator, elapsed);\n\n              if (isFinished) {\n                animators.splice(j, 1);\n                isFinished = false;\n\n                if (animator.callback) {\n                  animator.callback();\n                }\n              }\n            }\n          }\n\n          if (animators.length === 0) {\n            self.removeAnimator(i);\n          }\n        }\n\n        _this.canvas.draw();\n      }\n    });\n  },\n  addAnimator: function addAnimator(shape) {\n    this._animators.push(shape);\n  },\n  removeAnimator: function removeAnimator(index) {\n    this._animators.splice(index, 1);\n  },\n  isAnimating: function isAnimating() {\n    return !!this._animators.length;\n  },\n  stop: function stop() {\n    if (this._timer) {\n      this._timer.stop();\n    }\n  },\n  stopAllAnimations: function stopAllAnimations() {\n    this._animators.forEach(function (animator) {\n      animator.stopAnimate();\n    });\n\n    this._animators = [];\n    this.canvas.draw();\n  },\n  getTime: function getTime() {\n    return this._current;\n  }\n});\nmodule.exports = Timeline;\n\n/***/ }),\n/* 191 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(58);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (callback, delay, time) {\n  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__[\"a\" /* Timer */]();\n  delay = delay == null ? 0 : +delay;\n  t.restart(function (elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n});\n\n/***/ }),\n/* 192 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__timer__ = __webpack_require__(58);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (callback, delay, time) {\n  var t = new __WEBPACK_IMPORTED_MODULE_0__timer__[\"a\" /* Timer */](),\n      total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? Object(__WEBPACK_IMPORTED_MODULE_0__timer__[\"b\" /* now */])() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n});\n\n/***/ }),\n/* 193 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = linear;\nfunction linear(t) {\n  return +t;\n}\n\n/***/ }),\n/* 194 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = quadIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = quadOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = quadInOut;\nfunction quadIn(t) {\n  return t * t;\n}\nfunction quadOut(t) {\n  return t * (2 - t);\n}\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\n/***/ }),\n/* 195 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = cubicIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = cubicOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = cubicInOut;\nfunction cubicIn(t) {\n  return t * t * t;\n}\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\n/***/ }),\n/* 196 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return polyIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return polyOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return polyInOut; });\nvar exponent = 3;\nvar polyIn = function custom(e) {\n  e = +e;\n\n  function polyIn(t) {\n    return Math.pow(t, e);\n  }\n\n  polyIn.exponent = custom;\n  return polyIn;\n}(exponent);\nvar polyOut = function custom(e) {\n  e = +e;\n\n  function polyOut(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n\n  polyOut.exponent = custom;\n  return polyOut;\n}(exponent);\nvar polyInOut = function custom(e) {\n  e = +e;\n\n  function polyInOut(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n\n  polyInOut.exponent = custom;\n  return polyInOut;\n}(exponent);\n\n/***/ }),\n/* 197 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = sinIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = sinOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = sinInOut;\nvar pi = Math.PI,\n    halfPi = pi / 2;\nfunction sinIn(t) {\n  return 1 - Math.cos(t * halfPi);\n}\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\n/***/ }),\n/* 198 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = expIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = expOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = expInOut;\nfunction expIn(t) {\n  return Math.pow(2, 10 * t - 10);\n}\nfunction expOut(t) {\n  return 1 - Math.pow(2, -10 * t);\n}\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n}\n\n/***/ }),\n/* 199 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = circleIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = circleOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = circleInOut;\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\n/***/ }),\n/* 200 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = bounceIn;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = bounceOut;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = bounceInOut;\nvar b1 = 4 / 11,\n    b2 = 6 / 11,\n    b3 = 8 / 11,\n    b4 = 3 / 4,\n    b5 = 9 / 11,\n    b6 = 10 / 11,\n    b7 = 15 / 16,\n    b8 = 21 / 22,\n    b9 = 63 / 64,\n    b0 = 1 / b1 / b1;\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\n/***/ }),\n/* 201 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return backIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return backOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return backInOut; });\nvar overshoot = 1.70158;\nvar backIn = function custom(s) {\n  s = +s;\n\n  function backIn(t) {\n    return t * t * ((s + 1) * t - s);\n  }\n\n  backIn.overshoot = custom;\n  return backIn;\n}(overshoot);\nvar backOut = function custom(s) {\n  s = +s;\n\n  function backOut(t) {\n    return --t * t * ((s + 1) * t + s) + 1;\n  }\n\n  backOut.overshoot = custom;\n  return backOut;\n}(overshoot);\nvar backInOut = function custom(s) {\n  s = +s;\n\n  function backInOut(t) {\n    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n  }\n\n  backInOut.overshoot = custom;\n  return backInOut;\n}(overshoot);\n\n/***/ }),\n/* 202 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elasticIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return elasticOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return elasticInOut; });\nvar tau = 2 * Math.PI,\n    amplitude = 1,\n    period = 0.3;\nvar elasticIn = function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticIn(t) {\n    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n  }\n\n  elasticIn.amplitude = function (a) {\n    return custom(a, p * tau);\n  };\n\n  elasticIn.period = function (p) {\n    return custom(a, p);\n  };\n\n  return elasticIn;\n}(amplitude, period);\nvar elasticOut = function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function (a) {\n    return custom(a, p * tau);\n  };\n\n  elasticOut.period = function (p) {\n    return custom(a, p);\n  };\n\n  return elasticOut;\n}(amplitude, period);\nvar elasticInOut = function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticInOut(t) {\n    return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n  }\n\n  elasticInOut.amplitude = function (a) {\n    return custom(a, p * tau);\n  };\n\n  elasticInOut.period = function (p) {\n    return custom(a, p);\n  };\n\n  return elasticInOut;\n}(amplitude, period);\n\n/***/ }),\n/* 203 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = lab;\n/* unused harmony export Lab */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = hcl;\n/* unused harmony export Hcl */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(61);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(118);\n\n\n\nvar Kn = 18,\n    Xn = 0.950470,\n    // D65 standard referent\nYn = 1,\n    Zn = 1.088830,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n\n  if (o instanceof Hcl) {\n    var h = o.h * __WEBPACK_IMPORTED_MODULE_2__math__[\"a\" /* deg2rad */];\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n\n  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__[\"b\" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"h\" /* rgbConvert */])(o);\n  var b = rgb2xyz(o.r),\n      a = rgb2xyz(o.g),\n      l = rgb2xyz(o.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nfunction lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\nfunction Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Lab, lab, Object(__WEBPACK_IMPORTED_MODULE_0__define__[\"b\" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* Color */], {\n  brighter: function (k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function (k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function () {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new __WEBPACK_IMPORTED_MODULE_1__color__[\"b\" /* Rgb */](xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  var h = Math.atan2(o.b, o.a) * __WEBPACK_IMPORTED_MODULE_2__math__[\"b\" /* rad2deg */];\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nfunction hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\nfunction Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Hcl, hcl, Object(__WEBPACK_IMPORTED_MODULE_0__define__[\"b\" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* Color */], {\n  brighter: function (k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function (k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function () {\n    return labConvert(this).rgb();\n  }\n}));\n\n/***/ }),\n/* 204 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = cubehelix;\n/* unused harmony export Cubehelix */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__define__ = __webpack_require__(61);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math__ = __webpack_require__(118);\n\n\n\nvar A = -0.14861,\n    B = +1.78277,\n    C = -0.29227,\n    D = -0.90649,\n    E = +1.97294,\n    ED = E * D,\n    EB = E * B,\n    BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof __WEBPACK_IMPORTED_MODULE_1__color__[\"b\" /* Rgb */])) o = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"h\" /* rgbConvert */])(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),\n      // NaN if l=0 or l=1\n  h = s ? Math.atan2(k, bl) * __WEBPACK_IMPORTED_MODULE_2__math__[\"b\" /* rad2deg */] - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nfunction cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\nfunction Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\nObject(__WEBPACK_IMPORTED_MODULE_0__define__[\"a\" /* default */])(Cubehelix, cubehelix, Object(__WEBPACK_IMPORTED_MODULE_0__define__[\"b\" /* extend */])(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* Color */], {\n  brighter: function (k) {\n    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__[\"c\" /* brighter */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__[\"c\" /* brighter */], k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function (k) {\n    k = k == null ? __WEBPACK_IMPORTED_MODULE_1__color__[\"d\" /* darker */] : Math.pow(__WEBPACK_IMPORTED_MODULE_1__color__[\"d\" /* darker */], k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function () {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * __WEBPACK_IMPORTED_MODULE_2__math__[\"a\" /* deg2rad */],\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new __WEBPACK_IMPORTED_MODULE_1__color__[\"b\" /* Rgb */](255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);\n  }\n}));\n\n/***/ }),\n/* 205 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  return a = +a, b -= a, function (t) {\n    return Math.round(a + b * t);\n  };\n});\n\n/***/ }),\n/* 206 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return interpolateTransformCss; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return interpolateTransformSvg; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__number__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(207);\n\n\n\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n  function pop(s) {\n    return s.length ? s.pop() + \" \" : \"\";\n  }\n\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({\n        i: i - 4,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(xa, xb)\n      }, {\n        i: i - 2,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(ya, yb)\n      });\n    } else if (xb || yb) {\n      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path\n\n      q.push({\n        i: s.push(pop(s) + \"rotate(\", null, degParen) - 2,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(a, b)\n      });\n    } else if (b) {\n      s.push(pop(s) + \"rotate(\" + b + degParen);\n    }\n  }\n\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({\n        i: s.push(pop(s) + \"skewX(\", null, degParen) - 2,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(a, b)\n      });\n    } else if (b) {\n      s.push(pop(s) + \"skewX(\" + b + degParen);\n    }\n  }\n\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(xa, xb)\n      }, {\n        i: i - 2,\n        x: Object(__WEBPACK_IMPORTED_MODULE_0__number__[\"a\" /* default */])(ya, yb)\n      });\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n\n  return function (a, b) {\n    var s = [],\n        // string constants and placeholders\n    q = []; // number interpolators\n\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null; // gc\n\n    return function (t) {\n      var i = -1,\n          n = q.length,\n          o;\n\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n\n      return s.join(\"\");\n    };\n  };\n}\n\nvar interpolateTransformCss = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__[\"a\" /* parseCss */], \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(__WEBPACK_IMPORTED_MODULE_1__parse__[\"b\" /* parseSvg */], \", \", \")\", \")\");\n\n/***/ }),\n/* 207 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = parseCss;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = parseSvg;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__decompose__ = __webpack_require__(208);\n\nvar cssNode, cssRoot, cssView, svgNode;\nfunction parseCss(value) {\n  if (value === \"none\") return __WEBPACK_IMPORTED_MODULE_0__decompose__[\"b\" /* identity */];\n  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n  cssNode.style.transform = value;\n  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n  cssRoot.removeChild(cssNode);\n  value = value.slice(7, -1).split(\",\");\n  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__[\"a\" /* default */])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n}\nfunction parseSvg(value) {\n  if (value == null) return __WEBPACK_IMPORTED_MODULE_0__decompose__[\"b\" /* identity */];\n  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return __WEBPACK_IMPORTED_MODULE_0__decompose__[\"b\" /* identity */];\n  value = value.matrix;\n  return Object(__WEBPACK_IMPORTED_MODULE_0__decompose__[\"a\" /* default */])(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\n/***/ }),\n/* 208 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return identity; });\nvar degrees = 180 / Math.PI;\nvar identity = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n});\n\n/***/ }),\n/* 209 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar rho = Math.SQRT2,\n    rho2 = 2,\n    rho4 = 4,\n    epsilon2 = 1e-12;\n\nfunction cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n} // p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (p0, p1) {\n  var ux0 = p0[0],\n      uy0 = p0[1],\n      w0 = p0[2],\n      ux1 = p1[0],\n      uy1 = p1[1],\n      w1 = p1[2],\n      dx = ux1 - ux0,\n      dy = uy1 - uy0,\n      d2 = dx * dx + dy * dy,\n      i,\n      S; // Special case for u0 ≅ u1.\n\n  if (d2 < epsilon2) {\n    S = Math.log(w1 / w0) / rho;\n\n    i = function (t) {\n      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];\n    };\n  } // General case.\n  else {\n      var d1 = Math.sqrt(d2),\n          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / rho;\n\n      i = function (t) {\n        var s = t * S,\n            coshr0 = cosh(r0),\n            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];\n      };\n    }\n\n  i.duration = S * 1000;\n  return i;\n});\n\n/***/ }),\n/* 210 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return hslLong; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);\n\n\n\nfunction hsl(hue) {\n  return function (start, end) {\n    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"d\" /* hsl */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"d\" /* hsl */])(end)).h),\n        s = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.s, end.s),\n        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.l, end.l),\n        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.opacity, end.opacity);\n    return function (t) {\n      start.h = h(t);\n      start.s = s(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (hsl(__WEBPACK_IMPORTED_MODULE_1__color__[\"c\" /* hue */]));\nvar hslLong = hsl(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */]);\n\n/***/ }),\n/* 211 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = lab;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);\n\n\nfunction lab(start, end) {\n  var l = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"e\" /* lab */])(start)).l, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"e\" /* lab */])(end)).l),\n      a = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.a, end.a),\n      b = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.b, end.b),\n      opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.opacity, end.opacity);\n  return function (t) {\n    start.l = l(t);\n    start.a = a(t);\n    start.b = b(t);\n    start.opacity = opacity(t);\n    return start + \"\";\n  };\n}\n\n/***/ }),\n/* 212 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return hclLong; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);\n\n\n\nfunction hcl(hue) {\n  return function (start, end) {\n    var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"c\" /* hcl */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"c\" /* hcl */])(end)).h),\n        c = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.c, end.c),\n        l = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.l, end.l),\n        opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.opacity, end.opacity);\n    return function (t) {\n      start.h = h(t);\n      start.c = c(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (hcl(__WEBPACK_IMPORTED_MODULE_1__color__[\"c\" /* hue */]));\nvar hclLong = hcl(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */]);\n\n/***/ }),\n/* 213 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return cubehelixLong; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color__ = __webpack_require__(28);\n\n\n\nfunction cubehelix(hue) {\n  return function cubehelixGamma(y) {\n    y = +y;\n\n    function cubehelix(start, end) {\n      var h = hue((start = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"b\" /* cubehelix */])(start)).h, (end = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"b\" /* cubehelix */])(end)).h),\n          s = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.s, end.s),\n          l = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.l, end.l),\n          opacity = Object(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */])(start.opacity, end.opacity);\n      return function (t) {\n        start.h = h(t);\n        start.s = s(t);\n        start.l = l(Math.pow(t, y));\n        start.opacity = opacity(t);\n        return start + \"\";\n      };\n    }\n\n    cubehelix.gamma = cubehelixGamma;\n    return cubehelix;\n  }(1);\n}\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__[\"c\" /* hue */]));\nvar cubehelixLong = cubehelix(__WEBPACK_IMPORTED_MODULE_1__color__[\"a\" /* default */]);\n\n/***/ }),\n/* 214 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (interpolator, n) {\n  var samples = new Array(n);\n\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n\n  return samples;\n});\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  canvas: __webpack_require__(216),\n  svg: __webpack_require__(219)\n};\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  painter: __webpack_require__(217)\n};\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar renderUtil = __webpack_require__(218);\n\nvar SHAPE_ATTRS = ['fillStyle', 'font', 'globalAlpha', 'lineCap', 'lineWidth', 'lineJoin', 'miterLimit', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'strokeStyle', 'textAlign', 'textBaseline', 'lineDash', 'lineDashOffset'];\n\nvar Painter =\n/*#__PURE__*/\nfunction () {\n  function Painter(dom) {\n    if (!dom) {\n      return null;\n    }\n\n    var canvasId = Util.uniqueId('canvas_');\n    var canvasDom = Util.createDom('<canvas id=\"' + canvasId + '\"></canvas>');\n    dom.appendChild(canvasDom);\n    this.type = 'canvas';\n    this.canvas = canvasDom;\n    this.context = canvasDom.getContext('2d');\n    this.toDraw = false;\n    return this;\n  }\n\n  var _proto = Painter.prototype;\n\n  _proto.beforeDraw = function beforeDraw() {\n    var el = this.canvas;\n    this.context && this.context.clearRect(0, 0, el.width, el.height);\n  };\n\n  _proto.draw = function draw(model) {\n    var self = this;\n\n    function drawInner() {\n      self.animateHandler = Util.requestAnimationFrame(function () {\n        self.animateHandler = undefined;\n\n        if (self.toDraw) {\n          drawInner();\n        }\n      });\n      self.beforeDraw();\n\n      try {\n        self._drawGroup(model);\n      } catch (ev) {\n        // 绘制时异常，中断重绘\n        console.warn('error in draw canvas, detail as:');\n        console.warn(ev);\n        self.toDraw = false;\n      }\n\n      self.toDraw = false;\n    }\n\n    if (self.animateHandler) {\n      self.toDraw = true;\n    } else {\n      drawInner();\n    }\n  };\n\n  _proto.drawSync = function drawSync(model) {\n    this.beforeDraw();\n\n    this._drawGroup(model);\n  };\n\n  _proto._drawGroup = function _drawGroup(group) {\n    if (group._cfg.removed || group._cfg.destroyed || !group._cfg.visible) {\n      return;\n    }\n\n    var self = this;\n    var children = group._cfg.children;\n    var child = null;\n    this.setContext(group);\n\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (children[i].isGroup) {\n        self._drawGroup(child);\n      } else {\n        self._drawShape(child);\n      }\n    }\n\n    this.restoreContext(group);\n  };\n\n  _proto._drawShape = function _drawShape(shape) {\n    if (shape._cfg.removed || shape._cfg.destroyed || !shape._cfg.visible) {\n      return;\n    }\n\n    this.setContext(shape);\n    shape.drawInner(this.context);\n    this.restoreContext(shape);\n    shape._cfg.attrs = shape._attrs;\n    shape._cfg.hasUpdate = false;\n  };\n\n  _proto.setContext = function setContext(shape) {\n    var context = this.context;\n    var clip = shape._attrs.clip;\n    context.save();\n\n    if (clip) {\n      // context.save();\n      clip.resetTransform(context);\n      clip.createPath(context);\n      context.clip(); // context.restore();\n    }\n\n    this.resetContext(shape);\n    shape.resetTransform(context);\n  };\n\n  _proto.restoreContext = function restoreContext() {\n    this.context.restore();\n  };\n\n  _proto.resetContext = function resetContext(shape) {\n    var context = this.context;\n    var elAttrs = shape._attrs; // var canvas = this.get('canvas');\n\n    if (!shape.isGroup) {\n      for (var k in elAttrs) {\n        if (SHAPE_ATTRS.indexOf(k) > -1) {\n          // 非canvas属性不附加\n          var v = elAttrs[k];\n\n          if (k === 'fillStyle') {\n            v = renderUtil.parseStyle(v, shape, context);\n          }\n\n          if (k === 'strokeStyle') {\n            v = renderUtil.parseStyle(v, shape, context);\n          }\n\n          if (k === 'lineDash' && context.setLineDash) {\n            if (Util.isArray(v)) {\n              context.setLineDash(v);\n            } else if (Util.isString(v)) {\n              context.setLineDash(v.split(' '));\n            }\n          } else {\n            context[k] = v;\n          }\n        }\n      }\n    }\n  };\n\n  return Painter;\n}();\n\nmodule.exports = Painter;\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nvar regexDot = /[^\\s\\,]+/ig;\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/ig; // const numColorCache = {};\n\nfunction addStop(steps, gradient) {\n  var arr = steps.match(regexColorStop);\n  Util.each(arr, function (item) {\n    item = item.split(':');\n    gradient.addColorStop(item[0], item[1]);\n  });\n}\n\nfunction parseLineGradient(color, self, context) {\n  var arr = regexLG.exec(color);\n  var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);\n  var steps = arr[2];\n  var box = self.getBBox();\n  var start;\n  var end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: box.minX,\n      y: box.minY\n    };\n    end = {\n      x: box.maxX,\n      y: box.maxY\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.minY\n    };\n    end = {\n      x: box.minX,\n      y: box.maxY\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.maxY\n    };\n    end = {\n      x: box.minX,\n      y: box.minY\n    };\n  } else {\n    start = {\n      x: box.minX,\n      y: box.maxY\n    };\n    end = {\n      x: box.maxX,\n      y: box.minY\n    };\n  }\n\n  var tanTheta = Math.tan(angle);\n  var tanTheta2 = tanTheta * tanTheta;\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  var gradient = context.createLinearGradient(start.x, start.y, x, y);\n  addStop(steps, gradient);\n  return gradient;\n}\n\nfunction parseRadialGradient(color, self, context) {\n  var arr = regexRG.exec(color);\n  var fx = parseFloat(arr[1]);\n  var fy = parseFloat(arr[2]);\n  var fr = parseFloat(arr[3]);\n  var steps = arr[4]; // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n\n  if (fr === 0) {\n    var colors = steps.match(regexColorStop);\n    return colors[colors.length - 1].split(':')[1];\n  }\n\n  var box = self.getBBox();\n  var width = box.maxX - box.minX;\n  var height = box.maxY - box.minY;\n  var r = Math.sqrt(width * width + height * height) / 2;\n  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, fr * r, box.minX + width / 2, box.minY + height / 2, r);\n  addStop(steps, gradient);\n  return gradient;\n}\n\nfunction parsePattern(color, self, context) {\n  if (self.get('patternSource') && self.get('patternSource') === color) {\n    return self.get('pattern');\n  }\n\n  var pattern;\n  var img;\n  var arr = regexPR.exec(color);\n  var repeat = arr[1];\n  var source = arr[2]; // Function to be called when pattern loads\n\n  function onload() {\n    // Create pattern\n    pattern = context.createPattern(img, repeat);\n    self.setSilent('pattern', pattern); // be a cache\n\n    self.setSilent('patternSource', color);\n  }\n\n  switch (repeat) {\n    case 'a':\n      repeat = 'repeat';\n      break;\n\n    case 'x':\n      repeat = 'repeat-x';\n      break;\n\n    case 'y':\n      repeat = 'repeat-y';\n      break;\n\n    case 'n':\n      repeat = 'no-repeat';\n      break;\n\n    default:\n      repeat = 'no-repeat';\n  }\n\n  img = new Image(); // If source URL is not a data URL\n\n  if (!source.match(/^data:/i)) {\n    // Set crossOrigin for this image\n    img.crossOrigin = 'Anonymous';\n  }\n\n  img.src = source;\n\n  if (img.complete) {\n    onload();\n  } else {\n    img.onload = onload; // Fix onload() bug in IE9\n\n    img.src = img.src;\n  }\n\n  return pattern;\n}\n\nmodule.exports = {\n  parsePath: function parsePath(path) {\n    path = path || [];\n\n    if (Util.isArray(path)) {\n      return path;\n    }\n\n    if (Util.isString(path)) {\n      path = path.match(regexTags);\n      Util.each(path, function (item, index) {\n        item = item.match(regexDot);\n\n        if (item[0].length > 1) {\n          var tag = item[0].charAt(0);\n          item.splice(1, 0, item[0].substr(1));\n          item[0] = tag;\n        }\n\n        Util.each(item, function (sub, i) {\n          if (!isNaN(sub)) {\n            item[i] = +sub;\n          }\n        });\n        path[index] = item;\n      });\n      return path;\n    }\n  },\n  parseStyle: function parseStyle(color, self, context) {\n    if (Util.isString(color)) {\n      if (color[1] === '(' || color[2] === '(') {\n        if (color[0] === 'l') {\n          // regexLG.test(color)\n          return parseLineGradient(color, self, context);\n        } else if (color[0] === 'r') {\n          // regexRG.test(color)\n          return parseRadialGradient(color, self, context);\n        } else if (color[0] === 'p') {\n          // regexPR.test(color)\n          return parsePattern(color, self, context);\n        }\n      }\n\n      return color;\n    }\n  }\n  /* ,\n  numberToColor(num) {\n    // 增加缓存\n    let color = numColorCache[num];\n    if (!color) {\n      let str = num.toString(16);\n      for (let i = str.length; i < 6; i++) {\n        str = '0' + str;\n      }\n      color = '#' + str;\n      numColorCache[num] = color;\n    }\n    return color;\n  }*/\n\n};\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  painter: __webpack_require__(220),\n  getShape: __webpack_require__(227)\n};\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(1);\n\nvar _require = __webpack_require__(27),\n    parseRadius = _require.parseRadius;\n\nvar Marker = __webpack_require__(56);\n\nvar Defs = __webpack_require__(221);\n\nvar SHAPE_TO_TAGS = {\n  rect: 'path',\n  circle: 'circle',\n  line: 'line',\n  path: 'path',\n  marker: 'path',\n  text: 'text',\n  polygon: 'polygon',\n  image: 'image',\n  ellipse: 'ellipse',\n  dom: 'foreignObject',\n  fan: 'path',\n  group: 'g'\n};\nvar LETTER_SPACING = 0.3;\nvar SVG_ATTR_MAP = {\n  opacity: 'opacity',\n  fillStyle: 'fill',\n  strokeOpacity: 'stroke-opacity',\n  fillOpacity: 'fill-opacity',\n  strokeStyle: 'stroke',\n  x: 'x',\n  y: 'y',\n  r: 'r',\n  width: 'width',\n  height: 'height',\n  x1: 'x1',\n  x2: 'x2',\n  y1: 'y1',\n  y2: 'y2',\n  lineCap: 'stroke-linecap',\n  lineJoin: 'stroke-linejoin',\n  lineWidth: 'stroke-width',\n  lineDash: 'stroke-dasharray',\n  lineDashOffset: 'stroke-dashoffset',\n  miterLimit: 'stroke-miterlimit',\n  font: 'font',\n  fontSize: 'font-size',\n  fontStyle: 'font-style',\n  fontVariant: 'font-variant',\n  fontWeight: 'font-weight',\n  fontFamily: 'font-family',\n  startArrow: 'marker-start',\n  endArrow: 'marker-end',\n  path: 'd',\n  class: 'class',\n  id: 'id',\n  style: 'style',\n  preserveAspectRatio: 'preserveAspectRatio'\n};\nvar BASELINE_MAP = {\n  top: 'before-edge',\n  middle: 'central',\n  bottom: 'after-edge',\n  alphabetic: 'baseline',\n  hanging: 'hanging'\n};\nvar ANCHOR_MAP = {\n  left: 'left',\n  start: 'left',\n  center: 'middle',\n  right: 'end',\n  end: 'end'\n};\n\nvar Painter =\n/*#__PURE__*/\nfunction () {\n  function Painter(dom) {\n    if (!dom) {\n      return null;\n    }\n\n    var svgId = Util.uniqueId('canvas_');\n    var canvasDom = Util.createDom(\"<svg id=\\\"\" + svgId + \"\\\"></svg>\");\n    dom.appendChild(canvasDom);\n    this.type = 'svg';\n    this.canvas = canvasDom;\n    this.context = new Defs(canvasDom);\n    this.toDraw = false;\n    return this;\n  }\n\n  var _proto = Painter.prototype;\n\n  _proto.draw = function draw(model) {\n    var self = this;\n\n    function drawInner() {\n      self.animateHandler = Util.requestAnimationFrame(function () {\n        self.animateHandler = undefined;\n\n        if (self.toDraw) {\n          drawInner();\n        }\n      });\n\n      try {\n        self._drawChildren(model);\n      } catch (ev) {\n        // 绘制时异常，中断重绘\n        console.warn('error in draw canvas, detail as:');\n        console.warn(ev);\n        self.toDraw = false;\n      }\n\n      self.toDraw = false;\n    }\n\n    if (self.animateHandler) {\n      self.toDraw = true;\n    } else {\n      drawInner();\n    }\n  };\n\n  _proto.drawSync = function drawSync(model) {\n    this._drawChildren(model);\n  };\n\n  _proto._drawGroup = function _drawGroup(model, index) {\n    var cfg = model._cfg;\n\n    if (cfg.removed || cfg.destroyed) {\n      return;\n    }\n\n    if (cfg.tobeRemoved) {\n      Util.each(cfg.tobeRemoved, function (item) {\n        if (item.parentNode) {\n          item.parentNode.removeChild(item);\n        }\n      });\n      cfg.tobeRemoved = [];\n    }\n\n    this._drawShape(model, index);\n\n    if (cfg.children && cfg.children.length > 0) {\n      this._drawChildren(model);\n    }\n  };\n\n  _proto._drawChildren = function _drawChildren(parent) {\n    var self = this;\n    var children = parent._cfg.children;\n    var shape; // 防止在画children的时候，父group已经被destroy\n\n    if (!children) {\n      return;\n    }\n\n    for (var i = 0; i < children.length; i++) {\n      shape = children[i];\n\n      if (shape.isGroup) {\n        self._drawGroup(shape, i);\n      } else {\n        self._drawShape(shape, i);\n      }\n    }\n  };\n\n  _proto._drawShape = function _drawShape(model, index) {\n    var self = this;\n    var attrs = model._attrs;\n    var cfg = model._cfg;\n    var el = cfg.el; // 删除\n\n    if (cfg.removed || cfg.destroyed) {\n      if (el) {\n        el.parentNode.removeChild(cfg.el);\n      }\n\n      return;\n    } // 新增节点\n\n\n    if (!el && cfg.parent) {\n      self._createDom(model, index);\n\n      self._updateShape(model);\n    }\n\n    el = cfg.el;\n\n    if (cfg.visible === false) {\n      el.setAttribute('visibility', 'hidden');\n      return;\n    }\n\n    if (cfg.visible && el.hasAttribute('visibility')) {\n      el.removeAttribute('visibility');\n    } // 更新\n\n\n    if (cfg.hasUpdate) {\n      self._updateShape(model);\n    }\n\n    if (attrs.clip && attrs.clip._cfg.hasUpdate) {\n      self._updateShape(attrs.clip);\n    }\n  };\n\n  _proto._updateShape = function _updateShape(model) {\n    var self = this;\n    var attrs = model._attrs;\n    var formerAttrs = model._cfg.attrs;\n\n    if (!formerAttrs) {\n      return;\n    }\n\n    if (!model._cfg.el) {\n      self._createDom(model);\n    }\n\n    if ('clip' in attrs) {\n      this._setClip(model, attrs.clip);\n    }\n\n    if ('shadowOffsetX' in attrs || 'shadowOffsetY' in attrs || 'shadowBlur' in attrs || 'shadowColor' in attrs) {\n      this._setShadow(model);\n    }\n\n    if (model.type === 'text') {\n      self._updateText(model);\n\n      return;\n    }\n\n    if (model.type === 'fan') {\n      self._updateFan(model);\n    }\n\n    if (model.type === 'marker') {\n      model._cfg.el.setAttribute('d', self._assembleMarker(attrs));\n    }\n\n    if (model.type === 'rect') {\n      model._cfg.el.setAttribute('d', self._assembleRect(attrs));\n    }\n\n    for (var key in attrs) {\n      if (attrs[key] !== formerAttrs[key]) {\n        self._setAttribute(model, key, attrs[key]);\n      }\n    }\n\n    model._cfg.attrs = Util.deepMix({}, model._attrs);\n    model._cfg.hasUpdate = false;\n  };\n\n  _proto._setAttribute = function _setAttribute(model, name, value) {\n    var type = model.type;\n    var attrs = model._attrs;\n    var el = model._cfg.el;\n    var defs = this.context; // 计算marker路径\n\n    if ((type === 'marker' || type === 'rect') && ~['x', 'y', 'radius', 'r'].indexOf(name)) {\n      return;\n    } // 圆和椭圆不是x, y， 是cx, cy。 marker的x,y 用于计算marker的路径，不需要写到dom\n\n\n    if (~['circle', 'ellipse'].indexOf(type) && ~['x', 'y'].indexOf(name)) {\n      el.setAttribute('c' + name, parseInt(value, 10));\n      return;\n    } // 多边形\n\n\n    if (type === 'polygon' && name === 'points') {\n      if (!value || value.length === 0) {\n        value = '';\n      }\n\n      if (Util.isArray(value)) {\n        value = value.map(function (point) {\n          return point[0] + ',' + point[1];\n        });\n        value = value.join(' ');\n      }\n\n      el.setAttribute('points', value);\n      return;\n    } // 设置path\n\n\n    if (name === 'path' && Util.isArray(value)) {\n      el.setAttribute('d', this._formatPath(value));\n      return;\n    } // 设置图片\n\n\n    if (name === 'img') {\n      this._setImage(model, value);\n\n      return;\n    }\n\n    if (name === 'transform') {\n      if (!value) {\n        el.removeAttribute('transform');\n        return;\n      }\n\n      this._setTransform(model);\n\n      return;\n    }\n\n    if (name === 'rotate') {\n      if (!value) {\n        el.removeAttribute('transform');\n        return;\n      }\n\n      this._setTransform(model);\n\n      return;\n    }\n\n    if (name === 'matrix') {\n      this._setTransform(model);\n\n      return;\n    }\n\n    if (name === 'fillStyle' || name === 'strokeStyle') {\n      this._setColor(model, name, value);\n\n      return;\n    }\n\n    if (name === 'clip') {\n      return;\n    }\n\n    if (~name.indexOf('Arrow')) {\n      name = SVG_ATTR_MAP[name];\n\n      if (!value) {\n        model._cfg[name] = null;\n        el.removeAttribute(name);\n      } else {\n        var id = null;\n\n        if (typeof value === 'boolean') {\n          id = defs.getDefaultArrow(attrs, name);\n        } else {\n          id = defs.addArrow(attrs, name);\n        }\n\n        el.setAttribute(name, \"url(#\" + id + \")\");\n        model._cfg[name] = id;\n      }\n\n      return;\n    } // foreignObject\n\n\n    if (name === 'html') {\n      if (typeof value === 'string') {\n        el.innerHTML = value;\n      } else {\n        el.innerHTML = '';\n        el.appendChild(value);\n      }\n    }\n\n    if (SVG_ATTR_MAP[name]) {\n      el.setAttribute(SVG_ATTR_MAP[name], value);\n    }\n  };\n\n  _proto._createDom = function _createDom(model, index) {\n    var type = SHAPE_TO_TAGS[model.type];\n    var attrs = model._attrs;\n    var parent = model._cfg.parent;\n    var parentNode = parent._cfg.el;\n\n    if (!type) {\n      throw new Error('the type' + model.type + 'is not supported by svg');\n    }\n\n    var shape = document.createElementNS('http://www.w3.org/2000/svg', type);\n    model._cfg.el = shape;\n\n    if (parent) {\n      if (typeof index === 'undefined') {\n        parentNode.appendChild(shape);\n      } else {\n        var childNodes = parent._cfg.el.childNodes; // svg下天然有defs作为子节点，svg下子元素index需要+1\n\n        if (parentNode.tagName === 'svg') {\n          index += 1;\n        }\n\n        if (childNodes.length <= index) {\n          parentNode.appendChild(shape);\n        } else {\n          parentNode.insertBefore(shape, childNodes[index]);\n        }\n      }\n    }\n\n    model._cfg.attrs = {};\n\n    if (model.type === 'text') {\n      shape.setAttribute('paint-order', 'stroke');\n      shape.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');\n    } else {\n      if (!attrs.stroke && !attrs.strokeStyle) {\n        shape.setAttribute('stroke', 'none');\n      }\n\n      if (!attrs.fill && !attrs.fillStyle) {\n        shape.setAttribute('fill', 'none');\n      }\n    }\n\n    return shape;\n  };\n\n  _proto._assembleMarker = function _assembleMarker(attrs) {\n    var r = attrs.r;\n\n    if (typeof attrs.r === 'undefined') {\n      r = attrs.radius;\n    }\n\n    if (isNaN(Number(attrs.x)) || isNaN(Number(attrs.y)) || isNaN(Number(r))) {\n      return '';\n    }\n\n    var d = '';\n\n    if (typeof attrs.symbol === 'function') {\n      d = attrs.symbol(attrs.x, attrs.y, r);\n    } else {\n      d = Marker.Symbols[attrs.symbol || 'circle'](attrs.x, attrs.y, r);\n    }\n\n    if (Util.isArray(d)) {\n      d = d.map(function (path) {\n        return path.join(' ');\n      }).join('');\n    }\n\n    return d;\n  };\n\n  _proto._assembleRect = function _assembleRect(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    var radius = attrs.radius;\n\n    if (!radius) {\n      return \"M \" + x + \",\" + y + \" l \" + w + \",0 l 0,\" + h + \" l\" + -w + \" 0 z\";\n    }\n\n    var r = parseRadius(radius);\n\n    if (Util.isArray(radius)) {\n      if (radius.length === 1) {\n        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];\n      } else if (radius.length === 2) {\n        r.r1 = r.r3 = radius[0];\n        r.r2 = r.r4 = radius[1];\n      } else if (radius.length === 3) {\n        r.r1 = radius[0];\n        r.r2 = r.r4 = radius[1];\n        r.r3 = radius[2];\n      } else {\n        r.r1 = radius[0];\n        r.r2 = radius[1];\n        r.r3 = radius[2];\n        r.r4 = radius[3];\n      }\n    } else {\n      r.r1 = r.r2 = r.r3 = r.r4 = radius;\n    }\n\n    var d = [[\"M \" + (x + r.r1) + \",\" + y], [\"l \" + (w - r.r1 - r.r2) + \",0\"], [\"a \" + r.r2 + \",\" + r.r2 + \",0,0,1,\" + r.r2 + \",\" + r.r2], [\"l 0,\" + (h - r.r2 - r.r3)], [\"a \" + r.r3 + \",\" + r.r3 + \",0,0,1,\" + -r.r3 + \",\" + r.r3], [\"l \" + (r.r3 + r.r4 - w) + \",0\"], [\"a \" + r.r4 + \",\" + r.r4 + \",0,0,1,\" + -r.r4 + \",\" + -r.r4], [\"l 0,\" + (r.r4 + r.r1 - h)], [\"a \" + r.r1 + \",\" + r.r1 + \",0,0,1,\" + r.r1 + \",\" + -r.r1], ['z']];\n    return d.join(' ');\n  };\n\n  _proto._formatPath = function _formatPath(value) {\n    value = value.map(function (path) {\n      return path.join(' ');\n    }).join('');\n\n    if (~value.indexOf('NaN')) {\n      return '';\n    }\n\n    return value;\n  };\n\n  _proto._setTransform = function _setTransform(model) {\n    var matrix = model._attrs.matrix;\n    var el = model._cfg.el;\n    var transform = [];\n\n    for (var i = 0; i < 9; i += 3) {\n      transform.push(matrix[i] + ',' + matrix[i + 1]);\n    }\n\n    transform = transform.join(',');\n\n    if (transform.indexOf('NaN') === -1) {\n      el.setAttribute('transform', \"matrix(\" + transform + \")\");\n    } else {\n      console.warn('invalid matrix:', matrix);\n    }\n  };\n\n  _proto._setImage = function _setImage(model, img) {\n    var attrs = model._attrs;\n    var el = model._cfg.el;\n\n    if (Util.isString(img)) {\n      el.setAttribute('href', img);\n    } else if (img instanceof Image) {\n      if (!attrs.width) {\n        el.setAttribute('width', img.width);\n        model._attrs.width = img.width;\n      }\n\n      if (!attrs.height) {\n        el.setAttribute('height', img.height);\n        model._attrs.height = img.height;\n      }\n\n      el.setAttribute('href', img.src);\n    } else if (img instanceof HTMLElement && Util.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {\n      el.setAttribute('href', img.toDataURL());\n    } else if (img instanceof ImageData) {\n      var canvas = document.createElement('canvas');\n      canvas.setAttribute('width', img.width);\n      canvas.setAttribute('height', img.height);\n      canvas.getContext('2d').putImageData(img, 0, 0);\n\n      if (!attrs.width) {\n        el.setAttribute('width', img.width);\n        model._attrs.width = img.width;\n      }\n\n      if (!attrs.height) {\n        el.setAttribute('height', img.height);\n        model._attrs.height = img.height;\n      }\n\n      el.setAttribute('href', canvas.toDataURL());\n    }\n  };\n\n  _proto._updateFan = function _updateFan(model) {\n    function getPoint(angle, radius, center) {\n      return {\n        x: radius * Math.cos(angle) + center.x,\n        y: radius * Math.sin(angle) + center.y\n      };\n    }\n\n    var attrs = model._attrs;\n    var cfg = model._cfg;\n    var center = {\n      x: attrs.x,\n      y: attrs.y\n    };\n    var d = [];\n    var startAngle = attrs.startAngle;\n    var endAngle = attrs.endAngle;\n\n    if (Util.isNumberEqual(endAngle - startAngle, Math.PI * 2)) {\n      endAngle -= 0.00001;\n    }\n\n    var outerStart = getPoint(startAngle, attrs.re, center);\n    var outerEnd = getPoint(endAngle, attrs.re, center);\n    var fa = endAngle > startAngle ? 1 : 0;\n    var fs = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n    var rs = attrs.rs;\n    var re = attrs.re;\n    var innerStart = getPoint(startAngle, attrs.rs, center);\n    var innerEnd = getPoint(endAngle, attrs.rs, center);\n\n    if (attrs.rs > 0) {\n      d.push(\"M \" + outerEnd.x + \",\" + outerEnd.y);\n      d.push(\"L \" + innerEnd.x + \",\" + innerEnd.y);\n      d.push(\"A \" + rs + \",\" + rs + \",0,\" + fs + \",\" + (fa === 1 ? 0 : 1) + \",\" + innerStart.x + \",\" + innerStart.y);\n      d.push(\"L \" + outerStart.x + \" \" + outerStart.y);\n    } else {\n      d.push(\"M \" + center.x + \",\" + center.y);\n      d.push(\"L \" + outerStart.x + \",\" + outerStart.y);\n    }\n\n    d.push(\"A \" + re + \",\" + re + \",0,\" + fs + \",\" + fa + \",\" + outerEnd.x + \",\" + outerEnd.y);\n\n    if (attrs.rs > 0) {\n      d.push(\"L \" + innerEnd.x + \",\" + innerEnd.y);\n    } else {\n      d.push('Z');\n    }\n\n    cfg.el.setAttribute('d', d.join(' '));\n  };\n\n  _proto._updateText = function _updateText(model) {\n    var self = this;\n    var attrs = model._attrs;\n    var formerAttrs = model._cfg.attrs;\n    var el = model._cfg.el;\n\n    this._setFont(model);\n\n    for (var attr in attrs) {\n      if (attrs[attr] !== formerAttrs[attr]) {\n        if (attr === 'text') {\n          self._setText(model, \"\" + attrs[attr]);\n\n          continue;\n        }\n\n        if (attr === 'fillStyle' || attr === 'strokeStyle') {\n          this._setColor(model, attr, attrs[attr]);\n\n          continue;\n        }\n\n        if (attr === 'matrix') {\n          this._setTransform(model);\n\n          continue;\n        }\n\n        if (SVG_ATTR_MAP[attr]) {\n          el.setAttribute(SVG_ATTR_MAP[attr], attrs[attr]);\n        }\n      }\n    }\n\n    model._cfg.attrs = Object.assign({}, model._attrs);\n    model._cfg.hasUpdate = false;\n  };\n\n  _proto._setFont = function _setFont(model) {\n    var el = model.get('el');\n    var attrs = model._attrs;\n    var fontSize = attrs.fontSize;\n    el.setAttribute('alignment-baseline', BASELINE_MAP[attrs.textBaseline] || 'baseline');\n    el.setAttribute('text-anchor', ANCHOR_MAP[attrs.textAlign] || 'left');\n\n    if (fontSize && +fontSize < 12) {\n      // 小于 12 像素的文本进行 scale 处理\n      attrs.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      model.transform([['t', -attrs.x, -attrs.y], ['s', +fontSize / 12, +fontSize / 12], ['t', attrs.x, attrs.y]]);\n    }\n  };\n\n  _proto._setText = function _setText(model, text) {\n    var el = model._cfg.el;\n    var baseline = model._attrs.textBaseline || 'bottom';\n\n    if (!text) {\n      el.innerHTML = '';\n    } else if (~text.indexOf('\\n')) {\n      var x = model._attrs.x;\n      var textArr = text.split('\\n');\n      var textLen = textArr.length - 1;\n      var arr = '';\n      Util.each(textArr, function (segment, i) {\n        if (i === 0) {\n          if (baseline === 'alphabetic') {\n            arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"\" + -textLen + \"em\\\">\" + segment + \"</tspan>\";\n          } else if (baseline === 'top') {\n            arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"0.9em\\\">\" + segment + \"</tspan>\";\n          } else if (baseline === 'middle') {\n            arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"\" + -(textLen - 1) / 2 + \"em\\\">\" + segment + \"</tspan>\";\n          } else if (baseline === 'bottom') {\n            arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"-\" + (textLen + LETTER_SPACING) + \"em\\\">\" + segment + \"</tspan>\";\n          } else if (baseline === 'hanging') {\n            arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"\" + (-(textLen - 1) - LETTER_SPACING) + \"em\\\">\" + segment + \"</tspan>\";\n          }\n        } else {\n          arr += \"<tspan x=\\\"\" + x + \"\\\" dy=\\\"1em\\\">\" + segment + \"</tspan>\";\n        }\n      });\n      el.innerHTML = arr;\n    } else {\n      el.innerHTML = text;\n    }\n  };\n\n  _proto._setClip = function _setClip(model, value) {\n    var el = model._cfg.el;\n\n    if (!value) {\n      el.removeAttribute('clip-path');\n      return;\n    }\n\n    if (!el.hasAttribute('clip-path')) {\n      this._createDom(value);\n\n      this._updateShape(value);\n\n      var id = this.context.addClip(value);\n      el.setAttribute('clip-path', \"url(#\" + id + \")\");\n    } else if (value._cfg.hasUpdate) {\n      this._updateShape(value);\n    }\n  };\n\n  _proto._setColor = function _setColor(model, name, value) {\n    var el = model._cfg.el;\n    var defs = this.context;\n\n    if (!value) {\n      el.setAttribute(SVG_ATTR_MAP[name], 'none');\n      return;\n    }\n\n    value = value.trim();\n\n    if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n      var id = defs.find('gradient', value);\n\n      if (!id) {\n        id = defs.addGradient(value);\n      }\n\n      el.setAttribute(SVG_ATTR_MAP[name], \"url(#\" + id + \")\");\n    } else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n      var _id = defs.find('pattern', value);\n\n      if (!_id) {\n        _id = defs.addPattern(value);\n      }\n\n      el.setAttribute(SVG_ATTR_MAP[name], \"url(#\" + _id + \")\");\n    } else {\n      el.setAttribute(SVG_ATTR_MAP[name], value);\n    }\n  };\n\n  _proto._setShadow = function _setShadow(model) {\n    var el = model._cfg.el;\n    var attrs = model._attrs;\n    var cfg = {\n      dx: attrs.shadowOffsetX,\n      dy: attrs.shadowOffsetY,\n      blur: attrs.shadowBlur,\n      color: attrs.shadowColor\n    };\n\n    if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {\n      el.removeAttribute('filter');\n    } else {\n      var id = this.context.find('filter', cfg);\n\n      if (!id) {\n        id = this.context.addShadow(cfg, this);\n      }\n\n      el.setAttribute('filter', \"url(#\" + id + \")\");\n    }\n  };\n\n  return Painter;\n}();\n\nmodule.exports = Painter;\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/9.\n */\nvar Util = __webpack_require__(1);\n\nvar Gradient = __webpack_require__(222);\n\nvar Shadow = __webpack_require__(223);\n\nvar Arrow = __webpack_require__(224);\n\nvar Clip = __webpack_require__(225);\n\nvar Pattern = __webpack_require__(226);\n\nvar Defs =\n/*#__PURE__*/\nfunction () {\n  function Defs(canvas) {\n    var el = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    var id = Util.uniqueId('defs_');\n    el.id = id;\n    canvas.appendChild(el);\n    this.children = [];\n    this.defaultArrow = {};\n    this.el = el;\n    this.canvas = canvas;\n  }\n\n  var _proto = Defs.prototype;\n\n  _proto.find = function find(type, attr) {\n    var children = this.children;\n    var result = null;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].match(type, attr)) {\n        result = children[i].id;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  _proto.findById = function findById(id) {\n    var children = this.children;\n    var flag = null;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].id === id) {\n        flag = children[i];\n        break;\n      }\n    }\n\n    return flag;\n  };\n\n  _proto.add = function add(item) {\n    this.children.push(item);\n    item.canvas = this.canvas;\n    item.parent = this;\n  };\n\n  _proto.getDefaultArrow = function getDefaultArrow(attrs, name) {\n    var stroke = attrs.stroke || attrs.strokeStyle;\n\n    if (this.defaultArrow[stroke]) {\n      return this.defaultArrow[stroke].id;\n    }\n\n    var arrow = new Arrow(attrs, name);\n    this.defaultArrow[stroke] = arrow;\n    this.el.appendChild(arrow.el);\n    return arrow.id;\n  };\n\n  _proto.addGradient = function addGradient(cfg) {\n    var gradient = new Gradient(cfg);\n    this.el.appendChild(gradient.el);\n    this.add(gradient);\n    return gradient.id;\n  };\n\n  _proto.addArrow = function addArrow(attrs, name) {\n    var arrow = new Arrow(attrs, name);\n    this.el.appendChild(arrow.el);\n    return arrow.id;\n  };\n\n  _proto.addShadow = function addShadow(cfg) {\n    var shadow = new Shadow(cfg);\n    this.el.appendChild(shadow.el);\n    this.add(shadow);\n    return shadow.id;\n  };\n\n  _proto.addPattern = function addPattern(cfg) {\n    var pattern = new Pattern(cfg);\n    this.el.appendChild(pattern.el);\n    this.add(pattern);\n    return pattern.id;\n  };\n\n  _proto.addClip = function addClip(cfg) {\n    var clip = new Clip(cfg);\n    this.el.appendChild(clip.el);\n    this.add(clip);\n    return clip.id;\n  };\n\n  return Defs;\n}();\n\nmodule.exports = Defs;\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/9.\n */\nvar Util = __webpack_require__(1);\n\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/ig;\n\nfunction addStop(steps) {\n  var arr = steps.match(regexColorStop);\n\n  if (!arr) {\n    return '';\n  }\n\n  var stops = '';\n  arr.sort(function (a, b) {\n    a = a.split(':');\n    b = b.split(':');\n    return Number(a[0]) - Number(b[0]);\n  });\n  Util.each(arr, function (item) {\n    item = item.split(':');\n    stops += \"<stop offset=\\\"\" + item[0] + \"\\\" stop-color=\\\"\" + item[1] + \"\\\"></stop>\";\n  });\n  return stops;\n}\n\nfunction parseLineGradient(color, el) {\n  var arr = regexLG.exec(color);\n  var angle = Util.mod(Util.toRadian(parseFloat(arr[1])), Math.PI * 2);\n  var steps = arr[2];\n  var start;\n  var end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: 0,\n      y: 0\n    };\n    end = {\n      x: 1,\n      y: 1\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: 1,\n      y: 0\n    };\n    end = {\n      x: 0,\n      y: 1\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: 1,\n      y: 1\n    };\n    end = {\n      x: 0,\n      y: 0\n    };\n  } else {\n    start = {\n      x: 0,\n      y: 1\n    };\n    end = {\n      x: 1,\n      y: 0\n    };\n  }\n\n  var tanTheta = Math.tan(angle);\n  var tanTheta2 = tanTheta * tanTheta;\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  el.setAttribute('x1', start.x);\n  el.setAttribute('y1', start.y);\n  el.setAttribute('x2', x);\n  el.setAttribute('y2', y);\n  el.innerHTML = addStop(steps);\n}\n\nfunction parseRadialGradient(color, self) {\n  var arr = regexRG.exec(color);\n  var cx = parseFloat(arr[1]);\n  var cy = parseFloat(arr[2]);\n  var r = parseFloat(arr[3]);\n  var steps = arr[4];\n  self.setAttribute('cx', cx);\n  self.setAttribute('cy', cy);\n  self.setAttribute('r', r);\n  self.innerHTML = addStop(steps);\n}\n\nvar Gradient =\n/*#__PURE__*/\nfunction () {\n  function Gradient(cfg) {\n    var el = null;\n    var id = Util.uniqueId('gradient_');\n\n    if (cfg.toLowerCase()[0] === 'l') {\n      el = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');\n      parseLineGradient(cfg, el);\n    } else {\n      el = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');\n      parseRadialGradient(cfg, el);\n    }\n\n    el.setAttribute('id', id);\n    this.el = el;\n    this.id = id;\n    this.cfg = cfg;\n    return this;\n  }\n\n  var _proto = Gradient.prototype;\n\n  _proto.match = function match(type, attr) {\n    return this.cfg === attr;\n  };\n\n  return Gradient;\n}();\n\nmodule.exports = Gradient;\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/10.\n */\nvar Util = __webpack_require__(1);\n\nvar ATTR_MAP = {\n  shadowColor: 'color',\n  shadowOpacity: 'opacity',\n  shadowBlur: 'blur',\n  shadowOffsetX: 'dx',\n  shadowOffsetY: 'dy'\n};\nvar SHADOW_DIMENSION = {\n  x: '-40%',\n  y: '-40%',\n  width: '200%',\n  height: '200%'\n};\n\nvar Shadow =\n/*#__PURE__*/\nfunction () {\n  function Shadow(cfg) {\n    this.type = 'filter';\n    var el = document.createElementNS('http://www.w3.org/2000/svg', 'filter'); // expand the filter region to fill in shadows\n\n    Util.each(SHADOW_DIMENSION, function (v, k) {\n      el.setAttribute(k, v);\n    });\n    this.el = el;\n    this.id = Util.uniqueId('filter_');\n    this.el.id = this.id;\n    this.cfg = cfg;\n\n    this._parseShadow(cfg, el);\n\n    return this;\n  }\n\n  var _proto = Shadow.prototype;\n\n  _proto.match = function match(type, cfg) {\n    if (this.type !== type) {\n      return false;\n    }\n\n    var flag = true;\n    var config = this.cfg;\n    Util.each(Object.keys(config), function (attr) {\n      if (config[attr] !== cfg[attr]) {\n        flag = false;\n        return false;\n      }\n    });\n    return flag;\n  };\n\n  _proto.update = function update(name, value) {\n    var config = this.cfg;\n    config[ATTR_MAP[name]] = value;\n\n    this._parseShadow(config, this.el);\n\n    return this;\n  };\n\n  _proto._parseShadow = function _parseShadow(config, el) {\n    var child = \"<feDropShadow \\n      dx=\\\"\" + (config.dx || 0) + \"\\\" \\n      dy=\\\"\" + (config.dy || 0) + \"\\\" \\n      stdDeviation=\\\"\" + (config.blur ? config.blur / 10 : 0) + \"\\\"\\n      flood-color=\\\"\" + (config.color ? config.color : '#000') + \"\\\"\\n      flood-opacity=\\\"\" + (config.opacity ? config.opacity : 1) + \"\\\"\\n      />\";\n    el.innerHTML = child;\n  };\n\n  return Shadow;\n}();\n\nmodule.exports = Shadow;\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/11.\n */\nvar Util = __webpack_require__(1);\n\nvar Arrow =\n/*#__PURE__*/\nfunction () {\n  function Arrow(attrs, type) {\n    var el = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\n    var id = Util.uniqueId('marker_');\n    el.setAttribute('id', id);\n    var shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    shape.setAttribute('stroke', 'none');\n    shape.setAttribute('fill', attrs.stroke || '#000');\n    el.appendChild(shape);\n    el.setAttribute('overflow', 'visible');\n    el.setAttribute('orient', 'auto-start-reverse');\n    this.el = el;\n    this.child = shape;\n    this.id = id;\n    this.cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];\n    this.stroke = attrs.stroke || '#000';\n\n    if (this.cfg === true) {\n      this._setDefaultPath(type, shape);\n    } else {\n      this._setMarker(attrs.lineWidth, shape);\n    }\n\n    return this;\n  }\n\n  var _proto = Arrow.prototype;\n\n  _proto.match = function match() {\n    return false;\n  };\n\n  _proto._setDefaultPath = function _setDefaultPath(type, el) {\n    var parent = this.el;\n    el.setAttribute('d', 'M0,0 L6,3 L0,6 L3,3Z');\n    parent.setAttribute('refX', 3);\n    parent.setAttribute('refY', 3);\n  };\n\n  _proto._setMarker = function _setMarker(r, el) {\n    var parent = this.el;\n    var path = this.cfg.path;\n    var d = this.cfg.d;\n\n    if (Util.isArray(path)) {\n      path = path.map(function (segment) {\n        return segment.join(' ');\n      }).join('');\n    }\n\n    el.setAttribute('d', path);\n    parent.appendChild(el);\n\n    if (d) {\n      parent.setAttribute('refX', d / r);\n    }\n  };\n\n  _proto.update = function update(fill) {\n    var child = this.child;\n\n    if (child.attr) {\n      child.attr('fill', fill);\n    } else {\n      child.setAttribute('fill', fill);\n    }\n  };\n\n  return Arrow;\n}();\n\nmodule.exports = Arrow;\n\n/***/ }),\n/* 225 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/14.\n */\nvar Util = __webpack_require__(1);\n\nvar Clip =\n/*#__PURE__*/\nfunction () {\n  function Clip(cfg) {\n    this.type = 'clip';\n    var el = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');\n    this.el = el;\n    this.id = Util.uniqueId('clip_');\n    el.id = this.id;\n    var shapeEl = cfg._cfg.el; // just in case the clip shape is also a shape needs to be drawn\n\n    el.appendChild(shapeEl.cloneNode(true));\n    this.cfg = cfg;\n    return this;\n  }\n\n  var _proto = Clip.prototype;\n\n  _proto.match = function match() {\n    return false;\n  };\n\n  _proto.remove = function remove() {\n    var el = this.el;\n    el.parentNode.removeChild(el);\n  };\n\n  return Clip;\n}();\n\nmodule.exports = Clip;\n\n/***/ }),\n/* 226 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Created by Elaine on 2018/5/9.\n */\nvar Util = __webpack_require__(1);\n\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\n\nvar Pattern =\n/*#__PURE__*/\nfunction () {\n  function Pattern(cfg) {\n    var el = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n    el.setAttribute('patternUnits', 'userSpaceOnUse');\n    var child = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n    el.appendChild(child);\n    var id = Util.uniqueId('pattern_');\n    el.id = id;\n    this.el = el;\n    this.id = id;\n    this.cfg = cfg;\n    var arr = regexPR.exec(cfg);\n    var source = arr[2];\n    child.setAttribute('href', source);\n    var img = new Image();\n\n    if (!source.match(/^data:/i)) {\n      img.crossOrigin = 'Anonymous';\n    }\n\n    img.src = source;\n\n    function onload() {\n      console.log(img.width, img.height);\n      el.setAttribute('width', img.width);\n      el.setAttribute('height', img.height);\n    }\n\n    if (img.complete) {\n      onload();\n    } else {\n      img.onload = onload; // Fix onload() bug in IE9\n\n      img.src = img.src;\n    }\n\n    return this;\n  }\n\n  var _proto = Pattern.prototype;\n\n  _proto.match = function match(type, attr) {\n    return this.cfg === attr;\n  };\n\n  return Pattern;\n}();\n\nmodule.exports = Pattern;\n\n/***/ }),\n/* 227 */\n/***/ (function(module, exports) {\n\nvar TAG_MAP = {\n  svg: 'svg',\n  circle: 'circle',\n  rect: 'rect',\n  text: 'text',\n  path: 'path',\n  foreignObject: 'foreignObject',\n  polygon: 'polygon',\n  ellipse: 'ellipse',\n  image: 'image'\n};\n\nmodule.exports = function getShape(x, y, e) {\n  var target = e.target || e.srcElement;\n\n  if (!TAG_MAP[target.tagName]) {\n    var parent = target.parentNode;\n\n    while (parent && !TAG_MAP[parent.tagName]) {\n      parent = parent.parentNode;\n    }\n\n    target = parent;\n  }\n\n  if (this._cfg.el === target) {\n    return this;\n  }\n\n  return this.find(function (item) {\n    return item._cfg && item._cfg.el === target;\n  });\n};\n\n/***/ }),\n/* 228 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  addEventListener: __webpack_require__(229),\n  createDom: __webpack_require__(94),\n  getBoundingClientRect: __webpack_require__(230),\n  getHeight: __webpack_require__(231),\n  getOuterHeight: __webpack_require__(232),\n  getOuterWidth: __webpack_require__(233),\n  getRatio: __webpack_require__(234),\n  getStyle: __webpack_require__(235),\n  getWidth: __webpack_require__(236),\n  modifyCSS: __webpack_require__(95),\n  requestAnimationFrame: __webpack_require__(96)\n};\n\n/***/ }),\n/* 229 */\n/***/ (function(module, exports) {\n\n/**\n * 添加事件监听器\n * @param  {Object} target DOM对象\n * @param  {String} eventType 事件名\n * @param  {Funtion} callback 回调函数\n * @return {Object} 返回对象\n */\nmodule.exports = function addEventListener(target, eventType, callback) {\n  if (target) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function remove() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  }\n};\n\n/***/ }),\n/* 230 */\n/***/ (function(module, exports) {\n\nmodule.exports = function getBoundingClientRect(node, defaultValue) {\n  if (node && node.getBoundingClientRect) {\n    var rect = node.getBoundingClientRect();\n    var top = document.documentElement.clientTop;\n    var left = document.documentElement.clientLeft;\n    return {\n      top: rect.top - top,\n      bottom: rect.bottom - top,\n      left: rect.left - left,\n      right: rect.right - left\n    };\n  }\n\n  return defaultValue || null;\n};\n\n/***/ }),\n/* 231 */\n/***/ (function(module, exports) {\n\n/**\n * 获取高度\n * @param  {HTMLElement} el dom节点\n * @param  {Number} defaultValue 默认值\n * @return {Number} 高度\n */\nmodule.exports = function getHeight(el, defaultValue) {\n  var height = this.getStyle(el, 'height', defaultValue);\n\n  if (height === 'auto') {\n    height = el.offsetHeight;\n  }\n\n  return parseFloat(height);\n};\n\n/***/ }),\n/* 232 */\n/***/ (function(module, exports) {\n\n/**\n * 获取外层高度\n * @param  {HTMLElement} el dom节点\n * @param  {Number} defaultValue 默认值\n * @return {Number} 高度\n */\nmodule.exports = function getOuterHeight(el, defaultValue) {\n  var height = this.getHeight(el, defaultValue);\n  var bTop = parseFloat(this.getStyle(el, 'borderTopWidth')) || 0;\n  var pTop = parseFloat(this.getStyle(el, 'paddingTop')) || 0;\n  var pBottom = parseFloat(this.getStyle(el, 'paddingBottom')) || 0;\n  var bBottom = parseFloat(this.getStyle(el, 'borderBottomWidth')) || 0;\n  return height + bTop + bBottom + pTop + pBottom;\n};\n\n/***/ }),\n/* 233 */\n/***/ (function(module, exports) {\n\n/**\n * 获取外层宽度\n * @param  {HTMLElement} el dom节点\n * @param  {Number} defaultValue 默认值\n * @return {Number} 宽度\n */\nmodule.exports = function getOuterWidth(el, defaultValue) {\n  var width = this.getWidth(el, defaultValue);\n  var bLeft = parseFloat(this.getStyle(el, 'borderLeftWidth')) || 0;\n  var pLeft = parseFloat(this.getStyle(el, 'paddingLeft')) || 0;\n  var pRight = parseFloat(this.getStyle(el, 'paddingRight')) || 0;\n  var bRight = parseFloat(this.getStyle(el, 'borderRightWidth')) || 0;\n  return width + bLeft + bRight + pLeft + pRight;\n};\n\n/***/ }),\n/* 234 */\n/***/ (function(module, exports) {\n\nmodule.exports = function getRatio() {\n  return window.devicePixelRatio ? window.devicePixelRatio : 2;\n};\n\n/***/ }),\n/* 235 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(5);\n/**\n * 获取样式\n * @param  {Object} dom DOM节点\n * @param  {String} name 样式名\n * @param  {Any} defaultValue 默认值\n * @return {String} 属性值\n */\n\n\nmodule.exports = function getStyle(dom, name, defaultValue) {\n  try {\n    if (window.getComputedStyle) {\n      return window.getComputedStyle(dom, null)[name];\n    }\n\n    return dom.currentStyle[name];\n  } catch (e) {\n    if (!isNil(defaultValue)) {\n      return defaultValue;\n    }\n\n    return null;\n  }\n};\n\n/***/ }),\n/* 236 */\n/***/ (function(module, exports) {\n\n/**\n * 获取宽度\n * @param  {HTMLElement} el  dom节点\n * @param  {Number} defaultValue 默认值\n * @return {Number} 宽度\n */\nmodule.exports = function getWidth(el, defaultValue) {\n  var width = this.getStyle(el, 'width', defaultValue);\n\n  if (width === 'auto') {\n    width = el.offsetWidth;\n  }\n\n  return parseFloat(width);\n};\n\n/***/ }),\n/* 237 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  contains: __webpack_require__(41),\n  difference: __webpack_require__(238),\n  find: __webpack_require__(239),\n  firstValue: __webpack_require__(240),\n  flatten: __webpack_require__(241),\n  flattenDeep: __webpack_require__(242),\n  getRange: __webpack_require__(243),\n  merge: __webpack_require__(42),\n  pull: __webpack_require__(90),\n  pullAt: __webpack_require__(130),\n  reduce: __webpack_require__(244),\n  remove: __webpack_require__(245),\n  sortBy: __webpack_require__(246),\n  union: __webpack_require__(247),\n  uniq: __webpack_require__(131),\n  valuesOfKey: __webpack_require__(64)\n};\n\n/***/ }),\n/* 238 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar filter = __webpack_require__(63);\n\nvar contains = __webpack_require__(41);\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to inspect.\n * @param {Array} values The values to exclude.\n * @return {Array} Returns the new array of filtered values.\n * @example\n * difference([2, 1], [2, 3]);  // => [1]\n */\n\n\nvar difference = function difference(arr) {\n  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return filter(arr, function (value) {\n    return !contains(values, value);\n  });\n};\n\nmodule.exports = difference;\n\n/***/ }),\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(11);\n\nvar isPlainObject = __webpack_require__(26);\n\nvar isMatch = __webpack_require__(128);\n\nfunction find(arr, predicate) {\n  var _predicate = void 0;\n\n  if (isFunction(predicate)) {\n    _predicate = predicate;\n  }\n\n  if (isPlainObject(predicate)) {\n    _predicate = function _predicate(a) {\n      return isMatch(a, predicate);\n    };\n  }\n\n  if (_predicate) {\n    for (var i = 0; i < arr.length; i += 1) {\n      if (_predicate(arr[i])) {\n        return arr[i];\n      }\n    }\n  }\n\n  return null;\n}\n\nmodule.exports = find;\n\n/***/ }),\n/* 240 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(5);\n\nvar isArray = __webpack_require__(4);\n\nvar firstValue = function firstValue(data, name) {\n  var rst = null;\n\n  for (var i = 0; i < data.length; i++) {\n    var obj = data[i];\n    var value = obj[name];\n\n    if (!isNil(value)) {\n      if (isArray(value)) {\n        rst = value[0];\n      } else {\n        rst = value;\n      }\n\n      break;\n    }\n  }\n\n  return rst;\n};\n\nmodule.exports = firstValue;\n\n/***/ }),\n/* 241 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar each = __webpack_require__(2);\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]\n */\n\n\nvar flatten = function flatten(arr) {\n  if (!isArray(arr)) {\n    return arr;\n  }\n\n  var result = [];\n  each(arr, function (item) {\n    if (isArray(item)) {\n      each(item, function (subItem) {\n        result.push(subItem);\n      });\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nmodule.exports = flatten;\n\n/***/ }),\n/* 242 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @param {Array} result The array to return.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]\n */\n\n\nvar flattenDeep = function flattenDeep(arr) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (!isArray(arr)) {\n    result.push(arr);\n  } else {\n    for (var i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], result);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = flattenDeep;\n\n/***/ }),\n/* 243 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar filter = __webpack_require__(63);\n\nvar isArray = __webpack_require__(4);\n\nvar getRange = function getRange(values) {\n  // 存在 NaN 时，min,max 判定会出问题\n  values = filter(values, function (v) {\n    return !isNaN(v);\n  });\n\n  if (!values.length) {\n    // 如果没有数值则直接返回0\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n\n  if (isArray(values[0])) {\n    var tmp = [];\n\n    for (var i = 0; i < values.length; i++) {\n      tmp = tmp.concat(values[i]);\n    }\n\n    values = tmp;\n  }\n\n  var max = Math.max.apply(null, values);\n  var min = Math.min.apply(null, values);\n  return {\n    min: min,\n    max: max\n  };\n};\n\nmodule.exports = getRange;\n\n/***/ }),\n/* 244 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar isPlainObject = __webpack_require__(26);\n\nvar each = __webpack_require__(2);\n\nvar reduce = function reduce(arr, fn, init) {\n  if (!isArray(arr) && !isPlainObject(arr)) {\n    return arr;\n  }\n\n  var result = init;\n  each(arr, function (data, i) {\n    result = fn(result, data, i);\n  });\n  return result;\n};\n\nmodule.exports = reduce;\n\n/***/ }),\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(13);\n\nvar pullAt = __webpack_require__(130);\n\nvar remove = function remove(arr, predicate) {\n  /**\n   * const arr = [1, 2, 3, 4]\n   * const evens = remove(arr, n => n % 2 == 0)\n   * console.log(arr) // => [1, 3]\n   * console.log(evens) // => [2, 4]\n   */\n  var result = [];\n\n  if (!isArrayLike(arr)) {\n    return result;\n  }\n\n  var i = -1;\n  var indexes = [];\n  var length = arr.length;\n\n  while (++i < length) {\n    var value = arr[i];\n\n    if (predicate(value, i, arr)) {\n      result.push(value);\n      indexes.push(i);\n    }\n  }\n\n  pullAt(arr, indexes);\n  return result;\n};\n\nmodule.exports = remove;\n\n/***/ }),\n/* 246 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isString = __webpack_require__(10);\n\nvar isFunction = __webpack_require__(11);\n\nvar isArray = __webpack_require__(4);\n\nfunction sortBy(arr, key) {\n  var comparer = void 0;\n\n  if (isFunction(key)) {\n    comparer = function comparer(a, b) {\n      return key(a) - key(b);\n    };\n  } else {\n    var keys = [];\n\n    if (isString(key)) {\n      keys.push(key);\n    } else if (isArray(key)) {\n      keys = key;\n    }\n\n    comparer = function comparer(a, b) {\n      for (var i = 0; i < keys.length; i += 1) {\n        var prop = keys[i];\n\n        if (a[prop] > b[prop]) {\n          return 1;\n        }\n\n        if (a[prop] < b[prop]) {\n          return -1;\n        }\n      }\n\n      return 0;\n    };\n  }\n\n  arr.sort(comparer);\n  return arr;\n}\n\nmodule.exports = sortBy;\n\n/***/ }),\n/* 247 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar toArray = __webpack_require__(34);\n\nvar uniq = __webpack_require__(131);\n\nvar union = function union() {\n  var result = [];\n  var sources = toArray(arguments);\n  each(sources, function (arr) {\n    result = result.concat(arr);\n  });\n  return uniq(result);\n};\n\nmodule.exports = union;\n\n/***/ }),\n/* 248 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  getWrapBehavior: __webpack_require__(249),\n  wrapBehavior: __webpack_require__(250)\n};\n\n/***/ }),\n/* 249 */\n/***/ (function(module, exports) {\n\n/**\n * 获取封装的事件\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction getWrapBehavior(obj, action) {\n  return obj['_wrap_' + action];\n}\n\nmodule.exports = getWrapBehavior;\n\n/***/ }),\n/* 250 */\n/***/ (function(module, exports) {\n\n/**\n * 封装事件，便于使用上下文this,和便于解除事件时使用\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction wrapBehavior(obj, action) {\n  if (obj['_wrap_' + action]) {\n    return obj['_wrap_' + action];\n  }\n\n  var method = function method(e) {\n    obj[action](e);\n  };\n\n  obj['_wrap_' + action] = method;\n  return method;\n}\n\nmodule.exports = wrapBehavior;\n\n/***/ }),\n/* 251 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar number2color = __webpack_require__(252);\n\nmodule.exports = {\n  number2color: number2color,\n  numberToColor: number2color,\n  parsePath: __webpack_require__(253),\n  parseRadius: __webpack_require__(254)\n};\n\n/***/ }),\n/* 252 */\n/***/ (function(module, exports) {\n\nvar numColorCache = {};\n\nmodule.exports = function numberToColor(num) {\n  // 增加缓存\n  var color = numColorCache[num];\n\n  if (!color) {\n    var str = num.toString(16);\n\n    for (var i = str.length; i < 6; i++) {\n      str = '0' + str;\n    }\n\n    color = '#' + str;\n    numColorCache[num] = color;\n  }\n\n  return color;\n};\n\n/***/ }),\n/* 253 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar isString = __webpack_require__(10);\n\nvar each = __webpack_require__(2);\n\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nvar regexDot = /[^\\s\\,]+/ig;\n\nmodule.exports = function parsePath(path) {\n  path = path || [];\n\n  if (isArray(path)) {\n    return path;\n  }\n\n  if (isString(path)) {\n    path = path.match(regexTags);\n    each(path, function (item, index) {\n      item = item.match(regexDot);\n\n      if (item[0].length > 1) {\n        var tag = item[0].charAt(0);\n        item.splice(1, 0, item[0].substr(1));\n        item[0] = tag;\n      }\n\n      each(item, function (sub, i) {\n        if (!isNaN(sub)) {\n          item[i] = +sub;\n        }\n      });\n      path[index] = item;\n    });\n    return path;\n  }\n};\n\n/***/ }),\n/* 254 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nmodule.exports = function parseRadius(radius) {\n  var r1 = 0,\n      r2 = 0,\n      r3 = 0,\n      r4 = 0;\n\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n\n  return {\n    r1: r1,\n    r2: r2,\n    r3: r3,\n    r4: r4\n  };\n};\n\n/***/ }),\n/* 255 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumberEqual = __webpack_require__(35);\n\nmodule.exports = {\n  clamp: __webpack_require__(50),\n  fixedBase: __webpack_require__(256),\n  isDecimal: __webpack_require__(257),\n  isEven: __webpack_require__(258),\n  isInteger: __webpack_require__(259),\n  isNegative: __webpack_require__(260),\n  isNumberEqual: isNumberEqual,\n  isOdd: __webpack_require__(261),\n  isPositive: __webpack_require__(262),\n  maxBy: __webpack_require__(132),\n  minBy: __webpack_require__(263),\n  mod: __webpack_require__(93),\n  snapEqual: isNumberEqual,\n  toDegree: __webpack_require__(92),\n  toInt: __webpack_require__(133),\n  toInteger: __webpack_require__(133),\n  toRadian: __webpack_require__(91)\n};\n\n/***/ }),\n/* 256 */\n/***/ (function(module, exports) {\n\nvar fixedBase = function fixedBase(v, base) {\n  var str = base.toString();\n  var index = str.indexOf('.');\n\n  if (index === -1) {\n    return Math.round(v);\n  }\n\n  var length = str.substr(index + 1).length;\n\n  if (length > 20) {\n    length = 20;\n  }\n\n  return parseFloat(v.toFixed(length));\n};\n\nmodule.exports = fixedBase;\n\n/***/ }),\n/* 257 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isDecimal = function isDecimal(num) {\n  return isNumber(num) && num % 1 !== 0;\n};\n\nmodule.exports = isDecimal;\n\n/***/ }),\n/* 258 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isEven = function isEven(num) {\n  return isNumber(num) && num % 2 === 0;\n};\n\nmodule.exports = isEven;\n\n/***/ }),\n/* 259 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n  return isNumber(num) && num % 1 === 0;\n};\nmodule.exports = isInteger;\n\n/***/ }),\n/* 260 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isNagative = function isNagative(num) {\n  return isNumber(num) && num < 0;\n};\n\nmodule.exports = isNagative;\n\n/***/ }),\n/* 261 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isOdd = function isOdd(num) {\n  return isNumber(num) && num % 2 !== 0;\n};\n\nmodule.exports = isOdd;\n\n/***/ }),\n/* 262 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNumber = __webpack_require__(9);\n\nvar isPositive = function isPositive(num) {\n  return isNumber(num) && num > 0;\n};\n\nmodule.exports = isPositive;\n\n/***/ }),\n/* 263 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar isFunction = __webpack_require__(11);\n\nvar each = __webpack_require__(2);\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * minBy(objects, 'n');\n * // => { 'n': 1 }\n */\n\n\nvar minBy = function minBy(arr, fn) {\n  if (!isArray(arr)) {\n    return undefined;\n  }\n\n  var min = arr[0];\n  var minData = void 0;\n\n  if (isFunction(fn)) {\n    minData = fn(arr[0]);\n  } else {\n    minData = arr[0][fn];\n  }\n\n  var data = void 0;\n  each(arr, function (val) {\n    if (isFunction(fn)) {\n      data = fn(val);\n    } else {\n      data = val[fn];\n    }\n\n    if (data < minData) {\n      min = val;\n      minData = data;\n    }\n  });\n  return min;\n};\n\nmodule.exports = minBy;\n\n/***/ }),\n/* 264 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  forIn: __webpack_require__(265),\n  has: __webpack_require__(134),\n  hasKey: __webpack_require__(266),\n  hasValue: __webpack_require__(267),\n  keys: __webpack_require__(129),\n  isMatch: __webpack_require__(128),\n  values: __webpack_require__(135)\n};\n\n/***/ }),\n/* 265 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n/***/ }),\n/* 266 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(134);\n\n/***/ }),\n/* 267 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar contains = __webpack_require__(41);\n\nvar values = __webpack_require__(135);\n\nmodule.exports = function (obj, value) {\n  return contains(values(obj), value);\n};\n\n/***/ }),\n/* 268 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pathIntersection = __webpack_require__(269);\n\nvar path2absolute = __webpack_require__(139);\n\nvar path2curve = __webpack_require__(138);\n\nvar catmullRom2Bezier = __webpack_require__(141);\n\nmodule.exports = {\n  catmullRom2Bezier: catmullRom2Bezier,\n  catmullRomToBezier: catmullRom2Bezier,\n  fillPath: __webpack_require__(270),\n  fillPathByDiff: __webpack_require__(271),\n  formatPath: __webpack_require__(273),\n  intersection: pathIntersection,\n  pathIntersection: pathIntersection,\n  parsePathArray: __webpack_require__(137),\n  parsePathString: __webpack_require__(140),\n  pathToAbsolute: path2absolute,\n  path2absolute: path2absolute,\n  pathTocurve: path2curve,\n  path2curve: path2curve,\n  rectPath: __webpack_require__(136)\n};\n\n/***/ }),\n/* 269 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(4);\n\nvar rectPath = __webpack_require__(136);\n\nvar pathTocurve = __webpack_require__(138);\n\nvar base3 = function base3(t, p1, p2, p3, p4) {\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;\n  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n  return t * t2 - 3 * p1 + 3 * p2;\n};\n\nvar bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n  if (z === null) {\n    z = 1;\n  }\n\n  z = z > 1 ? 1 : z < 0 ? 0 : z;\n  var z2 = z / 2;\n  var n = 12;\n  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];\n  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\n  var sum = 0;\n\n  for (var i = 0; i < n; i++) {\n    var ct = z2 * Tvalues[i] + z2;\n    var xbase = base3(ct, x1, x2, x3, x4);\n    var ybase = base3(ct, y1, y2, y3, y4);\n    var comb = xbase * xbase + ybase * ybase;\n    sum += Cvalues[i] * Math.sqrt(comb);\n  }\n\n  return z2 * sum;\n};\n\nvar curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var tvalues = [];\n  var bounds = [[], []];\n  var a = void 0;\n  var b = void 0;\n  var c = void 0;\n  var t = void 0;\n\n  for (var i = 0; i < 2; ++i) {\n    if (i === 0) {\n      b = 6 * x0 - 12 * x1 + 6 * x2;\n      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n      c = 3 * x1 - 3 * x0;\n    } else {\n      b = 6 * y0 - 12 * y1 + 6 * y2;\n      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n      c = 3 * y1 - 3 * y0;\n    }\n\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) < 1e-12) {\n        continue;\n      }\n\n      t = -c / b;\n\n      if (t > 0 && t < 1) {\n        tvalues.push(t);\n      }\n\n      continue;\n    }\n\n    var b2ac = b * b - 4 * c * a;\n    var sqrtb2ac = Math.sqrt(b2ac);\n\n    if (b2ac < 0) {\n      continue;\n    }\n\n    var t1 = (-b + sqrtb2ac) / (2 * a);\n\n    if (t1 > 0 && t1 < 1) {\n      tvalues.push(t1);\n    }\n\n    var t2 = (-b - sqrtb2ac) / (2 * a);\n\n    if (t2 > 0 && t2 < 1) {\n      tvalues.push(t2);\n    }\n  }\n\n  var j = tvalues.length;\n  var jlen = j;\n  var mt = void 0;\n\n  while (j--) {\n    t = tvalues[j];\n    mt = 1 - t;\n    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n  }\n\n  bounds[0][jlen] = x0;\n  bounds[1][jlen] = y0;\n  bounds[0][jlen + 1] = x3;\n  bounds[1][jlen + 1] = y3;\n  bounds[0].length = bounds[1].length = jlen + 2;\n  return {\n    min: {\n      x: Math.min.apply(0, bounds[0]),\n      y: Math.min.apply(0, bounds[1])\n    },\n    max: {\n      x: Math.max.apply(0, bounds[0]),\n      y: Math.max.apply(0, bounds[1])\n    }\n  };\n};\n\nvar intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {\n    return;\n  }\n\n  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  if (!denominator) {\n    return;\n  }\n\n  var px = nx / denominator;\n  var py = ny / denominator;\n  var px2 = +px.toFixed(2);\n  var py2 = +py.toFixed(2);\n\n  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {\n    return;\n  }\n\n  return {\n    x: px,\n    y: py\n  };\n};\n\nvar isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n};\n\nvar box = function box(x, y, width, height) {\n  if (x === null) {\n    x = y = width = height = 0;\n  }\n\n  if (y === null) {\n    y = x.y;\n    width = x.width;\n    height = x.height;\n    x = x.x;\n  }\n\n  return {\n    x: x,\n    y: y,\n    width: width,\n    w: width,\n    height: height,\n    h: height,\n    x2: x + width,\n    y2: y + height,\n    cx: x + width / 2,\n    cy: y + height / 2,\n    r1: Math.min(width, height) / 2,\n    r2: Math.max(width, height) / 2,\n    r0: Math.sqrt(width * width + height * height) / 2,\n    path: rectPath(x, y, width, height),\n    vb: [x, y, width, height].join(' ')\n  };\n};\n\nvar isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {\n  bbox1 = box(bbox1);\n  bbox2 = box(bbox2);\n  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n};\n\nvar bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n  if (!isArray(p1x)) {\n    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n  }\n\n  var bbox = curveDim.apply(null, p1x);\n  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\n};\n\nvar findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n  var t1 = 1 - t;\n  var t13 = Math.pow(t1, 3);\n  var t12 = Math.pow(t1, 2);\n  var t2 = t * t;\n  var t3 = t2 * t;\n  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;\n  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;\n  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);\n  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);\n  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);\n  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);\n  var ax = t1 * p1x + t * c1x;\n  var ay = t1 * p1y + t * c1y;\n  var cx = t1 * c2x + t * p2x;\n  var cy = t1 * c2y + t * p2y;\n  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);\n\n  return {\n    x: x,\n    y: y,\n    m: {\n      x: mx,\n      y: my\n    },\n    n: {\n      x: nx,\n      y: ny\n    },\n    start: {\n      x: ax,\n      y: ay\n    },\n    end: {\n      x: cx,\n      y: cy\n    },\n    alpha: alpha\n  };\n};\n\nvar interHelper = function interHelper(bez1, bez2, justCount) {\n  var bbox1 = bezierBBox(bez1);\n  var bbox2 = bezierBBox(bez2);\n\n  if (!isBBoxIntersect(bbox1, bbox2)) {\n    return justCount ? 0 : [];\n  }\n\n  var l1 = bezlen.apply(0, bez1);\n  var l2 = bezlen.apply(0, bez2);\n  var n1 = ~~(l1 / 8);\n  var n2 = ~~(l2 / 8);\n  var dots1 = [];\n  var dots2 = [];\n  var xy = {};\n  var res = justCount ? 0 : [];\n\n  for (var i = 0; i < n1 + 1; i++) {\n    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n    dots1.push({\n      x: d.x,\n      y: d.y,\n      t: i / n1\n    });\n  }\n\n  for (var _i = 0; _i < n2 + 1; _i++) {\n    var _d = findDotsAtSegment.apply(0, bez2.concat(_i / n2));\n\n    dots2.push({\n      x: _d.x,\n      y: _d.y,\n      t: _i / n2\n    });\n  }\n\n  for (var _i2 = 0; _i2 < n1; _i2++) {\n    for (var j = 0; j < n2; j++) {\n      var di = dots1[_i2];\n      var di1 = dots1[_i2 + 1];\n      var dj = dots2[j];\n      var dj1 = dots2[j + 1];\n      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';\n      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';\n      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\n      if (is) {\n        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {\n          continue;\n        }\n\n        xy[is.x.toFixed(4)] = is.y.toFixed(4);\n        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);\n        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\n        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n          if (justCount) {\n            res++;\n          } else {\n            res.push({\n              x: is.x,\n              y: is.y,\n              t1: t1,\n              t2: t2\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return res;\n};\n\nvar interPathHelper = function interPathHelper(path1, path2, justCount) {\n  path1 = pathTocurve(path1);\n  path2 = pathTocurve(path2);\n  var x1 = void 0;\n  var y1 = void 0;\n  var x2 = void 0;\n  var y2 = void 0;\n  var x1m = void 0;\n  var y1m = void 0;\n  var x2m = void 0;\n  var y2m = void 0;\n  var bez1 = void 0;\n  var bez2 = void 0;\n  var res = justCount ? 0 : [];\n\n  for (var i = 0, ii = path1.length; i < ii; i++) {\n    var pi = path1[i];\n\n    if (pi[0] === 'M') {\n      x1 = x1m = pi[1];\n      y1 = y1m = pi[2];\n    } else {\n      if (pi[0] === 'C') {\n        bez1 = [x1, y1].concat(pi.slice(1));\n        x1 = bez1[6];\n        y1 = bez1[7];\n      } else {\n        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n        x1 = x1m;\n        y1 = y1m;\n      }\n\n      for (var j = 0, jj = path2.length; j < jj; j++) {\n        var pj = path2[j];\n\n        if (pj[0] === 'M') {\n          x2 = x2m = pj[1];\n          y2 = y2m = pj[2];\n        } else {\n          if (pj[0] === 'C') {\n            bez2 = [x2, y2].concat(pj.slice(1));\n            x2 = bez2[6];\n            y2 = bez2[7];\n          } else {\n            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n            x2 = x2m;\n            y2 = y2m;\n          }\n\n          var intr = interHelper(bez1, bez2, justCount);\n\n          if (justCount) {\n            res += intr;\n          } else {\n            for (var k = 0, kk = intr.length; k < kk; k++) {\n              intr[k].segment1 = i;\n              intr[k].segment2 = j;\n              intr[k].bez1 = bez1;\n              intr[k].bez2 = bez2;\n            }\n\n            res = res.concat(intr);\n          }\n        }\n      }\n    }\n  }\n\n  return res;\n};\n\nmodule.exports = function pathIntersection(path1, path2) {\n  return interPathHelper(path1, path2);\n};\n\n/***/ }),\n/* 270 */\n/***/ (function(module, exports) {\n\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function recurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var middlePoints = [];\n\n      for (var i = 0; i < points.length - 1; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === points.length - 2) {\n          right.push(points[i + 1]);\n        }\n\n        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      recurse(middlePoints, t);\n    }\n  }\n\n  if (points.length) {\n    recurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n\nfunction splitCurve(start, end, count) {\n  var points = [[start[1], start[2]]];\n  count = count || 2;\n  var segments = [];\n\n  if (end[0] === 'A') {\n    points.push(end[6]);\n    points.push(end[7]);\n  } else if (end[0] === 'C') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n    points.push([end[5], end[6]]);\n  } else if (end[0] === 'S' || end[0] === 'Q') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n  } else {\n    points.push([end[1], end[2]]);\n  }\n\n  var leftSegments = points;\n  var t = 1 / count;\n\n  for (var i = 0; i < count - 1; i++) {\n    var rt = t / (1 - t * i);\n    var split = decasteljau(leftSegments, rt);\n    segments.push(split.left);\n    leftSegments = split.right;\n  }\n\n  segments.push(leftSegments);\n  var result = segments.map(function (segment) {\n    var cmd = [];\n\n    if (segment.length === 4) {\n      cmd.push('C');\n      cmd = cmd.concat(segment[2]);\n    }\n\n    if (segment.length >= 3) {\n      if (segment.length === 3) {\n        cmd.push('Q');\n      }\n\n      cmd = cmd.concat(segment[1]);\n    }\n\n    if (segment.length === 2) {\n      cmd.push('L');\n    }\n\n    cmd = cmd.concat(segment[segment.length - 1]);\n    return cmd;\n  });\n  return result;\n}\n\nfunction splitSegment(start, end, count) {\n  if (count === 1) {\n    return [[].concat(start)];\n  }\n\n  var segments = [];\n\n  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n    segments = segments.concat(splitCurve(start, end, count));\n  } else {\n    var temp = [].concat(start);\n\n    if (temp[0] === 'M') {\n      temp[0] = 'L';\n    }\n\n    for (var i = 0; i <= count - 1; i++) {\n      segments.push(temp);\n    }\n  }\n\n  return segments;\n}\n\nmodule.exports = function fillPath(source, target) {\n  if (source.length === 1) {\n    return source;\n  }\n\n  var sourceLen = source.length - 1;\n  var targetLen = target.length - 1;\n  var ratio = sourceLen / targetLen;\n  var segmentsToFill = [];\n\n  if (source.length === 1 && source[0][0] === 'M') {\n    for (var i = 0; i < targetLen - sourceLen; i++) {\n      source.push(source[0]);\n    }\n\n    return source;\n  }\n\n  for (var _i = 0; _i < targetLen; _i++) {\n    var index = Math.floor(ratio * _i);\n    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n  }\n\n  var filled = segmentsToFill.reduce(function (filled, count, i) {\n    if (i === sourceLen) {\n      return filled.concat(source[sourceLen]);\n    }\n\n    return filled.concat(splitSegment(source[i], source[i + 1], count));\n  }, []);\n  filled.unshift(source[0]);\n\n  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n    filled.push('Z');\n  }\n\n  return filled;\n};\n\n/***/ }),\n/* 271 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isEqual = __webpack_require__(272);\n\nfunction getMinDiff(del, add, modify) {\n  var type = null;\n  var min = modify;\n\n  if (add < min) {\n    min = add;\n    type = 'add';\n  }\n\n  if (del < min) {\n    min = del;\n    type = 'del';\n  }\n\n  return {\n    type: type,\n    min: min\n  };\n}\n/*\n * https://en.wikipedia.org/wiki/Levenshtein_distance\n * 计算两条path的编辑距离\n */\n\n\nvar levenshteinDistance = function levenshteinDistance(source, target) {\n  var sourceLen = source.length;\n  var targetLen = target.length;\n  var sourceSegment = void 0,\n      targetSegment = void 0;\n  var temp = 0;\n\n  if (sourceLen === 0 || targetLen === 0) {\n    return null;\n  }\n\n  var dist = [];\n\n  for (var i = 0; i <= sourceLen; i++) {\n    dist[i] = [];\n    dist[i][0] = {\n      min: i\n    };\n  }\n\n  for (var j = 0; j <= targetLen; j++) {\n    dist[0][j] = {\n      min: j\n    };\n  }\n\n  for (var _i = 1; _i <= sourceLen; _i++) {\n    sourceSegment = source[_i - 1];\n\n    for (var _j = 1; _j <= targetLen; _j++) {\n      targetSegment = target[_j - 1];\n\n      if (isEqual(sourceSegment, targetSegment)) {\n        temp = 0;\n      } else {\n        temp = 1;\n      }\n\n      var del = dist[_i - 1][_j].min + 1;\n      var add = dist[_i][_j - 1].min + 1;\n      var modify = dist[_i - 1][_j - 1].min + temp;\n      dist[_i][_j] = getMinDiff(del, add, modify);\n    }\n  }\n\n  return dist;\n};\n\nmodule.exports = function fillPathByDiff(source, target) {\n  var diffMatrix = levenshteinDistance(source, target);\n  var sourceLen = source.length;\n  var targetLen = target.length;\n  var changes = [];\n  var index = 1;\n  var minPos = 1; // 如果source和target不是完全不相等\n\n  if (diffMatrix[sourceLen][targetLen] !== sourceLen) {\n    // 获取从source到target所需改动\n    for (var i = 1; i <= sourceLen; i++) {\n      var min = diffMatrix[i][i].min;\n      minPos = i;\n\n      for (var j = index; j <= targetLen; j++) {\n        if (diffMatrix[i][j].min < min) {\n          min = diffMatrix[i][j].min;\n          minPos = j;\n        }\n      }\n\n      index = minPos;\n\n      if (diffMatrix[i][index].type) {\n        changes.push({\n          index: i - 1,\n          type: diffMatrix[i][index].type\n        });\n      }\n    } // 对source进行增删path\n\n\n    for (var _i2 = changes.length - 1; _i2 >= 0; _i2--) {\n      index = changes[_i2].index;\n\n      if (changes[_i2].type === 'add') {\n        source.splice(index, 0, [].concat(source[index]));\n      } else {\n        source.splice(index, 1);\n      }\n    }\n  } // source尾部补齐\n\n\n  sourceLen = source.length;\n\n  if (sourceLen < targetLen) {\n    for (var _i3 = 0; _i3 < targetLen - sourceLen; _i3++) {\n      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {\n        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);\n      } else {\n        source.push(source[sourceLen - 1]);\n      }\n    }\n  }\n\n  return source;\n};\n\n/***/ }),\n/* 272 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nmodule.exports = function isEqual(obj1, obj2) {\n  if (obj1.length !== obj2.length) {\n    return false;\n  }\n\n  var result = true;\n  each(obj1, function (item, i) {\n    if (item !== obj2[i]) {\n      result = false;\n      return false;\n    }\n  });\n  return result;\n};\n\n/***/ }),\n/* 273 */\n/***/ (function(module, exports) {\n\n/*\n * 抽取pathSegment中的关键点\n * M,L,A,Q,H,V一个端点\n * Q, S抽取一个端点，一个控制点\n * C抽取一个端点，两个控制点\n */\nfunction _getSegmentPoints(segment) {\n  var points = [];\n\n  switch (segment[0]) {\n    case 'M':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'L':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'A':\n      points.push([segment[6], segment[7]]);\n      break;\n\n    case 'Q':\n      points.push([segment[3], segment[4]]);\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'T':\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'C':\n      points.push([segment[5], segment[6]]);\n      points.push([segment[1], segment[2]]);\n      points.push([segment[3], segment[4]]);\n      break;\n\n    case 'S':\n      points.push([segment[3], segment[4]]);\n      points.push([segment[1], segment[2]]);\n      break;\n\n    case 'H':\n      points.push([segment[1], segment[1]]);\n      break;\n\n    case 'V':\n      points.push([segment[1], segment[1]]);\n      break;\n\n    default:\n  }\n\n  return points;\n} // 将两个点均分成count个点\n\n\nfunction _splitPoints(points, former, count) {\n  var result = [].concat(points);\n  var index = void 0;\n  var t = 1 / (count + 1);\n\n  var formerEnd = _getSegmentPoints(former)[0];\n\n  for (var i = 1; i <= count; i++) {\n    t *= i;\n    index = Math.floor(points.length * t);\n\n    if (index === 0) {\n      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    } else {\n      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = function formatPath(fromPath, toPath) {\n  if (fromPath.length <= 1) {\n    return fromPath;\n  }\n\n  var points = void 0;\n\n  for (var i = 0; i < toPath.length; i++) {\n    if (fromPath[i][0] !== toPath[i][0]) {\n      // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造\n      points = _getSegmentPoints(fromPath[i]);\n\n      switch (toPath[i][0]) {\n        case 'M':\n          fromPath[i] = ['M'].concat(points[0]);\n          break;\n\n        case 'L':\n          fromPath[i] = ['L'].concat(points[0]);\n          break;\n\n        case 'A':\n          fromPath[i] = [].concat(toPath[i]);\n          fromPath[i][6] = points[0][0];\n          fromPath[i][7] = points[0][1];\n          break;\n\n        case 'Q':\n          if (points.length < 2) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 1);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        case 'T':\n          fromPath[i] = ['T'].concat(points[0]);\n          break;\n\n        case 'C':\n          if (points.length < 3) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 2);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        case 'S':\n          if (points.length < 2) {\n            if (i > 0) {\n              points = _splitPoints(points, fromPath[i - 1], 1);\n            } else {\n              fromPath[i] = toPath[i];\n              break;\n            }\n          }\n\n          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {\n            return arr.concat(i);\n          }, []));\n          break;\n\n        default:\n          fromPath[i] = toPath[i];\n      }\n    }\n  }\n\n  return fromPath;\n};\n\n/***/ }),\n/* 274 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar strUtil = {\n  lc: __webpack_require__(275),\n  lowerCase: __webpack_require__(142),\n  lowerFirst: __webpack_require__(75),\n  substitute: __webpack_require__(276),\n  uc: __webpack_require__(277),\n  upperCase: __webpack_require__(143),\n  upperFirst: __webpack_require__(87)\n};\nmodule.exports = strUtil;\n\n/***/ }),\n/* 275 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(142);\n\n/***/ }),\n/* 276 */\n/***/ (function(module, exports) {\n\nvar substitute = function substitute(str, o) {\n  if (!str || !o) {\n    return str;\n  }\n\n  return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n    if (match.charAt(0) === '\\\\') {\n      return match.slice(1);\n    }\n\n    return o[name] === undefined ? '' : o[name];\n  });\n};\n\nmodule.exports = substitute;\n\n/***/ }),\n/* 277 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(143);\n\n/***/ }),\n/* 278 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(12);\n\nvar checkType = {\n  getType: __webpack_require__(84),\n  isArray: __webpack_require__(4),\n  isArrayLike: __webpack_require__(13),\n  isBoolean: __webpack_require__(82),\n  isFunction: __webpack_require__(11),\n  isNil: __webpack_require__(5),\n  isNull: __webpack_require__(279),\n  isNumber: __webpack_require__(9),\n  isObject: __webpack_require__(24),\n  isObjectLike: __webpack_require__(48),\n  isPlainObject: __webpack_require__(26),\n  isPrototype: __webpack_require__(85),\n  isType: isType,\n  isUndefined: __webpack_require__(280),\n  isString: __webpack_require__(10),\n  isRegExp: __webpack_require__(281),\n  isDate: __webpack_require__(80),\n  isArguments: __webpack_require__(282),\n  isError: __webpack_require__(283)\n};\nmodule.exports = checkType;\n\n/***/ }),\n/* 279 */\n/***/ (function(module, exports) {\n\nvar isNull = function isNull(value) {\n  return value === null;\n};\n\nmodule.exports = isNull;\n\n/***/ }),\n/* 280 */\n/***/ (function(module, exports) {\n\nvar isUndefined = function isUndefined(value) {\n  return value === undefined;\n};\n\nmodule.exports = isUndefined;\n\n/***/ }),\n/* 281 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(12);\n\nvar isRegExp = function isRegExp(str) {\n  return isType(str, 'RegExp');\n};\n\nmodule.exports = isRegExp;\n\n/***/ }),\n/* 282 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar isType = __webpack_require__(12);\n\nvar isArguments = function isArguments(value) {\n  return isType(value, 'Arguments');\n};\n\nmodule.exports = isArguments;\n\n/***/ }),\n/* 283 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar isType = __webpack_require__(12);\n\nvar isError = function isError(value) {\n  return isType(value, 'Error');\n};\n\nmodule.exports = isError;\n\n/***/ }),\n/* 284 */\n/***/ (function(module, exports) {\n\nfunction debounce(func, wait, immediate) {\n  var timeout = void 0;\n  return function () {\n    var context = this,\n        args = arguments;\n\n    var later = function later() {\n      timeout = null;\n\n      if (!immediate) {\n        func.apply(context, args);\n      }\n    };\n\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      func.apply(context, args);\n    }\n  };\n}\n\nmodule.exports = debounce;\n\n/***/ }),\n/* 285 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(13);\n\nvar indexOf = function indexOf(arr, obj) {\n  if (!isArrayLike(arr)) {\n    return -1;\n  }\n\n  var m = Array.prototype.indexOf;\n\n  if (m) {\n    return m.call(arr, obj);\n  }\n\n  var index = -1;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] === obj) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n};\n\nmodule.exports = indexOf;\n\n/***/ }),\n/* 286 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(11);\n\nvar isEqual = __webpack_require__(49);\n/**\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [fn] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * isEqualWith(array, other, customizer);  // => true\n */\n\n\nvar isEqualWith = function isEqualWith(value, other, fn) {\n  if (!isFunction(fn)) {\n    return isEqual(value, other);\n  }\n\n  return !!fn(value, other);\n};\n\nmodule.exports = isEqualWith;\n\n/***/ }),\n/* 287 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isArrayLike = __webpack_require__(13);\n\nvar map = function map(arr, func) {\n  if (!isArrayLike(arr)) {\n    return arr;\n  }\n\n  var result = [];\n  each(arr, function (value, index) {\n    result.push(func(value, index));\n  });\n  return result;\n};\n\nmodule.exports = map;\n\n/***/ }),\n/* 288 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(2);\n\nvar isPlaineObject = __webpack_require__(26);\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n * pick(object, ['a', 'c']);  // => { 'a': 1, 'c': 3 }\n */\n\nvar pick = function pick(object, keys) {\n  if (object === null || !isPlaineObject(object)) {\n    return {};\n  }\n\n  var result = {};\n  each(keys, function (key) {\n    if (hasOwnProperty.call(object, key)) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n};\n\nmodule.exports = pick;\n\n/***/ }),\n/* 289 */\n/***/ (function(module, exports) {\n\nfunction throttle(func, wait, options) {\n  var timeout = void 0,\n      context = void 0,\n      args = void 0,\n      result = void 0;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function throttled() {\n    var now = Date.now();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\nmodule.exports = throttle;\n\n/***/ }),\n/* 290 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Default animation funciton\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar G = __webpack_require__(16);\n\nvar PathUtil = Util.PathUtil;\n\nfunction getClip(coord) {\n  var start = coord.start;\n  var end = coord.end;\n  var width = coord.getWidth();\n  var height = coord.getHeight();\n  var margin = 200;\n  var startAngle;\n  var endAngle;\n  var center;\n  var radius;\n  var clip;\n\n  if (coord.isPolar) {\n    radius = coord.getRadius();\n    center = coord.getCenter();\n    startAngle = coord.startAngle;\n    endAngle = coord.endAngle;\n    clip = new G.Fan({\n      attrs: {\n        x: center.x,\n        y: center.y,\n        rs: 0,\n        re: radius + margin,\n        startAngle: startAngle,\n        endAngle: startAngle\n      }\n    });\n    clip.endState = {\n      endAngle: endAngle\n    };\n  } else {\n    clip = new G.Rect({\n      attrs: {\n        x: start.x - margin,\n        y: end.y - margin,\n        width: coord.isTransposed ? width + margin * 2 : 0,\n        height: coord.isTransposed ? 0 : height + margin * 2\n      }\n    });\n\n    if (coord.isTransposed) {\n      clip.endState = {\n        height: height + margin * 2\n      };\n    } else {\n      clip.endState = {\n        width: width + margin * 2\n      };\n    }\n  }\n\n  clip.isClip = true;\n  return clip;\n} // 获取图形的包围盒\n\n\nfunction getPointsBox(points) {\n  if (Util.isEmpty(points)) {\n    return null;\n  }\n\n  var minX = points[0].x;\n  var maxX = points[0].x;\n  var minY = points[0].y;\n  var maxY = points[0].y;\n  Util.each(points, function (point) {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2\n  };\n}\n\nfunction getAngle(shape, coord) {\n  var points = shape.points || shape.get('origin').points;\n  var box = getPointsBox(points);\n  var endAngle;\n  var startAngle;\n  var coordStartAngle = coord.startAngle;\n  var coordEndAngle = coord.endAngle;\n  var diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coord.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n\nfunction getAnimateParam(animateCfg, index, id) {\n  var result = {};\n\n  if (animateCfg.delay) {\n    result.delay = Util.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay;\n  }\n\n  result.easing = Util.isFunction(animateCfg.easing) ? animateCfg.easing(index, id) : animateCfg.easing;\n  result.duration = Util.isFunction(animateCfg.duration) ? animateCfg.duration(index, id) : animateCfg.duration;\n  result.callback = animateCfg.callback;\n  return result;\n}\n\nfunction scaleInY(shape, animateCfg) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var box = shape.getBBox();\n  var points = shape.get('origin').points;\n  var x = (box.minX + box.maxX) / 2;\n  var y;\n\n  if (points[0].y - points[1].y <= 0) {\n    // 当顶点在零点之下\n    y = box.maxY;\n  } else {\n    y = box.minY;\n  }\n\n  var v = [x, y, 1];\n  shape.apply(v);\n  shape.attr('transform', [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);\n  var endState = {\n    transform: [['t', -x, -y], ['s', 1, 100], ['t', x, y]]\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);\n}\n\nfunction scaleInX(shape, animateCfg) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var box = shape.getBBox();\n  var points = shape.get('origin').points;\n  var x;\n  var y = (box.minY + box.maxY) / 2;\n\n  if (points[0].y - points[1].y > 0) {\n    // 当顶点在零点之下\n    x = box.maxX;\n  } else {\n    x = box.minX;\n  }\n\n  var v = [x, y, 1];\n  shape.apply(v);\n  shape.attr({\n    transform: [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]\n  });\n  var endState = {\n    transform: [['t', -x, -y], ['s', 100, 1], ['t', x, y]]\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);\n}\n\nfunction lineWidthOut(shape, animateCfg) {\n  var endState = {\n    lineWidth: 0,\n    opacity: 0\n  };\n  var id = shape._id;\n  var index = shape.get('index');\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, function () {\n    shape.remove();\n  }, animateParam.delay);\n}\n\nfunction zoomIn(shape, animateCfg, coord) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var x;\n  var y;\n\n  if (coord.isPolar && shape.name !== 'point') {\n    x = coord.getCenter().x;\n    y = coord.getCenter().y;\n  } else {\n    var box = shape.getBBox();\n    x = (box.minX + box.maxX) / 2;\n    y = (box.minY + box.maxY) / 2;\n  }\n\n  var v = [x, y, 1];\n  shape.apply(v);\n  shape.attr({\n    transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]\n  });\n  var endState = {\n    transform: [['t', -x, -y], ['s', 100, 100], ['t', x, y]]\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);\n}\n\nfunction zoomOut(shape, animateCfg, coord) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var x;\n  var y;\n\n  if (coord.isPolar && shape.name !== 'point') {\n    x = coord.getCenter().x;\n    y = coord.getCenter().y;\n  } else {\n    var box = shape.getBBox();\n    x = (box.minX + box.maxX) / 2;\n    y = (box.minY + box.maxY) / 2;\n  }\n\n  var v = [x, y, 1];\n  shape.apply(v);\n  var endState = {\n    transform: [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, function () {\n    shape.remove();\n  }, animateParam.delay);\n}\n\nfunction pathIn(shape, animateCfg) {\n  if (shape.get('type') !== 'path') return;\n  var id = shape._id;\n  var index = shape.get('index');\n  var path = PathUtil.pathToAbsolute(shape.attr('path'));\n  shape.attr('path', [path[0]]);\n  var endState = {\n    path: path\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);\n}\n\nfunction pathOut(shape, animateCfg) {\n  if (shape.get('type') !== 'path') return;\n  var id = shape._id;\n  var index = shape.get('index');\n  var path = PathUtil.pathToAbsolute(shape.attr('path'));\n  var endState = {\n    path: [path[0]]\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, function () {\n    shape.remove();\n  }, animateParam.delay);\n}\n\nfunction clipIn(shape, animateCfg, coord, startAngle, endAngle) {\n  var clip = getClip(coord);\n  var canvas = shape.get('canvas');\n  var id = shape._id;\n  var index = shape.get('index');\n  var endState;\n\n  if (startAngle) {\n    clip.attr('startAngle', startAngle);\n    clip.attr('endAngle', startAngle);\n    endState = {\n      endAngle: endAngle\n    };\n  } else {\n    endState = clip.endState;\n  }\n\n  clip.set('canvas', canvas);\n  shape.attr('clip', clip);\n  shape.setSilent('animating', true);\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  clip.animate(endState, animateParam.duration, animateParam.easing, function () {\n    if (shape && !shape.get('destroyed')) {\n      shape.attr('clip', null);\n      shape.setSilent('cacheShape', null);\n      shape.setSilent('animating', false);\n      clip.remove();\n    }\n  }, animateParam.delay);\n}\n\nfunction fadeIn(shape, animateCfg) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var fillOpacity = Util.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');\n  var strokeOpacity = Util.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');\n  shape.attr('fillOpacity', 0);\n  shape.attr('strokeOpacity', 0);\n  var endState = {\n    fillOpacity: fillOpacity,\n    strokeOpacity: strokeOpacity\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, animateParam.callback, animateParam.delay);\n}\n\nfunction fadeOut(shape, animateCfg) {\n  var id = shape._id;\n  var index = shape.get('index');\n  var endState = {\n    fillOpacity: 0,\n    strokeOpacity: 0\n  };\n  var animateParam = getAnimateParam(animateCfg, index, id, endState);\n  shape.animate(endState, animateParam.duration, animateParam.easing, function () {\n    shape.remove();\n  }, animateParam.delay);\n}\n\nfunction fanIn(shape, animateCfg, coord) {\n  var angle = getAngle(shape, coord);\n  var endAngle = angle.endAngle;\n  var startAngle = angle.startAngle;\n  clipIn(shape, animateCfg, coord, startAngle, endAngle);\n} // 默认动画库\n\n\nmodule.exports = {\n  enter: {\n    clipIn: clipIn,\n    zoomIn: zoomIn,\n    pathIn: pathIn,\n    scaleInY: scaleInY,\n    scaleInX: scaleInX,\n    fanIn: fanIn,\n    fadeIn: fadeIn\n  },\n  leave: {\n    lineWidthOut: lineWidthOut,\n    zoomOut: zoomOut,\n    pathOut: pathOut,\n    fadeOut: fadeOut\n  },\n  appear: {\n    clipIn: clipIn,\n    zoomIn: zoomIn,\n    pathIn: pathIn,\n    scaleInY: scaleInY,\n    scaleInX: scaleInX,\n    fanIn: fanIn,\n    fadeIn: fadeIn\n  },\n  update: {\n    fadeIn: fadeIn,\n    fanIn: fanIn\n  }\n};\n\n/***/ }),\n/* 291 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview view\n * @author dxq613@gmail.com\n */\nvar Base = __webpack_require__(148);\n\nvar Geom = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar Controller = __webpack_require__(165);\n\nvar Global = __webpack_require__(7);\n\nvar Theme = __webpack_require__(151);\n\nvar FIELD_ORIGIN = '_origin';\n\nvar Animate = __webpack_require__(355);\n\nfunction isFullCircle(coord) {\n  var startAngle = coord.startAngle;\n  var endAngle = coord.endAngle;\n\n  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isBetween(value, start, end) {\n  var tmp = (value - start) / (end - start);\n  return tmp >= 0 && tmp <= 1;\n}\n\nfunction isPointInCoord(coord, point) {\n  var result = false;\n\n  if (coord) {\n    var type = coord.type;\n\n    if (type === 'theta') {\n      var start = coord.start;\n      var end = coord.end;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      var invertPoint = coord.invert(point);\n      result = invertPoint.x >= 0 && invertPoint.y >= 0 && invertPoint.x <= 1 && invertPoint.y <= 1;\n    }\n  }\n\n  return result;\n}\n\nvar ViewGeoms = {};\nUtil.each(Geom, function (geomConstructor, className) {\n  var methodName = Util.lowerFirst(className);\n\n  ViewGeoms[methodName] = function (cfg) {\n    var geom = new geomConstructor(cfg);\n    this.addGeom(geom);\n    return geom;\n  };\n});\n/**\n * 图表中的视图\n * @class View\n */\n\nvar View =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(View, _Base);\n\n  var _proto = View.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      viewContainer: null,\n      coord: null,\n      start: {\n        x: 0,\n        y: 0\n      },\n      end: {\n        x: 1,\n        y: 1\n      },\n      geoms: [],\n      scales: {},\n      options: {},\n      scaleController: null,\n      padding: 0,\n      theme: null,\n      parent: null,\n      tooltipEnable: true,\n      // 是否展示 tooltip\n      animate: Global.animate,\n      visible: true\n    };\n  };\n\n  function View(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    self._setTheme();\n\n    Util.each(Geom, function (GeomConstructor, className) {\n      var methodName = Util.lowerFirst(className);\n\n      self[methodName] = function (cfg) {\n        if (cfg === void 0) {\n          cfg = {};\n        }\n\n        cfg.viewTheme = self.get('viewTheme');\n        var geom = new GeomConstructor(cfg);\n        self.addGeom(geom);\n        return geom;\n      };\n    }); // Util.mix(this, ViewGeoms);\n\n    self.init();\n    return _this;\n  }\n\n  _proto._setTheme = function _setTheme() {\n    var self = this;\n    var theme = self.get('theme');\n    var viewTheme = {};\n    var newTheme = {};\n\n    if (Util.isObject(theme)) {\n      newTheme = theme;\n    } else if (Util.indexOf(Object.keys(Theme), theme) !== -1) {\n      newTheme = Theme[theme];\n    }\n\n    Util.deepMix(viewTheme, Global, newTheme);\n    self.set('viewTheme', viewTheme);\n  };\n  /**\n   * @protected\n   * 初始化\n   */\n\n\n  _proto.init = function init() {\n    this._initViewPlot(); // 先创建容器\n\n\n    if (this.get('data')) {\n      this._initData(this.get('data'));\n    }\n\n    this._initOptions();\n\n    this._initControllers();\n\n    this._bindEvents();\n  }; // 初始化配置项\n\n\n  _proto._initOptions = function _initOptions() {\n    var self = this;\n    var options = Util.mix({}, self.get('options')); // 防止修改原始值\n\n    if (!options.scales) {\n      options.scales = {};\n    }\n\n    if (!options.coord) {\n      options.coord = {};\n    }\n\n    if (options.animate === false) {\n      this.set('animate', false);\n    }\n\n    if (options.tooltip === false || Util.isNull(options.tooltip)) {\n      // 配置项方式关闭 tooltip\n      this.set('tooltipEnable', false);\n    }\n\n    if (options.geoms && options.geoms.length) {\n      Util.each(options.geoms, function (geomOption) {\n        self._createGeom(geomOption);\n      });\n    }\n\n    var scaleController = self.get('scaleController');\n\n    if (scaleController) {\n      scaleController.defs = options.scales;\n    }\n\n    var coordController = self.get('coordController');\n\n    if (coordController) {\n      coordController.reset(options.coord);\n    }\n\n    this.set('options', options);\n  };\n\n  _proto._createGeom = function _createGeom(cfg) {\n    var type = cfg.type;\n    var geom;\n\n    if (this[type]) {\n      geom = this[type]();\n      Util.each(cfg, function (v, k) {\n        if (geom[k]) {\n          if (Util.isObject(v) && v.field) {\n            // 配置项传入\n            if (v === 'label') {\n              geom[k](v.field, v.callback, v.cfg);\n            } else {\n              var _cfg;\n\n              Util.each(v, function (value, key) {\n                if (key !== 'field') {\n                  _cfg = value;\n                }\n              });\n              geom[k](v.field, _cfg);\n            }\n          } else {\n            geom[k](v);\n          }\n        }\n      });\n    }\n  }; // 初始化所有的控制器\n\n\n  _proto._initControllers = function _initControllers() {\n    var self = this;\n    var options = self.get('options');\n    var viewTheme = self.get('viewTheme');\n    var canvas = self.get('canvas');\n    var scaleController = new Controller.Scale({\n      viewTheme: viewTheme,\n      defs: options.scales\n    });\n    var coordController = new Controller.Coord(options.coord);\n    this.set('scaleController', scaleController);\n    this.set('coordController', coordController);\n    var axisController = new Controller.Axis({\n      canvas: canvas,\n      viewTheme: viewTheme\n    });\n    this.set('axisController', axisController);\n    var guideController = new Controller.Guide({\n      viewTheme: viewTheme,\n      options: options.guides || []\n    });\n    this.set('guideController', guideController);\n  };\n\n  _proto._initViewPlot = function _initViewPlot() {\n    if (!this.get('viewContainer')) {\n      // 用于 geom 的绘制\n      this.set('viewContainer', this.get('middlePlot'));\n    }\n  };\n\n  _proto._initGeoms = function _initGeoms() {\n    var geoms = this.get('geoms');\n    var filteredData = this.get('filteredData');\n    var coord = this.get('coord');\n    var viewId = this.get('_id');\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n      geom.set('data', filteredData);\n      geom.set('coord', coord);\n      geom.set('_id', viewId + '-geom' + i);\n      geom.set('keyFields', this.get('keyFields'));\n      geom.init();\n    }\n  };\n\n  _proto._clearGeoms = function _clearGeoms() {\n    var self = this;\n    var geoms = self.get('geoms');\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n      geom.clear();\n    }\n  };\n\n  _proto._removeGeoms = function _removeGeoms() {\n    var self = this;\n    var geoms = self.get('geoms');\n\n    while (geoms.length > 0) {\n      var geom = geoms.shift();\n      geom.destroy();\n    }\n  };\n\n  _proto._drawGeoms = function _drawGeoms() {\n    this.emit('beforedrawgeoms');\n    var geoms = this.get('geoms');\n    var coord = this.get('coord');\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n      geom.setCoord(coord);\n      geom.paint();\n    }\n\n    this.emit('afterdrawgeoms');\n  };\n\n  _proto.isShapeInView = function isShapeInView(shape) {\n    var id = this.get('_id');\n    var shapeId = shape._id;\n\n    if (!shapeId) {\n      return shape.get('parent').get('viewId') === id;\n    }\n\n    return shapeId.split('-')[0] === id;\n  };\n  /**\n   * View 所在的范围\n   * @protected\n   * @return {Object} View 所在的范围\n   */\n\n\n  _proto.getViewRegion = function getViewRegion() {\n    var self = this;\n    var parent = self.get('parent');\n    var start;\n    var end;\n\n    if (parent) {\n      var region = parent.getViewRegion();\n\n      var viewRegion = self._getViewRegion(region.start, region.end);\n\n      start = viewRegion.start;\n      end = viewRegion.end;\n    } else {\n      start = self.get('start');\n      end = self.get('end');\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // 获取 range 所在的范围\n\n\n  _proto._getViewRegion = function _getViewRegion(plotStart, plotEnd) {\n    var start = this.get('start');\n    var end = this.get('end');\n    var startX = start.x;\n    var startY = 1 - end.y;\n    var endX = end.x;\n    var endY = 1 - start.y;\n    var padding = this.get('padding'); // 转换成 上、右、下、左的模式\n\n    var allPadding = Util.toAllPadding(padding);\n    var top = allPadding[0];\n    var right = allPadding[1];\n    var bottom = allPadding[2];\n    var left = allPadding[3];\n    var startPoint = {\n      x: startX * (plotEnd.x - plotStart.x) + plotStart.x + left,\n      y: startY * (plotEnd.y - plotStart.y) + plotStart.y - bottom\n    };\n    var endPoint = {\n      x: endX * (plotEnd.x - plotStart.x) + plotStart.x - right,\n      y: endY * (plotEnd.y - plotStart.y) + plotStart.y + top\n    };\n    return {\n      start: startPoint,\n      end: endPoint\n    };\n  };\n\n  _proto._createCoord = function _createCoord() {\n    var coordController = this.get('coordController');\n    var region = this.getViewRegion();\n    var coord = coordController.createCoord(region.start, region.end);\n    this.set('coord', coord);\n  };\n\n  _proto._renderAxes = function _renderAxes() {\n    var options = this.get('options');\n    var axesOptions = options.axes;\n\n    if (axesOptions === false) {\n      // 不渲染坐标轴\n      return;\n    }\n\n    var axisController = this.get('axisController');\n    axisController.container = this.get('backPlot');\n    axisController.coord = this.get('coord');\n    axisController.options = axesOptions || {};\n    var xScale = this.getXScale();\n    var yScales = this.getYScales();\n    var viewId = this.get('_id');\n    axisController.createAxis(xScale, yScales, viewId);\n  };\n\n  _proto._renderGuides = function _renderGuides() {\n    var guideController = this.get('guideController');\n\n    if (!Util.isEmpty(guideController.options)) {\n      var coord = this.get('coord');\n      guideController.view = this;\n      guideController.backContainer = this.get('backPlot');\n      guideController.frontContainer = this.get('frontPlot');\n      guideController.xScales = this._getScales('x');\n      guideController.yScales = this._getScales('y');\n      guideController.render(coord);\n    }\n  }; // 注册事件\n\n\n  _proto._bindEvents = function _bindEvents() {\n    var eventController = new Controller.Event({\n      view: this,\n      canvas: this.get('canvas')\n    });\n    eventController.bindEvents();\n    this.set('eventController', eventController);\n  }; // 清理时间\n\n\n  _proto._clearEvents = function _clearEvents() {\n    var eventController = this.get('eventController');\n    eventController && eventController.clearEvents();\n  };\n\n  _proto._getScales = function _getScales(dimType) {\n    var geoms = this.get('geoms');\n    var result = {};\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n      var scale = dimType === 'x' ? geom.getXScale() : geom.getYScale();\n\n      if (scale && !result[scale.field]) {\n        result[scale.field] = scale;\n      }\n    }\n\n    return result;\n  };\n\n  _proto._adjustScale = function _adjustScale() {\n    this._setCatScalesRange();\n\n    var geoms = this.get('geoms');\n    var scaleController = this.get('scaleController');\n    var colDefs = scaleController.defs;\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n\n      if (geom.get('type') === 'interval') {\n        var yScale = geom.getYScale();\n        var field = yScale.field,\n            min = yScale.min,\n            max = yScale.max,\n            type = yScale.type;\n\n        if (!(colDefs[field] && colDefs[field].min) && type !== 'time') {\n          if (min > 0) {\n            yScale.change({\n              min: 0\n            });\n          } else if (max <= 0) {\n            // 当柱状图全为负值时也需要从 0 开始生长\n            yScale.change({\n              max: 0\n            });\n          }\n        }\n      }\n    }\n  };\n\n  _proto._setCatScalesRange = function _setCatScalesRange() {\n    var self = this;\n    var coord = self.get('coord');\n    var viewTheme = self.get('viewTheme');\n    var xScale = self.getXScale();\n    var yScales = self.getYScales();\n    var scales = [];\n    xScale && scales.push(xScale);\n    scales = scales.concat(yScales);\n    var inFullCircle = coord.isPolar && isFullCircle(coord);\n    var scaleController = self.get('scaleController');\n    var colDefs = scaleController.defs;\n    Util.each(scales, function (scale) {\n      if ((scale.isCategory || scale.isIdentity) && scale.values && !(colDefs[scale.field] && colDefs[scale.field].range)) {\n        var count = scale.values.length;\n        var range;\n\n        if (count === 1) {\n          range = [0.5, 1]; // 只有一个分类时,防止计算出现 [0.5,0.5]的状态\n        } else {\n          var widthRatio = 1;\n          var offset = 0;\n\n          if (inFullCircle) {\n            if (!coord.isTransposed) {\n              range = [0, 1 - 1 / count];\n            } else {\n              widthRatio = viewTheme.widthRatio.multiplePie;\n              offset = 1 / count * widthRatio;\n              range = [offset / 2, 1 - offset / 2];\n            }\n          } else {\n            offset = 1 / count * 1 / 2; // 两边留下分类空间的一半\n\n            range = [offset, 1 - offset]; // 坐标轴最前面和最后面留下空白防止绘制柱状图时\n          }\n        }\n\n        scale.range = range;\n      }\n    });\n  };\n\n  _proto.getXScale = function getXScale() {\n    var geoms = this.get('geoms'); // 如果进行过滤，那么 geom 默认隐藏时会出现不一致\n    // 默认隐藏时坐标轴不绘制，但是调用了 geom.show() 后，则图形显示了，坐标轴依然不见\n\n    /* .filter(function(geom) {\n      return geom.get('visible');\n    }); */\n\n    var xScale = null;\n\n    if (!Util.isEmpty(geoms)) {\n      xScale = geoms[0].getXScale();\n    }\n\n    return xScale;\n  };\n\n  _proto.getYScales = function getYScales() {\n    var geoms = this.get('geoms');\n    /* .filter(function(geom) {\n      return geom.get('visible');\n    }); */\n\n    var rst = [];\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n      var yScale = geom.getYScale();\n\n      if (yScale && Util.indexOf(rst, yScale) === -1) {\n        rst.push(yScale);\n      }\n    }\n\n    return rst;\n  };\n  /**\n   * 获取数据对应在画布空间的坐标\n   * @param  {Object} item 原始数据\n   * @return {Object}      返回对应的画布上的坐标点\n   */\n\n\n  _proto.getXY = function getXY(item) {\n    var self = this;\n    var coord = self.get('coord');\n\n    var xScales = self._getScales('x');\n\n    var yScales = self._getScales('y');\n\n    var x;\n    var y;\n\n    for (var field in item) {\n      if (xScales[field]) {\n        x = xScales[field].scale(item[field]);\n      }\n\n      if (yScales[field]) {\n        y = yScales[field].scale(item[field]);\n      }\n    }\n\n    if (!Util.isNil(x) && !Util.isNil(y)) {\n      return coord.convert({\n        x: x,\n        y: y\n      });\n    }\n\n    return null;\n  };\n  /**\n   * 获取逼近的点的数据集合\n   * @param  {Object} point 画布上的像素点\n   * @return {Array} 数据\n   */\n\n\n  _proto.getSnapRecords = function getSnapRecords(point) {\n    var self = this;\n    var geoms = self.get('geoms');\n    var rst = [];\n    Util.each(geoms, function (geom) {\n      var dataArray = geom.get('dataArray');\n      var record;\n      Util.each(dataArray, function (data) {\n        record = geom.findPoint(point, data);\n        record && rst.push(record);\n      });\n    });\n    return rst;\n  };\n  /**\n   * @protected\n   * 添加几何标记\n   * @param {Geom} geom 几何标记\n   */\n\n\n  _proto.addGeom = function addGeom(geom) {\n    var self = this;\n    var geoms = self.get('geoms');\n    geoms.push(geom);\n    geom.set('view', self);\n    var container = self.get('viewContainer');\n    geom.set('container', container);\n    geom.set('animate', self.get('animate'));\n    geom.bindEvents();\n  };\n  /**\n   * @protected\n   * 移除几何标记\n   * @param {Geom} geom 几何标记\n   */\n\n\n  _proto.removeGeom = function removeGeom(geom) {\n    var geoms = this.get('geoms');\n    Util.Array.remove(geoms, geom);\n    geom.destroy();\n  };\n\n  _proto.createScale = function createScale(field, data) {\n    var scales = this.get('scales');\n    var parent = this.get('parent');\n    var scale = scales[field]; // const filters = this._getFilters();\n\n    if (!data) {\n      var filteredData = this.get('filteredData');\n\n      var legendFields = this._getFieldsForLegend(); // 过滤导致数据为空时，需要使用全局数据\n      // 参与过滤的字段的度量也根据全局数据来生成\n\n\n      if (filteredData.length && legendFields.indexOf(field) === -1) {\n        data = filteredData;\n      } else {\n        data = this.get('data');\n      }\n    }\n\n    var scaleController = this.get('scaleController');\n\n    if (!scale) {\n      scale = scaleController.createScale(field, data);\n\n      if (scale.sync && parent) {\n        var parentScale = parent.createScale(field, data);\n        scale = this._getSyncScale(parentScale, scale);\n      }\n\n      scales[field] = scale;\n    } else if (scale.sync) {\n      // 防止 view 内部创建的scale，Chart 上的scale 范围更大\n      var newScale = scaleController.createScale(field, data);\n\n      this._syncScale(scale, newScale);\n    }\n\n    return scale;\n  };\n\n  _proto._getFieldsForLegend = function _getFieldsForLegend() {\n    var fields = [];\n    var geoms = this.get('geoms');\n    Util.each(geoms, function (geom) {\n      var geomFields = geom.getFieldsForLegend();\n      fields = fields.concat(geomFields);\n    });\n    return Util.uniq(fields);\n  }; // 如果需要同步度量，则使得 values,min,max的范围最大\n\n\n  _proto._getSyncScale = function _getSyncScale(parentScale, scale) {\n    if (parentScale.type !== scale.type) {\n      return scale;\n    }\n\n    this._syncScale(parentScale, scale);\n\n    return parentScale;\n  };\n\n  _proto._syncScale = function _syncScale(distScale, sourceScale) {\n    var mergeValues = Util.union(distScale.values, sourceScale.values);\n\n    if (sourceScale.isLinear) {\n      var max = Math.max(distScale.max, sourceScale.max);\n      var min = Math.min(distScale.min, sourceScale.min);\n\n      if (distScale.max !== max || distScale.min !== min) {\n        distScale.change({\n          min: min,\n          max: max,\n          values: mergeValues\n        });\n      }\n    }\n\n    if (mergeValues.length !== distScale.values.length) {\n      distScale.change({\n        values: mergeValues\n      });\n    }\n  };\n  /**\n   * @protected\n   * 获取过滤后的值（需要显示的值）\n   * @param {String} field 度量\n   * @return {Array.<String>} 滤后的值\n   */\n\n\n  _proto.getFilteredValues = function getFilteredValues(field) {\n    var scale = this.get('scales')[field];\n    var values = scale.values;\n\n    var filters = this._getFilters();\n\n    var rst;\n\n    if (filters && filters[field]) {\n      rst = values.filter(filters[field]);\n    } else {\n      rst = values.slice(0);\n    }\n\n    return rst;\n  };\n  /**\n   * @protected\n   * 获取被过滤的值（不需显示的值）\n   * @param {String} field 度量\n   * @return {Array.<String>} 滤出的值\n   */\n\n\n  _proto.getFilteredOutValues = function getFilteredOutValues(field) {\n    var scale = this.get('scales')[field];\n    var values = scale.values;\n\n    var filters = this._getFilters();\n\n    var rst;\n\n    if (filters && filters[field]) {\n      rst = values.filter(function (v) {\n        return !filters[field](v);\n      });\n    } else {\n      rst = [];\n    }\n\n    return rst;\n  };\n\n  _proto.filter = function filter(field, condition) {\n    var options = this.get('options');\n\n    if (!options.filters) {\n      options.filters = {};\n    }\n\n    options.filters[field] = condition;\n    this.get('scaleController').filters = options.filters;\n  }; // 获取 filters\n\n\n  _proto._getFilters = function _getFilters() {\n    var options = this.get('options');\n    return options.filters;\n  }; // 执行 filter 数据\n\n\n  _proto.execFilter = function execFilter(data) {\n    var self = this;\n\n    var filters = self._getFilters();\n\n    if (filters) {\n      data = data.filter(function (obj) {\n        var rst = true;\n        Util.each(filters, function (fn, k) {\n          if (fn) {\n            rst = fn(obj[k], obj);\n\n            if (!rst) {\n              return false;\n            }\n          }\n        });\n        return rst;\n      });\n    }\n\n    return data;\n  };\n\n  _proto.axis = function axis(field, cfg) {\n    var options = this.get('options');\n\n    if (field === false) {\n      options.axes = false;\n    } else {\n      if (!options.axes) {\n        options.axes = {};\n      }\n\n      var axisOptions = options.axes;\n      axisOptions[field] = cfg;\n    }\n\n    return this;\n  };\n\n  _proto.guide = function guide() {\n    return this.get('guideController');\n  };\n\n  _proto._getKeyFields = function _getKeyFields(scaleDefs) {\n    var keyFields = [];\n    Util.each(scaleDefs, function (def, field) {\n      if (def.key) {\n        keyFields.push(field);\n      }\n    });\n    this.set('keyFields', keyFields);\n  };\n\n  _proto.scale = function scale(field, cfg) {\n    var options = this.get('options');\n    var scaleDefs = options.scales;\n\n    if (Util.isObject(field)) {\n      Util.mix(scaleDefs, field);\n    } else {\n      scaleDefs[field] = cfg;\n    }\n\n    this._getKeyFields(scaleDefs);\n\n    return this;\n  };\n\n  _proto.tooltip = function tooltip(visible) {\n    this.set('tooltipEnable', visible);\n    return this;\n  };\n\n  _proto.animate = function animate(enable) {\n    var options = this.get('options');\n    options.animate = enable;\n    this.set('animate', enable);\n    return this;\n  };\n\n  _proto.changeOptions = function changeOptions(options) {\n    this.set('options', options);\n\n    this._initOptions(options);\n\n    return this;\n  };\n  /**\n   * @internal 查找包含指定点的视图\n   * @param  {Object} point 点的位置\n   * @return {Array} 多个视图\n   */\n\n\n  _proto.getViewsByPoint = function getViewsByPoint(point) {\n    var rst = [];\n    var views = this.get('views');\n\n    if (isPointInCoord(this.get('coord'), point)) {\n      rst.push(this);\n    }\n\n    Util.each(views, function (view) {\n      if (view.get('visible') && isPointInCoord(view.get('coord'), point)) {\n        rst.push(view);\n      }\n    });\n    return rst;\n  };\n  /**\n   * 遍历所有的 shape ，用户更改 shape 后进行刷新\n   * @param  {Function} fn 回调函数包含参数：record,shape,geom,view\n   * @return {View} 当前视图\n   */\n\n\n  _proto.eachShape = function eachShape(fn) {\n    var self = this;\n    var views = self.get('views');\n    var canvas = self.get('canvas');\n    Util.each(views, function (view) {\n      view.eachShape(fn);\n    });\n    var geoms = this.get('geoms');\n    Util.each(geoms, function (geom) {\n      var shapes = geom.getShapes();\n      Util.each(shapes, function (shape) {\n        var origin = shape.get('origin');\n\n        if (Util.isArray(origin)) {\n          var arr = origin.map(function (subOrigin) {\n            return subOrigin[FIELD_ORIGIN];\n          });\n          fn(arr, shape, geom, self);\n        } else {\n          var obj = origin[FIELD_ORIGIN];\n          fn(obj, shape, geom, self);\n        }\n      });\n    });\n    canvas.draw();\n    return this;\n  };\n  /**\n   * 遍历所有的 shape ，回调函数中 true / false 控制图形是否显示\n   * @param  {Function} fn 回调函数包含参数：record,shape,geom,view\n   * @return {View} 当前视图\n   */\n\n\n  _proto.filterShape = function filterShape(fn) {\n    var callback = function callback(record, shape, geom, view) {\n      if (!fn(record, shape, geom, view)) {\n        shape.hide();\n      } else {\n        shape.show();\n      }\n    };\n\n    this.eachShape(callback);\n    return this;\n  };\n\n  _proto.clearInner = function clearInner() {\n    this.set('scales', {});\n    this.emit('beforeclearinner');\n    var options = this.get('options');\n    options.geoms = null;\n\n    this._clearGeoms(); // reset guide\n\n\n    this.get('guideController') && this.get('guideController').reset(); // clear axis\n\n    this.get('axisController') && this.get('axisController').clear();\n    this.emit('afterclearinner');\n  };\n  /**\n   * 清除视图内容，包括 geoms\n   * @return {View} 当前视图\n   */\n\n\n  _proto.clear = function clear() {\n    var options = this.get('options');\n    options.filters = null;\n\n    this._removeGeoms(); // const container = this.get('viewContainer');\n    // container.clear();\n\n\n    this.clearInner();\n    this.get('guideController') && this.get('guideController').clear();\n    this.set('isUpdate', false);\n    this.set('keyFields', []);\n    return this;\n  };\n  /**\n   * 设置坐标系信息\n   * @param  {String} type 类型\n   * @param  {Object} cfg  配置项\n   * @return {Object} coordController 坐标系的管理器\n   */\n\n\n  _proto.coord = function coord(type, cfg) {\n    var coordController = this.get('coordController');\n    coordController.reset({\n      type: type,\n      cfg: cfg\n    });\n    return coordController;\n  };\n  /**\n   * 当父元素边框发生改变时坐标系需要重新调整\n   * @protected\n   */\n\n\n  _proto.resetCoord = function resetCoord() {\n    this._createCoord();\n  };\n\n  _proto.source = function source(data, scales) {\n    this._initData(data);\n\n    if (scales) {\n      this.scale(scales);\n    }\n\n    this.emit('setdata');\n    return this;\n  };\n\n  _proto.changeData = function changeData(data) {\n    this.emit('beforechangedata');\n\n    this._initData(data);\n\n    this.emit('afterchangedata');\n    this.repaint();\n    return this;\n  };\n\n  _proto._initData = function _initData(data) {\n    var dataView = this.get('dataView');\n\n    if (dataView) {\n      dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));\n      this.set('dataView', null);\n    }\n\n    if (data && data.isDataView) {\n      data.on('change', Util.wrapBehavior(this, '_onViewChange'));\n      this.set('dataView', data);\n      data = data.rows;\n    }\n\n    this.set('data', data);\n  };\n\n  _proto._onViewChange = function _onViewChange() {\n    this.emit('beforechangedata');\n    var dataView = this.get('dataView');\n    var rows = dataView.rows;\n    this.set('data', rows);\n    this.emit('afterchangedata');\n    this.repaint();\n  }; // 初始化各个 view 和绘制辅助元素\n\n\n  _proto.beforeRender = function beforeRender() {\n    var views = this.get('views'); // 如果存在 views 则初始化子 view 的方法\n\n    Util.each(views, function (view) {\n      view.beforeRender();\n    });\n    this.initView();\n  }; // 绘制坐标轴、图例、辅助元素等图表组件\n\n\n  _proto.drawComponents = function drawComponents() {\n    var views = this.get('views'); // 如果存在 views 则初始化子 view 的方法\n\n    Util.each(views, function (view) {\n      view.drawComponents();\n    });\n\n    this._renderAxes();\n\n    this._renderGuides();\n  }; // 绘制图形\n\n\n  _proto.drawCanvas = function drawCanvas(stopDraw) {\n    if (!stopDraw) {\n      var views = this.get('views');\n      var backPlot = this.get('backPlot');\n      backPlot.sort();\n      var canvas = this.get('canvas');\n      var animate = this.get('animate');\n\n      if (animate) {\n        var isUpdate = this.get('isUpdate');\n        Util.each(views, function (view) {\n          Animate.execAnimation(view, isUpdate);\n        });\n        Animate.execAnimation(this, isUpdate);\n      } else {\n        canvas.draw();\n      }\n    }\n  };\n\n  _proto.render = function render(stopDraw) {\n    this.clearInner();\n    this.emit('beforerender');\n    this.beforeRender();\n    this.emit('beforepaint');\n    this.drawComponents();\n    this.paint();\n    this.emit('afterpaint');\n    this.drawCanvas(stopDraw);\n    this.emit('afterrender');\n    this.set('rendered', true);\n    return this;\n  };\n\n  _proto.initView = function initView() {\n    var data = this.get('data') || [];\n    var filteredData = this.execFilter(data);\n    this.set('filteredData', filteredData); // if (!Util.isEmpty(data)) {\n\n    this._createCoord(); // draw geometry 前绘制区域可能会发生改变\n\n\n    this.emit('beforeinitgeoms');\n\n    this._initGeoms();\n\n    this._adjustScale(); // }\n\n  };\n\n  _proto.paint = function paint() {\n    var views = this.get('views'); // 绘制\n\n    Util.each(views, function (view) {\n      view.paint();\n    });\n    var data = this.get('data');\n\n    if (!Util.isEmpty(data)) {\n      this._drawGeoms();\n    } // 如果 view 隐藏了，隐藏所有的图形和坐标轴\n\n\n    if (!this.get('visible')) {\n      this.changeVisible(false, true); // 隐藏所有的图形，但是不绘制\n    }\n  };\n\n  _proto.changeVisible = function changeVisible(visible, stopDraw) {\n    var geoms = this.get('geoms');\n    Util.each(geoms, function (geom) {\n      // if (geom.get('visible')) { // geom 隐藏时不受\n      geom.changeVisible(visible, true); // }\n    });\n    this.get('axisController') && this.get('axisController').changeVisible(visible);\n    this.get('guideController') && this.get('guideController').changeVisible(visible);\n\n    if (!stopDraw) {\n      var canvas = this.get('canvas');\n      canvas.draw();\n    }\n  };\n\n  _proto.repaint = function repaint() {\n    this.set('isUpdate', true);\n    this.clearInner();\n    this.render();\n  };\n\n  _proto.destroy = function destroy() {\n    this._clearEvents();\n\n    var dataView = this.get('dataView');\n    dataView && dataView.off('change', Util.getWrapBehavior(this, '_onViewChange'));\n    this.clear();\n\n    _Base.prototype.destroy.call(this);\n  };\n\n  return View;\n}(Base);\n\nmodule.exports = View;\n\n/***/ }),\n/* 292 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar isNil = __webpack_require__(5);\n\nvar isArray = __webpack_require__(4);\n\nvar each = __webpack_require__(2);\n\nvar Base = __webpack_require__(29);\n\nvar Position =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Position, _Base);\n\n  function Position(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['x', 'y'];\n    _this.type = 'position';\n    return _this;\n  }\n\n  var _proto = Position.prototype;\n\n  _proto.mapping = function mapping(x, y) {\n    var scales = this.scales;\n    var coord = this.coord;\n    var scaleX = scales[0];\n    var scaleY = scales[1];\n    var rstX;\n    var rstY;\n    var obj;\n\n    if (isNil(x) || isNil(y)) {\n      return [];\n    }\n\n    if (isArray(y) && isArray(x)) {\n      rstX = [];\n      rstY = [];\n\n      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i++, j++) {\n        obj = coord.convertPoint({\n          x: scaleX.scale(x[i]),\n          y: scaleY.scale(y[j])\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      x = scaleX.scale(x);\n      rstY = [];\n      each(y, function (yVal) {\n        yVal = scaleY.scale(yVal);\n        obj = coord.convertPoint({\n          x: x,\n          y: yVal\n        });\n\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n\n        rstY.push(obj.y);\n      });\n    } else if (isArray(x)) {\n      y = scaleY.scale(y);\n      rstX = [];\n      each(x, function (xVal) {\n        xVal = scaleX.scale(xVal);\n        obj = coord.convertPoint({\n          x: xVal,\n          y: y\n        });\n\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n\n        rstX.push(obj.x);\n      });\n    } else {\n      x = scaleX.scale(x);\n      y = scaleY.scale(y);\n      var point = coord.convertPoint({\n        x: x,\n        y: y\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n\n    return [rstX, rstY];\n  };\n\n  return Position;\n}(Base);\n\nmodule.exports = Position;\n\n/***/ }),\n/* 293 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar isString = __webpack_require__(10);\n\nvar ColorUtil = __webpack_require__(149);\n\nvar Base = __webpack_require__(29);\n\nvar Color =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Color, _Base);\n\n  function Color(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['color'];\n    _this.type = 'color';\n    _this.gradient = null;\n\n    if (isString(_this.values)) {\n      _this.linear = true;\n    }\n\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  var _proto = Color.prototype;\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var gradient = this.gradient;\n\n    if (!gradient) {\n      var values = this.values;\n      gradient = ColorUtil.gradient(values);\n      this.gradient = gradient;\n    }\n\n    return gradient(percent);\n  };\n\n  return Color;\n}(Base);\n\nmodule.exports = Color;\n\n/***/ }),\n/* 294 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(29);\n\nvar Shape =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Shape, _Base);\n\n  function Shape(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['shape'];\n    _this.type = 'shape';\n    _this.gradient = null;\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  var _proto = Shape.prototype;\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var values = this.values;\n    var index = Math.round((values.length - 1) * percent);\n    return values[index];\n  };\n\n  return Shape;\n}(Base);\n\nmodule.exports = Shape;\n\n/***/ }),\n/* 295 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(29);\n\nvar Size =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Size, _Base);\n\n  function Size(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['size'];\n    _this.type = 'size';\n    _this.gradient = null;\n    return _this;\n  }\n\n  return Size;\n}(Base);\n\nmodule.exports = Size;\n\n/***/ }),\n/* 296 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(29);\n\nvar Opacity =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Opacity, _Base);\n\n  function Opacity(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['opacity'];\n    _this.type = 'opacity';\n    _this.gradient = null;\n    return _this;\n  }\n\n  return Opacity;\n}(Base);\n\nmodule.exports = Opacity;\n\n/***/ }),\n/* 297 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 完整版下使用支持按照某个字段进行分组的 dodge\nvar mix = __webpack_require__(8);\n\nvar Adjust = __webpack_require__(30);\n\nvar Dodge = __webpack_require__(298);\n\nvar Stack = __webpack_require__(299);\n\nvar AdjustMixin = __webpack_require__(150);\n\nvar DodgeMixin = __webpack_require__(300);\n\nvar StackMixin = __webpack_require__(301);\n\nmix(Adjust.prototype, AdjustMixin);\nmix(Dodge.prototype, AdjustMixin, DodgeMixin);\nmix(Stack.prototype, StackMixin);\nAdjust.Jitter = __webpack_require__(302);\nAdjust.Symmetric = __webpack_require__(303);\nAdjust.Dodge = Dodge;\nAdjust.Stack = Stack;\nmodule.exports = Adjust;\n\n/***/ }),\n/* 298 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Adjust = __webpack_require__(30);\n\nvar each = __webpack_require__(2);\n\nvar MARGIN_RATIO = 1 / 2;\nvar DODGE_RATIO = 1 / 2;\n\nvar Dodge =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Dodge, _Adjust);\n\n  function Dodge() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Dodge.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    /**\n     * 调整过程中,2个数据的间距\n     * @type {Number}\n     */\n    this.marginRatio = MARGIN_RATIO;\n    /**\n     * 调整占单位宽度的比例,例如：占2个分类间距的 1/2\n     * @type {Number}\n     */\n\n    this.dodgeRatio = DODGE_RATIO;\n    this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整\n  };\n\n  _proto.getDodgeOffset = function getDodgeOffset(range, index, count) {\n    var self = this;\n    var pre = range.pre;\n    var next = range.next;\n    var tickLength = next - pre;\n    var width = tickLength * self.dodgeRatio / count;\n    var margin = self.marginRatio * width;\n    var offset = 1 / 2 * (tickLength - count * width - (count - 1) * margin) + ((index + 1) * width + index * margin) - 1 / 2 * width - 1 / 2 * tickLength;\n    return (pre + next) / 2 + offset;\n  };\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    var self = this;\n    var count = dataArray.length;\n    var xField = self.xField;\n    each(dataArray, function (data, index) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        var obj = data[i];\n        var value = obj[xField];\n        var range = {\n          pre: value - 0.5,\n          next: value + 0.5\n        };\n        var dodgeValue = self.getDodgeOffset(range, index, count);\n        obj[xField] = dodgeValue;\n      }\n    });\n  };\n\n  return Dodge;\n}(Adjust);\n\nAdjust.Dodge = Dodge;\nmodule.exports = Dodge;\n\n/***/ }),\n/* 299 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar isArray = __webpack_require__(4);\n\nvar isNil = __webpack_require__(5);\n\nvar Adjust = __webpack_require__(30);\n\nvar Stack =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Stack, _Adjust);\n\n  function Stack() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Stack.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.xField = null; // 调整对应的 x 方向对应的字段名称\n\n    this.yField = null; // 调整对应的 y 方向对应的字段名称\n  };\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    this.processStack(dataArray);\n  };\n\n  _proto.processStack = function processStack(dataArray) {\n    var self = this;\n    var xField = self.xField;\n    var yField = self.yField;\n    var count = dataArray.length;\n    var stackCache = {\n      positive: {},\n      negative: {}\n    }; // 层叠顺序翻转\n\n    if (self.reverseOrder) {\n      dataArray = dataArray.slice(0).reverse();\n    }\n\n    for (var i = 0; i < count; i++) {\n      var data = dataArray[i];\n\n      for (var j = 0, len = data.length; j < len; j++) {\n        var item = data[j];\n        var x = item[xField] || 0;\n        var y = item[yField];\n        var xkey = x.toString();\n        y = isArray(y) ? y[1] : y;\n\n        if (!isNil(y)) {\n          var direction = y >= 0 ? 'positive' : 'negative';\n\n          if (!stackCache[direction][xkey]) {\n            stackCache[direction][xkey] = 0;\n          }\n\n          item[yField] = [stackCache[direction][xkey], y + stackCache[direction][xkey]];\n          stackCache[direction][xkey] += y;\n        }\n      }\n    }\n  };\n\n  return Stack;\n}(Adjust);\n\nAdjust.Stack = Stack;\nmodule.exports = Stack;\n\n/***/ }),\n/* 300 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ArrayUtil = {\n  merge: __webpack_require__(42),\n  values: __webpack_require__(64)\n};\n\nvar group = __webpack_require__(144);\n\nvar each = __webpack_require__(2);\n\nmodule.exports = {\n  /**\n   * @protected\n   * @override\n   */\n  processAdjust: function processAdjust(dataArray) {\n    var self = this;\n    var mergeData = ArrayUtil.merge(dataArray);\n    var dodgeDim = self.dodgeBy;\n    var adjDataArray = dataArray;\n\n    if (dodgeDim) {\n      // 如果指定了分组dim的字段\n      adjDataArray = group(mergeData, dodgeDim);\n    }\n\n    self.cacheMap = {};\n    self.adjDataArray = adjDataArray;\n    self.mergeData = mergeData;\n    self.adjustData(adjDataArray, mergeData);\n    self.adjDataArray = null;\n    self.mergeData = null;\n  },\n  getDistribution: function getDistribution(dim) {\n    var self = this;\n    var dataArray = self.adjDataArray;\n    var cacheMap = self.cacheMap;\n    var map = cacheMap[dim];\n\n    if (!map) {\n      map = {};\n      each(dataArray, function (data, index) {\n        var values = ArrayUtil.values(data, dim);\n\n        if (!values.length) {\n          values.push(0);\n        }\n\n        each(values, function (val) {\n          if (!map[val]) {\n            map[val] = [];\n          }\n\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n\n    return map;\n  },\n  adjustDim: function adjustDim(dim, values, data, frameCount, frameIndex) {\n    var self = this;\n    var map = self.getDistribution(dim);\n    var groupData = self.groupData(data, dim); // 根据值分组\n\n    each(groupData, function (group, key) {\n      key = parseFloat(key);\n      var range;\n\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1\n        };\n      } else {\n        range = self.getAdjustRange(dim, key, values);\n      }\n\n      each(group, function (record) {\n        var value = record[dim];\n        var valueArr = map[value];\n        var valIndex = valueArr.indexOf(frameIndex);\n        record[dim] = self.getDodgeOffset(range, valIndex, valueArr.length);\n      });\n    });\n  }\n};\n\n/***/ }),\n/* 301 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  _initDefaultCfg: function _initDefaultCfg() {\n    this.xField = null; // 调整对应的 x 方向对应的字段名称\n\n    this.yField = null; // 调整对应的 y 方向对应的字段名称\n\n    this.height = null; // 仅有一个维度调整时，总的高度\n\n    this.size = 10; // 单个点的大小\n\n    this.reverseOrder = false; // 是否反序进行层叠\n\n    this.adjustNames = ['y']; // Only support stack y\n  },\n  processOneDimStack: function processOneDimStack(dataArray) {\n    var self = this;\n    var xField = self.xField;\n    var yField = self.yField || 'y';\n    var height = self.height;\n    var stackY = {}; // 如果层叠的顺序翻转\n\n    if (self.reverseOrder) {\n      dataArray = dataArray.slice(0).reverse();\n    }\n\n    for (var i = 0, len = dataArray.length; i < len; i++) {\n      var data = dataArray[i]; // cates\n\n      for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n        var item = data[j];\n        var size = item.size || self.size;\n        var stackHeight = size * 2 / height;\n        var x = item[xField];\n\n        if (!stackY[x]) {\n          stackY[x] = stackHeight / 2;\n        }\n\n        item[yField] = stackY[x];\n        stackY[x] += stackHeight;\n      }\n    }\n  },\n  processAdjust: function processAdjust(dataArray) {\n    if (this.yField) {\n      this.processStack(dataArray);\n    } else {\n      this.processOneDimStack(dataArray);\n    }\n  }\n};\n\n/***/ }),\n/* 302 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar each = __webpack_require__(2);\n\nvar mix = __webpack_require__(8);\n\nvar ArrayUtil = {\n  merge: __webpack_require__(42)\n};\n\nvar Adjust = __webpack_require__(30);\n\nvar AdjustMixin = __webpack_require__(150);\n\nvar Jitter =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Jitter, _Adjust);\n\n  function Jitter() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Jitter.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.xField = null; // 调整对应的 x 方向对应的字段名称\n\n    this.yField = null; // 调整对应的 y 方向对应的字段名称\n\n    this.adjustNames = ['x', 'y']; // 指x,y\n\n    this.groupFields = null; // 参与分组的数据维度\n  };\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    var self = this;\n    var mergeData = ArrayUtil.merge(dataArray);\n    self.adjDataArray = dataArray;\n    self.mergeData = mergeData;\n    self.adjustData(dataArray, mergeData);\n    self.adjFrames = null;\n    self.mergeData = null;\n  };\n\n  _proto.getAdjustOffset = function getAdjustOffset(pre, next) {\n    var r = Math.random(); // 随机位置，均匀分布\n\n    var avg = next - pre; // * length\n\n    var append = avg * 0.05;\n    return pre + append + avg * 0.9 * r;\n  }; // adjust group data\n\n\n  _proto._adjustGroup = function _adjustGroup(group, dim, key, values) {\n    var self = this;\n    var range = self.getAdjustRange(dim, key, values);\n    each(group, function (record) {\n      record[dim] = self.getAdjustOffset(range.pre, range.next); // 获取调整的位置\n    });\n  };\n\n  _proto.adjustDim = function adjustDim(dim, values, data) {\n    var self = this;\n    var groupData = self.groupData(data, dim);\n    each(groupData, function (group, key) {\n      key = parseFloat(key);\n\n      self._adjustGroup(group, dim, key, values);\n    });\n  };\n\n  return Jitter;\n}(Adjust);\n\nmix(Jitter.prototype, AdjustMixin);\nAdjust.Jitter = Jitter;\nmodule.exports = Jitter;\n\n/***/ }),\n/* 303 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar each = __webpack_require__(2);\n\nvar maxBy = __webpack_require__(132);\n\nvar isArray = __webpack_require__(4);\n\nvar ArrayUtil = {\n  merge: __webpack_require__(42)\n};\n\nvar Adjust = __webpack_require__(30);\n\nvar Symmetric =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Symmetric, _Adjust);\n\n  function Symmetric() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Symmetric.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.xField = null; // 调整对应的 x 方向对应的字段名称\n\n    this.yField = null; // 调整对应的 y 方向对应的字段名称\n\n    this.cacheMax = null; // 缓存的最大值\n\n    this.adjustNames = ['y']; // Only support stack y\n\n    this.groupFields = null; // 参与分组的数据维度\n  }; // 获取最大的y值\n\n\n  _proto._getMax = function _getMax(dim) {\n    var self = this;\n    var mergeData = self.mergeData;\n    var maxRecord = maxBy(mergeData, function (obj) {\n      var value = obj[dim];\n\n      if (isArray(value)) {\n        return Math.max.apply(null, value);\n      }\n\n      return value;\n    });\n    var maxValue = maxRecord[dim];\n    var max = isArray(maxValue) ? Math.max.apply(null, maxValue) : maxValue;\n    return max;\n  }; // 获取每个字段最大的值\n\n\n  _proto._getXValuesMax = function _getXValuesMax() {\n    var self = this;\n    var yField = self.yField;\n    var xField = self.xField;\n    var cache = {};\n    var mergeData = self.mergeData;\n    each(mergeData, function (obj) {\n      var xValue = obj[xField];\n      var yValue = obj[yField];\n      var max = isArray(yValue) ? Math.max.apply(null, yValue) : yValue;\n      cache[xValue] = cache[xValue] || 0;\n\n      if (cache[xValue] < max) {\n        cache[xValue] = max;\n      }\n    });\n    return cache;\n  }; // 入口函数\n\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    var self = this;\n    var mergeData = ArrayUtil.merge(dataArray);\n    self.mergeData = mergeData;\n\n    self._processSymmetric(dataArray);\n\n    self.mergeData = null;\n  }; // 处理对称\n\n\n  _proto._processSymmetric = function _processSymmetric(dataArray) {\n    var self = this;\n    var xField = self.xField;\n    var yField = self.yField;\n\n    var max = self._getMax(yField);\n\n    var first = dataArray[0][0];\n    var cache;\n\n    if (first && isArray(first[yField])) {\n      cache = self._getXValuesMax();\n    }\n\n    each(dataArray, function (data) {\n      each(data, function (obj) {\n        var value = obj[yField];\n        var offset;\n\n        if (isArray(value)) {\n          var xValue = obj[xField];\n          var valueMax = cache[xValue];\n          offset = (max - valueMax) / 2;\n          var tmp = [];\n          /* eslint-disable no-loop-func */\n\n          each(value, function (subVal) {\n            // 多个字段\n            tmp.push(offset + subVal);\n          });\n          /* eslint-enable no-loop-func */\n\n          obj[yField] = tmp;\n        } else {\n          offset = (max - value) / 2;\n          obj[yField] = [offset, value + offset];\n        }\n      });\n    });\n  };\n\n  return Symmetric;\n}(Adjust);\n\nAdjust.Symmetric = Symmetric;\nmodule.exports = Symmetric;\n\n/***/ }),\n/* 304 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _html, _tooltip;\n\n/**\n * @fileOverview G2 3.0 dark theme\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar BasicTheme = __webpack_require__(152); // tooltip 相关 dom 的 css 类名\n\n\nvar TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';\nvar LEGEND_CONTAINER_CLASS = 'g2-legend';\nvar DarkTheme = Util.deepMix({}, BasicTheme, {\n  background: {\n    fill: '#1F1F1F',\n    radius: 2\n  },\n  // 容器区域\n  plotBackground: {\n    fill: '#1F1F1F'\n  },\n  // 绘图区域\n  axis: {\n    top: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      line: {\n        stroke: '#737373'\n      },\n      tickLine: {\n        stroke: '#737373'\n      }\n    },\n    bottom: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      line: {\n        stroke: '#737373'\n      },\n      tickLine: {\n        stroke: '#737373'\n      }\n    },\n    left: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#404040'\n        }\n      }\n    },\n    right: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#404040'\n        }\n      }\n    },\n    circle: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      line: {\n        stroke: '#737373'\n      },\n      tickLine: {\n        stroke: '#737373'\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#404040'\n        }\n      }\n    },\n    radius: {\n      label: {\n        textStyle: {\n          fill: '#A6A6A6'\n        }\n      },\n      line: {\n        stroke: '#737373'\n      },\n      tickLine: {\n        stroke: '#737373'\n      },\n      grid: {\n        lineStyle: {\n          stroke: '#404040'\n        }\n      }\n    },\n    helix: {\n      line: {\n        stroke: '#737373'\n      },\n      tickLine: {\n        stroke: '#737373'\n      }\n    }\n  },\n  label: {\n    textStyle: {\n      fill: '#A6A6A6'\n    }\n  },\n  legend: {\n    right: {\n      textStyle: {\n        fill: '#737373'\n      },\n      unCheckColor: '#bfbfbf'\n    },\n    left: {\n      textStyle: {\n        fill: '#737373'\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    top: {\n      textStyle: {\n        fill: '#737373'\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    bottom: {\n      textStyle: {\n        fill: '#737373'\n      },\n      // 图例项文本的样式\n      unCheckColor: '#bfbfbf'\n    },\n    html: (_html = {}, _html[\"\" + LEGEND_CONTAINER_CLASS] = {\n      color: '#D9D9D9'\n    }, _html),\n    gradient: {\n      textStyle: {\n        fill: '#D9D9D9'\n      },\n      lineStyle: {\n        stroke: '#404040'\n      }\n    }\n  },\n  tooltip: (_tooltip = {}, _tooltip[\"\" + TOOLTIP_CONTAINER_CLASS] = {\n    color: '#D9D9D9',\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    boxShadow: '0px 0px 2px #000'\n  }, _tooltip),\n  tooltipCrosshairsRect: {\n    type: 'rect',\n    rectStyle: {\n      fill: '#fff',\n      opacity: 0.1\n    }\n  },\n  // tooltip 辅助背景框样式\n  tooltipCrosshairsLine: {\n    lineStyle: {\n      stroke: 'rgba(255, 255, 255, 0.45)'\n    }\n  },\n  guide: {\n    line: {\n      text: {\n        style: {\n          fill: '#A6A6A6'\n        }\n      }\n    },\n    text: {\n      style: {\n        fill: '#A6A6A6'\n      }\n    },\n    region: {\n      // TODO\n      style: {\n        lineWidth: 0,\n        // 辅助框的边框宽度\n        fill: '#000',\n        // 辅助框填充的颜色\n        fillOpacity: 0.04 // 辅助框的背景透明度\n        // 辅助框的图形样式属性\n\n      }\n    }\n  }\n});\nmodule.exports = DarkTheme;\n\n/***/ }),\n/* 305 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar GeomLabels = __webpack_require__(65);\n\nvar PolarLabels = __webpack_require__(164);\n\nvar PieLabels = __webpack_require__(335);\n\nvar IntervalLabels = __webpack_require__(336);\n\nvar Labels = {\n  getLabelsClass: function getLabelsClass(coordType, type) {\n    var rst = GeomLabels;\n\n    if (coordType === 'polar') {\n      rst = PolarLabels;\n    } else if (coordType === 'theta') {\n      // pie chart\n      rst = PieLabels;\n    } else if (type === 'interval' || type === 'polygon') {\n      // bar\n      rst = IntervalLabels;\n    }\n\n    return rst;\n  }\n};\nmodule.exports = Labels;\n\n/***/ }),\n/* 306 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Axis = __webpack_require__(31);\n\nAxis.Base = Axis;\nAxis.Circle = __webpack_require__(310);\nAxis.Grid = __webpack_require__(153);\nAxis.Helix = __webpack_require__(311);\nAxis.Line = __webpack_require__(312);\nAxis.Polyline = __webpack_require__(313);\nmodule.exports = Axis;\n\n/***/ }),\n/* 307 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Greedy = __webpack_require__(155);\n/*\n   *  根据如下规则尝试放置label\n   *                5\n   *        ------------------\n   *        |    1   |   0   |\n   *    8   —————————4————————   7\n   *        |    2   |   3   |\n   *        ——————————————————\n   *                 6\n   */\n\n\nfunction adjustLabelPosition(label, x, y, index) {\n  var bbox = label.getBBox();\n  var width = bbox.width;\n  var height = bbox.height;\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n\n  switch (index) {\n    case 0:\n      attrs.y -= height / 2;\n      attrs.textAlign = 'left';\n      break;\n\n    case 1:\n      attrs.y -= height / 2;\n      attrs.textAlign = 'right';\n      break;\n\n    case 2:\n      attrs.y += height / 2;\n      attrs.textAlign = 'right';\n      break;\n\n    case 3:\n      attrs.y += height / 2;\n      attrs.textAlign = 'left';\n      break;\n\n    case 5:\n      attrs.y -= height / 2;\n      break;\n\n    case 6:\n      attrs.y += height / 2;\n      break;\n\n    case 7:\n      attrs.x += width / 2;\n      attrs.textAlign = 'left';\n      break;\n\n    case 8:\n      attrs.x -= width / 2;\n      attrs.textAlign = 'right';\n      break;\n\n    default:\n      break;\n  }\n\n  label.attr(attrs);\n  return label.getBBox();\n}\n\nmodule.exports = function (labels) {\n  var greedy = new Greedy();\n  var toBeRemoved = [];\n  var bbox, label, x, y, canFill;\n\n  for (var i = 0; i < labels.length; i++) {\n    label = labels[i];\n    x = label.attr('x');\n    y = label.attr('y');\n    canFill = false;\n\n    for (var _i = 0; _i < 8; _i++) {\n      bbox = adjustLabelPosition(label, x, y, _i);\n\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n\n    if (!canFill) {\n      toBeRemoved.push(label);\n    }\n  }\n\n  for (var _i2 = 0; _i2 < toBeRemoved.length; _i2++) {\n    toBeRemoved[_i2].remove();\n  }\n\n  return canFill;\n};\n\n/***/ }),\n/* 308 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Greedy = __webpack_require__(155);\n\nvar MAX_TIMES = 20;\n\nfunction spiralFill(label, greedy) {\n  var dt = -1;\n  var x = label.attr('x'),\n      y = label.attr('y');\n  var bbox = label.getBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy,\n      t = -dt,\n      dx = 0,\n      dy = 0;\n\n  var f = function f(t) {\n    return [(t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n\n  var canFill = false,\n      times = 0;\n\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < MAX_TIMES) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n    times++;\n\n    if (greedy.hasGap(label.getBBox())) {\n      greedy.fillGap(bbox);\n      canFill = true;\n      break;\n    }\n  }\n\n  return canFill;\n}\n\nmodule.exports = function (labels) {\n  var label;\n  var greedy = new Greedy();\n  var toBeRemoved = [];\n\n  for (var i = 0; i < labels.length; i++) {\n    label = labels[i];\n\n    if (!spiralFill(label, greedy)) {\n      toBeRemoved.push(label);\n    }\n  }\n\n  for (var _i = 0; _i < toBeRemoved.length; _i++) {\n    toBeRemoved[_i].remove();\n  }\n};\n\n/***/ }),\n/* 309 */\n/***/ (function(module, exports) {\n\nmodule.exports = function bboxAdjust(labels, shapes) {\n  var labelBBox, shapeBBox;\n  var toBeRemoved = [];\n\n  for (var i = 0; i < labels.length; i++) {\n    labelBBox = labels[i].getBBox();\n    shapeBBox = shapes[i].getBBox();\n\n    if (labelBBox.width > shapeBBox.width || labelBBox.height > shapeBBox.height) {\n      toBeRemoved.push(labels[i]);\n    } else if (labelBBox.width * labelBBox.height > shapeBBox.width * shapeBBox.height) {\n      toBeRemoved.push(labels[i]);\n    }\n  }\n\n  for (var _i = 0; _i < toBeRemoved.length; _i++) {\n    toBeRemoved[_i].remove();\n  }\n};\n\n/***/ }),\n/* 310 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Base = __webpack_require__(31);\n\nvar vec2 = Util.MatrixUtil.vec2;\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Circle, _Base);\n\n  function Circle() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Circle.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 坐标轴的类型\n       * @type {String}\n       */\n      type: 'circle',\n\n      /**\n       * 指定刻度之间的间距\n       * @type {Number}\n       */\n      tickInterval: null,\n\n      /**\n       * 开始弧度\n       * @type {Number}\n       */\n      startAngle: -Math.PI / 2,\n\n      /**\n       * 结束弧度\n       * @type {Number}\n       */\n      endAngle: Math.PI * 3 / 2,\n      line: {\n        // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n        lineWidth: 1,\n        stroke: '#C0D0E0'\n      },\n      tickLine: {\n        // @type {Attrs} 标注坐标线的图形属性\n        lineWidth: 1,\n        stroke: '#C0D0E0',\n        length: 5\n      },\n\n      /**\n       * 默认文本距离轴线的距离\n       * @type {Number}\n       */\n      _labelOffset: 5\n    });\n  };\n\n  _proto.parseTick = function parseTick(tick, index, length) {\n    return {\n      text: tick,\n      value: index / length\n    };\n  };\n\n  _proto._getCirclePoint = function _getCirclePoint(angle, radius) {\n    var self = this;\n    var center = self.get('center');\n    radius = radius || self.get('radius');\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  _proto.getTickPoint = function getTickPoint(value) {\n    var self = this;\n    var startAngle = self.get('startAngle');\n    var endAngle = self.get('endAngle');\n    var angle = startAngle + (endAngle - startAngle) * value;\n    return self._getCirclePoint(angle);\n  };\n\n  _proto.getSideVector = function getSideVector(offset, point) {\n    var self = this;\n    var center = self.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n\n    if (!Util.isNil(offset)) {\n      var vecLen = vec2.length(vector);\n      vec2.scale(vector, vector, offset / vecLen);\n    }\n\n    return vector;\n  };\n\n  _proto.getSidePoint = function getSidePoint(point, offset) {\n    var self = this;\n    var vector = self.getSideVector(offset, point);\n    return {\n      x: point.x + vector[0],\n      y: point.y + vector[1]\n    };\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, length) {\n    var self = this;\n    var tickLine = self.get('tickLine');\n    length = length ? length : tickLine.length;\n    return self.getSidePoint(start, length);\n  };\n\n  _proto.getTextAnchor = function getTextAnchor(vector) {\n    var align;\n\n    if (Util.snapEqual(vector[0], 0)) {\n      align = 'center';\n    } else if (vector[0] > 0) {\n      align = 'left';\n    } else if (vector[0] < 0) {\n      align = 'right';\n    }\n\n    return align;\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var center = self.get('center');\n    var x = center.x;\n    var y = center.y;\n    var rx = self.get('radius');\n    var ry = rx;\n    var startAngle = self.get('startAngle');\n    var endAngle = self.get('endAngle');\n    var inner = self.get('inner');\n    var path = [];\n\n    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n      path = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\n    } else {\n      var startPoint = self._getCirclePoint(startAngle);\n\n      var endPoint = self._getCirclePoint(endAngle);\n\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n\n      if (!inner) {\n        path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];\n      } else {\n        var innerStartVector = self.getSideVector(inner * rx, startPoint);\n        var innerEndVector = self.getSideVector(inner * rx, endPoint);\n        var innerStartPoint = {\n          x: innerStartVector[0] + x,\n          y: innerStartVector[1] + y\n        };\n        var innerEndPoint = {\n          x: innerEndVector[0] + x,\n          y: innerEndVector[1] + y\n        };\n        path = [['M', innerStartPoint.x, innerStartPoint.y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', innerEndPoint.x, innerEndPoint.y], ['A', rx * inner, ry * inner, 0, large, Math.abs(sweep - 1), innerStartPoint.x, innerStartPoint.y]];\n      }\n    }\n\n    return path;\n  };\n\n  _proto.addLabel = function addLabel(tick, point, index) {\n    var self = this;\n    var offset = self.get('label').offset || self.get('_labelOffset') || 0.001;\n    point = self.getSidePoint(point, offset);\n\n    _Base.prototype.addLabel.call(this, tick, point, index);\n  };\n\n  _proto.autoRotateLabels = function autoRotateLabels() {\n    var self = this;\n    var ticks = self.get('ticks');\n    var labelRenderer = self.get('labelRenderer');\n\n    if (labelRenderer && ticks.length > 12) {\n      // 小于12个文本时文本不旋转\n      var radius = self.get('radius');\n      var startAngle = self.get('startAngle');\n      var endAngle = self.get('endAngle');\n      var totalAngle = endAngle - startAngle;\n      var avgAngle = totalAngle / (ticks.length - 1);\n      var avgWidth = Math.sin(avgAngle / 2) * radius * 2;\n      var maxLength = self.getMaxLabelWidth(labelRenderer);\n      Util.each(labelRenderer.get('group').get('children'), function (label, index) {\n        var tick = ticks[index];\n        var angle = tick.value * totalAngle + startAngle;\n        var mode = angle % (Math.PI * 2);\n\n        if (maxLength < avgWidth) {\n          // 文本的最大宽度大于\n          if (mode <= 0) {\n            angle = angle + Math.PI;\n          }\n\n          if (mode > Math.PI) {\n            angle = angle - Math.PI;\n          }\n\n          angle = angle - Math.PI / 2;\n          label.attr('textAlign', 'center');\n        } else {\n          if (mode > Math.PI / 2) {\n            angle = angle - Math.PI;\n          } else if (mode < Math.PI / 2 * -1) {\n            angle = angle + Math.PI;\n          }\n        }\n\n        label.rotateAtStart(angle);\n      });\n    }\n  };\n\n  return Circle;\n}(Base);\n\nmodule.exports = Circle;\n\n/***/ }),\n/* 311 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Base = __webpack_require__(31);\n\nvar MatrixUtil = Util.MatrixUtil,\n    PathUtil = Util.PathUtil;\nvar vec2 = MatrixUtil.vec2;\n\nvar Helix =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Helix, _Base);\n\n  function Helix() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Helix.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      inner: 0,\n      type: 'helix',\n      line: {\n        // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n        lineWidth: 1,\n        stroke: '#C0D0E0'\n      },\n      tickLine: {\n        // @type {Attrs} 标注坐标线的图形属性\n        lineWidth: 1,\n        stroke: '#C0D0E0',\n        length: 5\n      },\n      startAngle: 1.25 * Math.PI,\n      endAngle: 7.25 * Math.PI,\n      // 螺旋系数\n      a: 0,\n      // 画布中心坐标\n      center: null,\n      // 坐标轴绘制起点\n      axisStart: null,\n      // 坐标轴的n个坐标点\n      crp: []\n    });\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var crp = self.get('crp');\n    var axisStart = self.get('axisStart');\n    var path = PathUtil.catmullRomToBezier(crp);\n    path.unshift(['M', axisStart.x, axisStart.y]);\n    return path;\n  };\n\n  _proto.getTickPoint = function getTickPoint(value) {\n    var self = this;\n    var startAngle = self.get('startAngle');\n    var endAngle = self.get('endAngle');\n    var angle = startAngle + (endAngle - startAngle) * value;\n    return self._getHelixPoint(angle);\n  };\n\n  _proto._getHelixPoint = function _getHelixPoint(angle) {\n    var self = this;\n    var center = self.get('center');\n    var a = self.get('a'); // 螺线系数\n\n    var radius = a * angle + self.get('inner'); // 螺线方程\n\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  _proto.getSideVector = function getSideVector(offset, point) {\n    var self = this;\n    var center = self.get('center');\n    var vector = [point.x - center.x, point.y - center.y];\n\n    if (offset) {\n      var vecLen = vec2.length(vector);\n      vec2.scale(vector, vector, offset / vecLen);\n    }\n\n    return vector;\n  };\n\n  _proto.getSidePoint = function getSidePoint(point, offset) {\n    var self = this;\n    var vector = self.getSideVector(offset, point);\n    return {\n      x: point.x + vector[0],\n      y: point.y + vector[1]\n    };\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, length) {\n    var self = this;\n    var tickLine = self.get('tickLine');\n    length = length ? length : tickLine.length;\n    return self.getSidePoint(start, length);\n  };\n\n  return Helix;\n}(Base);\n\nmodule.exports = Helix;\n\n/***/ }),\n/* 312 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(31);\n\nvar Util = __webpack_require__(3);\n\nvar MatrixUtil = Util.MatrixUtil;\nvar vec2 = MatrixUtil.vec2;\n\nvar Line =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Line, _Base);\n\n  function Line() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      x: null,\n      // @type {Number} 距离初始位置的x轴偏移量,仅对于左侧、右侧的纵向坐标有效\n      y: null,\n      // @type {Number} 距离初始位置的y轴偏移量，仅对顶部、底部的横向坐标轴有效\n      line: {\n        // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n        lineWidth: 1,\n        stroke: '#C0D0E0'\n      },\n      tickLine: {\n        // @type {Attrs} 标注坐标线的图形属性\n        lineWidth: 1,\n        stroke: '#C0D0E0',\n        length: 5\n      },\n      isVertical: false,\n      start: null,\n      // @type {Object} 起点\n      end: null // @type {Object} 终点\n\n    });\n  };\n\n  _proto._getAvgLabelLength = function _getAvgLabelLength(labelRenderer) {\n    var labels = labelRenderer.get('group').get('children');\n    return labels[1].attr('x') - labels[0].attr('x');\n  };\n\n  _proto._getAvgLabelHeightSpace = function _getAvgLabelHeightSpace(labelRenderer) {\n    var labels = labelRenderer.get('group').get('children');\n    return labels[1].attr('y') - labels[0].attr('y');\n  };\n  /**\n   * 获取距离坐标轴的向量\n   * @override\n   * @param  {Number} offset 偏移值\n   * @return {Array}        返回二维向量\n   */\n\n\n  _proto.getSideVector = function getSideVector(offset) {\n    var self = this;\n    var isVertical = self.get('isVertical');\n    var factor = self.get('factor'); // if (Util.isArray(offset)) {\n    //   return offset.map(value => value * factor);\n    // }\n\n    if (!Util.isNumber(offset)) {\n      return [0, 0];\n    }\n\n    var start = self.get('start');\n    var end = self.get('end');\n    var axisVector = self.getAxisVector();\n    var normal = vec2.normalize([], axisVector);\n    var direction = false;\n\n    if (isVertical && start.y < end.y || !isVertical && start.x > end.x) {\n      direction = true;\n    }\n\n    var verticalVector = vec2.vertical([], normal, direction);\n    return vec2.scale([], verticalVector, offset * factor);\n  };\n\n  _proto.getAxisVector = function getAxisVector() {\n    var start = this.get('start');\n    var end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, value) {\n    var self = this;\n    var offsetVector = self.getSideVector(value);\n    return {\n      x: start.x + offsetVector[0],\n      y: start.y + offsetVector[1]\n    };\n  };\n\n  _proto.getTickPoint = function getTickPoint(tickValue) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var rangeX = end.x - start.x;\n    var rangeY = end.y - start.y;\n    return {\n      x: start.x + rangeX * tickValue,\n      y: start.y + rangeY * tickValue\n    };\n  };\n\n  _proto.renderTitle = function renderTitle() {\n    var self = this;\n    var title = self.get('title');\n    var offsetPoint = self.getTickPoint(0.5);\n    var titleOffset = title.offset;\n\n    if (Util.isNil(titleOffset)) {\n      // 没有指定 offset 则自动计算\n      titleOffset = 20;\n      var labelsGroup = self.get('labelsGroup');\n\n      if (labelsGroup) {\n        var labelLength = self.getMaxLabelWidth(labelsGroup);\n        var labelOffset = self.get('label').offset || self.get('_labelOffset');\n        titleOffset += labelLength + labelOffset;\n      }\n    }\n\n    var textStyle = title.textStyle;\n    var cfg = Util.mix({}, textStyle);\n\n    if (title.text) {\n      var vector = self.getAxisVector(); // 坐标轴方向的向量\n\n      if (title.autoRotate && Util.isNil(textStyle.rotate)) {\n        // 自动旋转并且用户没有指定标题的旋转角度\n        var angle = 0;\n\n        if (!Util.snapEqual(vector[1], 0)) {\n          // 所有水平坐标轴，文本不转置\n          var v1 = [1, 0];\n          var v2 = [vector[0], vector[1]];\n          angle = vec2.angleTo(v2, v1, true);\n        }\n\n        cfg.rotate = angle * (180 / Math.PI);\n      } else if (!Util.isNil(textStyle.rotate)) {\n        // 用户设置了旋转角度就以用户设置的为准\n        cfg.rotate = textStyle.rotate / 180 * Math.PI; // 将角度转换为弧度\n      }\n\n      var sideVector = self.getSideVector(titleOffset);\n      var point;\n      var position = title.position;\n\n      if (position === 'start') {\n        point = {\n          x: this.get('start').x + sideVector[0],\n          y: this.get('start').y + sideVector[1]\n        };\n      } else if (position === 'end') {\n        point = {\n          x: this.get('end').x + sideVector[0],\n          y: this.get('end').y + sideVector[1]\n        };\n      } else {\n        point = {\n          x: offsetPoint.x + sideVector[0],\n          y: offsetPoint.y + sideVector[1]\n        };\n      }\n\n      cfg.x = point.x;\n      cfg.y = point.y;\n      cfg.text = title.text;\n      var group = self.get('group');\n      var titleShape = group.addShape('Text', {\n        zIndex: 2,\n        attrs: cfg\n      });\n      titleShape.name = 'axis-title';\n      self.get('appendInfo') && titleShape.setSilent('appendInfo', self.get('appendInfo'));\n    }\n  };\n\n  _proto.autoRotateLabels = function autoRotateLabels() {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var title = self.get('title');\n\n    if (labelRenderer) {\n      var labelGroup = labelRenderer.get('group');\n      var labels = labelGroup.get('children');\n      var offset = self.get('label').offset;\n      var append = 12;\n      var titleOffset = title ? title.offset : 48;\n\n      if (titleOffset < 0) {\n        // 如果是负的的话就不旋转\n        return;\n      }\n\n      var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景\n\n      var angle;\n      var maxWidth;\n\n      if (Util.snapEqual(vector[0], 0) && title && title.text) {\n        // 坐标轴垂直，由于不知道边距，只能防止跟title重合，如果title不存在，则不自动旋转\n        maxWidth = self.getMaxLabelWidth(labelRenderer);\n\n        if (maxWidth > titleOffset - offset - append) {\n          angle = Math.acos((titleOffset - offset - append) / maxWidth) * -1;\n        }\n      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n        // 坐标轴水平，不考虑边距，根据最长的和平均值进行翻转\n        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n        maxWidth = self.getMaxLabelWidth(labelRenderer);\n\n        if (maxWidth > avgWidth) {\n          angle = Math.asin((titleOffset - offset - append) * 1.25 / maxWidth);\n        }\n      }\n\n      if (angle) {\n        var factor = self.get('factor');\n        Util.each(labels, function (label) {\n          label.rotateAtStart(angle);\n\n          if (Util.snapEqual(vector[1], 0)) {\n            if (factor > 0) {\n              label.attr('textAlign', 'left');\n            } else {\n              label.attr('textAlign', 'right');\n            }\n          }\n        });\n      }\n    }\n  };\n\n  _proto.autoHideLabels = function autoHideLabels() {\n    var self = this;\n    var labelRenderer = self.get('labelRenderer');\n    var labelSpace;\n    var tickStep;\n    var append = 8;\n\n    if (labelRenderer) {\n      var labelGroup = labelRenderer.get('group');\n      var labels = labelGroup.get('children');\n      var vector = self.getAxisVector(); // 坐标轴的向量，仅处理水平或者垂直的场景\n\n      if (labels.length < 2) {\n        return;\n      }\n\n      if (Util.snapEqual(vector[0], 0)) {\n        // 坐标轴垂直\n        var maxHeight = self.getMaxLabelHeight(labelRenderer) + append;\n        var avgHeight = Math.abs(self._getAvgLabelHeightSpace(labelRenderer));\n\n        if (maxHeight > avgHeight) {\n          labelSpace = maxHeight;\n          tickStep = avgHeight;\n        }\n      } else if (Util.snapEqual(vector[1], 0) && labels.length > 1) {\n        // 坐标轴水平\n        var maxWidth = self.getMaxLabelWidth(labelRenderer) + append;\n        var avgWidth = Math.abs(self._getAvgLabelLength(labelRenderer));\n\n        if (maxWidth > avgWidth) {\n          labelSpace = maxWidth;\n          tickStep = avgWidth;\n        }\n      }\n\n      if (labelSpace && tickStep) {\n        var ratio = Math.ceil(labelSpace / tickStep);\n        Util.each(labels, function (label, i) {\n          if (i % ratio !== 0) {\n            label.attr('text', '');\n          }\n        });\n      }\n    }\n  };\n\n  return Line;\n}(Base);\n\nmodule.exports = Line;\n\n/***/ }),\n/* 313 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Base = __webpack_require__(31);\n\nvar MatrixUtil = Util.MatrixUtil,\n    PathUtil = Util.PathUtil;\nvar vec2 = MatrixUtil.vec2;\n\nvar Polyline =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Polyline, _Base);\n\n  function Polyline() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Polyline.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      type: 'polyline'\n    });\n  };\n\n  _proto.getLinePath = function getLinePath() {\n    var self = this;\n    var tickPoints = self.get('tickPoints');\n    var start = self.get('start');\n    var end = self.get('end');\n    var points = [];\n    points.push(start.x);\n    points.push(start.y);\n    Util.each(tickPoints, function (tick) {\n      points.push(tick.x);\n      points.push(tick.y);\n    });\n    points.push(end.x);\n    points.push(end.y);\n    var path = PathUtil.catmullRomToBezier(points);\n    path.unshift(['M', start.x, start.y]);\n    return path;\n  };\n\n  _proto.getTickPoint = function getTickPoint(value, index) {\n    var tickPoints = this.get('tickPoints');\n    return tickPoints[index];\n  };\n\n  _proto.getTickEnd = function getTickEnd(start, value, index) {\n    var self = this;\n    var lineAttrs = self.get('tickLine');\n    var tickLength = value ? value : lineAttrs.length;\n    var offsetVector = self.getSideVector(tickLength, start, index);\n    return {\n      x: start.x + offsetVector[0],\n      y: start.y + offsetVector[1]\n    };\n  };\n\n  _proto.getSideVector = function getSideVector(offset, point, index) {\n    var self = this;\n    var preTickPoint;\n\n    if (index === 0) {\n      preTickPoint = self.get('start');\n\n      if (preTickPoint.x === point.x && preTickPoint.y === point.y) {\n        return [0, 0];\n      }\n    } else {\n      var tickPoints = self.get('tickPoints');\n      preTickPoint = tickPoints[index - 1];\n    }\n\n    var vector = [point.x - preTickPoint.x, point.y - preTickPoint.y];\n    var normal = vec2.normalize([], vector);\n    var verticalVector = vec2.vertical([], normal, false);\n    return vec2.scale([], verticalVector, offset);\n  };\n\n  return Polyline;\n}(Base);\n\nmodule.exports = Polyline;\n\n/***/ }),\n/* 314 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Guide: __webpack_require__(15),\n  Arc: __webpack_require__(315),\n  DataMarker: __webpack_require__(316),\n  DataRegion: __webpack_require__(317),\n  Html: __webpack_require__(318),\n  Image: __webpack_require__(319),\n  Line: __webpack_require__(320),\n  Region: __webpack_require__(321),\n  Text: __webpack_require__(322)\n};\n\n/***/ }),\n/* 315 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar PI = Math.PI;\nvar atan = Math.atan;\n\nfunction calculateAngle(point, center) {\n  var x = point.x - center.x;\n  var y = point.y - center.y;\n  var deg;\n\n  if (y === 0) {\n    if (x < 0) {\n      deg = PI / 2;\n    } else {\n      deg = 270 * PI / 180;\n    }\n  } else if (x >= 0 && y > 0) {\n    deg = PI * 2 - atan(x / y);\n  } else if (x <= 0 && y < 0) {\n    deg = PI - atan(x / y);\n  } else if (x > 0 && y < 0) {\n    deg = PI + atan(-x / y);\n  } else if (x < 0 && y > 0) {\n    deg = atan(x / -y);\n  }\n\n  return deg;\n}\n\nvar Arc =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Arc, _Guide);\n\n  function Arc() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Arc.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 辅助元素类型\n       * @type {String}\n       */\n      name: 'arc',\n\n      /**\n       * 辅助弧线的起始点\n       * @type {Object | Function | Array}\n       */\n      start: null,\n\n      /**\n       * 辅助弧线的终止点\n       * @type {Object | Function | Array}\n       */\n      end: null,\n\n      /**\n       * 辅助文本的样式配置\n       * @type {Object}\n       */\n      style: {\n        stroke: '#999',\n        lineWidth: 1\n      }\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var start = self.parsePoint(coord, self.get('start'));\n    var end = self.parsePoint(coord, self.get('end'));\n    var coordCenter = coord.getCenter();\n    var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));\n    var path; // 处理整圆的情况\n\n    var startAngle = calculateAngle(start, coordCenter);\n    var endAngle = calculateAngle(end, coordCenter);\n\n    if (endAngle < startAngle) {\n      endAngle += PI * 2;\n    }\n\n    if (Util.isNumberEqual(start.x, end.x) && Util.isNumberEqual(start.y, end.y) && (self.get('start')[0] !== self.get('end')[0] || self.get('start')[1] !== self.get('end')[1])) {\n      path = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, 2 * coordCenter.x - start.x, 2 * coordCenter.y - start.y], ['A', radius, radius, 0, 1, 1, start.x, start.y]];\n    } else {\n      var dAngle = (endAngle - startAngle) % (PI * 2);\n      var largeArc = dAngle > PI ? 1 : 0;\n      path = [['M', start.x, start.y], ['A', radius, radius, 0, largeArc, 1, end.x, end.y]];\n    }\n\n    var arcShape = group.addShape('path', {\n      zIndex: self.get('zIndex'),\n      attrs: Util.mix({\n        path: path\n      }, self.get('style'))\n    });\n    arcShape.name = 'guide-arc';\n    self.get('appendInfo') && arcShape.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', arcShape);\n  };\n\n  return Arc;\n}(Guide);\n\nmodule.exports = Arc;\n\n/***/ }),\n/* 316 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar DataMarker =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(DataMarker, _Guide);\n\n  function DataMarker() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = DataMarker.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'dataMarker',\n      zIndex: 1,\n      top: true,\n      position: null,\n      style: {\n        point: {\n          r: 3,\n          fill: '#FFFFFF',\n          stroke: '#1890FF',\n          lineWidth: 2\n        },\n        line: {\n          stroke: '#A3B1BF',\n          lineWidth: 1\n        },\n        text: {\n          fill: '#000000',\n          opacity: 0.65,\n          fontSize: 12,\n          textAlign: 'start'\n        }\n      },\n      // end of style\n      display: {\n        point: true,\n        line: true,\n        text: true\n      },\n      lineLength: 20,\n      direction: 'upward',\n      autoAdjust: true\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var point = self.parsePoint(coord, self.get('position')); // container\n\n    var markerGroup = group.addGroup();\n    markerGroup.name = 'guide-data-marker'; // markerGroup.translate(point.x, point.y);\n\n    var positions = self._getElementPosition(point);\n\n    var display = self.get('display');\n    var lineShape;\n    var textShape; // add line\n\n    if (display.line) {\n      var lineData = positions.line;\n      lineShape = self._drawLine(lineData, markerGroup);\n    } // add text\n\n\n    if (display.text && self.get('content')) {\n      var textPosition = positions.text;\n      textShape = self._drawText(textPosition, markerGroup);\n    } // add circle\n\n\n    if (display.point) {\n      var pointPoisition = positions.point;\n\n      self._drawPoint(pointPoisition, markerGroup);\n    }\n\n    if (self.get('autoAdjust')) {\n      var bbox = markerGroup.getBBox();\n      var minX = bbox.minX,\n          minY = bbox.minY,\n          maxX = bbox.maxX,\n          maxY = bbox.maxY;\n      var start = coord.start,\n          end = coord.end;\n\n      if (textShape) {\n        if (minX <= start.x) {\n          // 左侧超出\n          textShape.attr('textAlign', 'start');\n        }\n\n        if (maxX >= end.x) {\n          // 右侧超出\n          textShape.attr('textAlign', 'end');\n        }\n\n        var direction = self.get('direction');\n\n        if (direction === 'upward' && minY <= end.y || direction !== 'upward' && maxY >= start.y) {\n          // 上方或者下方超出\n          var textBaseline;\n          var dir;\n\n          if (direction === 'upward' && minY <= end.y) {\n            textBaseline = 'top';\n            dir = 1;\n          } else {\n            textBaseline = 'bottom';\n            dir = -1;\n          }\n\n          textShape.attr('textBaseline', textBaseline);\n          var lineLength = 0;\n\n          if (self.get('display').line) {\n            lineLength = self.get('lineLength');\n            var linePath = [['M', point.x, point.y], ['L', point.x, point.y + lineLength * dir]];\n            lineShape.attr('path', linePath);\n          }\n\n          var newY = point.y + (lineLength + 2) * dir;\n          textShape.attr('y', newY);\n        }\n      }\n    }\n\n    self.get('appendInfo') && markerGroup.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', markerGroup);\n  };\n\n  _proto._getElementPosition = function _getElementPosition(position) {\n    var self = this;\n    var x = position.x,\n        y = position.y;\n    var lineLength = self.get('display').line ? self.get('lineLength') : 0;\n    var direction = self.get('direction');\n    var textStyle = self.get('style').text;\n    textStyle.textBaseline = direction === 'upward' ? 'bottom' : 'top';\n    var dir = direction === 'upward' ? -1 : 1;\n    var pointPoisition = {\n      x: x,\n      y: y\n    };\n    var lineStart = {\n      x: x,\n      y: y\n    };\n    var lineEnd = {\n      x: x,\n      y: lineLength * dir + y\n    };\n    var textPosition = {\n      x: x,\n      y: (lineLength + 2) * dir + y\n    };\n    return {\n      point: pointPoisition,\n      line: [lineStart, lineEnd],\n      text: textPosition\n    };\n  };\n\n  _proto._drawLine = function _drawLine(lineData, g) {\n    var self = this;\n    var lineStyle = self.get('style').line;\n    var linePath = [['M', lineData[0].x, lineData[0].y], ['L', lineData[1].x, lineData[1].y]];\n    var lineShape = g.addShape('path', {\n      attrs: Util.mix({\n        path: linePath\n      }, lineStyle)\n    });\n    return lineShape;\n  };\n\n  _proto._drawText = function _drawText(position, g) {\n    var self = this;\n    var textStyle = this.get('style').text;\n    var textShape = g.addShape('text', {\n      attrs: Util.mix({\n        text: self.get('content')\n      }, textStyle, position)\n    });\n    return textShape;\n  };\n\n  _proto._drawPoint = function _drawPoint(position, g) {\n    var self = this;\n    var pointStyle = self.get('style').point;\n    var pointShape = g.addShape('circle', {\n      attrs: Util.mix({}, pointStyle, position)\n    });\n    return pointShape;\n  };\n\n  return DataMarker;\n}(Guide);\n\nmodule.exports = DataMarker;\n\n/***/ }),\n/* 317 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Helper = __webpack_require__(156);\n\nvar Guide = __webpack_require__(15);\n\nvar DataRegion =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(DataRegion, _Guide);\n\n  function DataRegion() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = DataRegion.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'dataRegion',\n      start: null,\n      // 只支持数值\n      end: null,\n      // 只支持数值\n      content: '',\n      // 文本内容\n      style: {\n        region: {\n          lineWidth: 0,\n          fill: '#000000',\n          opacity: 0.04\n        },\n        text: {\n          textAlign: 'center',\n          textBaseline: 'bottom',\n          fontSize: 12,\n          fill: 'rgba(0, 0, 0, .65)'\n        }\n      }\n    });\n  };\n\n  _proto.render = function render(coord, group, data) {\n    var self = this; // draw region\n\n    var lineLength = self.get('lineLength') || 0; // TODO: 如何命名\n\n    var regionData = self._getRegionData(coord, data);\n\n    if (!regionData.length) return;\n\n    var regionBBox = self._getBBox(regionData);\n\n    var path = [];\n    path.push(['M', regionData[0].x, regionBBox.yMin - lineLength]);\n\n    for (var i = 0, len = regionData.length; i < len; i++) {\n      var p = ['L', regionData[i].x, regionData[i].y];\n      path.push(p);\n    }\n\n    path.push(['L', regionData[regionData.length - 1].x, regionBBox.yMin - lineLength]); // draw\n\n    var style = self.get('style');\n    var regionStyle = style.region; // 兼容之前的写法\n\n    var textStyle = style.text;\n    var regionGroup = group.addGroup();\n    regionGroup.name = 'guide-data-region';\n    regionGroup.addShape('path', {\n      attrs: Util.mix({\n        path: path\n      }, regionStyle)\n    });\n    var content = self.get('content');\n\n    if (content) {\n      regionGroup.addShape('Text', {\n        attrs: Util.mix({\n          x: (regionBBox.xMin + regionBBox.xMax) / 2,\n          y: regionBBox.yMin - lineLength,\n          text: content\n        }, textStyle)\n      });\n    }\n\n    self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', regionGroup);\n  };\n\n  _proto._getRegionData = function _getRegionData(coord, data) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var xField = Helper.getFirstScale(self.get('xScales')).field;\n    var yField = Helper.getFirstScale(self.get('yScales')).field;\n    var startXValue = Util.isArray(start) ? start[0] : start[xField];\n    var endXValue = Util.isArray(end) ? end[0] : end[xField];\n    var startIndex;\n    var arr = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item[xField] === startXValue) {\n        startIndex = i;\n      }\n\n      if (i >= startIndex) {\n        arr.push(self.parsePoint(coord, [item[xField], item[yField]]));\n      }\n\n      if (item[xField] === endXValue) {\n        break;\n      }\n    }\n\n    return arr;\n  };\n\n  _proto._getBBox = function _getBBox(data) {\n    var xs = [];\n    var ys = [];\n\n    for (var i = 0; i < data.length; i++) {\n      xs.push(data[i].x);\n      ys.push(data[i].y);\n    }\n\n    var xRange = Util.arrayUtil.getRange(xs);\n    var yRange = Util.arrayUtil.getRange(ys);\n    return {\n      xMin: xRange.min,\n      xMax: xRange.max,\n      yMin: yRange.min,\n      yMax: yRange.max\n    };\n  };\n\n  return DataRegion;\n}(Guide);\n\nmodule.exports = DataRegion;\n\n/***/ }),\n/* 318 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar DomUtil = Util.DomUtil;\n\nvar Guide = __webpack_require__(15);\n\nvar Html =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Html, _Guide);\n\n  function Html() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Html.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'html',\n      zIndex: 7,\n      position: null,\n\n      /**\n       * Horizontal alignment, can be 'left'、'middle'、'right'\n       * @type {String}\n       */\n      alignX: 'middle',\n\n      /**\n       * vertical alignment, can be 'top'、'middle'、'bottom'\n       * @type {String}\n       */\n      alignY: 'middle',\n\n      /**\n       * Horizontal offset\n       * @type {Number}\n       */\n      offsetX: null,\n\n      /**\n       * Vertical offset\n       * @type {Number}\n       */\n      offsetY: null,\n\n      /**\n      * html content\n      *@type {String | Function}\n      */\n      html: null\n    });\n  };\n  /**\n   * render Html Guide\n   * @override\n   * @param {Coordinate} coord the instance of Coordinate class\n   * @param {Container} container the container which contain the guide component\n   */\n\n\n  _proto.render = function render(coord, container) {\n    var self = this;\n    var position = self.parsePoint(coord, self.get('position'));\n    var parentNode = container.get('canvas').get('el').parentNode;\n    var wrapperNode = DomUtil.createDom('<div class=\"g-guide\"></div>');\n    parentNode.appendChild(wrapperNode);\n    var html = self.get('htmlContent') || self.get('html');\n\n    if (Util.isFunction(html)) {\n      var xScales = self.get('xScales');\n      var yScales = self.get('yScales');\n      html = html(xScales, yScales);\n    }\n\n    var htmlNode = DomUtil.createDom(html);\n    wrapperNode.appendChild(htmlNode);\n    DomUtil.modifyCSS(wrapperNode, {\n      position: 'absolute' // to fix dom in the document stream to get the true width\n\n    });\n\n    self._setDomPosition(wrapperNode, htmlNode, position);\n\n    self.set('el', wrapperNode);\n  };\n\n  _proto._setDomPosition = function _setDomPosition(parentDom, childDom, point) {\n    var self = this;\n    var alignX = self.get('alignX');\n    var alignY = self.get('alignY');\n    var domWidth = DomUtil.getOuterWidth(childDom);\n    var domHeight = DomUtil.getOuterHeight(childDom);\n    var position = {\n      x: point.x,\n      y: point.y\n    };\n\n    if (alignX === 'middle' && alignY === 'top') {\n      position.x -= Math.round(domWidth / 2);\n    } else if (alignX === 'middle' && alignY === 'bottom') {\n      position.x -= Math.round(domWidth / 2);\n      position.y -= Math.round(domHeight);\n    } else if (alignX === 'left' && alignY === 'bottom') {\n      position.y -= Math.round(domHeight);\n    } else if (alignX === 'left' && alignY === 'middle') {\n      position.y -= Math.round(domHeight / 2);\n    } else if (alignX === 'left' && alignY === 'top') {\n      position.x = point.x;\n      position.y = point.y;\n    } else if (alignX === 'right' && alignY === 'bottom') {\n      position.x -= Math.round(domWidth);\n      position.y -= Math.round(domHeight);\n    } else if (alignX === 'right' && alignY === 'middle') {\n      position.x -= Math.round(domWidth);\n      position.y -= Math.round(domHeight / 2);\n    } else if (alignX === 'right' && alignY === 'top') {\n      position.x -= Math.round(domWidth);\n    } else {\n      // 默认位于中心点\n      position.x -= Math.round(domWidth / 2);\n      position.y -= Math.round(domHeight / 2);\n    }\n\n    var offsetX = self.get('offsetX');\n\n    if (offsetX) {\n      position.x += offsetX;\n    }\n\n    var offsetY = self.get('offsetY');\n\n    if (offsetY) {\n      position.y += offsetY;\n    }\n\n    DomUtil.modifyCSS(parentDom, {\n      top: Math.round(position.y) + 'px',\n      left: Math.round(position.x) + 'px',\n      visibility: 'visible',\n      zIndex: self.get('zIndex')\n    });\n  };\n  /**\n   * clear html guide\n   * @override\n   */\n\n\n  _proto.clear = function clear() {\n    var self = this;\n    var el = self.get('el');\n    el && el.parentNode && el.parentNode.removeChild(el);\n  };\n\n  return Html;\n}(Guide);\n\nmodule.exports = Html;\n\n/***/ }),\n/* 319 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar Image =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Image, _Guide);\n\n  function Image() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Image.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      type: 'image',\n\n      /**\n       * the start of image\n       * @type {Object | Function | Array}\n       */\n      start: null,\n\n      /**\n       * the end of image\n       * @type {Object | Function | Array}\n       */\n      end: null,\n\n      /**\n       * image url\n       * @type {String}\n       */\n      src: null,\n\n      /**\n       * Horizontal offset\n       * @type {Number}\n       */\n      offsetX: null,\n\n      /**\n       * Vertical offset\n       * @type {Number}\n       */\n      offsetY: null\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var start = self.parsePoint(coord, self.get('start'));\n    var cfg = {\n      x: start.x,\n      y: start.y\n    };\n    cfg.img = self.get('src');\n\n    if (!self.get('end')) {\n      // 如果咩有指定结束点，则 start 为图片的左上角坐标\n      cfg.width = self.get('width') || 32;\n      cfg.height = self.get('height') || 32;\n    } else {\n      var end = self.parsePoint(coord, self.get('end')); // cfg.width = Math.abs(end.x - start.x);\n      // cfg.height = Math.abs(end.y - start.y);\n\n      cfg.width = end.x - start.x;\n      cfg.height = end.y - start.y;\n    }\n\n    if (self.get('offsetX')) {\n      cfg.x += self.get('offsetX');\n    }\n\n    if (self.get('offsetY')) {\n      cfg.y += self.get('offsetY');\n    }\n\n    var imgGuide = group.addShape('Image', {\n      zIndex: 1,\n      attrs: cfg\n    });\n    imgGuide.name = 'guide-image';\n    self.get('appendInfo') && imgGuide.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', imgGuide);\n  };\n\n  return Image;\n}(Guide);\n\nmodule.exports = Image;\n\n/***/ }),\n/* 320 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar vec2 = Util.MatrixUtil.vec2;\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar Line =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Line, _Guide);\n\n  function Line() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 辅助元素类型\n       * @type {String}\n       */\n      name: 'line',\n\n      /**\n       * 辅助线的起点位置\n       * @type {Object | Function | Array}\n       */\n      start: null,\n\n      /**\n       * 辅助线的终点位置\n       * @type {Object | Function | Array}\n       */\n      end: null,\n\n      /**\n       * 辅助线的图形样式\n       * @type {Object}\n       */\n      lineStyle: {\n        stroke: '#000',\n        lineWidth: 1\n      },\n\n      /**\n       * 辅助文本配置\n       * @type {Object}\n       */\n      text: {\n        position: 'end',\n        // 文本的显示位置： start / center / end / 百分比\n        autoRotate: true,\n        // 文本是否沿着辅助线的方向自动旋转\n        style: {\n          fill: '#999',\n          fontSize: 12,\n          fontWeight: 500,\n          fontFamily: FONT_FAMILY\n        },\n        // 辅助文本的样式\n        content: null // 辅助文本的文字\n\n      }\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var start = self.parsePoint(coord, self.get('start'));\n    var end = self.parsePoint(coord, self.get('end'));\n    var guideLineGroup = group.addGroup({\n      viewId: group.get('viewId')\n    });\n\n    self._drawLines(start, end, guideLineGroup);\n\n    var text = self.get('text');\n\n    if (text && text.content) {\n      self._drawText(start, end, guideLineGroup);\n    }\n\n    self.set('el', guideLineGroup);\n  };\n\n  _proto._drawLines = function _drawLines(start, end, group) {\n    var path = [['M', start.x, start.y], ['L', end.x, end.y]];\n    var guideLine = group.addShape('Path', {\n      attrs: Util.mix({\n        path: path\n      }, this.get('lineStyle'))\n    });\n    guideLine.name = 'guide-line';\n    this.get('appendInfo') && guideLine.setSilent('appendInfo', this.get('appendInfo'));\n  };\n\n  _proto._drawText = function _drawText(start, end, group) {\n    var textCfg = this.get('text');\n    var position = textCfg.position;\n    var textStyle = textCfg.style || {};\n    var percent;\n\n    if (position === 'start') {\n      percent = 0;\n    } else if (position === 'center') {\n      percent = 0.5;\n    } else if (Util.isString(position) && position.indexOf('%') !== -1) {\n      percent = parseInt(position, 10) / 100;\n    } else if (Util.isNumber(position)) {\n      percent = position;\n    } else {\n      percent = 1;\n    }\n\n    if (percent > 1 || percent < 0) {\n      percent = 1;\n    }\n\n    var cfg = {\n      x: start.x + (end.x - start.x) * percent,\n      y: start.y + (end.y - start.y) * percent\n    };\n\n    if (textCfg.offsetX) {\n      // 设置了偏移量\n      cfg.x += textCfg.offsetX;\n    }\n\n    if (textCfg.offsetY) {\n      // 设置了偏移量\n      cfg.y += textCfg.offsetY;\n    }\n\n    cfg.text = textCfg.content;\n    cfg = Util.mix({}, cfg, textStyle);\n\n    if (textCfg.autoRotate && Util.isNil(textStyle.rotate)) {\n      // 自动旋转且用户没有设置旋转角度\n      var angle = vec2.angleTo([end.x - start.x, end.y - start.y], [1, 0], 1);\n      cfg.rotate = angle;\n    } else if (!Util.isNil(textStyle.rotate)) {\n      // 用户设置了旋转角度\n      cfg.rotate = textStyle.rotate * Math.PI / 180;\n    }\n\n    var shape = group.addShape('Text', {\n      attrs: cfg\n    });\n    shape.name = 'guide-line-text';\n    this.get('appendInfo') && shape.setSilent('appendInfo', this.get('appendInfo'));\n  };\n\n  return Line;\n}(Guide);\n\nmodule.exports = Line;\n\n/***/ }),\n/* 321 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar Region =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Region, _Guide);\n\n  function Region() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Region.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'region',\n      zIndex: 1,\n      start: null,\n      end: null,\n      style: {\n        lineWidth: 0,\n        fill: '#CCD7EB',\n        opacity: 0.4\n      }\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var rectStyle = self.get('style');\n\n    var path = self._getPath(coord);\n\n    var regionGroup = group.addShape('path', {\n      zIndex: self.get('zIndex'),\n      attrs: Util.mix({\n        path: path\n      }, rectStyle)\n    });\n    regionGroup.name = 'guide-region';\n    self.get('appendInfo') && regionGroup.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', regionGroup);\n  };\n\n  _proto._getPath = function _getPath(coord) {\n    var self = this;\n    var start = self.parsePoint(coord, self.get('start'));\n    var end = self.parsePoint(coord, self.get('end'));\n    var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];\n    return path;\n  };\n\n  return Region;\n}(Guide);\n\nmodule.exports = Region;\n\n/***/ }),\n/* 322 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar Guide = __webpack_require__(15);\n\nvar Text =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(Text, _Guide);\n\n  function Text() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = Text.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 辅助元素类型\n       * @type {String}\n       */\n      name: 'text',\n\n      /**\n       * 辅助文本的位置\n       * @type {Object | Function | Array}\n       */\n      position: null,\n\n      /**\n       * 辅助文本的显示文字\n       * @type {String}\n       */\n      content: null,\n\n      /**\n       * 辅助文本的样式配置\n       * @type {Object}\n       */\n      style: {\n        fill: '#999',\n        fontSize: 12,\n        fontWeight: 500,\n        textAlign: 'center'\n      },\n\n      /**\n       * x 方向的偏移量\n       * @type {Number}\n       */\n      offsetX: null,\n\n      /**\n       * y 方向的偏移量\n       * @type {Number}\n       */\n      offsetY: null,\n      top: true\n    });\n  };\n\n  _proto.render = function render(coord, group) {\n    var self = this;\n    var point = self.parsePoint(coord, self.get('position'));\n    var textStyle = Util.mix({}, self.get('style'));\n    var offsetX = self.get('offsetX');\n    var offsetY = self.get('offsetY');\n\n    if (offsetX) {\n      point.x += offsetX;\n    }\n\n    if (offsetY) {\n      point.y += offsetY;\n    }\n\n    if (textStyle.rotate) {\n      textStyle.rotate = textStyle.rotate * Math.PI / 180; // 将角度转换为弧度\n    }\n\n    var guideText = group.addShape('Text', {\n      zIndex: self.get('zIndex'),\n      attrs: Util.mix({\n        text: self.get('content')\n      }, textStyle, point)\n    });\n    guideText.name = 'guide-text';\n    self.get('appendInfo') && guideText.setSilent('appendInfo', self.get('appendInfo'));\n    self.set('el', guideText);\n  };\n\n  return Text;\n}(Guide);\n\nmodule.exports = Text;\n\n/***/ }),\n/* 323 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Label = __webpack_require__(154);\n\nmodule.exports = Label;\n\n/***/ }),\n/* 324 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The entry of legend\n * @author sima.zhang\n */\nmodule.exports = {\n  Category: __webpack_require__(157),\n  // 分类图例\n  CatHtml: __webpack_require__(159),\n  // 分类图例\n  CatPageHtml: __webpack_require__(325),\n  // 分类图例\n  // Tail: require('./tail'), // 尾部跟随图例\n  Color: __webpack_require__(326),\n  // 颜色图例\n  Size: __webpack_require__(328),\n  // 大小图例（适用于除映射点大小以外的其他大小）\n  CircleSize: __webpack_require__(329) // 点大小图例\n\n};\n\n/***/ }),\n/* 325 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar CatHtml = __webpack_require__(159);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar DomUtil = Util.DomUtil;\nvar LIST_CLASS = 'g2-legend-list';\nvar CONTAINER_CLASS = 'g2-legend';\nvar SLIP_CLASS = 'g2-slip';\nvar CARET_UP_CLASS = 'g2-caret-up';\nvar CARET_DOWN_CLASS = 'g2-caret-down';\nvar ENABLED_CARET_COLOR = 'rgba(0,0,0,0.65)';\nvar DISABLED_CARET_COLOR = 'rgba(0,0,0,0.25)';\n\nfunction findNodeByClass(node, className) {\n  return node.getElementsByClassName(className)[0];\n}\n\nvar CatPageHtml =\n/*#__PURE__*/\nfunction (_CatHtml) {\n  _inheritsLoose(CatPageHtml, _CatHtml);\n\n  function CatPageHtml() {\n    return _CatHtml.apply(this, arguments) || this;\n  }\n\n  var _proto = CatPageHtml.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _CatHtml.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * type标识\n       * @type {String}\n       */\n      type: 'category-page-legend',\n\n      /**\n       * html 容器\n       * @type {DOM}\n       */\n      container: null,\n\n      /**\n       * 向上 / 下翻页图标的样式\n       * @type {ATTRS}\n       */\n      caretStyle: {\n        fill: 'rgba(0,0,0,0.65)'\n      },\n\n      /**\n       * 页码文字的样式\n       * @type {ATTRS}\n       */\n      pageNumStyle: {\n        display: 'inline-block',\n        fontSize: '12px',\n        fontFamily: FONT_FAMILY,\n        cursor: 'default'\n      },\n\n      /**\n       * 翻页块 DOM 的样式\n       * @type {ATTRS}\n       */\n      slipDomStyle: {\n        width: 'auto',\n        height: 'auto',\n        position: 'absolute'\n      },\n\n      /**\n       * 翻页块 DOM\n       * @type {String}\n       */\n      slipTpl: '<div class=\"' + SLIP_CLASS + '\" >' + '<svg viewBox=\"64 64 896 896\" class=\"g2-caret-up\" data-icon=\"left\" width=\"1em\" height=\"1em\" aria-hidden=\"true\">' + '<path d=\"M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z\"></path>' + '</svg>' + '<p class=\"cur-pagenum\" style = \"display:inline-block;\">1</p>' + '<p class=\"next-pagenum\" style = \"display:inline-block;\">/2</p>' + '<svg viewBox=\"64 64 896 896\" class=\"g2-caret-down\" data-icon=\"right\" width=\"1em\" height=\"1em\" aria-hidden=\"true\">' + '<path d=\"M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z\"></path>' + '</svg>' + '</div>',\n\n      /**\n       * 翻页块的宽度，用于设置翻页块相对于 legend 的位置\n       * @type {Number}\n       */\n      slipWidth: 65,\n\n      /**\n       * legend 内容超出容器的处理方式\n       * @type {String}\n       */\n      legendOverflow: 'unset'\n    });\n  };\n\n  _proto.render = function render() {\n    _CatHtml.prototype._renderHTML.call(this);\n\n    this._renderFlipPage();\n  };\n\n  _proto._renderFlipPage = function _renderFlipPage() {\n    var legendWrapper = document.getElementsByClassName(CONTAINER_CLASS)[0]; // ul\n\n    var itemListDom = findNodeByClass(legendWrapper, LIST_CLASS);\n    var position = this.get('position');\n    var layout = this.get('layout');\n    var itemDisplay = position === 'right' || position === 'left' || layout === 'vertical' ? 'block' : 'inline-block'; // 翻页\n\n    if (legendWrapper.scrollHeight > legendWrapper.offsetHeight) {\n      // append a slip div\n      var slipTpl = this.get('slipTpl');\n      var slipDom = DomUtil.createDom(slipTpl);\n      var caretUpDom = findNodeByClass(slipDom, CARET_UP_CLASS);\n      var caretDownDom = findNodeByClass(slipDom, CARET_DOWN_CLASS);\n      DomUtil.modifyCSS(caretUpDom, this.get('caretStyle'));\n      DomUtil.modifyCSS(caretUpDom, {\n        fill: 'rgba(0,0,0,0.25)'\n      });\n      DomUtil.modifyCSS(caretDownDom, this.get('caretStyle'));\n      var curPageNumDom = findNodeByClass(slipDom, 'cur-pagenum');\n      var totalPageNumDom = findNodeByClass(slipDom, 'next-pagenum');\n      var pageNumStyle = this.get('pageNumStyle');\n      DomUtil.modifyCSS(curPageNumDom, Util.mix({}, pageNumStyle, {\n        paddingLeft: '10px'\n      }));\n      DomUtil.modifyCSS(totalPageNumDom, Util.mix({}, pageNumStyle, {\n        opacity: 0.3,\n        paddingRight: '10px'\n      })); // layout at the center-bottom of the legendWrapper\n\n      DomUtil.modifyCSS(slipDom, Util.mix({}, this.get('slipDomStyle'), {\n        top: legendWrapper.offsetHeight + 'px'\n      }));\n      legendWrapper.style.overflow = this.get('legendOverflow');\n      legendWrapper.appendChild(slipDom);\n      var li = itemListDom.childNodes;\n      var curHeight = 0; // find the total page number\n\n      var pages = 1;\n      var blockLi = [];\n\n      for (var i = 0; i < li.length; i++) {\n        li[i].style.display = itemDisplay;\n        curHeight = li[i].offsetTop + li[i].offsetHeight;\n\n        if (curHeight >= legendWrapper.offsetHeight) {\n          pages++;\n          blockLi.forEach(function (bl) {\n            bl.style.display = 'none';\n          });\n          blockLi = [];\n        }\n\n        blockLi.push(li[i]);\n      }\n\n      totalPageNumDom.innerText = '/' + pages; // initialize the page\n\n      li.forEach(function (l) {\n        l.style.display = itemDisplay;\n        curHeight = l.offsetTop + l.offsetHeight;\n\n        if (curHeight > legendWrapper.offsetHeight) {\n          l.style.display = 'none';\n        }\n      }); // 上翻事件\n\n      caretUpDom.addEventListener('click', function () {\n        // it is the 1st page\n        if (li[0].style.display === itemDisplay) return; // otherwise\n\n        var firstDisplayItemIdx = -1;\n        li.forEach(function (l, i) {\n          if (l.style.display === itemDisplay) {\n            firstDisplayItemIdx = firstDisplayItemIdx === -1 ? i : firstDisplayItemIdx;\n            l.style.display = 'none';\n          }\n        });\n\n        for (var _i = firstDisplayItemIdx - 1; _i >= 0; _i--) {\n          li[_i].style.display = itemDisplay;\n          curHeight = li[firstDisplayItemIdx - 1].offsetTop + li[firstDisplayItemIdx - 1].offsetHeight;\n          li[_i].style.display = 'none';\n\n          if (curHeight < legendWrapper.offsetHeight) {\n            li[_i].style.display = itemDisplay;\n          } else break;\n        } // change the page number\n\n\n        var currentPage = Number.parseInt(curPageNumDom.innerText, 10) - 1;\n\n        if (currentPage === 1) {\n          caretUpDom.style.fill = DISABLED_CARET_COLOR;\n        } else {\n          caretUpDom.style.fill = ENABLED_CARET_COLOR;\n        }\n\n        caretDownDom.style.fill = ENABLED_CARET_COLOR;\n        curPageNumDom.innerText = currentPage;\n      }); // 下翻事件\n\n      caretDownDom.addEventListener('click', function () {\n        // it is the last page\n        if (li[li.length - 1].style.display === itemDisplay) return; // otherwise\n\n        var lastDisplayItemIdx = -1;\n        li.forEach(function (l, i) {\n          if (l.style.display === itemDisplay) {\n            lastDisplayItemIdx = i;\n            l.style.display = 'none';\n          }\n        });\n\n        for (var _i2 = lastDisplayItemIdx + 1; _i2 < li.length; _i2++) {\n          li[_i2].style.display = itemDisplay;\n          curHeight = li[_i2].offsetTop + li[_i2].offsetHeight;\n          li[_i2].style.display = 'none';\n          if (curHeight < legendWrapper.offsetHeight) li[_i2].style.display = itemDisplay;else break;\n        } // change the page number\n\n\n        var currentPage = Number.parseInt(curPageNumDom.innerText, 10) + 1;\n\n        if (currentPage === itemDisplay) {\n          caretDownDom.style.fill = DISABLED_CARET_COLOR;\n        } else {\n          caretDownDom.style.fill = ENABLED_CARET_COLOR;\n        }\n\n        caretUpDom.style.fill = ENABLED_CARET_COLOR;\n        curPageNumDom.innerText = currentPage;\n      });\n      this.set('slipDom', slipDom);\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    _CatHtml.prototype.destroy.call(this);\n\n    var slipDom = this.get('slipDom');\n\n    if (slipDom && slipDom.parentNode) {\n      slipDom.parentNode.removeChild(slipDom);\n    }\n  };\n\n  return CatPageHtml;\n}(CatHtml);\n\nmodule.exports = CatPageHtml;\n\n/***/ }),\n/* 326 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The class of the gradient color legend\n * @author sima.zhang\n */\n\n\nvar _require = __webpack_require__(73),\n    ColorUtil = _require.ColorUtil; // TODO：ColorUtil 包需要从 attr 包中抽离\n\n\nvar Util = __webpack_require__(3);\n\nvar Continuous = __webpack_require__(67);\n\nvar Color =\n/*#__PURE__*/\nfunction (_Continuous) {\n  _inheritsLoose(Color, _Continuous);\n\n  function Color() {\n    return _Continuous.apply(this, arguments) || this;\n  }\n\n  var _proto = Color.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Continuous.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'color-legend',\n\n      /**\n       * 布局方式\n       * horizontal 水平\n       * vertical 垂直\n       * @type {String}\n       */\n      layout: 'vertical',\n\n      /**\n       * 两头滑块的样式\n       * @type {object}\n       */\n      triggerAttr: {\n        fill: '#fff',\n        shadowOffsetX: -2,\n        shadowOffsetY: 2,\n        shadowBlur: 10,\n        shadowColor: '#ccc',\n        radius: 3\n      },\n\n      /**\n       * 同一分段是否使用相同颜色而不使用渐变色，在 slidable = false 时生效\n       * @type {boolean}\n       */\n      isSegment: false\n    });\n  };\n\n  _proto._setPercentage = function _setPercentage() {\n    var items = this.get('items');\n    if (items[0].percentage) return;\n    var min = items[0].value;\n    var max = items[items.length - 1].value;\n    Util.each(items, function (it) {\n      it.percentage = (it.value - min) / (max - min);\n    });\n    return;\n  }; // render the slider while slidable === true\n\n\n  _proto._renderSliderShape = function _renderSliderShape() {\n    this._setPercentage();\n\n    var slider = this.get('slider');\n    var backgroundElement = slider.get('backgroundElement');\n    var width = this.get('width');\n    var height = this.get('height');\n    var layout = this.get('layout');\n    var items = this.get('items');\n    var fill = '';\n    var rgbColor; // gradient color distributed according to the percentage\n\n    if (layout === 'vertical') {\n      fill += 'l (90) ';\n      Util.each(items, function (v) {\n        rgbColor = ColorUtil.toRGB(v.color);\n        fill += 1 - v.percentage + ':' + rgbColor + ' ';\n      });\n    } else {\n      fill += 'l (0) ';\n      Util.each(items, function (v) {\n        rgbColor = ColorUtil.toRGB(v.color);\n        fill += v.percentage + ':' + rgbColor + ' ';\n      });\n    }\n\n    return this._addMiddleBar(backgroundElement, 'Rect', {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      fill: fill,\n      strokeOpacity: 0\n    });\n  }; // render the silder while slidable === false\n\n\n  _proto._renderUnslidable = function _renderUnslidable() {\n    this._setPercentage();\n\n    var titleShape = this.get('titleShape');\n    var titleGap = this.get('titleGap');\n    titleGap = titleShape ? titleShape.getBBox().height + titleGap : titleGap;\n    var width = this.get('width');\n    var height = this.get('height');\n    var layout = this.get('layout');\n    var items = this.get('items');\n    var fill = '';\n    var rgbColor;\n    var path = [];\n    var group = this.get('group');\n    var bgGroup = group.addGroup();\n    var isize = items.length; // gradient color distributed according to the percentage\n\n    if (layout === 'vertical') {\n      fill += 'l (90) ';\n\n      for (var i = 0; i < isize; i += 1) {\n        if (i !== 0 && i !== isize - 1) {\n          path.push(['M', 0, height - items[i].percentage * height]);\n          path.push(['L', width, height - items[i].percentage * height]);\n        }\n\n        rgbColor = ColorUtil.toRGB(items[i].color);\n        fill += 1 - items[i].percentage + ':' + rgbColor + ' ';\n\n        if (this.get('isSegment') && i > 0) {\n          // one color instead of gradient color for a block while isSegment === true\n          var preRgbColor = ColorUtil.toRGB(items[i - 1].color);\n          fill += 1 - items[i].percentage + ':' + preRgbColor + ' ';\n        }\n\n        bgGroup.addShape('text', {\n          attrs: Util.mix({}, {\n            x: width + this.get('textOffset') / 2,\n            y: height - items[i].percentage * height,\n            text: this._formatItemValue(items[i].value) + '' // 以字符串格式展示\n\n          }, this.get('textStyle'), {\n            textAlign: 'start'\n          })\n        });\n      }\n    } else {\n      // horizontal\n      fill += 'l (0) ';\n\n      for (var _i = 0; _i < isize; _i += 1) {\n        if (_i !== 0 && _i !== isize - 1) {\n          path.push(['M', items[_i].percentage * width, 0]);\n          path.push(['L', items[_i].percentage * width, height]);\n        }\n\n        rgbColor = ColorUtil.toRGB(items[_i].color);\n\n        if (this.get('isSegment') && _i > 0) {\n          var _preRgbColor = ColorUtil.toRGB(items[_i - 1].color);\n\n          fill += items[_i].percentage + ':' + _preRgbColor + ' ';\n        }\n\n        fill += items[_i].percentage + ':' + rgbColor + ' ';\n        bgGroup.addShape('text', {\n          attrs: Util.mix({}, {\n            x: items[_i].percentage * width,\n            y: height + 5 + this.get('textOffset'),\n            text: this._formatItemValue(items[_i].value) + '' // 以字符串格式展示\n\n          }, this.get('textStyle'))\n        });\n      }\n    }\n\n    bgGroup.addShape('rect', {\n      attrs: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        fill: fill,\n        strokeOpacity: 0\n      }\n    }); // the white line segment to seperate color blocks\n\n    bgGroup.addShape('path', {\n      attrs: Util.mix({\n        path: path\n      }, this.get('lineStyle'))\n    });\n    bgGroup.move(0, titleGap);\n  };\n\n  return Color;\n}(Continuous);\n\nmodule.exports = Color;\n\n/***/ }),\n/* 327 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The class of slider\n * @author sima.zhang\n */\n\n\nvar Util = __webpack_require__(3);\n\nvar DomUtil = Util.DomUtil;\nvar Group = Util.Group;\n\nvar Slider =\n/*#__PURE__*/\nfunction (_Group) {\n  _inheritsLoose(Slider, _Group);\n\n  function Slider() {\n    return _Group.apply(this, arguments) || this;\n  }\n\n  var _proto = Slider.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * 范围\n       * @type {Array}\n       */\n      range: null,\n\n      /**\n       * 中滑块属性\n       * 透明的，用于用户交互\n       * @type {ATTRS}\n       */\n      middleAttr: {\n        fill: '#fff',\n        fillOpacity: 0\n      },\n\n      /**\n       * 背景\n       * @type {G-Element}\n       */\n      backgroundElement: null,\n\n      /**\n       * 下滑块\n       * @type {G-Element}\n       */\n      minHandleElement: null,\n\n      /**\n       * 上滑块\n       * @type {G-Element}\n       */\n      maxHandleElement: null,\n\n      /**\n       * 中块，\n       * 透明的，用于用户交互\n       * @type {G-Element}\n       */\n      middleHandleElement: null,\n\n      /**\n       * 当前的激活的元素\n       * @type {G-Element}\n       */\n      currentTarget: null,\n\n      /**\n       * 布局方式： horizontal，vertical\n       * @type {String}\n       */\n      layout: 'vertical',\n\n      /**\n       * 宽\n       * @type {Number}\n       */\n      width: null,\n\n      /**\n       * 高\n       * @type {Number}\n       */\n      height: null,\n\n      /**\n       * 当前的PageX\n       * @type {Number}\n       */\n      pageX: null,\n\n      /**\n       * 当前的PageY\n       * @type {Number}\n       */\n      pageY: null\n    };\n  }; // arrange the zindex and cursors of each element\n\n\n  _proto._beforeRenderUI = function _beforeRenderUI() {\n    var layout = this.get('layout');\n    var backgroundElement = this.get('backgroundElement');\n    var minHandleElement = this.get('minHandleElement');\n    var maxHandleElement = this.get('maxHandleElement');\n    var middleHandleElement = this.addShape('rect', {\n      attrs: this.get('middleAttr')\n    });\n    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';\n    this.add([backgroundElement, minHandleElement, maxHandleElement]);\n    this.set('middleHandleElement', middleHandleElement);\n    backgroundElement.set('zIndex', 0);\n    middleHandleElement.set('zIndex', 1);\n    minHandleElement.set('zIndex', 2);\n    maxHandleElement.set('zIndex', 2);\n    middleHandleElement.attr('cursor', 'move');\n    minHandleElement.attr('cursor', trigerCursor);\n    maxHandleElement.attr('cursor', trigerCursor);\n    this.sort();\n  }; // rendering\n\n\n  _proto._renderUI = function _renderUI() {\n    if (this.get('layout') === 'horizontal') {\n      this._renderHorizontal();\n    } else {\n      this._renderVertical();\n    }\n  };\n\n  _proto._transform = function _transform(layout) {\n    var range = this.get('range');\n    var minRatio = range[0] / 100;\n    var maxRatio = range[1] / 100;\n    var width = this.get('width');\n    var height = this.get('height');\n    var minHandleElement = this.get('minHandleElement');\n    var maxHandleElement = this.get('maxHandleElement');\n    var middleHandleElement = this.get('middleHandleElement');\n    minHandleElement.resetMatrix();\n    maxHandleElement.resetMatrix();\n\n    if (layout === 'horizontal') {\n      middleHandleElement.attr({\n        x: width * minRatio,\n        y: 0,\n        width: (maxRatio - minRatio) * width,\n        height: height\n      });\n      minHandleElement.translate(minRatio * width, height);\n      maxHandleElement.translate(maxRatio * width, height);\n    } else {\n      middleHandleElement.attr({\n        x: 0,\n        y: height * (1 - maxRatio),\n        width: width,\n        height: (maxRatio - minRatio) * height\n      });\n      minHandleElement.translate(1, (1 - minRatio) * height);\n      maxHandleElement.translate(1, (1 - maxRatio) * height);\n    }\n  };\n\n  _proto._renderHorizontal = function _renderHorizontal() {\n    this._transform('horizontal');\n  };\n\n  _proto._renderVertical = function _renderVertical() {\n    this._transform('vertical');\n  };\n\n  _proto._bindUI = function _bindUI() {\n    this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));\n  }; // if the target matches name\n\n\n  _proto._isElement = function _isElement(target, name) {\n    var element = this.get(name);\n\n    if (target === element) {\n      return true;\n    }\n\n    if (element.isGroup) {\n      var elementChildren = element.get('children');\n      return elementChildren.indexOf(target) > -1;\n    }\n\n    return false;\n  }; // get the result range after adding diff to range\n  // insure that the result out of the interval [0, 100]\n\n\n  _proto._getRange = function _getRange(diff, range) {\n    var rst = diff + range;\n    rst = rst > 100 ? 100 : rst;\n    rst = rst < 0 ? 0 : rst;\n    return rst;\n  };\n\n  _proto._updateStatus = function _updateStatus(dim, ev) {\n    var totalLength = dim === 'x' ? this.get('width') : this.get('height');\n    dim = Util.upperFirst(dim);\n    var range = this.get('range');\n    var page = this.get('page' + dim);\n    var currentTarget = this.get('currentTarget');\n    var rangeStash = this.get('rangeStash');\n    var layout = this.get('layout');\n    var sign = layout === 'vertical' ? -1 : 1;\n    var currentPage = ev['page' + dim]; // the distance of the mouse dragging\n\n    var diffPage = currentPage - page;\n    var diffRange = diffPage / totalLength * 100 * sign;\n    var diffStashRange; // the min and max trigger overlap, range[0] and range[1] change together\n\n    if (range[1] <= range[0]) {\n      if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {\n        range[0] = this._getRange(diffRange, range[0]);\n        range[1] = this._getRange(diffRange, range[0]);\n      }\n    } else {\n      // user drags the min trigger\n      if (this._isElement(currentTarget, 'minHandleElement')) {\n        range[0] = this._getRange(diffRange, range[0]);\n      } // user drags the max trigger\n\n\n      if (this._isElement(currentTarget, 'maxHandleElement')) {\n        range[1] = this._getRange(diffRange, range[1]);\n      }\n    } // the user drags the middle bar\n\n\n    if (this._isElement(currentTarget, 'middleHandleElement')) {\n      // the diffrence between min and max trigger while mouse down\n      diffStashRange = rangeStash[1] - rangeStash[0];\n      range[0] = this._getRange(diffRange, range[0]); // keep the diffStashRange\n\n      range[1] = range[0] + diffStashRange;\n\n      if (range[1] > 100) {\n        range[1] = 100;\n        range[0] = range[1] - diffStashRange;\n      }\n    }\n\n    this.emit('sliderchange', {\n      range: range\n    });\n    this.set('page' + dim, currentPage);\n\n    this._renderUI();\n\n    this.get('canvas').draw(); // need delete\n\n    return;\n  }; // the listener of mouse down\n\n\n  _proto._onMouseDown = function _onMouseDown(ev) {\n    var currentTarget = ev.currentTarget;\n    var originEvent = ev.event;\n    var range = this.get('range');\n    originEvent.stopPropagation();\n    originEvent.preventDefault();\n    this.set('pageX', originEvent.pageX);\n    this.set('pageY', originEvent.pageY);\n    this.set('currentTarget', currentTarget); // stash the range\n\n    this.set('rangeStash', [range[0], range[1]]);\n\n    this._bindCanvasEvents();\n  };\n\n  _proto._bindCanvasEvents = function _bindCanvasEvents() {\n    var containerDOM = this.get('canvas').get('containerDOM'); // this.on('mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));\n\n    this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));\n    this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp'));\n    this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));\n  }; // listener of mouse click and move = drag\n\n\n  _proto._onCanvasMouseMove = function _onCanvasMouseMove(ev) {\n    if (!this._mouseOutArea(ev)) {\n      var layout = this.get('layout');\n\n      if (layout === 'horizontal') {\n        this._updateStatus('x', ev);\n      } else {\n        this._updateStatus('y', ev);\n      }\n    }\n  }; // listener of mouse up\n\n\n  _proto._onCanvasMouseUp = function _onCanvasMouseUp() {\n    this._removeDocumentEvents();\n  }; // remove listeners\n\n\n  _proto._removeDocumentEvents = function _removeDocumentEvents() {\n    this.onMouseMoveListener.remove();\n    this.onMouseUpListener.remove();\n  }; // if the mouse is out of the area\n\n\n  _proto._mouseOutArea = function _mouseOutArea(ev) {\n    var el = this.get('canvas').get('el');\n    var el_bbox = el.getBoundingClientRect();\n    var parent = this.get('parent');\n    var bbox = parent.getBBox();\n    var left = parent.attr('matrix')[6];\n    var top = parent.attr('matrix')[7];\n    var right = left + bbox.width;\n    var bottom = top + bbox.height;\n    var mouseX = ev.clientX - el_bbox.x;\n    var mouseY = ev.clientY - el_bbox.y;\n\n    if (mouseX < left || mouseX > right || mouseY < top || mouseY > bottom) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return Slider;\n}(Group);\n\nmodule.exports = Slider;\n\n/***/ }),\n/* 328 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The class of the gradient color legend\n * @author sima.zhang\n */\n\n\nvar Util = __webpack_require__(3);\n\nvar Continuous = __webpack_require__(67);\n\nvar Size =\n/*#__PURE__*/\nfunction (_Continuous) {\n  _inheritsLoose(Size, _Continuous);\n\n  function Size() {\n    return _Continuous.apply(this, arguments) || this;\n  }\n\n  var _proto = Size.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Continuous.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'size-legend',\n      width: 100,\n      height: 200,\n\n      /**\n       * 不能滑动时圈的样式\n       * @type {ATTRS}\n       */\n      _unslidableElementStyle: {\n        fill: '#4E7CCC',\n        fillOpacity: 1\n      },\n\n      /**\n       * 中间 bar 的前景颜色\n       * @type {ATTRS}\n       */\n      frontMiddleBarStyle: {\n        fill: 'rgb(64, 141, 251)'\n      }\n    });\n  }; // render the slider shape\n\n\n  _proto._renderSliderShape = function _renderSliderShape() {\n    var slider = this.get('slider');\n    var backgroundElement = slider.get('backgroundElement');\n    var layout = this.get('layout');\n    var width = this.get('width');\n    var height = this.get('height'); // const x = minRadius;\n\n    var y = this.get('height') / 2;\n    var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar\n\n    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, y + height / 2], [0, y + height / 2 - 4], [width, y - height / 2], [width, y + height / 2]];\n    return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({\n      points: points\n    }, frontMiddleBarStyle));\n  }; // render the middle bar while slidable === false,\n  // there are no triggers for this situation\n\n\n  _proto._renderUnslidable = function _renderUnslidable() {\n    var layout = this.get('layout');\n    var width = this.get('width');\n    var height = this.get('height');\n    var frontMiddleBarStyle = this.get('frontMiddleBarStyle');\n    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [width - 4, height]] : [[0, height], [0, height - 4], [width, 0], [width, height]];\n    var group = this.get('group');\n    var bgGroup = group.addGroup();\n    bgGroup.addShape('Polygon', {\n      attrs: Util.mix({\n        points: points\n      }, frontMiddleBarStyle)\n    });\n\n    var minText = this._formatItemValue(this.get('firstItem').value);\n\n    var maxText = this._formatItemValue(this.get('lastItem').value);\n\n    if (this.get('layout') === 'vertical') {\n      this._addText(width + 10, height - 3, minText); // min\n\n\n      this._addText(width + 10, 3, maxText); // max\n\n    } else {\n      this._addText(0, height, minText); // min\n\n\n      this._addText(width, height, maxText); // max\n\n    }\n  }; // add min and max text while slidable === false\n\n\n  _proto._addText = function _addText(x, y, text) {\n    var group = this.get('group');\n    var textGroup = group.addGroup();\n    var textStyle = this.get('textStyle');\n    var titleShape = this.get('titleShape');\n    var titleGap = this.get('titleGap');\n\n    if (titleShape) {\n      titleGap += titleShape.getBBox().height;\n    }\n\n    if (this.get('layout') === 'vertical') {\n      textGroup.addShape('text', {\n        attrs: Util.mix({\n          x: x + this.get('textOffset'),\n          y: y,\n          text: text === 0 ? '0' : text\n        }, textStyle)\n      });\n    } else {\n      y += titleGap + this.get('textOffset') - 20;\n      if (!titleShape) y += 10;\n      textGroup.addShape('text', {\n        attrs: Util.mix({\n          x: x,\n          y: y,\n          text: text === 0 ? '0' : text\n        }, textStyle)\n      });\n    }\n  };\n\n  return Size;\n}(Continuous);\n\nmodule.exports = Size;\n\n/***/ }),\n/* 329 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The class of the size legend\n * @author sima.zhang\n * @author ye liu\n */\n\n\nvar Util = __webpack_require__(3); // const Global = require('../../global');\n\n\nvar Continuous = __webpack_require__(67);\n\nvar SLIDER_HEIGHT = 2;\nvar CIRCLE_GAP = 16;\nvar MAX_SIZE = 16;\nvar MIN_SIZE = 5;\n\nvar CircleSize =\n/*#__PURE__*/\nfunction (_Continuous) {\n  _inheritsLoose(CircleSize, _Continuous);\n\n  function CircleSize() {\n    return _Continuous.apply(this, arguments) || this;\n  }\n\n  var _proto = CircleSize.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Continuous.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'size-circle-legend',\n      width: 100,\n      height: 200,\n\n      /**\n       * 不能滑动时圈的样式\n       * @type {ATTRS}\n       */\n      _unslidableCircleStyle: {\n        stroke: 'rgb(99, 161, 248)',\n        fill: 'rgb(99, 161, 248)',\n        fillOpacity: 0.3,\n        lineWidth: 1.5\n      },\n\n      /**\n       * 滑块的样式\n       * @type {ATTRS}\n       */\n      triggerAttr: {\n        fill: 'white',\n        shadowOffsetX: -2,\n        shadowOffsetY: 2,\n        shadowBlur: 10,\n        shadowColor: '#ccc'\n      },\n\n      /**\n       * 中间 bar 的前景颜色\n       * @type {ATTRS}\n       */\n      frontMiddleBarStyle: {\n        fill: 'rgb(64, 141, 251)'\n      }\n    });\n  }; // render the slider shape\n\n\n  _proto._renderSliderShape = function _renderSliderShape() {\n    var minRadius = MIN_SIZE;\n    var slider = this.get('slider');\n    var backgroundElement = slider.get('backgroundElement');\n    var layout = this.get('layout');\n    var width = layout === 'vertical' ? SLIDER_HEIGHT : this.get('width');\n    var height = layout === 'vertical' ? this.get('height') : SLIDER_HEIGHT;\n    var x = minRadius;\n    var y = this.get('height') / 2;\n    var frontMiddleBarStyle = this.get('frontMiddleBarStyle'); // background of middle bar\n\n    var points = layout === 'vertical' ? [[0, 0], [width, 0], [width, height], [0, height]] : [[0, y + height], [0, y - height], [x + width - 4, y - height], [x + width - 4, y + height]];\n    return this._addMiddleBar(backgroundElement, 'Polygon', Util.mix({\n      points: points\n    }, frontMiddleBarStyle));\n  }; // triggers while layout === horizontal\n\n\n  _proto._addHorizontalTrigger = function _addHorizontalTrigger(type, blockAttr, textAttr, radius) {\n    var slider = this.get('slider');\n    var trigger = slider.get(type + 'HandleElement');\n    var y = -this.get('height') / 2;\n    var button = trigger.addShape('circle', {\n      attrs: Util.mix({\n        x: 0,\n        y: y,\n        r: radius\n      }, blockAttr)\n    });\n    var text = trigger.addShape('text', {\n      attrs: Util.mix(textAttr, {\n        x: 0,\n        y: y + radius + 10,\n        textAlign: 'center',\n        textBaseline: 'middle'\n      })\n    });\n    var layout = this.get('layout');\n    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';\n    button.attr('cursor', trigerCursor);\n    text.attr('cursor', trigerCursor);\n    this.set(type + 'ButtonElement', button);\n    this.set(type + 'TextElement', text);\n  }; // triggers while layout === vertical\n\n\n  _proto._addVerticalTrigger = function _addVerticalTrigger(type, blockAttr, textAttr, radius) {\n    var slider = this.get('slider');\n    var trigger = slider.get(type + 'HandleElement');\n    var button = trigger.addShape('circle', {\n      attrs: Util.mix({\n        x: 0,\n        y: 0,\n        r: radius\n      }, blockAttr)\n    });\n    var text = trigger.addShape('text', {\n      attrs: Util.mix(textAttr, {\n        x: radius + 10,\n        y: 0,\n        textAlign: 'start',\n        textBaseline: 'middle'\n      })\n    });\n    var layout = this.get('layout');\n    var trigerCursor = layout === 'vertical' ? 'ns-resize' : 'ew-resize';\n    button.attr('cursor', trigerCursor);\n    text.attr('cursor', trigerCursor);\n    this.set(type + 'ButtonElement', button);\n    this.set(type + 'TextElement', text);\n  }; // render the triggers\n\n\n  _proto._renderTrigger = function _renderTrigger() {\n    var min = this.get('firstItem');\n    var max = this.get('lastItem');\n    var layout = this.get('layout');\n    var textStyle = this.get('textStyle');\n    var triggerAttr = this.get('triggerAttr');\n    var minBlockAttr = Util.mix({}, triggerAttr);\n    var maxBlockAttr = Util.mix({}, triggerAttr);\n    var minRadius = MIN_SIZE;\n    var maxRadius = MAX_SIZE;\n    var minTextAttr = Util.mix({\n      text: this._formatItemValue(min.value) + ''\n    }, textStyle);\n    var maxTextAttr = Util.mix({\n      text: this._formatItemValue(max.value) + ''\n    }, textStyle);\n\n    if (layout === 'vertical') {\n      this._addVerticalTrigger('min', minBlockAttr, minTextAttr, minRadius);\n\n      this._addVerticalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);\n    } else {\n      this._addHorizontalTrigger('min', minBlockAttr, minTextAttr, minRadius);\n\n      this._addHorizontalTrigger('max', maxBlockAttr, maxTextAttr, maxRadius);\n    }\n  }; // user interactions\n\n\n  _proto._bindEvents = function _bindEvents() {\n    var _this = this;\n\n    if (this.get('slidable')) {\n      var slider = this.get('slider');\n      slider.on('sliderchange', function (ev) {\n        var range = ev.range;\n\n        var firstItemValue = _this.get('firstItem').value;\n\n        var lastItemValue = _this.get('lastItem').value;\n\n        var minValue = firstItemValue + range[0] / 100 * (lastItemValue - firstItemValue);\n        var maxValue = firstItemValue + range[1] / 100 * (lastItemValue - firstItemValue);\n        var minRadius = MIN_SIZE + range[0] / 100 * (MAX_SIZE - MIN_SIZE);\n        var maxRadius = MIN_SIZE + range[1] / 100 * (MAX_SIZE - MIN_SIZE);\n\n        _this._updateElement(minValue, maxValue, minRadius, maxRadius);\n\n        var itemFiltered = new Event('itemfilter', ev, true, true);\n        itemFiltered.range = [minValue, maxValue];\n\n        _this.emit('itemfilter', itemFiltered);\n      });\n    }\n  }; // update the triggers\n\n\n  _proto._updateElement = function _updateElement(min, max, minR, maxR) {\n    // update the text of the triggers\n    _Continuous.prototype._updateElement.call(this, min, max);\n\n    var minTextElement = this.get('minTextElement');\n    var maxTextElement = this.get('maxTextElement');\n    var minCircleElement = this.get('minButtonElement');\n    var maxCircleElement = this.get('maxButtonElement'); // update the radius of the triggers\n\n    minCircleElement.attr('r', minR);\n    maxCircleElement.attr('r', maxR); // update the text position of the triggers\n\n    var layout = this.get('layout');\n\n    if (layout === 'vertical') {\n      minTextElement.attr('x', minR + 10);\n      maxTextElement.attr('x', maxR + 10);\n    } else {\n      var y = -this.get('height') / 2;\n      minTextElement.attr('y', y + minR + 10);\n      maxTextElement.attr('y', y + maxR + 10);\n    }\n  }; // add a circle for slidable === false\n\n\n  _proto._addCircle = function _addCircle(x, y, r, text, maxWidth) {\n    var group = this.get('group');\n    var circleGroup = group.addGroup();\n    var circleStyle = this.get('_unslidableCircleStyle');\n    var textStyle = this.get('textStyle');\n    var titleShape = this.get('titleShape');\n    var titleGap = this.get('titleGap');\n\n    if (titleShape) {\n      titleGap += titleShape.getBBox().height;\n    }\n\n    circleGroup.addShape('circle', {\n      attrs: Util.mix({\n        x: x,\n        y: y + titleGap,\n        r: r === 0 ? 1 : r\n      }, circleStyle)\n    });\n\n    if (this.get('layout') === 'vertical') {\n      circleGroup.addShape('text', {\n        attrs: Util.mix({\n          x: maxWidth + 20 + this.get('textOffset'),\n          y: y + titleGap,\n          text: text === 0 ? '0' : text\n        }, textStyle)\n      });\n    } else {\n      circleGroup.addShape('text', {\n        attrs: Util.mix({\n          x: x,\n          y: y + titleGap + maxWidth + 13 + this.get('textOffset'),\n          text: text === 0 ? '0' : text\n        }, textStyle)\n      });\n    }\n  }; // the circles while slidable === false\n\n\n  _proto._renderUnslidable = function _renderUnslidable() {\n    var firstItemValue = this.get('firstItem').value;\n    var lastItemValue = this.get('lastItem').value;\n\n    if (firstItemValue > lastItemValue) {\n      var tmp = lastItemValue;\n      lastItemValue = firstItemValue;\n      firstItemValue = tmp;\n    }\n\n    var minText = this._formatItemValue(firstItemValue);\n\n    var maxText = this._formatItemValue(lastItemValue);\n\n    var minRadius = firstItemValue < MIN_SIZE ? MIN_SIZE : firstItemValue;\n    var maxRadius = lastItemValue > MAX_SIZE ? MAX_SIZE : lastItemValue;\n\n    if (minRadius > maxRadius) {\n      minRadius = MIN_SIZE;\n      maxRadius = MAX_SIZE;\n    }\n\n    if (this.get('layout') === 'vertical') {\n      this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min\n\n\n      this._addCircle(maxRadius, maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxText, 2 * maxRadius); // max\n\n    } else {\n      this._addCircle(maxRadius, maxRadius, minRadius, minText, 2 * maxRadius); // min\n\n\n      this._addCircle(maxRadius * 2 + CIRCLE_GAP + minRadius, maxRadius, maxRadius, maxText, 2 * maxRadius); // max\n\n    }\n  };\n\n  _proto.activate = function activate(value) {\n    if (!this.get('slidable')) {\n      return;\n    }\n\n    _Continuous.prototype.activate.call(this, value);\n  };\n\n  return CircleSize;\n}(Continuous);\n\nmodule.exports = CircleSize;\n\n/***/ }),\n/* 330 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Tooltip = __webpack_require__(68);\n\nTooltip.Html = __webpack_require__(331);\nTooltip.Canvas = __webpack_require__(163);\nTooltip.Mini = __webpack_require__(333);\nmodule.exports = Tooltip;\n\n/***/ }),\n/* 331 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar Tooltip = __webpack_require__(68);\n\nvar Util = __webpack_require__(3);\n\nvar DomUtil = Util.DomUtil;\n\nvar TooltipTheme = __webpack_require__(332);\n\nvar Crosshair = __webpack_require__(160);\n\nvar PositionMixin = __webpack_require__(161);\n\nvar MarkerGroupMixin = __webpack_require__(162);\n\nvar CONTAINER_CLASS = 'g2-tooltip';\nvar TITLE_CLASS = 'g2-tooltip-title';\nvar LIST_CLASS = 'g2-tooltip-list';\nvar MARKER_CLASS = 'g2-tooltip-marker';\nvar VALUE_CLASS = 'g2-tooltip-value';\nvar LIST_ITEM_CLASS = 'g2-tooltip-list-item';\n\nfunction find(dom, cls) {\n  return dom.getElementsByClassName(cls)[0];\n}\n\nfunction mergeStyles(styles, cfg) {\n  Object.keys(styles).forEach(function (k) {\n    if (cfg[k]) {\n      styles[k] = Util.mix(styles[k], cfg[k]);\n    }\n  });\n  return styles;\n}\n\nvar HtmlTooltip =\n/*#__PURE__*/\nfunction (_Tooltip) {\n  _inheritsLoose(HtmlTooltip, _Tooltip);\n\n  var _proto = HtmlTooltip.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Tooltip.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n         * tooltip 容器模板\n         * @type {String}\n      */\n      containerTpl: ' <div class=\"' + CONTAINER_CLASS + '\"> ' + '<div class=\"' + TITLE_CLASS + '\"></div>' + '<ul class=\"' + LIST_CLASS + '\"></ul>' + '</div>',\n\n      /**\n       * tooltip 列表项模板\n       * @type {String}\n       */\n      itemTpl: '<li data-index={index}>' + '<span style=\"background-color:{color};\" class=' + MARKER_CLASS + '></span>' + '{name}<span class=' + VALUE_CLASS + '>{value}</span></li>',\n\n      /**\n       * tooltip html内容\n       * @type {String}\n       */\n      htmlContent: null,\n\n      /**\n       * tooltip 内容跟随鼠标移动\n       * @type {Boolean}\n       */\n      follow: true,\n\n      /**\n       * 是否允许鼠标停留在 tooltip 上，默认不允许\n       * @type {Boolean}\n       */\n      enterable: false\n    });\n  };\n\n  function HtmlTooltip(cfg) {\n    var _this;\n\n    _this = _Tooltip.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), PositionMixin);\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), MarkerGroupMixin);\n    var style = TooltipTheme;\n    _this.style = mergeStyles(style, cfg);\n\n    _this._init_();\n\n    if (_this.get('items')) {\n      _this.render();\n    } // crosshair\n\n\n    var crosshair = _this.get('crosshairs');\n\n    if (crosshair) {\n      var plot = crosshair.type === 'rect' ? _this.get('backPlot') : _this.get('frontPlot');\n      var crosshairGroup = new Crosshair(Util.mix({\n        plot: plot,\n        plotRange: _this.get('plotRange'),\n        canvas: _this.get('canvas')\n      }, _this.get('crosshairs')));\n      crosshairGroup.hide();\n\n      _this.set('crosshairGroup', crosshairGroup);\n    }\n\n    return _this;\n  }\n\n  _proto._init_ = function _init_() {\n    var self = this;\n    var containerTpl = self.get('containerTpl');\n    var outterNode = self.get('canvas').get('el').parentNode;\n    var container;\n\n    if (!this.get('htmlContent')) {\n      if (/^\\#/.test(containerTpl)) {\n        // 如果传入 dom 节点的 id\n        var id = containerTpl.replace('#', '');\n        container = document.getElementById(id);\n      } else {\n        container = DomUtil.createDom(containerTpl);\n        DomUtil.modifyCSS(container, self.style[CONTAINER_CLASS]);\n        outterNode.appendChild(container);\n        outterNode.style.position = 'relative';\n      }\n\n      self.set('container', container);\n    }\n  };\n\n  _proto.render = function render() {\n    var self = this;\n    self.clear();\n\n    if (self.get('htmlContent')) {\n      var outterNode = self.get('canvas').get('el').parentNode;\n\n      var container = self._getHtmlContent();\n\n      outterNode.appendChild(container);\n      self.set('container', container);\n    } else {\n      self._renderTpl();\n    }\n  };\n\n  _proto._renderTpl = function _renderTpl() {\n    var self = this;\n    var showTitle = self.get('showTitle');\n    var titleContent = self.get('titleContent');\n    var container = self.get('container');\n    var titleDom = find(container, TITLE_CLASS);\n    var listDom = find(container, LIST_CLASS);\n    var items = self.get('items');\n\n    if (titleDom && showTitle) {\n      DomUtil.modifyCSS(titleDom, self.style[TITLE_CLASS]);\n      titleDom.innerHTML = titleContent;\n    }\n\n    if (listDom) {\n      DomUtil.modifyCSS(listDom, self.style[LIST_CLASS]);\n      Util.each(items, function (item, index) {\n        listDom.appendChild(self._addItem(item, index));\n      });\n    }\n  };\n\n  _proto.clear = function clear() {\n    var container = this.get('container');\n\n    if (this.get('htmlContent')) {\n      container && container.remove();\n    } else {\n      var titleDom = find(container, TITLE_CLASS);\n      var listDom = find(container, LIST_CLASS);\n\n      if (titleDom) {\n        titleDom.innerHTML = '';\n      }\n\n      if (listDom) {\n        listDom.innerHTML = '';\n      }\n    }\n  };\n\n  _proto.show = function show() {\n    var container = this.get('container');\n    container.style.visibility = 'visible';\n    container.style.display = 'block';\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.show();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.show();\n\n    _Tooltip.prototype.show.call(this);\n\n    this.get('canvas').draw();\n  };\n\n  _proto.hide = function hide() {\n    var container = this.get('container');\n    container.style.visibility = 'hidden';\n    container.style.display = 'none';\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.hide();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.hide();\n\n    _Tooltip.prototype.hide.call(this);\n\n    this.get('canvas').draw();\n  };\n\n  _proto.destroy = function destroy() {\n    var self = this;\n    var container = self.get('container');\n    var containerTpl = self.get('containerTpl');\n\n    if (container && !/^\\#/.test(containerTpl)) {\n      container.parentNode.removeChild(container);\n    }\n\n    var crosshairGroup = this.get('crosshairGroup');\n    crosshairGroup && crosshairGroup.destroy();\n    var markerGroup = this.get('markerGroup');\n    markerGroup && markerGroup.remove();\n\n    _Tooltip.prototype.destroy.call(this);\n  };\n\n  _proto._addItem = function _addItem(item, index) {\n    var itemTpl = this.get('itemTpl'); // TODO: 有可能是个回调函数\n\n    var itemDiv = Util.substitute(itemTpl, Util.mix({\n      index: index\n    }, item));\n    var itemDOM = DomUtil.createDom(itemDiv);\n    DomUtil.modifyCSS(itemDOM, this.style[LIST_ITEM_CLASS]);\n    var markerDom = find(itemDOM, MARKER_CLASS);\n\n    if (markerDom) {\n      DomUtil.modifyCSS(markerDom, this.style[MARKER_CLASS]);\n    }\n\n    var valueDom = find(itemDOM, VALUE_CLASS);\n\n    if (valueDom) {\n      DomUtil.modifyCSS(valueDom, this.style[VALUE_CLASS]);\n    }\n\n    return itemDOM;\n  };\n\n  _proto._getHtmlContent = function _getHtmlContent() {\n    var htmlContent = this.get('htmlContent');\n    var title = this.get('titleContent');\n    var items = this.get('items');\n    var htmlString = htmlContent(title, items);\n    var ele = DomUtil.createDom(htmlString);\n    return ele;\n  };\n\n  _proto.setPosition = function setPosition(x, y, target) {\n    var container = this.get('container');\n    var outterNode = this.get('canvas').get('el');\n    var viewWidth = DomUtil.getWidth(outterNode);\n    var viewHeight = DomUtil.getHeight(outterNode);\n    var containerWidth = container.clientWidth;\n    var containerHeight = container.clientHeight;\n    var endx = x;\n    var endy = y;\n    var position;\n    var prePosition = this.get('prePosition') || {\n      x: 0,\n      y: 0\n    };\n\n    if (this.get('enterable')) {\n      y = y - container.clientHeight / 2;\n      position = [x, y];\n\n      if (prePosition && x - prePosition.x > 0) {\n        // 留 1px 防止鼠标点击事件无法在画布上触发\n        x -= container.clientWidth + 1;\n      } else {\n        x += 1;\n      }\n    } else if (this.get('position')) {\n      var _containerWidth = container.clientWidth;\n      var _containerHeight = container.clientHeight;\n      position = this._calcTooltipPosition(x, y, this.get('position'), _containerWidth, _containerHeight, target);\n      x = position[0];\n      y = position[1];\n    } else {\n      position = this._constraintPositionInBoundary(x, y, containerWidth, containerHeight, viewWidth, viewHeight);\n      x = position[0];\n      y = position[1];\n    }\n\n    if (this.get('inPlot')) {\n      // tooltip 必须限制在绘图区域内\n      var plotRange = this.get('plotRange');\n      position = this._constraintPositionInPlot(x, y, containerWidth, containerHeight, plotRange, this.get('enterable'));\n      x = position[0];\n      y = position[1];\n    }\n\n    var markerItems = this.get('markerItems');\n\n    if (!Util.isEmpty(markerItems)) {\n      endx = markerItems[0].x;\n      endy = markerItems[0].y;\n    }\n\n    this.set('prePosition', position); // 记录上次的位置\n\n    var follow = this.get('follow');\n\n    if (follow) {\n      container.style.left = x + 'px';\n      container.style.top = y + 'px';\n    }\n\n    var crosshairGroup = this.get('crosshairGroup');\n\n    if (crosshairGroup) {\n      var items = this.get('items');\n      crosshairGroup.setPosition(endx, endy, items);\n    }\n\n    _Tooltip.prototype.setPosition.call(this, x, y);\n  };\n\n  return HtmlTooltip;\n}(Tooltip);\n\nmodule.exports = HtmlTooltip;\n\n/***/ }),\n/* 332 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _TooltipTheme;\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY; // tooltip 相关 dom 的 css 类名\n\n\nvar TOOLTIP_CONTAINER_CLASS = 'g2-tooltip';\nvar TOOLTIP_TITLE_CLASS = 'g2-tooltip-title';\nvar TOOLTIP_LIST_CLASS = 'g2-tooltip-list';\nvar TOOLTIP_LIST_ITEM_CLASS = 'g2-tooltip-list-item';\nvar TOOLTIP_MARKER_CLASS = 'g2-tooltip-marker';\nvar TOOLTIP_VALUE_CLASS = 'g2-tooltip-value';\nvar TooltipTheme = (_TooltipTheme = {\n  crosshairs: false,\n  offset: 15\n}, _TooltipTheme[\"\" + TOOLTIP_CONTAINER_CLASS] = {\n  position: 'absolute',\n  visibility: 'hidden',\n  // @2018-07-25 by blue.lb 这里去掉浮动，火狐上存在样式错位\n  // whiteSpace: 'nowrap',\n  zIndex: 8,\n  transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',\n  backgroundColor: 'rgba(255, 255, 255, 0.9)',\n  boxShadow: '0px 0px 10px #aeaeae',\n  borderRadius: '3px',\n  color: 'rgb(87, 87, 87)',\n  fontSize: '12px',\n  fontFamily: FONT_FAMILY,\n  lineHeight: '20px',\n  padding: '10px 10px 6px 10px'\n}, _TooltipTheme[\"\" + TOOLTIP_TITLE_CLASS] = {\n  marginBottom: '4px'\n}, _TooltipTheme[\"\" + TOOLTIP_LIST_CLASS] = {\n  margin: 0,\n  listStyleType: 'none',\n  padding: 0\n}, _TooltipTheme[\"\" + TOOLTIP_LIST_ITEM_CLASS] = {\n  marginBottom: '4px'\n}, _TooltipTheme[\"\" + TOOLTIP_MARKER_CLASS] = {\n  width: '5px',\n  height: '5px',\n  borderRadius: '50%',\n  display: 'inline-block',\n  marginRight: '8px'\n}, _TooltipTheme[\"\" + TOOLTIP_VALUE_CLASS] = {\n  display: 'inline-block',\n  float: 'right',\n  marginLeft: '30px'\n}, _TooltipTheme);\nmodule.exports = TooltipTheme;\n\n/***/ }),\n/* 333 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Util = __webpack_require__(3);\n\nvar CanvasTooltip = __webpack_require__(163);\n\nvar _require = __webpack_require__(14),\n    FONT_FAMILY = _require.FONT_FAMILY;\n\nvar DomUtil = Util.DomUtil;\nvar MatrixUtil = Util.MatrixUtil;\n\nvar MiniTooltip =\n/*#__PURE__*/\nfunction (_CanvasTooltip) {\n  _inheritsLoose(MiniTooltip, _CanvasTooltip);\n\n  function MiniTooltip() {\n    return _CanvasTooltip.apply(this, arguments) || this;\n  }\n\n  var _proto = MiniTooltip.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _CanvasTooltip.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * 默认背景板样式\n       * @type {Object}\n       */\n      boardStyle: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        // fill: 'rgba(50, 50, 50, 1)',\n        radius: 3\n      },\n\n      /**\n       * 默认value样式\n       * @type {Object}\n       * */\n      valueStyle: {\n        x: 0,\n        y: 0,\n        text: '',\n        fontFamily: FONT_FAMILY,\n        fontSize: 12,\n        stroke: '#fff',\n        lineWidth: 2,\n        fill: 'black',\n        textBaseline: 'top',\n        textAlign: 'start'\n      },\n\n      /**\n       * 默认padding值\n       * @type {Object}\n       */\n      padding: {\n        top: 5,\n        right: 5,\n        bottom: 0,\n        left: 5\n      },\n      triangleWidth: 10,\n      triangleHeight: 4\n    });\n  };\n\n  _proto._init_ = function _init_() {\n    var self = this;\n    var padding = self.get('padding');\n    var parent = self.get('frontPlot'); // container\n\n    var container = parent.addGroup();\n    self.set('container', container); // board\n\n    var board = container.addShape('rect', {\n      attrs: Util.mix({}, self.get('boardStyle'))\n    });\n    self.set('board', board); // triangleShpe\n\n    var triangleShape = container.addShape('path', {\n      attrs: {\n        fill: self.get('boardStyle').fill\n      }\n    });\n    self.set('triangleShape', triangleShape); // itemGroup\n\n    var itemGroup = container.addGroup();\n    itemGroup.move(padding.left, padding.top); // value\n\n    var valueShape = itemGroup.addShape('text', {\n      attrs: Util.mix({}, self.get('valueStyle'))\n    });\n    self.set('valueShape', valueShape);\n  };\n\n  _proto.render = function render() {\n    var self = this;\n    self.clear();\n    var board = self.get('board');\n    var valueShape = self.get('valueShape');\n    var padding = self.get('padding');\n    var item = self.get('items')[0];\n\n    if (valueShape) {\n      valueShape.attr('text', item.value);\n    } // update board based on bbox\n\n\n    var bbox = valueShape ? valueShape.getBBox() : {\n      width: 80,\n      height: 30\n    };\n    var width = padding.left + bbox.width + padding.right;\n    var height = padding.top + bbox.height + padding.bottom;\n    board.attr('width', width);\n    board.attr('height', height); // update triangle shape\n\n    self._centerTriangleShape();\n  };\n\n  _proto.clear = function clear() {\n    var valueShape = this.get('valueShape');\n    valueShape.attr('text', '');\n  };\n\n  _proto.setPosition = function setPosition(x, y, target) {\n    var self = this;\n    var container = self.get('container');\n    var plotRange = self.get('plotRange');\n    var bbox = container.getBBox();\n    var width = bbox.width;\n    var height = bbox.height;\n    x -= width / 2;\n\n    if (target && (target.name === 'point' || target.name === 'interval')) {\n      var targetY = target.getBBox().y;\n      y = targetY;\n    }\n\n    y -= height;\n\n    if (this.get('inPlot')) {\n      // constrain in plot\n      if (x < plotRange.tl.x) {\n        x = plotRange.tl.x;\n\n        self._leftTriangleShape();\n      } else if (x + width / 2 > plotRange.tr.x) {\n        x = plotRange.tr.x - width;\n\n        self._rightTriangleShape();\n      } else {\n        self._centerTriangleShape();\n      }\n\n      if (y < plotRange.tl.y) {\n        y = plotRange.tl.y;\n      } else if (y + height > plotRange.bl.y) {\n        y = plotRange.bl.y - height;\n      }\n    } else {\n      // constrain in dom\n      var outterNode = this.get('canvas').get('el');\n      var viewWidth = DomUtil.getWidth(outterNode);\n      var viewHeight = DomUtil.getHeight(outterNode);\n\n      if (x < 0) {\n        x = 0;\n\n        self._leftTriangleShape();\n      } else if (x + width / 2 > viewWidth) {\n        x = viewWidth - width;\n\n        self._rightTriangleShape();\n      } else {\n        self._centerTriangleShape();\n      }\n\n      if (y < 0) {\n        y = 0;\n      } else if (y + height > viewHeight) {\n        y = viewHeight - height;\n      }\n    }\n\n    var ulMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var mat = MatrixUtil.transform(ulMatrix, [['t', x, y]]);\n    container.stopAnimate();\n    container.animate({\n      matrix: mat\n    }, this.get('animationDuration'));\n  };\n\n  _proto._centerTriangleShape = function _centerTriangleShape() {\n    var triangle = this.get('triangleShape');\n    var width = this.get('triangleWidth');\n    var height = this.get('triangleHeight');\n    var boardBBox = this.get('board').getBBox();\n    var boardWidth = boardBBox.width;\n    var boardHeight = boardBBox.height;\n    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width / 2, height], ['L', 0, 0], ['Z']];\n    triangle.attr('path', pathArray);\n    triangle.move(boardWidth / 2 - width / 2, boardHeight - 1);\n  };\n\n  _proto._leftTriangleShape = function _leftTriangleShape() {\n    var triangle = this.get('triangleShape');\n    var width = this.get('triangleWidth');\n    var height = this.get('triangleHeight');\n    var boardBBox = this.get('board').getBBox();\n    var boardHeight = boardBBox.height;\n    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', 0, height + 3], ['L', 0, 0], ['Z']];\n    triangle.attr('path', pathArray);\n    triangle.move(0, boardHeight - 3);\n  };\n\n  _proto._rightTriangleShape = function _rightTriangleShape() {\n    var triangle = this.get('triangleShape');\n    var width = this.get('triangleWidth');\n    var height = this.get('triangleHeight');\n    var boardBBox = this.get('board').getBBox();\n    var boardWidth = boardBBox.width;\n    var boardHeight = boardBBox.height;\n    var pathArray = [['M', 0, 0], ['L', width, 0], ['L', width, height + 4], ['L', 0, 0], ['Z']];\n    triangle.attr('path', pathArray);\n    triangle.move(boardWidth - width - 1, boardHeight - 4);\n  };\n\n  return MiniTooltip;\n}(CanvasTooltip);\n\nmodule.exports = MiniTooltip;\n\n/***/ }),\n/* 334 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MatrixUtil = __webpack_require__(0).MatrixUtil;\n\nvar Vector2 = MatrixUtil.vec2;\n\nfunction smoothBezier(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min, max;\n\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = Vector2.min([], min, point);\n      max = Vector2.max([], max, point);\n    }\n\n    min = Vector2.min([], min, constraint[0]);\n    max = Vector2.max([], max, constraint[1]);\n  }\n\n  for (var _i = 0, len = points.length; _i < len; _i++) {\n    var _point = points[_i];\n\n    if (isLoop) {\n      prevPoint = points[_i ? _i - 1 : len - 1];\n      nextPoint = points[(_i + 1) % len];\n    } else {\n      if (_i === 0 || _i === len - 1) {\n        cps.push(_point);\n        continue;\n      } else {\n        prevPoint = points[_i - 1];\n        nextPoint = points[_i + 1];\n      }\n    }\n\n    var v = [];\n    v = Vector2.sub(v, nextPoint, prevPoint);\n    v = Vector2.scale(v, v, smooth);\n    var d0 = Vector2.distance(_point, prevPoint);\n    var d1 = Vector2.distance(_point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    var v1 = Vector2.scale([], v, -d0);\n    var v2 = Vector2.scale([], v, d1);\n    var cp0 = Vector2.add([], _point, v1);\n    var cp1 = Vector2.add([], _point, v2);\n\n    if (hasConstraint) {\n      cp0 = Vector2.max([], cp0, min);\n      cp0 = Vector2.min([], cp0, max);\n      cp1 = Vector2.max([], cp1, min);\n      cp1 = Vector2.min([], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nfunction catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var _i2 = 0; _i2 < len - 1; _i2++) {\n    cp1 = controlPointList[_i2 * 2];\n    cp2 = controlPointList[_i2 * 2 + 1];\n    p = pointList[_i2 + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n}\n\nmodule.exports = {\n  catmullRom2bezier: catmullRom2bezier\n};\n\n/***/ }),\n/* 335 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar PolarLabels = __webpack_require__(164);\n\nvar PathUtil = __webpack_require__(22);\n\nvar Global = __webpack_require__(7);\n\nvar MARGIN = 5;\n\nfunction getEndPoint(center, angle, r) {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle)\n  };\n}\n\nfunction antiCollision(labels, lineHeight, plotRange, center, isRight) {\n  // adjust y position of labels to avoid overlapping\n  var overlapping = true;\n  var start = plotRange.start;\n  var end = plotRange.end;\n  var startY = Math.min(start.y, end.y);\n  var totalHeight = Math.abs(start.y - end.y);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n\n    if (label.y < minY) {\n      minY = label.y;\n    }\n\n    return {\n      size: lineHeight,\n      targets: [label.y - startY]\n    };\n  });\n  minY -= startY;\n\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size); // box.pos = Math.max(0, target - box.size / 2);\n    }); // detect overlapping and join boxes\n\n    overlapping = false;\n    i = boxes.length;\n\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n\n          boxes.splice(i, 1); // removing box\n\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0; // step 4: normalize y and adjust x\n\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + lineHeight / 2; // middle of the label\n\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += lineHeight;\n      i++;\n    });\n  }); // (x - cx)^2 + (y - cy)^2 = totalR^2\n\n  labels.forEach(function (label) {\n    var rPow2 = label.r * label.r;\n    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n\n    if (rPow2 < dyPow2) {\n      label.x = center.x;\n    } else {\n      var dx = Math.sqrt(rPow2 - dyPow2);\n\n      if (!isRight) {\n        // left\n        label.x = center.x - dx;\n      } else {\n        // right\n        label.x = center.x + dx;\n      }\n    }\n  });\n}\n\nvar PieLabels =\n/*#__PURE__*/\nfunction (_PolarLabels) {\n  _inheritsLoose(PieLabels, _PolarLabels);\n\n  function PieLabels() {\n    return _PolarLabels.apply(this, arguments) || this;\n  }\n\n  var _proto = PieLabels.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      label: Global.thetaLabels\n    };\n  };\n\n  _proto.getDefaultOffset = function getDefaultOffset(point) {\n    return point.offset || 0;\n  };\n  /**\n   * @protected\n   * to avoid overlapping\n   * @param {Array} items labels to be placed\n   * @return {Array} items\n   */\n\n\n  _proto.adjustItems = function adjustItems(items) {\n    var self = this;\n    var offset = items[0] ? items[0].offset : 0;\n\n    if (offset > 0) {\n      items = self._distribute(items, offset);\n    }\n\n    return _PolarLabels.prototype.adjustItems.call(this, items);\n  };\n  /**\n   * @private\n   * distribute labels\n   * @param {Array} labels labels\n   * @param {Number} offset offset\n   * @return {Array} labels\n   */\n\n\n  _proto._distribute = function _distribute(labels, offset) {\n    var self = this;\n    var coord = self.get('coord');\n    var radius = coord.getRadius();\n    var lineHeight = self.get('label').labelHeight;\n    var center = coord.getCenter();\n    var totalR = radius + offset;\n    var totalHeight = totalR * 2 + lineHeight * 2;\n    var plotRange = {\n      start: coord.start,\n      end: coord.end\n    };\n    var geom = self.get('geom');\n\n    if (geom) {\n      var view = geom.get('view');\n      plotRange = view.getViewRegion();\n    } // step 1: separate labels\n\n\n    var halves = [[], // left\n    [] // right\n    ];\n    labels.forEach(function (label) {\n      if (!label) {\n        return;\n      }\n\n      if (label.textAlign === 'right') {\n        // left\n        halves[0].push(label);\n      } else {\n        // right or center will be put on the right side\n        halves[1].push(label);\n      }\n    });\n    halves.forEach(function (half, index) {\n      // step 2: reduce labels\n      var maxLabelsCountForOneSide = parseInt(totalHeight / lineHeight, 10);\n\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort(function (a, b) {\n          // sort by percentage DESC\n          return b['..percent'] - a['..percent'];\n        });\n        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n      } // step 3: distribute position (x and y)\n\n\n      half.sort(function (a, b) {\n        // sort by y ASC\n        return a.y - b.y;\n      });\n      antiCollision(half, lineHeight, plotRange, center, index);\n    });\n    return halves[0].concat(halves[1]);\n  }; // 连接线\n\n\n  _proto.lineToLabel = function lineToLabel(label) {\n    var self = this;\n    var coord = self.get('coord');\n    var r = coord.getRadius();\n    var distance = label.offset;\n    var angle = label.orignAngle || label.angle;\n    var center = coord.getCenter();\n    var start = getEndPoint(center, angle, r + MARGIN / 2);\n    var inner = getEndPoint(center, angle, r + distance / 2);\n\n    if (!label.labelLine) {\n      label.labelLine = self.get('label').labelLine || {};\n    }\n\n    label.labelLine.path = ['M' + start.x, start.y + ' Q' + inner.x, inner.y + ' ' + label.x, label.y].join(',');\n  };\n  /**\n   * @protected\n   * get rotation for label\n   * @param {Number} angle angle\n   * @param {Number} offset offset\n   * @return {Number} rotate\n   */\n\n\n  _proto.getLabelRotate = function getLabelRotate(angle, offset) {\n    var rotate;\n\n    if (offset < 0) {\n      rotate = angle * 180 / Math.PI;\n\n      if (rotate > 90) {\n        rotate = rotate - 180;\n      }\n\n      if (rotate < -90) {\n        rotate = rotate + 180;\n      }\n    }\n\n    return rotate / 180 * Math.PI;\n  };\n  /**\n   * @protected\n   * get text align for label\n   * @param {Object} point point\n   * @return {String} align\n   */\n\n\n  _proto.getLabelAlign = function getLabelAlign(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var center = coord.getCenter();\n    var align;\n\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n\n    var offset = self.getDefaultOffset(point);\n\n    if (offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n\n    return align;\n  };\n\n  _proto.getArcPoint = function getArcPoint(point) {\n    return point;\n  };\n\n  _proto.getPointAngle = function getPointAngle(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var startPoint = {\n      x: Util.isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0]\n    };\n    self.transLabelPoint(startPoint); // 转换到画布坐标，如果坐标系发生改变\n\n    var endPoint = {\n      x: Util.isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1]\n    };\n    self.transLabelPoint(endPoint); // 转换到画布坐标，如果坐标系发生改变\n\n    var angle;\n    var startAngle = PathUtil.getPointAngle(coord, startPoint);\n\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      var endAngle = PathUtil.getPointAngle(coord, endPoint);\n\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n\n    return angle;\n  };\n\n  _proto.getCirclePoint = function getCirclePoint(angle, offset) {\n    var self = this;\n    var coord = self.get('coord');\n    var center = coord.getCenter();\n    var r = coord.getRadius() + offset;\n    var point = getEndPoint(center, angle, r);\n    point.angle = angle;\n    point.r = r;\n    return point;\n  };\n\n  return PieLabels;\n}(PolarLabels);\n\nmodule.exports = PieLabels;\n\n/***/ }),\n/* 336 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GeomLabels = __webpack_require__(65);\n\nvar IntervalLabels =\n/*#__PURE__*/\nfunction (_GeomLabels) {\n  _inheritsLoose(IntervalLabels, _GeomLabels);\n\n  function IntervalLabels() {\n    return _GeomLabels.apply(this, arguments) || this;\n  }\n\n  var _proto = IntervalLabels.prototype;\n\n  _proto.setLabelPosition = function setLabelPosition(point, originPoint, index, position) {\n    if (Util.isFunction(position)) {\n      position = position(point.text, originPoint._origin, index);\n    }\n\n    var coord = this.get('coord');\n    var transposed = coord.isTransposed;\n    var point0 = coord.convertPoint(originPoint.points[0]);\n    var point1 = coord.convertPoint(originPoint.points[2]);\n    var width = (point0.x - point1.x) / 2 * (transposed ? -1 : 1);\n    var height = (point0.y - point1.y) / 2 * (transposed ? -1 : 1);\n\n    switch (position) {\n      case 'right':\n        if (transposed) {\n          point.x -= width;\n          point.y += height;\n          point.textAlign = point.textAlign || 'center';\n        } else {\n          point.x -= width;\n          point.y += height;\n          point.textAlign = point.textAlign || 'left';\n        }\n\n        break;\n\n      case 'left':\n        if (transposed) {\n          point.x -= width;\n          point.y -= height;\n          point.textAlign = point.textAlign || 'center';\n        } else {\n          point.x += width;\n          point.y += height;\n          point.textAlign = point.textAlign || 'right';\n        }\n\n        break;\n\n      case 'bottom':\n        if (transposed) {\n          point.x -= width * 2;\n          point.textAlign = point.textAlign || 'left';\n        } else {\n          point.y += height * 2;\n          point.textAlign = point.textAlign || 'center';\n        }\n\n        break;\n\n      case 'middle':\n        if (transposed) {\n          point.x -= width;\n        } else {\n          point.y += height;\n        }\n\n        point.textAlign = point.textAlign || 'center';\n        break;\n\n      case 'top':\n        if (transposed) {\n          point.textAlign = point.textAlign || 'left';\n        } else {\n          point.textAlign = point.textAlign || 'center';\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  return IntervalLabels;\n}(GeomLabels);\n\nmodule.exports = IntervalLabels;\n\n/***/ }),\n/* 337 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The tooltip handler\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(7),\n    defaultColor = _require.defaultColor;\n\nvar FIELD_ORIGIN = '_origin';\n\nfunction getScaleName(scale) {\n  return scale.alias || scale.field;\n}\n\nvar TooltipMixin = {\n  _getIntervalSize: function _getIntervalSize(obj) {\n    var size = null;\n    var type = this.get('type');\n    var coord = this.get('coord');\n\n    if (coord.isRect && (type === 'interval' || type === 'schema')) {\n      size = this.getSize(obj[FIELD_ORIGIN]); // 如果字段发生了映射，宽度计算就会报错\n\n      var dim = coord.isTransposed ? 'y' : 'x';\n\n      if (Util.isArray(obj[dim])) {\n        var width = Math.abs(obj[dim][1] - obj[dim][0]);\n        size = size < width ? null : size; // 直方图计算错误\n      }\n    }\n\n    return size;\n  },\n  _snapEqual: function _snapEqual(v1, v2, scale) {\n    var equals;\n    v1 = scale.translate(v1);\n    v2 = scale.translate(v2);\n\n    if (scale.isCategory) {\n      equals = v1 === v2;\n    } else {\n      equals = Util.snapEqual(v1, v2);\n    }\n\n    return equals;\n  },\n  _getScaleValueByPoint: function _getScaleValueByPoint(point) {\n    var result = 0;\n    var coord = this.get('coord');\n    var xScale = this.getXScale();\n    var invertPoint = coord.invert(point);\n    var xValue = invertPoint.x;\n\n    if (this.isInCircle() && xValue > (1 + xScale.rangeMax()) / 2) {\n      xValue = xScale.rangeMin(); // 极坐标下，scale 的 range 被做过特殊处理 see view.js#L88\n    }\n\n    result = xScale.invert(xValue);\n\n    if (xScale.isCategory) {\n      result = xScale.translate(result); // 防止分类类型\n    }\n\n    return result;\n  },\n  _getOriginByPoint: function _getOriginByPoint(point) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var xField = xScale.field;\n    var yField = yScale.field;\n    var coord = this.get('coord');\n    var invertPoint = coord.invert(point);\n    var xValue = xScale.invert(invertPoint.x);\n    var yValue = yScale.invert(invertPoint.y);\n    var result = {};\n    result[xField] = xValue;\n    result[yField] = yValue;\n    return result;\n  },\n  _getScale: function _getScale(field) {\n    var self = this;\n    var scales = self.get('scales');\n    var rst = null;\n    Util.each(scales, function (scale) {\n      if (scale.field === field) {\n        rst = scale;\n        return false;\n      }\n    });\n    return rst;\n  },\n  // 获取值对应的度量\n  _getTipValueScale: function _getTipValueScale() {\n    var attrs = this.getAttrsForLegend();\n    var scale;\n    Util.each(attrs, function (attr) {\n      var tmpScale = attr.getScale(attr.type);\n\n      if (tmpScale.isLinear) {\n        // 如果指定字段是非position的，同时是连续的\n        scale = tmpScale;\n        return false;\n      }\n    });\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n\n    if (!scale && yScale && yScale.field === '..y') {\n      return xScale;\n    }\n\n    return scale || yScale || xScale;\n  },\n  _getTipTitleScale: function _getTipTitleScale(titleField) {\n    var self = this;\n\n    if (titleField) {\n      return self._getScale(titleField);\n    }\n\n    var position = self.getAttr('position');\n    var fields = position.getFields();\n    var tmpField;\n    Util.each(fields, function (field) {\n      if (field.indexOf('..') === -1) {\n        tmpField = field;\n        return false;\n      }\n    });\n    return self._getScale(tmpField);\n  },\n  _filterValue: function _filterValue(arr, point) {\n    var coord = this.get('coord');\n    var yScale = this.getYScale();\n    var yField = yScale.field;\n    var invertPoint = coord.invert(point);\n    var yValue = invertPoint.y;\n    yValue = yScale.invert(yValue);\n    var rst = arr[arr.length - 1];\n    Util.each(arr, function (obj) {\n      var origin = obj[FIELD_ORIGIN];\n\n      if (origin[yField][0] <= yValue && origin[yField][1] >= yValue) {\n        rst = obj;\n        return false;\n      }\n    });\n    return rst;\n  },\n  getXDistance: function getXDistance() {\n    var self = this;\n    var distance = self.get('xDistance');\n\n    if (!distance) {\n      var xScale = self.getXScale();\n\n      if (xScale.isCategory) {\n        distance = 1;\n      } else {\n        var values = xScale.values; // values 是无序的\n\n        var min = xScale.translate(values[0]);\n        var max = min;\n        Util.each(values, function (value) {\n          // 时间类型需要 translate\n          value = xScale.translate(value);\n\n          if (value < min) {\n            min = value;\n          }\n\n          if (value > max) {\n            max = value;\n          }\n        });\n        var length = values.length; // 应该是除以 length - 1\n\n        distance = (max - min) / (length - 1);\n      }\n\n      self.set('xDistance', distance);\n    }\n\n    return distance;\n  },\n  findPoint: function findPoint(point, dataArray) {\n    var self = this;\n    var type = self.get('type');\n    var xScale = self.getXScale();\n    var yScale = self.getYScale();\n    var xField = xScale.field;\n    var yField = yScale.field;\n    var rst = null;\n\n    if (Util.indexOf(['heatmap', 'point'], type) > -1) {\n      var coord = self.get('coord');\n      var invertPoint = coord.invert(point);\n      var xValue = xScale.invert(invertPoint.x);\n      var yValue = yScale.invert(invertPoint.y);\n      var min = Infinity;\n      Util.each(dataArray, function (obj) {\n        var distance = Math.pow(obj[FIELD_ORIGIN][xField] - xValue, 2) + Math.pow(obj[FIELD_ORIGIN][yField] - yValue, 2);\n\n        if (distance < min) {\n          min = distance;\n          rst = obj;\n        }\n      });\n      return rst;\n    }\n\n    var first = dataArray[0];\n    var last = dataArray[dataArray.length - 1];\n\n    if (!first) {\n      return rst;\n    }\n\n    var value = self._getScaleValueByPoint(point); // 根据该点获得对应度量后数据的值\n\n\n    var firstXValue = first[FIELD_ORIGIN][xField];\n    var firstYValue = first[FIELD_ORIGIN][yField];\n    var lastXValue = last[FIELD_ORIGIN][xField];\n    var isYRange = yScale.isLinear && Util.isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n    // 如果x的值是数组\n\n    if (Util.isArray(firstXValue)) {\n      Util.each(dataArray, function (record) {\n        var origin = record[FIELD_ORIGIN];\n\n        if (xScale.translate(origin[xField][0]) <= value && xScale.translate(origin[xField][1]) >= value) {\n          if (isYRange) {\n            if (!Util.isArray(rst)) {\n              rst = [];\n            }\n\n            rst.push(record);\n          } else {\n            rst = record;\n            return false;\n          }\n        }\n      });\n\n      if (Util.isArray(rst)) {\n        rst = this._filterValue(rst, point);\n      }\n    } else {\n      var next;\n\n      if (!xScale.isLinear && xScale.type !== 'timeCat') {\n        Util.each(dataArray, function (record, index) {\n          var origin = record[FIELD_ORIGIN];\n\n          if (self._snapEqual(origin[xField], value, xScale)) {\n            if (isYRange) {\n              if (!Util.isArray(rst)) {\n                rst = [];\n              }\n\n              rst.push(record);\n            } else {\n              rst = record;\n              return false;\n            }\n          } else if (xScale.translate(origin[xField]) <= value) {\n            last = record;\n            next = dataArray[index + 1];\n          }\n        });\n\n        if (Util.isArray(rst)) {\n          rst = this._filterValue(rst, point);\n        }\n      } else {\n        if ((value > xScale.translate(lastXValue) || value < xScale.translate(firstXValue)) && (value > xScale.max || value < xScale.min)) {\n          return null;\n        }\n\n        var firstIdx = 0;\n        var lastIdx = dataArray.length - 1;\n        var middleIdx;\n\n        while (firstIdx <= lastIdx) {\n          middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n          var item = dataArray[middleIdx][FIELD_ORIGIN][xField];\n\n          if (self._snapEqual(item, value, xScale)) {\n            return dataArray[middleIdx];\n          }\n\n          if (xScale.translate(item) <= xScale.translate(value)) {\n            firstIdx = middleIdx + 1;\n            last = dataArray[middleIdx];\n            next = dataArray[middleIdx + 1];\n          } else {\n            if (lastIdx === 0) {\n              last = dataArray[0];\n            }\n\n            lastIdx = middleIdx - 1;\n          }\n        }\n      }\n\n      if (last && next) {\n        // 计算最逼近的\n        if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - value)) {\n          last = next;\n        }\n      }\n    }\n\n    var distance = self.getXDistance(); // 每个分类间的平均间距\n\n    if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - value) <= distance / 2) {\n      rst = last;\n    }\n\n    return rst;\n  },\n\n  /**\n   * @protected\n   * 获取tooltip的标题\n   * @param  {Object} origin 点的原始信息\n   * @param  {String} titleField 标题的字段\n   * @return {String} 提示信息的标题\n   */\n  getTipTitle: function getTipTitle(origin, titleField) {\n    var tipTitle = '';\n\n    var titleScale = this._getTipTitleScale(titleField);\n\n    if (titleScale) {\n      var value = origin[titleScale.field];\n      tipTitle = titleScale.getText(value);\n    } else if (this.get('type') === 'heatmap') {\n      // 热力图在不存在 title 的时候特殊处理\n      var xScale = this.getXScale();\n      var yScale = this.getYScale();\n      var xValue = xScale.getText(origin[xScale.field]);\n      var yValue = yScale.getText(origin[yScale.field]);\n      tipTitle = '( ' + xValue + ', ' + yValue + ' )';\n    }\n\n    return tipTitle;\n  },\n  getTipValue: function getTipValue(origin, valueScale) {\n    var value;\n    var field = valueScale.field;\n    var key = origin.key;\n    value = origin[field];\n\n    if (Util.isArray(value)) {\n      var tmp = [];\n      Util.each(value, function (sub) {\n        tmp.push(valueScale.getText(sub));\n      });\n      value = tmp.join('-');\n    } else {\n      value = valueScale.getText(value, key);\n    }\n\n    return value;\n  },\n\n  /**\n   * @protected\n   * 获取tooltip的名称\n   * @param  {Object} origin 点的原始信息\n   * @return {String} 提示信息的名称\n   */\n  getTipName: function getTipName(origin) {\n    var name;\n    var nameScale;\n\n    var groupScales = this._getGroupScales();\n\n    if (groupScales.length) {\n      // 如果存在分组类型，取第一个分组类型\n      Util.each(groupScales, function (scale) {\n        nameScale = scale;\n        return false;\n      });\n    }\n\n    if (nameScale) {\n      var field = nameScale.field;\n      name = nameScale.getText(origin[field]);\n    } else {\n      var valueScale = this._getTipValueScale();\n\n      name = getScaleName(valueScale);\n    }\n\n    return name;\n  },\n\n  /**\n   * 获取点对应tooltip的信息\n   * @protected\n   * @param  {Object} point 原始的数据记录\n   * @param  {String} titleField tooltipTitle 配置信息\n   * @return {Array}  一条或者多条记录\n   */\n  getTipItems: function getTipItems(point, titleField) {\n    var self = this;\n    var origin = point[FIELD_ORIGIN];\n    var tipTitle = self.getTipTitle(origin, titleField);\n    var tooltipCfg = self.get('tooltipCfg');\n    var items = [];\n    var name;\n    var value;\n\n    function addItem(itemName, itemValue, cfg) {\n      if (!Util.isNil(itemValue) && itemValue !== '') {\n        // 值为null的时候，忽视\n        var item = {\n          title: tipTitle,\n          point: point,\n          name: itemName || tipTitle,\n          value: itemValue,\n          color: point.color || defaultColor,\n          marker: true\n        };\n        item.size = self._getIntervalSize(point);\n        items.push(Util.mix({}, item, cfg));\n      }\n    }\n\n    if (tooltipCfg) {\n      var fields = tooltipCfg.fields;\n      var cfg = tooltipCfg.cfg;\n      var callbackParams = [];\n      Util.each(fields, function (field) {\n        callbackParams.push(origin[field]);\n      });\n\n      if (cfg) {\n        // 存在回调函数\n        if (Util.isFunction(cfg)) {\n          cfg = cfg.apply(null, callbackParams);\n        }\n\n        var itemCfg = Util.mix({}, {\n          point: point,\n          title: tipTitle,\n          color: point.color || defaultColor,\n          marker: true // 默认展示 marker\n\n        }, cfg);\n        itemCfg.size = self._getIntervalSize(point);\n        items.push(itemCfg);\n      } else {\n        Util.each(fields, function (field) {\n          if (!Util.isNil(origin[field])) {\n            // 字段数据为null ,undefined时不显示\n            var scale = self._getScale(field);\n\n            name = getScaleName(scale);\n            value = scale.getText(origin[field]);\n            addItem(name, value);\n          }\n        });\n      }\n    } else {\n      var valueScale = self._getTipValueScale();\n\n      if (!Util.isNil(origin[valueScale.field])) {\n        // 字段数据为null ,undefined时不显示\n        value = self.getTipValue(origin, valueScale);\n        name = self.getTipName(origin);\n        addItem(name, value);\n      }\n    }\n\n    return items;\n  },\n  isShareTooltip: function isShareTooltip() {\n    var shareTooltip = this.get('shareTooltip');\n    var type = this.get('type');\n    var view = this.get('view');\n    var options;\n\n    if (view.get('parent')) {\n      options = view.get('parent').get('options');\n    } else {\n      options = view.get('options');\n    }\n\n    if (type === 'interval') {\n      var coord = this.get('coord');\n      var coordType = coord.type;\n\n      if (coordType === 'theta' || coordType === 'polar' && coord.isTransposed) {\n        shareTooltip = false;\n      }\n    } else if (!this.getYScale() || Util.inArray(['contour', 'point', 'polygon', 'edge'], type)) {\n      shareTooltip = false;\n    }\n\n    if (options.tooltip && Util.isBoolean(options.tooltip.shared)) {\n      // 以用户设置的为准\n      shareTooltip = options.tooltip.shared;\n    }\n\n    return shareTooltip;\n  }\n};\nmodule.exports = TooltipMixin;\n\n/***/ }),\n/* 338 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview the interaction when geom was actived\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar FIELD_ORIGIN = '_origin';\n\nfunction isSameShape(shape1, shape2) {\n  if (Util.isNil(shape1) || Util.isNil(shape2)) {\n    return false;\n  }\n\n  var shape1Origin = shape1.get('origin');\n  var shape2Origin = shape2.get('origin');\n  return Util.isEqual(shape1Origin, shape2Origin);\n}\n\nfunction isChange(preShapes, shapes) {\n  if (!preShapes) {\n    return true;\n  }\n\n  if (preShapes.length !== shapes.length) {\n    return true;\n  }\n\n  var rst = false;\n  Util.each(shapes, function (shape, index) {\n    if (!isSameShape(shape, preShapes[index])) {\n      rst = true;\n      return false;\n    }\n  });\n  return rst;\n}\n\nfunction getOriginAttrs(activeCfg, shape) {\n  var originAttrs = {};\n  Util.each(activeCfg, function (v, k) {\n    var originValue = shape.attr(k);\n\n    if (Util.isArray(originValue)) {\n      originValue = Util.cloneDeep(originValue); // 缓存原来的属性，由于 .attr('matrix') 是数组，所以此处需要深度复制\n    }\n\n    originAttrs[k] = originValue;\n  });\n  return originAttrs;\n}\n\nvar ActiveMixin = {\n  _isAllowActive: function _isAllowActive() {\n    var allowActive = this.get('allowActive');\n\n    if (Util.isNil(allowActive)) {\n      // 用户未设置，使用默认的策略\n      var view = this.get('view');\n      var isShareTooltip = this.isShareTooltip();\n      var options = view.get('options'); // 默认情况下，tooltip 关闭或者 tooltip 模式为 shared === false 的时候允许 active\n\n      if (options.tooltip === false || !isShareTooltip) {\n        return true;\n      }\n    } else {\n      return allowActive;\n    }\n\n    return false;\n  },\n  _onMouseenter: function _onMouseenter(ev) {\n    var self = this;\n    var shape = ev.shape;\n    var shapeContainer = self.get('shapeContainer');\n\n    if (shape && shapeContainer.contain(shape) && self._isAllowActive()) {\n      // shape.get('animating')\n      self.setShapesActived(shape);\n    }\n  },\n  _onMouseleave: function _onMouseleave() {\n    var self = this;\n    var view = self.get('view');\n    var canvas = view.get('canvas');\n\n    if (self.get('activeShapes')) {\n      self.clearActivedShapes();\n      canvas.draw();\n    }\n  },\n  _bindActiveAction: function _bindActiveAction() {\n    var self = this;\n    var view = self.get('view');\n    var type = self.get('type');\n    view.on(type + ':mouseenter', Util.wrapBehavior(self, '_onMouseenter'));\n    view.on(type + ':mouseleave', Util.wrapBehavior(self, '_onMouseleave'));\n  },\n  _offActiveAction: function _offActiveAction() {\n    var self = this;\n    var view = self.get('view');\n    var type = self.get('type');\n    view.off(type + ':mouseenter', Util.getWrapBehavior(self, '_onMouseenter'));\n    view.off(type + ':mouseleave', Util.getWrapBehavior(self, '_onMouseleave'));\n  },\n  _setActiveShape: function _setActiveShape(shape) {\n    var self = this;\n    var activedOptions = self.get('activedOptions') || {};\n    var shapeData = shape.get('origin');\n    var shapeName = shapeData.shape || self.getDefaultValue('shape');\n\n    if (Util.isArray(shapeName)) {\n      shapeName = shapeName[0];\n    }\n\n    var shapeFactory = self.get('shapeFactory');\n    var shapeCfg = Util.mix({}, shape.attr(), {\n      origin: shapeData\n    });\n    var activeCfg = shapeFactory.getActiveCfg(shapeName, shapeCfg);\n\n    if (activedOptions.style) {\n      Util.mix(activeCfg, activedOptions.style);\n    }\n\n    var originAttrs = getOriginAttrs(activeCfg, shape);\n    shape.setSilent('_originAttrs', originAttrs);\n\n    if (activedOptions.animate) {\n      shape.animate(activeCfg, 300);\n    } else {\n      shape.attr(activeCfg);\n    }\n\n    shape.set('zIndex', 1); // 提前\n  },\n  setShapesActived: function setShapesActived(shapes) {\n    var self = this;\n\n    if (!Util.isArray(shapes)) {\n      shapes = [shapes];\n    }\n\n    var preShapes = self.get('activeShapes'); // 获取上次被激活的 shapes\n\n    if (!isChange(preShapes, shapes)) {\n      return;\n    }\n\n    var view = self.get('view');\n    var canvas = view.get('canvas');\n    var shapeContainer = self.get('shapeContainer');\n    var activedOptions = self.get('activedOptions');\n\n    if (activedOptions && activedOptions.highlight) {\n      // 上次的动画未完成，所以要停止掉动画\n      Util.each(shapes, function (shape) {\n        if (shape.get('animating')) {\n          shape.stopAnimate();\n        }\n      });\n      self.highlightShapes(shapes);\n    } else {\n      if (preShapes) {\n        self.clearActivedShapes(); // 先清除激活元素\n      }\n\n      Util.each(shapes, function (shape) {\n        if (shape.get('animating')) {\n          shape.stopAnimate();\n        }\n\n        if (shape.get('visible') && !shape.get('selected')) {\n          self._setActiveShape(shape);\n        }\n      });\n    }\n\n    self.set('activeShapes', shapes);\n    shapeContainer.sort();\n    canvas.draw();\n  },\n  clearActivedShapes: function clearActivedShapes() {\n    var self = this;\n    var shapeContainer = self.get('shapeContainer');\n    var activedOptions = self.get('activedOptions');\n    var activeAnimate = activedOptions && activedOptions.animate;\n\n    if (shapeContainer && !shapeContainer.get('destroyed')) {\n      var activeShapes = self.get('activeShapes');\n      Util.each(activeShapes, function (activeShape) {\n        if (!activeShape.get('selected')) {\n          var originAttrs = activeShape.get('_originAttrs');\n\n          if (activeAnimate) {\n            activeShape.stopAnimate();\n            activeShape.animate(originAttrs, 300);\n          } else {\n            activeShape.attr(originAttrs);\n          }\n\n          activeShape.setZIndex(0);\n          activeShape.set('_originAttrs', null);\n        }\n      });\n      var preHighlightShapes = self.get('preHighlightShapes');\n\n      if (preHighlightShapes) {\n        var shapes = shapeContainer.get('children');\n        Util.each(shapes, function (shape) {\n          if (!shape.get('selected')) {\n            var originAttrs = shape.get('_originAttrs');\n\n            if (originAttrs) {\n              if (activeAnimate) {\n                shape.stopAnimate();\n                shape.animate(originAttrs, 300);\n              } else {\n                shape.attr(originAttrs);\n              }\n\n              shape.setZIndex(0);\n              shape.set('_originAttrs', null);\n            }\n          }\n        });\n      } // 恢复原来排序\n\n\n      var children = shapeContainer.get('children');\n      children.sort(function (obj1, obj2) {\n        return obj1._INDEX - obj2._INDEX;\n      });\n      self.set('activeShapes', null);\n      self.set('preHighlightShapes', null);\n    }\n  },\n  getGroupShapesByPoint: function getGroupShapesByPoint(point) {\n    var self = this;\n    var shapeContainer = self.get('shapeContainer');\n    var activeShapes = [];\n\n    if (shapeContainer) {\n      var xField = self.getXScale().field;\n      var shapes = self.getShapes();\n\n      var originObj = self._getOriginByPoint(point);\n\n      Util.each(shapes, function (shape) {\n        var origin = shape.get('origin');\n\n        if (shape.get('visible') && origin) {\n          // 有可能不是图形，而是label文本，所以判断一下\n          var shapeXValue = origin[FIELD_ORIGIN][xField];\n\n          if (shapeXValue === originObj[xField]) {\n            activeShapes.push(shape);\n          }\n        }\n      });\n    }\n\n    return activeShapes;\n  },\n  getSingleShapeByPoint: function getSingleShapeByPoint(point) {\n    var self = this;\n    var shapeContainer = self.get('shapeContainer');\n    var canvas = shapeContainer.get('canvas');\n    var pixelRatio = canvas.get('pixelRatio');\n    var result;\n\n    if (shapeContainer) {\n      result = shapeContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);\n    }\n\n    if (result && result.get('origin')) {\n      return result;\n    }\n  },\n  highlightShapes: function highlightShapes(_highlightShapes, highlightCfg) {\n    var self = this;\n\n    if (!Util.isArray(_highlightShapes)) {\n      _highlightShapes = [_highlightShapes];\n    }\n\n    var preHighlightShapes = self.get('activeShapes'); // 获取上次被激活的 shapes\n\n    if (!isChange(preHighlightShapes, _highlightShapes)) {\n      return;\n    }\n\n    if (preHighlightShapes) {\n      self.clearActivedShapes();\n    }\n\n    var shapes = self.getShapes();\n    var activedOptions = self.get('activedOptions');\n    var activeAnimate = activedOptions && activedOptions.animate;\n    var activeStyle = activedOptions && activedOptions.style;\n    Util.each(shapes, function (shape) {\n      var changeAttrs = {};\n      shape.stopAnimate();\n\n      if (Util.indexOf(_highlightShapes, shape) !== -1) {\n        Util.mix(changeAttrs, activeStyle, highlightCfg);\n        shape.setZIndex(1); // 提前\n      } else {\n        Util.mix(changeAttrs, {\n          fillOpacity: 0.3,\n          // @2018-07-11 by blue.lb 由于线图只有stoke，fillOpacity不生效，最好还是直接改成整个图形透明度opacity\n          opacity: 0.3\n        });\n        shape.setZIndex(0);\n      }\n\n      var originAttrs = getOriginAttrs(changeAttrs, shape);\n      shape.setSilent('_originAttrs', originAttrs);\n\n      if (activeAnimate) {\n        shape.animate(changeAttrs, 300);\n      } else {\n        shape.attr(changeAttrs);\n      }\n    });\n    self.set('preHighlightShapes', _highlightShapes);\n    self.set('activeShapes', _highlightShapes);\n  }\n};\nmodule.exports = ActiveMixin;\n\n/***/ }),\n/* 339 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview the interaction when geom was selected\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar FIELD_ORIGIN = '_origin';\n\nfunction isSameShape(shape1, shape2) {\n  if (Util.isNil(shape1) || Util.isNil(shape2)) {\n    return false;\n  }\n\n  var shape1Origin = shape1.get('origin');\n  var shape2Origin = shape2.get('origin');\n  return Util.isEqual(shape1Origin, shape2Origin);\n}\n\nfunction getOriginAttrs(selectedCfg, shape) {\n  var originAttrs = {};\n  Util.each(selectedCfg, function (v, k) {\n    if (k === 'transform') {\n      k = 'matrix';\n    }\n\n    var originValue = shape.attr(k);\n\n    if (Util.isArray(originValue)) {\n      originValue = Util.cloneDeep(originValue); // 缓存原来的属性，由于 .attr('matrix') 是数组，所以此处需要深度复制\n    }\n\n    originAttrs[k] = originValue;\n  });\n  return originAttrs;\n}\n\nvar SelectMixin = {\n  _isAllowSelect: function _isAllowSelect() {\n    var isAllowSelect = this.get('allowSelect');\n\n    if (Util.isNil(isAllowSelect)) {\n      var type = this.get('type');\n      var coord = this.get('coord');\n      var coordType = coord && coord.type;\n\n      if (type === 'interval' && coordType === 'theta') {\n        // 饼图默认可以进行选中\n        return true;\n      }\n    } else {\n      // 用户设置了 select 配置\n      return isAllowSelect;\n    }\n\n    return false;\n  },\n  _onClick: function _onClick(ev) {\n    var self = this;\n\n    if (self._isAllowSelect()) {\n      // 允许选中下才执行\n      self.clearActivedShapes(); // 清除hover效果\n\n      var shape = ev.shape;\n      var shapeContainer = self.get('shapeContainer');\n\n      if (shape && !shape.get('animating') && shapeContainer.contain(shape)) {\n        self.setShapeSelected(shape);\n      }\n    }\n  },\n  _bindSelectedAction: function _bindSelectedAction() {\n    var self = this;\n    var view = self.get('view');\n    var type = self.get('type');\n    view.on(type + ':click', Util.wrapBehavior(self, '_onClick'));\n  },\n  _offSelectedAction: function _offSelectedAction() {\n    var self = this;\n    var view = self.get('view');\n    var type = self.get('type');\n    view.off(type + ':click', Util.getWrapBehavior(self, '_onClick'));\n  },\n  _setShapeStatus: function _setShapeStatus(shape, status) {\n    var self = this;\n    var view = self.get('view');\n    var selectedOptions = self.get('selectedOptions') || {};\n    var animate = selectedOptions.animate !== false; // 默认允许动画\n\n    var canvas = view.get('canvas');\n    shape.set('selected', status);\n    var shapeData = shape.get('origin');\n\n    if (status) {\n      // 选中状态\n      var shapeName = shapeData.shape || self.getDefaultValue('shape');\n\n      if (Util.isArray(shapeName)) {\n        shapeName = shapeName[0];\n      }\n\n      var shapeFactory = self.get('shapeFactory');\n      var cfg = Util.mix({\n        geom: self,\n        point: shapeData\n      }, selectedOptions);\n      var selectedStyle = shapeFactory.getSelectedCfg(shapeName, cfg);\n      Util.mix(selectedStyle, cfg.style); // 用户设置的优先级更高\n\n      if (!shape.get('_originAttrs')) {\n        // 缓存原有属性\n        if (shape.get('animating')) {\n          // 停止动画\n          shape.stopAnimate();\n        }\n\n        shape.set('_originAttrs', getOriginAttrs(selectedStyle, shape));\n      }\n\n      if (animate) {\n        shape.animate(selectedStyle, 300);\n      } else {\n        shape.attr(selectedStyle);\n        canvas.draw();\n      }\n    } else {\n      var originAttrs = shape.get('_originAttrs');\n      shape.set('_originAttrs', null);\n\n      if (animate) {\n        shape.animate(originAttrs, 300);\n      } else {\n        shape.attr(originAttrs);\n        canvas.draw();\n      }\n    }\n  },\n  setShapeSelected: function setShapeSelected(shape) {\n    var self = this;\n\n    var selectedShapes = self._getSelectedShapes();\n\n    var selectedOptions = self.get('selectedOptions') || {};\n    var cancelable = selectedOptions.cancelable !== false; // 选中状态是否允许取消，默认允许\n\n    if (selectedOptions.mode === 'multiple') {\n      // 支持多选\n      if (Util.indexOf(selectedShapes, shape) === -1) {\n        selectedShapes.push(shape);\n\n        self._setShapeStatus(shape, true);\n      } else if (cancelable) {\n        // 图形已经被选中并且选中状态允许取消选中\n        Util.Array.remove(selectedShapes, shape);\n\n        self._setShapeStatus(shape, false);\n      }\n    } else {\n      var selectedShape = selectedShapes[0];\n\n      if (cancelable) {\n        // 如果允许取消，则选中null\n        shape = isSameShape(selectedShape, shape) ? null : shape;\n      }\n\n      if (!isSameShape(selectedShape, shape)) {\n        if (selectedShape) {\n          self._setShapeStatus(selectedShape, false);\n        }\n\n        if (shape) {\n          self._setShapeStatus(shape, true);\n        }\n      }\n    }\n  },\n  clearSelected: function clearSelected() {\n    var self = this;\n    var shapeContainer = self.get('shapeContainer');\n\n    if (shapeContainer && !shapeContainer.get('destroyed')) {\n      var selectedShapes = self._getSelectedShapes();\n\n      Util.each(selectedShapes, function (shape) {\n        self._setShapeStatus(shape, false);\n\n        shape.set('_originAttrs', null);\n      });\n    }\n  },\n\n  /**\n   * 设置记录对应的图形选中\n   * @param {Object} record 选中的记录\n   * @chainable\n   * @return {Geom} 返回当前的 Geometry\n   */\n  setSelected: function setSelected(record) {\n    var self = this;\n    var shapes = self.getShapes();\n    Util.each(shapes, function (shape) {\n      var origin = shape.get('origin');\n\n      if (origin && origin[FIELD_ORIGIN] === record) {\n        self.setShapeSelected(shape);\n      }\n    });\n    return this;\n  },\n  _getSelectedShapes: function _getSelectedShapes() {\n    var self = this;\n    var shapes = self.getShapes();\n    var selectedShapes = [];\n    Util.each(shapes, function (shape) {\n      if (shape.get('selected')) {\n        selectedShapes.push(shape);\n      }\n    });\n    self.set('selectedShapes', selectedShapes);\n    return selectedShapes;\n  }\n};\nmodule.exports = SelectMixin;\n\n/***/ }),\n/* 340 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nmodule.exports = function (field) {\n  if (Util.isArray(field)) {\n    return field;\n  }\n\n  if (Util.isString(field)) {\n    return field.split('*');\n  }\n\n  return [field];\n};\n\n/***/ }),\n/* 341 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 度量的控制器\n * @author dxq613@gmail.com\n */\nvar Scale = __webpack_require__(74);\n\nvar Util = __webpack_require__(0);\n\nvar dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))(\\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;\nvar TYPES = {\n  LINEAR: 'linear',\n  CAT: 'cat',\n  TIME: 'time'\n};\n\nvar ScaleController =\n/*#__PURE__*/\nfunction () {\n  function ScaleController(cfg) {\n    // defs 列定义\n    this.defs = {};\n    this.viewTheme = {\n      scales: {}\n    }; // filtered fields\n\n    this.filters = {};\n    Util.assign(this, cfg);\n  }\n\n  var _proto = ScaleController.prototype;\n\n  _proto._getDef = function _getDef(field) {\n    var defs = this.defs;\n    var viewTheme = this.viewTheme;\n    var def = null;\n\n    if (viewTheme.scales[field] || defs[field]) {\n      def = Util.mix({}, viewTheme.scales[field]); // 处理覆盖属性的问题\n\n      Util.each(defs[field], function (v, k) {\n        if (Util.isNil(v)) {\n          delete def[k];\n        } else {\n          def[k] = v;\n        }\n      });\n\n      if (this.filters[field]) {\n        delete def.min;\n        delete def.max;\n      }\n    }\n\n    return def;\n  };\n\n  _proto._getDefaultType = function _getDefaultType(field, data) {\n    var type = TYPES.LINEAR;\n    var value = Util.Array.firstValue(data, field);\n\n    if (Util.isArray(value)) {\n      value = value[0];\n    }\n\n    if (dateRegex.test(value)) {\n      type = TYPES.TIME;\n    } else if (Util.isString(value)) {\n      type = TYPES.CAT;\n    }\n\n    return type;\n  };\n\n  _proto._getScaleCfg = function _getScaleCfg(type, field, data) {\n    var cfg = {\n      field: field\n    };\n    var values = Util.Array.values(data, field);\n    cfg.values = values;\n\n    if (!Scale.isCategory(type) && type !== 'time') {\n      var range = Util.Array.getRange(values);\n      cfg.min = range.min;\n      cfg.max = range.max;\n      cfg.nice = true;\n    }\n\n    if (type === 'time') {\n      cfg.nice = false;\n    }\n\n    return cfg;\n  };\n\n  _proto.createScale = function createScale(field, data) {\n    var self = this;\n\n    var def = self._getDef(field);\n\n    var scale; // 如果数据为空直接返回常量度量\n\n    if (!data || !data.length) {\n      if (def && def.type) {\n        scale = Scale[def.type](def);\n      } else {\n        scale = Scale.identity({\n          value: field,\n          field: field.toString(),\n          values: [field]\n        });\n      }\n\n      return scale;\n    }\n\n    var firstValue = Util.Array.firstValue(data, field);\n\n    if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {\n      scale = Scale.identity({\n        value: field,\n        field: field.toString(),\n        values: [field]\n      });\n    } else {\n      // 如果已经定义过这个度量\n      var type;\n\n      if (def) {\n        type = def.type;\n      }\n\n      type = type || self._getDefaultType(field, data);\n\n      var cfg = self._getScaleCfg(type, field, data);\n\n      if (def) {\n        Util.mix(cfg, def);\n      }\n\n      scale = Scale[type](cfg);\n    }\n\n    return scale;\n  };\n\n  return ScaleController;\n}();\n\nmodule.exports = ScaleController;\n\n/***/ }),\n/* 342 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The controller of coordinate\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar Coord = __webpack_require__(343);\n\nvar CoordController =\n/*#__PURE__*/\nfunction () {\n  function CoordController(option) {\n    this.type = 'rect';\n    this.actions = [];\n    this.cfg = {};\n    Util.mix(this, option);\n    this.option = option || {};\n  }\n\n  var _proto = CoordController.prototype;\n\n  _proto.reset = function reset(coordOption) {\n    this.actions = coordOption.actions || [];\n    this.type = coordOption.type;\n    this.cfg = coordOption.cfg;\n    this.option.actions = this.actions;\n    this.option.type = this.type;\n    this.option.cfg = this.cfg;\n    return this;\n  };\n\n  _proto._execActions = function _execActions(coord) {\n    var actions = this.actions;\n    Util.each(actions, function (action) {\n      var m = action[0];\n      coord[m](action[1], action[2]);\n    });\n  };\n\n  _proto.hasAction = function hasAction(actionName) {\n    var actions = this.actions;\n    var rst = false;\n    Util.each(actions, function (action) {\n      if (actionName === action[0]) {\n        rst = true;\n        return false;\n      }\n    });\n    return rst;\n  };\n  /**\n   * 创建坐标系对象\n   * @param  {Object} start 坐标系起始点\n   * @param  {Object} end   坐标系结束点\n   * @return {Function} 坐标系的构造函数\n   */\n\n\n  _proto.createCoord = function createCoord(start, end) {\n    var self = this;\n    var type = self.type;\n    var cfg = self.cfg;\n    var C; // 构造函数\n\n    var coord;\n    var coordCfg = Util.mix({\n      start: start,\n      end: end\n    }, cfg);\n\n    if (type === 'theta') {\n      // definition of theta coord\n      C = Coord.Polar;\n\n      if (!self.hasAction('transpose')) {\n        self.transpose(); // 极坐标，同时transpose\n      }\n\n      coord = new C(coordCfg);\n      coord.type = type;\n    } else {\n      C = Coord[Util.upperFirst(type || '')] || Coord.Rect;\n      coord = new C(coordCfg);\n    }\n\n    self._execActions(coord);\n\n    return coord;\n  };\n\n  _proto.rotate = function rotate(angle) {\n    angle = angle * Math.PI / 180;\n    this.actions.push(['rotate', angle]);\n    return this;\n  };\n\n  _proto.reflect = function reflect(dim) {\n    this.actions.push(['reflect', dim]);\n    return this;\n  };\n\n  _proto.scale = function scale(sx, sy) {\n    this.actions.push(['scale', sx, sy]);\n    return this;\n  };\n\n  _proto.transpose = function transpose() {\n    this.actions.push(['transpose']);\n    return this;\n  };\n\n  return CoordController;\n}();\n\nmodule.exports = CoordController;\n\n/***/ }),\n/* 343 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileOverview the entry of coordinate\n * @author sima.zhang1990@gmail.com\n */\n\nvar Coord = __webpack_require__(44);\n\nCoord.Cartesian = __webpack_require__(344);\nCoord.Rect = Coord.Cartesian;\nCoord.Polar = __webpack_require__(345);\nCoord.Helix = __webpack_require__(346);\nmodule.exports = Coord;\n\n/***/ }),\n/* 344 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * @fileOverview the class of Cartesian Coordinate\n * @author sima.zhang\n */\n\n\nvar mix = __webpack_require__(8);\n\nvar Base = __webpack_require__(44);\n\nvar Cartesian =\n/*#__PURE__*/\nfunction (_Base) {\n  _inherits(Cartesian, _Base);\n\n  _createClass(Cartesian, [{\n    key: \"getDefaultCfg\",\n\n    /**\n     * @override\n     */\n    value: function getDefaultCfg() {\n      var cfg = _get(_getPrototypeOf(Cartesian.prototype), \"getDefaultCfg\", this).call(this);\n\n      return mix({}, cfg, {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 0\n        },\n        type: 'cartesian',\n        isRect: true\n      });\n    }\n  }]);\n\n  function Cartesian(cfg) {\n    var _this;\n\n    _classCallCheck(this, Cartesian);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Cartesian).call(this, cfg));\n\n    _this._init();\n\n    return _this;\n  }\n\n  _createClass(Cartesian, [{\n    key: \"_init\",\n    value: function _init() {\n      var start = this.start,\n          end = this.end;\n      var x = {\n        start: start.x,\n        end: end.x\n      };\n      var y = {\n        start: start.y,\n        end: end.y\n      };\n      this.x = x;\n      this.y = y;\n    }\n  }, {\n    key: \"convertPoint\",\n    value: function convertPoint(point) {\n      var x;\n      var y;\n\n      if (this.isTransposed) {\n        x = point.y;\n        y = point.x;\n      } else {\n        x = point.x;\n        y = point.y;\n      }\n\n      return {\n        x: this.convertDim(x, 'x'),\n        y: this.convertDim(y, 'y')\n      };\n    }\n  }, {\n    key: \"invertPoint\",\n    value: function invertPoint(point) {\n      var x = this.invertDim(point.x, 'x');\n      var y = this.invertDim(point.y, 'y');\n\n      if (this.isTransposed) {\n        return {\n          x: y,\n          y: x\n        };\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n\n  return Cartesian;\n}(Base);\n\nmodule.exports = Cartesian;\n\n/***/ }),\n/* 345 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * @fileOverview the class of Polar Coordinate\n * @author sima.zhang\n */\n\n\nvar MatrixUtil = __webpack_require__(43);\n\nvar isNumberEqual = __webpack_require__(35);\n\nvar mix = __webpack_require__(8);\n\nvar Base = __webpack_require__(44);\n\nvar mat3 = MatrixUtil.mat3;\nvar vec2 = MatrixUtil.vec2;\nvar vec3 = MatrixUtil.vec3;\n\nvar Polar =\n/*#__PURE__*/\nfunction (_Base) {\n  _inherits(Polar, _Base);\n\n  _createClass(Polar, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      var cfg = _get(_getPrototypeOf(Polar.prototype), \"getDefaultCfg\", this).call(this);\n\n      return mix({}, cfg, {\n        startAngle: -Math.PI / 2,\n        endAngle: Math.PI * 3 / 2,\n        innerRadius: 0,\n        type: 'polar',\n        isPolar: true\n      });\n    }\n  }]);\n\n  function Polar(cfg) {\n    var _this;\n\n    _classCallCheck(this, Polar);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Polar).call(this, cfg));\n\n    _this._init();\n\n    return _this;\n  }\n\n  _createClass(Polar, [{\n    key: \"_init\",\n    value: function _init() {\n      var radius = this.radius;\n      var innerRadius = this.innerRadius;\n      var center = this.center;\n      var startAngle = this.startAngle;\n      var endAngle = this.endAngle;\n\n      while (endAngle < startAngle) {\n        endAngle += Math.PI * 2;\n      }\n\n      this.endAngle = endAngle;\n      var oneBox = this.getOneBox();\n      var oneWidth = oneBox.maxX - oneBox.minX;\n      var oneHeight = oneBox.maxY - oneBox.minY;\n      var left = Math.abs(oneBox.minX) / oneWidth;\n      var top = Math.abs(oneBox.minY) / oneHeight;\n      var width = this.width;\n      var height = this.height;\n      var maxRadius;\n      var circleCentre;\n\n      if (height / oneHeight > width / oneWidth) {\n        // width为主\n        maxRadius = width / oneWidth;\n        circleCentre = {\n          x: center.x - (0.5 - left) * width,\n          y: center.y - (0.5 - top) * maxRadius * oneHeight\n        };\n      } else {\n        // height为主\n        maxRadius = height / oneHeight;\n        circleCentre = {\n          x: center.x - (0.5 - left) * maxRadius * oneWidth,\n          y: center.y - (0.5 - top) * height\n        };\n      }\n\n      if (!radius) {\n        radius = maxRadius;\n      } else if (radius > 0 && radius <= 1) {\n        radius = maxRadius * radius;\n      } else if (radius <= 0 || radius > maxRadius) {\n        radius = maxRadius;\n      }\n\n      var x = {\n        start: startAngle,\n        end: endAngle\n      };\n      var y = {\n        start: innerRadius * radius,\n        end: radius\n      };\n      this.x = x;\n      this.y = y;\n      this.radius = radius;\n      this.circleCentre = circleCentre;\n      this.center = circleCentre;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.circleCentre;\n    }\n  }, {\n    key: \"getOneBox\",\n    value: function getOneBox() {\n      var startAngle = this.startAngle;\n      var endAngle = this.endAngle;\n\n      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n        return {\n          minX: -1,\n          maxX: 1,\n          minY: -1,\n          maxY: 1\n        };\n      }\n\n      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];\n      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];\n\n      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n        xs.push(Math.cos(i));\n        ys.push(Math.sin(i));\n      }\n\n      return {\n        minX: Math.min.apply(Math, xs),\n        maxX: Math.max.apply(Math, xs),\n        minY: Math.min.apply(Math, ys),\n        maxY: Math.max.apply(Math, ys)\n      };\n    }\n  }, {\n    key: \"getRadius\",\n    value: function getRadius() {\n      return this.radius;\n    }\n  }, {\n    key: \"convertPoint\",\n    value: function convertPoint(point) {\n      var center = this.getCenter();\n      var x = this.isTransposed ? point.y : point.x;\n      var y = this.isTransposed ? point.x : point.y;\n      x = this.convertDim(x, 'x');\n      y = this.convertDim(y, 'y');\n      return {\n        x: center.x + Math.cos(x) * y,\n        y: center.y + Math.sin(x) * y\n      };\n    }\n  }, {\n    key: \"invertPoint\",\n    value: function invertPoint(point) {\n      var center = this.getCenter();\n      var vPoint = [point.x - center.x, point.y - center.y];\n      var x = this.x;\n      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      mat3.rotate(m, m, x.start);\n      var vStart = [1, 0, 0];\n      vec3.transformMat3(vStart, vStart, m);\n      vStart = [vStart[0], vStart[1]];\n      var angle = vec2.angleTo(vStart, vPoint, x.end < x.start);\n\n      if (isNumberEqual(angle, Math.PI * 2)) {\n        angle = 0;\n      }\n\n      var radius = vec2.length(vPoint);\n      var xPercent = angle / (x.end - x.start);\n      xPercent = x.end - x.start > 0 ? xPercent : -xPercent;\n      var yPercent = this.invertDim(radius, 'y');\n      var rst = {};\n      rst.x = this.isTransposed ? yPercent : xPercent;\n      rst.y = this.isTransposed ? xPercent : yPercent;\n      return rst;\n    }\n  }]);\n\n  return Polar;\n}(Base);\n\nmodule.exports = Polar;\n\n/***/ }),\n/* 346 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/**\n * @fileOverview the class of Helix Coordinate\n * @author sima.zhang\n */\n\n\nvar MatrixUtil = __webpack_require__(43);\n\nvar isNumberEqual = __webpack_require__(35);\n\nvar mix = __webpack_require__(8);\n\nvar Base = __webpack_require__(44);\n\nvar vec2 = MatrixUtil.vec2;\n\nvar Helix =\n/*#__PURE__*/\nfunction (_Base) {\n  _inherits(Helix, _Base);\n\n  _createClass(Helix, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      var cfg = _get(_getPrototypeOf(Helix.prototype), \"getDefaultCfg\", this).call(this);\n\n      return mix({}, cfg, {\n        startAngle: 1.25 * Math.PI,\n        endAngle: 7.25 * Math.PI,\n        innerRadius: 0,\n        type: 'helix',\n        isHelix: true\n      });\n    }\n  }]);\n\n  function Helix(cfg) {\n    var _this;\n\n    _classCallCheck(this, Helix);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Helix).call(this, cfg));\n\n    _this._init();\n\n    return _this;\n  }\n\n  _createClass(Helix, [{\n    key: \"_init\",\n    value: function _init() {\n      var width = this.width;\n      var height = this.height;\n      var radius = this.radius;\n      var innerRadius = this.innerRadius;\n      var startAngle = this.startAngle;\n      var endAngle = this.endAngle;\n      var index = (endAngle - startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n\n      var maxRadius = Math.min(width, height) / 2;\n\n      if (radius && radius >= 0 && radius <= 1) {\n        maxRadius = maxRadius * radius;\n      }\n\n      var d = Math.floor(maxRadius * (1 - innerRadius) / index);\n      var a = d / (Math.PI * 2); // 螺线系数\n\n      var x = {\n        start: startAngle,\n        end: endAngle\n      };\n      var y = {\n        start: innerRadius * maxRadius,\n        end: innerRadius * maxRadius + d * 0.99\n      };\n      this.a = a;\n      this.d = d;\n      this.x = x;\n      this.y = y;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n    /**\n     * 将百分比数据变成屏幕坐标\n     * @param  {Object} point 归一化的点坐标\n     * @return {Object}       返回对应的屏幕坐标\n     */\n\n  }, {\n    key: \"convertPoint\",\n    value: function convertPoint(point) {\n      var a = this.a;\n      var center = this.center;\n      var x;\n      var y;\n\n      if (this.isTransposed) {\n        x = point.y;\n        y = point.x;\n      } else {\n        x = point.x;\n        y = point.y;\n      }\n\n      var thi = this.convertDim(x, 'x');\n      var r = a * thi;\n      var newY = this.convertDim(y, 'y');\n      return {\n        x: center.x + Math.cos(thi) * (r + newY),\n        y: center.y + Math.sin(thi) * (r + newY)\n      };\n    }\n    /**\n     * 将屏幕坐标点还原成百分比数据\n     * @param  {Object} point 屏幕坐标\n     * @return {Object}       返回对应的归一化后的数据\n     */\n\n  }, {\n    key: \"invertPoint\",\n    value: function invertPoint(point) {\n      var center = this.center;\n      var a = this.a;\n      var d = this.d + this.y.start;\n      var v = vec2.subtract([], [point.x, point.y], [center.x, center.y]);\n      var thi = vec2.angleTo(v, [1, 0], true);\n      var rMin = thi * a; // 坐标与原点的连线在第一圈上的交点，最小r值\n\n      if (vec2.length(v) < rMin) {\n        // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n        rMin = vec2.length(v);\n      }\n\n      var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n\n      thi = 2 * index * Math.PI + thi;\n      var r = a * thi;\n      var newY = vec2.length(v) - r;\n      newY = isNumberEqual(newY, 0) ? 0 : newY;\n      var x = this.invertDim(thi, 'x');\n      var y = this.invertDim(newY, 'y');\n      x = isNumberEqual(x, 0) ? 0 : x;\n      y = isNumberEqual(y, 0) ? 0 : y;\n      var rst = {};\n      rst.x = this.isTransposed ? y : x;\n      rst.y = this.isTransposed ? x : y;\n      return rst;\n    }\n  }]);\n\n  return Helix;\n}(Base);\n\nmodule.exports = Helix;\n\n/***/ }),\n/* 347 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The controller of axis\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(21),\n    Axis = _require.Axis;\n\nvar vec2 = Util.MatrixUtil.vec2;\n\nfunction formatTicks(ticks) {\n  var tmp = [];\n\n  if (ticks.length > 0) {\n    tmp = ticks.slice(0);\n    var first = tmp[0];\n    var last = tmp[tmp.length - 1];\n\n    if (first.value !== 0) {\n      tmp.unshift({\n        value: 0\n      });\n    }\n\n    if (last.value !== 1) {\n      tmp.push({\n        value: 1\n      });\n    }\n  }\n\n  return tmp;\n}\n\nfunction fillAxisTicks(ticks, isLinear, gridCentering) {\n  var result = [];\n  if (ticks.length < 1) return result;\n\n  if (ticks.length >= 2 && isLinear && gridCentering) {\n    result.push({\n      text: '',\n      tickValue: '',\n      value: 0\n    });\n  }\n\n  if (ticks[0].value !== 0) {\n    result.push({\n      text: '',\n      tickValue: '',\n      value: 0\n    });\n  }\n\n  result = result.concat(ticks);\n\n  if (result[result.length - 1].value !== 1) {\n    result.push({\n      text: '',\n      tickValue: '',\n      value: 1\n    });\n  }\n\n  return result;\n}\n\nfunction getDefaultValueFromPosition(position, val) {\n  if (val === void 0) {\n    val = 0;\n  }\n\n  if (position === 'middle') {\n    val = 0.5;\n  }\n\n  if (position.indexOf('%') !== -1) {\n    val = parseInt(position, 10) / 100;\n  }\n\n  return val;\n}\n\nvar AxisController =\n/*#__PURE__*/\nfunction () {\n  function AxisController(cfg) {\n    this.visible = true;\n    this.canvas = null;\n    this.container = null;\n    this.coord = null;\n    this.options = null;\n    this.axes = [];\n    Util.mix(this, cfg);\n  }\n\n  var _proto = AxisController.prototype;\n\n  _proto._isHide = function _isHide(field) {\n    // 对应的坐标轴是否隐藏\n    var options = this.options;\n\n    if (options && options[field] === false) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._getMiddleValue = function _getMiddleValue(curValue, ticks, index, isLinear) {\n    if (curValue === 0 && !isLinear) {\n      return 0;\n    }\n\n    if (curValue === 1) {\n      return 1;\n    }\n\n    var nextValue = ticks[index + 1].value;\n\n    if (!isLinear && nextValue === 1) {\n      return 1;\n    }\n\n    return (curValue + nextValue) / 2;\n  };\n\n  _proto._getLineRange = function _getLineRange(coord, scale, dimType, index) {\n    var start;\n    var end;\n    var isVertical;\n    var field = scale.field;\n    var options = this.options;\n    var position = '';\n\n    if (options[field] && options[field].position) {\n      position = options[field].position;\n    } // TODO middle & percentage for position\n\n\n    if (dimType === 'x') {\n      // x轴的坐标轴,底部的横坐标\n      var y = position === 'top' ? 1 : 0;\n      y = getDefaultValueFromPosition(position, y);\n      start = {\n        x: 0,\n        y: y\n      };\n      end = {\n        x: 1,\n        y: y\n      };\n      isVertical = false;\n    } else {\n      // y轴坐标轴\n      if (index) {\n        // 多轴的情况\n        var x = position === 'left' ? 0 : 1;\n        x = getDefaultValueFromPosition(position, x);\n        start = {\n          x: x,\n          y: 0\n        };\n        end = {\n          x: x,\n          y: 1\n        };\n      } else {\n        // 单个y轴，或者第一个y轴\n        var _x = position === 'right' ? 1 : 0;\n\n        _x = getDefaultValueFromPosition(position, _x);\n        start = {\n          x: _x,\n          y: 0\n        };\n        end = {\n          x: _x,\n          y: 1\n        };\n      }\n\n      isVertical = true;\n    }\n\n    start = coord.convert(start);\n    end = coord.convert(end);\n    return {\n      start: start,\n      end: end,\n      isVertical: isVertical\n    };\n  };\n\n  _proto._getLineCfg = function _getLineCfg(coord, scale, dimType, index) {\n    var factor;\n\n    var range = this._getLineRange(coord, scale, dimType, index);\n\n    var isVertical = range.isVertical; // 标识该坐标轴是否是纵坐标\n\n    var start = range.start;\n    var end = range.end;\n    var center = coord.center;\n\n    if (coord.isTransposed) {\n      isVertical = !isVertical;\n    }\n\n    if (isVertical && start.x > center.x || !isVertical && start.y > center.y) {\n      factor = 1;\n    } else {\n      factor = -1;\n    }\n\n    return {\n      isVertical: isVertical,\n      factor: factor,\n      start: start,\n      end: end\n    };\n  }; // 获取圆弧坐标轴配置项信息\n\n\n  _proto._getCircleCfg = function _getCircleCfg(coord) {\n    var circleCfg = {};\n    var rangeX = coord.x;\n    var rangeY = coord.y;\n    var isReflectY = rangeY.start > rangeY.end;\n    var start;\n\n    if (coord.isTransposed) {\n      start = {\n        x: isReflectY ? 0 : 1,\n        y: 0\n      };\n    } else {\n      start = {\n        x: 0,\n        y: isReflectY ? 0 : 1\n      };\n    }\n\n    start = coord.convert(start);\n    var center = coord.circleCentre;\n    var startVector = [start.x - center.x, start.y - center.y];\n    var normalVector = [1, 0];\n    var startAngle;\n\n    if (start.y > center.y) {\n      startAngle = vec2.angle(startVector, normalVector);\n    } else {\n      startAngle = vec2.angle(startVector, normalVector) * -1;\n    }\n\n    var endAngle = startAngle + (rangeX.end - rangeX.start);\n    circleCfg.startAngle = startAngle;\n    circleCfg.endAngle = endAngle;\n    circleCfg.center = center;\n    circleCfg.radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));\n    circleCfg.inner = coord.innerRadius || 0;\n    return circleCfg;\n  };\n\n  _proto._getRadiusCfg = function _getRadiusCfg(coord) {\n    var startAngle = coord.x.start;\n    var factor = startAngle < 0 ? -1 : 1;\n    var start;\n    var end;\n\n    if (coord.isTransposed) {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 0,\n        y: 1\n      };\n    }\n\n    return {\n      factor: factor,\n      start: coord.convert(start),\n      end: coord.convert(end)\n    };\n  }; // 确定坐标轴的位置\n\n\n  _proto._getAxisPosition = function _getAxisPosition(coord, dimType, index, field) {\n    var position = ''; // 用户自己定义了 position\n\n    var options = this.options; // const VALID_POSITIONS = [\n    //   'top',\n    //   'left',\n    //   'right',\n    //   'bottom'\n    // ];\n\n    if (options[field] && options[field].position) {\n      position = options[field].position; // if (VALID_POSITIONS.indexOf(position) > -1) {\n      //   return position;\n      // }\n    } else {\n      var coordType = coord.type;\n\n      if (coord.isRect) {\n        if (dimType === 'x') {\n          position = 'bottom';\n        } else if (dimType === 'y') {\n          if (index) {\n            position = 'right';\n          } else {\n            position = 'left';\n          }\n        }\n      } else if (coordType === 'helix') {\n        position = 'helix';\n      } else if (dimType === 'x') {\n        position = coord.isTransposed ? 'radius' : 'circle';\n      } else {\n        position = coord.isTransposed ? 'circle' : 'radius';\n      }\n    }\n\n    return position;\n  }; // 获取坐标轴构成的配置信息\n\n\n  _proto._getAxisDefaultCfg = function _getAxisDefaultCfg(coord, scale, type, position) {\n    var self = this;\n    var viewTheme = self.viewTheme;\n    var cfg = {};\n    var options = self.options;\n    var field = scale.field;\n    cfg = Util.deepMix({}, viewTheme.axis[position], cfg, options[field]);\n    cfg.viewTheme = viewTheme;\n\n    if (cfg.title) {\n      var title = Util.isPlainObject(cfg.title) ? cfg.title : {};\n      title.text = title.text || scale.alias || field;\n      Util.deepMix(cfg, {\n        title: title\n      });\n    }\n\n    cfg.ticks = scale.getTicks();\n\n    if (coord.isPolar && !scale.isCategory) {\n      if (type === 'x' && Math.abs(coord.endAngle - coord.startAngle) === Math.PI * 2) {\n        cfg.ticks.pop();\n      }\n    }\n\n    cfg.coord = coord;\n\n    if (cfg.label && Util.isNil(cfg.label.autoRotate)) {\n      cfg.label.autoRotate = true; // 允许自动旋转，避免重叠\n    }\n\n    if (options.hasOwnProperty('xField') && options.xField.hasOwnProperty('grid')) {\n      if (cfg.position === 'left') {\n        Util.deepMix(cfg, options.xField);\n      }\n    }\n\n    return cfg;\n  }; // 确定坐标轴的配置信息\n\n\n  _proto._getAxisCfg = function _getAxisCfg(coord, scale, verticalScale, dimType, index, viewId) {\n    if (index === void 0) {\n      index = '';\n    }\n\n    var self = this;\n\n    var position = self._getAxisPosition(coord, dimType, index, scale.field);\n\n    var cfg = self._getAxisDefaultCfg(coord, scale, dimType, position);\n\n    if (!Util.isEmpty(cfg.grid) && verticalScale) {\n      // 生成 gridPoints\n      var gridPoints = [];\n      var tickValues = [];\n      var verticalTicks = formatTicks(verticalScale.getTicks()); // 没有垂直的坐标点时不会只栅格\n\n      if (verticalTicks.length) {\n        var ticks = fillAxisTicks(cfg.ticks, scale.isLinear, cfg.grid.align === 'center');\n        Util.each(ticks, function (tick, idx) {\n          tickValues.push(tick.tickValue);\n          var subPoints = [];\n          var value = tick.value;\n\n          if (cfg.grid.align === 'center') {\n            value = self._getMiddleValue(value, ticks, idx, scale.isLinear);\n          }\n\n          if (!Util.isNil(value)) {\n            var rangeX = coord.x;\n            var rangeY = coord.y;\n            Util.each(verticalTicks, function (verticalTick) {\n              var x = dimType === 'x' ? value : verticalTick.value;\n              var y = dimType === 'x' ? verticalTick.value : value;\n              var point = coord.convert({\n                x: x,\n                y: y\n              });\n\n              if (coord.isPolar) {\n                var center = coord.circleCentre;\n\n                if (rangeY.start > rangeY.end) {\n                  y = 1 - y;\n                }\n\n                point.flag = rangeX.start > rangeX.end ? 0 : 1;\n                point.radius = Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n              }\n\n              subPoints.push(point);\n            });\n            gridPoints.push({\n              _id: viewId + '-' + dimType + index + '-grid-' + tick.tickValue,\n              points: subPoints\n            });\n          }\n        });\n      }\n\n      cfg.grid.items = gridPoints;\n      cfg.grid.tickValues = tickValues;\n    }\n\n    cfg.type = scale.type;\n    return cfg;\n  };\n\n  _proto._getHelixCfg = function _getHelixCfg(coord) {\n    var helixCfg = {};\n    var a = coord.a;\n    var startAngle = coord.startAngle;\n    var endAngle = coord.endAngle;\n    var index = 100;\n    var crp = [];\n\n    for (var i = 0; i <= index; i++) {\n      var point = coord.convert({\n        x: i / 100,\n        y: 0\n      });\n      crp.push(point.x);\n      crp.push(point.y);\n    }\n\n    var axisStart = coord.convert({\n      x: 0,\n      y: 0\n    });\n    helixCfg.a = a;\n    helixCfg.startAngle = startAngle;\n    helixCfg.endAngle = endAngle;\n    helixCfg.crp = crp;\n    helixCfg.axisStart = axisStart;\n    helixCfg.center = coord.center;\n    helixCfg.inner = coord.y.start; // 内半径\n\n    return helixCfg;\n  };\n\n  _proto._drawAxis = function _drawAxis(coord, scale, verticalScale, dimType, viewId, xAxis, index) {\n    var container = this.container;\n    var canvas = this.canvas;\n    var C; // 坐标轴类\n\n    var appendCfg; // 每个坐标轴 start end 等绘制边界的信息\n\n    if (coord.type === 'cartesian') {\n      C = Axis.Line;\n      appendCfg = this._getLineCfg(coord, scale, dimType, index);\n    } else if (coord.type === 'helix' && dimType === 'x') {\n      C = Axis.Helix;\n      appendCfg = this._getHelixCfg(coord);\n    } else if (dimType === 'x') {\n      C = Axis.Circle;\n      appendCfg = this._getCircleCfg(coord);\n    } else {\n      C = Axis.Line;\n      appendCfg = this._getRadiusCfg(coord);\n    }\n\n    var cfg = this._getAxisCfg(coord, scale, verticalScale, dimType, index, viewId);\n\n    cfg = Util.mix({}, cfg, appendCfg);\n\n    if (dimType === 'y' && xAxis && xAxis.get('type') === 'circle') {\n      cfg.circle = xAxis;\n    }\n\n    cfg._id = viewId + '-' + dimType;\n\n    if (!Util.isNil(index)) {\n      cfg._id = viewId + '-' + dimType + index;\n    }\n\n    Util.mix(cfg, {\n      canvas: canvas,\n      group: container\n    });\n    var axis = new C(cfg);\n    axis.render();\n    this.axes.push(axis);\n    return axis;\n  };\n\n  _proto.createAxis = function createAxis(xScale, yScales, viewId) {\n    var self = this;\n    var coord = this.coord;\n    var coordType = coord.type; // theta坐标系默认不绘制坐标轴\n\n    if (coordType !== 'theta' && !(coordType === 'polar' && coord.isTransposed)) {\n      var xAxis;\n\n      if (xScale && !self._isHide(xScale.field)) {\n        xAxis = self._drawAxis(coord, xScale, yScales[0], 'x', viewId); // 绘制 x 轴\n      }\n\n      if (!Util.isEmpty(yScales) && coordType !== 'helix') {\n        Util.each(yScales, function (yScale, index) {\n          if (!self._isHide(yScale.field)) {\n            self._drawAxis(coord, yScale, xScale, 'y', viewId, xAxis, index);\n          }\n        });\n      }\n    }\n  };\n\n  _proto.changeVisible = function changeVisible(visible) {\n    var axes = this.axes;\n    Util.each(axes, function (axis) {\n      axis.set('visible', visible);\n    });\n  };\n\n  _proto.clear = function clear() {\n    var self = this;\n    var axes = self.axes;\n    Util.each(axes, function (axis) {\n      axis.clear();\n    });\n    self.axes = [];\n  };\n\n  return AxisController;\n}();\n\nmodule.exports = AxisController;\n\n/***/ }),\n/* 348 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Guide = __webpack_require__(349);\n\nvar GuideController =\n/*#__PURE__*/\nfunction () {\n  function GuideController(cfg) {\n    this.guides = [];\n    this.options = [];\n    this.xScales = null;\n    this.yScales = null;\n    this.view = null;\n    this.viewTheme = null;\n    this.frontGroup = null;\n    this.backGroup = null;\n    Util.mix(this, cfg);\n  }\n\n  var _proto = GuideController.prototype;\n\n  _proto._creatGuides = function _creatGuides() {\n    var self = this;\n    var options = this.options;\n    var xScales = this.xScales;\n    var yScales = this.yScales;\n    var view = this.view;\n    var viewTheme = this.viewTheme;\n\n    if (this.backContainer && view) {\n      this.backGroup = this.backContainer.addGroup({\n        viewId: view.get('_id')\n      });\n    }\n\n    if (this.frontContainer && view) {\n      this.frontGroup = this.frontContainer.addGroup({\n        viewId: view.get('_id')\n      });\n    }\n\n    options.forEach(function (option) {\n      var type = option.type;\n      var config = Util.deepMix({\n        xScales: xScales,\n        yScales: yScales,\n        viewTheme: viewTheme\n      }, viewTheme ? viewTheme.guide[type] : {}, option);\n      type = Util.upperFirst(type);\n      var guide = new Guide[type](config);\n      self.guides.push(guide);\n    });\n    return self.guides;\n  };\n\n  _proto.line = function line(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'line'\n    }, cfg));\n    return this;\n  };\n\n  _proto.arc = function arc(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'arc'\n    }, cfg));\n    return this;\n  };\n\n  _proto.text = function text(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'text'\n    }, cfg));\n    return this;\n  };\n\n  _proto.image = function image(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'image'\n    }, cfg));\n    return this;\n  };\n\n  _proto.region = function region(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'region'\n    }, cfg));\n    return this;\n  };\n\n  _proto.regionFilter = function regionFilter(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'regionFilter'\n    }, cfg));\n    return this;\n  };\n\n  _proto.dataMarker = function dataMarker(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'dataMarker'\n    }, cfg));\n    return this;\n  };\n\n  _proto.dataRegion = function dataRegion(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'dataRegion'\n    }, cfg));\n    return this;\n  };\n\n  _proto.html = function html(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.options.push(Util.mix({\n      type: 'html'\n    }, cfg));\n    return this;\n  };\n\n  _proto.render = function render(coord) {\n    var self = this;\n    var view = self.view;\n    var viewData = view && view.get('data');\n\n    var guides = self._creatGuides();\n\n    Util.each(guides, function (guide) {\n      var container;\n\n      if (guide.get('top')) {\n        // 默认 guide 绘制到 backPlot，用户也可以声明 top: true，显示在最上层\n        container = self.frontGroup || self.frontContainer;\n      } else {\n        container = self.backGroup || self.backContainer;\n      }\n\n      guide.render(coord, container, viewData, view);\n    });\n  };\n\n  _proto.clear = function clear() {\n    this.options = [];\n    this.reset();\n  };\n\n  _proto.changeVisible = function changeVisible(visible) {\n    var guides = this.guides;\n    Util.each(guides, function (guide) {\n      guide.changeVisible(visible);\n    });\n  };\n\n  _proto.reset = function reset() {\n    var guides = this.guides;\n    Util.each(guides, function (guide) {\n      guide.clear();\n    });\n    this.guides = [];\n    this.backGroup && this.backGroup.remove();\n    this.frontGroup && this.frontGroup.remove();\n  };\n\n  return GuideController;\n}();\n\nmodule.exports = GuideController;\n\n/***/ }),\n/* 349 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _require = __webpack_require__(21),\n    Guide = _require.Guide;\n\nvar RegionFilter = __webpack_require__(350);\n\nGuide.RegionFilter = RegionFilter;\nmodule.exports = Guide;\n\n/***/ }),\n/* 350 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Guide = __webpack_require__(15);\n\nvar _require = __webpack_require__(25),\n    Path = _require.Path;\n\nvar RegionFilter =\n/*#__PURE__*/\nfunction (_Guide) {\n  _inheritsLoose(RegionFilter, _Guide);\n\n  function RegionFilter() {\n    return _Guide.apply(this, arguments) || this;\n  }\n\n  var _proto = RegionFilter.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Guide.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      name: 'regionFilter',\n      zIndex: 1,\n      top: true,\n      start: null,\n      end: null,\n      color: null,\n      apply: null,\n      style: {\n        opacity: 1\n      }\n    });\n  };\n\n  _proto.render = function render(coord, group, viewData, view) {\n    var self = this;\n    var layer = group.addGroup();\n    layer.name = 'guide-region-filter';\n    view.once('afterpaint', function () {\n      // 2018-08-08 by blue.lb padding为auto时，会导致重新绘制一次，这时候layer已经被销毁了\n      if (layer.get('destroyed')) return;\n\n      self._drawShapes(view, layer);\n\n      var clip = self._drawClip(coord);\n\n      layer.attr({\n        clip: clip\n      });\n      self.set('clip', clip);\n      self.get('appendInfo') && layer.setSilent('appendInfo', self.get('appendInfo'));\n      self.set('el', layer);\n    });\n  };\n\n  _proto._drawShapes = function _drawShapes(view, layer) {\n    var self = this;\n    var output = [];\n    var geoms = view.getAllGeoms();\n    geoms.map(function (geom) {\n      var shapes = geom.getShapes();\n      var geomType = geom.get('type');\n\n      var filter = self._geomFilter(geomType);\n\n      if (filter) {\n        shapes.map(function (shape) {\n          var shapeType = shape.type; // const shapeAttr = Util.mix({}, shape.attr());\n\n          var shapeAttr = Util.cloneDeep(shape.attr());\n\n          self._adjustDisplay(shapeAttr);\n\n          var s = layer.addShape(shapeType, {\n            attrs: shapeAttr\n          });\n          output.push(s);\n          return shape;\n        });\n      }\n\n      return geom;\n    });\n    return output;\n  };\n\n  _proto._drawClip = function _drawClip(coord) {\n    var self = this;\n    var start = self.parsePoint(coord, self.get('start'));\n    var end = self.parsePoint(coord, self.get('end'));\n    var path = [['M', start.x, start.y], ['L', end.x, start.y], ['L', end.x, end.y], ['L', start.x, end.y], ['z']];\n    var clip = new Path({\n      attrs: {\n        path: path,\n        opacity: 1\n      }\n    });\n    return clip;\n  };\n\n  _proto._adjustDisplay = function _adjustDisplay(attr) {\n    var self = this;\n    var color = self.get('color');\n\n    if (attr.fill) {\n      attr.fill = attr.fillStyle = color;\n    }\n\n    attr.stroke = attr.strokeStyle = color;\n  };\n\n  _proto._geomFilter = function _geomFilter(geomType) {\n    var self = this;\n    var apply = self.get('apply');\n\n    if (apply) {\n      return Util.contains(apply, geomType);\n    }\n\n    return true;\n  };\n\n  _proto.clear = function clear() {\n    _Guide.prototype.clear.call(this);\n\n    var clip = this.get('clip');\n    clip && clip.remove();\n  };\n\n  return RegionFilter;\n}(Guide);\n\nmodule.exports = RegionFilter;\n\n/***/ }),\n/* 351 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(21),\n    Legend = _require.Legend;\n\nvar Tail = __webpack_require__(352);\n\nvar Shape = __webpack_require__(18);\n\nvar bboxOfBackPlot = __webpack_require__(166);\n\nvar plotRange2BBox = __webpack_require__(168);\n\nvar FIELD_ORIGIN = '_origin';\nvar MARKER_SIZE = 4.5;\nvar requireAnimationFrameFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\nfunction _snapEqual(v1, v2, scale) {\n  var isEqual;\n\n  if (Util.isNil(scale)) {\n    return false;\n  }\n\n  v1 = scale.translate(v1);\n  v2 = scale.translate(v2);\n\n  if (scale.isCategory) {\n    isEqual = v1 === v2;\n  } else {\n    isEqual = Math.abs(v1 - v2) <= 1;\n  }\n\n  return isEqual;\n}\n\nfunction findGeom(geoms, value) {\n  var rst;\n  Util.each(geoms, function (geom) {\n    if (geom.get('visible')) {\n      var yScale = geom.getYScale();\n\n      if (yScale.field === value) {\n        rst = geom;\n        return;\n      }\n    }\n  });\n  return rst;\n}\n\nvar LegendController =\n/*#__PURE__*/\nfunction () {\n  function LegendController(cfg) {\n    var self = this;\n    self.options = {};\n    Util.mix(self, cfg);\n    self.clear();\n    var chart = self.chart;\n    self.container = chart.get('frontPlot');\n    self.plotRange = chart.get('plotRange');\n  }\n\n  var _proto = LegendController.prototype;\n\n  _proto.clear = function clear() {\n    var legends = this.legends;\n    this.backRange = null;\n    Util.each(legends, function (legendItems) {\n      Util.each(legendItems, function (legend) {\n        legend.destroy();\n      });\n    });\n    this.legends = {};\n  }; // 获取坐标轴等背景元素占的范围，防止遮挡坐标轴\n\n\n  _proto.getBackRange = function getBackRange() {\n    var backRange = this.backRange;\n\n    if (!backRange) {\n      var backPlot = this.chart.get('backPlot');\n      backRange = bboxOfBackPlot(backPlot, plotRange2BBox(this.chart.get('plotRange')));\n      var plotRange = this.plotRange;\n\n      if (backRange.maxX - backRange.minX < plotRange.br.x - plotRange.tl.x && backRange.maxY - backRange.minY < plotRange.br.y - plotRange.tl.y) {\n        // 如果背景小于则直接使用 plotRange\n        backRange = {\n          minX: plotRange.tl.x,\n          minY: plotRange.tl.y,\n          maxX: plotRange.br.x,\n          maxY: plotRange.br.y\n        };\n      }\n\n      this.backRange = backRange;\n    }\n\n    return backRange;\n  };\n\n  _proto._isFieldInView = function _isFieldInView(field, value, view) {\n    var flag = false;\n    var scales = view.get('scales');\n    var fieldScale = scales[field];\n\n    if (fieldScale && fieldScale.values) {\n      flag = Util.inArray(fieldScale.values, value);\n    }\n\n    return flag;\n  };\n\n  _proto._bindClickEvent = function _bindClickEvent(legend, scale, filterVals) {\n    var self = this;\n    var chart = self.chart;\n    var views = chart.get('views');\n    var field = scale.field;\n    var options = self.options;\n    legend.on('itemclick', function (ev) {\n      if (options.onClick && options.defaultClickHandlerEnabled !== true) {\n        options.onClick(ev);\n      } else {\n        // if 'defaultClickHandlerEnabled' is true the default click behavior would be worked.\n        var item = ev.item;\n        var checked = ev.checked;\n        var isSingleSelected = legend.get('selectedMode') === 'single'; // 图例的选中模式\n\n        var clickedValue = item.dataValue; // import: 需要取该图例项原始的数值\n\n        if (checked) {\n          Util.Array.remove(filterVals, clickedValue);\n\n          if (self._isFieldInView(field, clickedValue, chart)) {\n            chart.filter(field, function (field) {\n              return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);\n            });\n          }\n\n          Util.each(views, function (view) {\n            if (self._isFieldInView(field, clickedValue, view)) {\n              view.filter(field, function (field) {\n                return isSingleSelected ? field === clickedValue : !Util.inArray(filterVals, field);\n              });\n            }\n          });\n        } else if (!isSingleSelected) {\n          filterVals.push(clickedValue);\n\n          if (self._isFieldInView(field, clickedValue, chart)) {\n            chart.filter(field, function (field) {\n              return !Util.inArray(filterVals, field);\n            });\n          }\n\n          Util.each(views, function (view) {\n            if (self._isFieldInView(field, clickedValue, view)) {\n              view.filter(field, function (field) {\n                return !Util.inArray(filterVals, field);\n              });\n            }\n          });\n        }\n\n        if (options.onClick) {\n          options.onClick(ev);\n        }\n\n        chart.set('keepLegend', true); // 图例不重新渲染\n\n        chart.set('keepPadding', true); // 边框不重新计算\n\n        chart.repaint();\n        chart.set('keepPadding', false);\n        chart.set('keepLegend', false);\n      }\n    });\n  };\n\n  _proto._bindClickEventForMix = function _bindClickEventForMix(legend) {\n    var self = this;\n    var chart = self.chart;\n    var geoms = chart.getAllGeoms();\n    legend.on('itemclick', function (ev) {\n      var value = ev.item.value;\n      var checked = ev.checked;\n\n      if (checked) {\n        Util.each(geoms, function (geom) {\n          var field = geom.getYScale().field;\n\n          if (field === value) {\n            geom.show();\n          }\n        });\n      } else {\n        Util.each(geoms, function (geom) {\n          var field = geom.getYScale().field;\n\n          if (field === value) {\n            geom.hide();\n          }\n        });\n      }\n    });\n  };\n\n  _proto._filterLabels = function _filterLabels(shape, geom, visible) {\n    if (shape.get('gLabel')) {\n      shape.get('gLabel').set('visible', visible);\n    } else {\n      var labelCfg = geom.get('labelCfg');\n\n      if (labelCfg && labelCfg.fields && labelCfg.fields.length > 0) {\n        var xScale = geom.getXScale();\n        var yScale = geom.getYScale();\n        var xField = xScale.field;\n        var yField = yScale.field;\n\n        var shapeData = shape.get('origin')._origin;\n\n        var labelContainer = geom.get('labelContainer');\n        var labels = labelContainer.get('labelsGroup').get('children');\n        Util.each(labels, function (label) {\n          var labelData = label.get('origin') || [];\n\n          if (labelData[xField] === shapeData[xField] && labelData[yField] === shapeData[yField]) {\n            label.set('visible', visible);\n            shape.set('gLabel', label);\n          }\n        });\n      }\n    }\n  };\n\n  _proto._bindFilterEvent = function _bindFilterEvent(legend, scale) {\n    var self = this;\n    var chart = this.chart;\n    var field = scale.field;\n    legend.on('itemfilter', function (ev) {\n      var range = ev.range;\n      chart.filterShape(function (obj, shape, geom) {\n        // @2018-12-21 by blue.lb 由于数值0直接被类型转换为false，这里需要做更精确一点的判断\n        if (!Util.isNil(obj[field])) {\n          var filtered = obj[field] >= range[0] && obj[field] <= range[1]; // shape 带 label，则还需要隐藏 label\n\n          self._filterLabels(shape, geom, filtered);\n\n          return filtered;\n        }\n\n        return true;\n      });\n      var geoms = chart.getAllGeoms() || [];\n\n      var _loop = function _loop(i) {\n        var geom = geoms[i];\n\n        if (geom.get('type') === 'heatmap') {\n          requireAnimationFrameFn(function () {\n            geom.drawWithRange(range);\n          });\n        }\n      };\n\n      for (var i = 0; i < geoms.length; i++) {\n        _loop(i);\n      }\n    });\n  };\n\n  _proto._getShapeData = function _getShapeData(shape) {\n    var originData = shape.get('origin');\n\n    if (Util.isArray(originData)) {\n      originData = originData[0];\n    }\n\n    return originData[FIELD_ORIGIN];\n  };\n\n  _proto._bindHoverEvent = function _bindHoverEvent(legend, field) {\n    var self = this;\n    var chart = self.chart;\n    var geoms = chart.getAllGeoms();\n    var options = self.options;\n    var canvas = chart.get('canvas');\n    legend.on('itemhover', function (ev) {\n      var value = ev.item.value;\n      var pre = self.pre;\n\n      if (!pre) {\n        Util.each(geoms, function (geom) {\n          var shapeContainer = geom.get('shapeContainer');\n          var shapes = geom.getShapes();\n          var activeShapes = [];\n\n          if (field) {\n            var scale = geom.get('scales')[field];\n            Util.each(shapes, function (shape) {\n              var origin = self._getShapeData(shape);\n\n              if (origin && _snapEqual(origin[field], value, scale)) {\n                activeShapes.push(shape);\n              }\n            });\n          } else if (geom.getYScale().field === value) {\n            activeShapes = shapes;\n          }\n\n          if (!Util.isEmpty(activeShapes)) {\n            ev.shapes = activeShapes;\n            ev.geom = geom;\n\n            if (options.onHover) {\n              options.onHover(ev);\n              shapeContainer.sort();\n              canvas.draw();\n            } else {\n              geom.setShapesActived(activeShapes);\n            }\n          }\n        });\n        self.pre = value;\n      } else if (pre === value) {\n        return;\n      }\n    });\n    legend.on('itemunhover', function (ev) {\n      self.pre = null;\n\n      if (options.onUnhover) {\n        options.onUnhover(ev);\n      }\n\n      Util.each(geoms, function (geom) {\n        if (geom.get('activeShapes')) {\n          geom.clearActivedShapes();\n          canvas.draw();\n        }\n      });\n    });\n  };\n\n  _proto._isFiltered = function _isFiltered(scale, filterVals, scaleValue) {\n    if (!scale.isCategory) {\n      return true;\n    }\n\n    var rst = true;\n    scaleValue = scale.invert(scaleValue);\n    Util.each(filterVals, function (val) {\n      if (scale.getText(val) === scale.getText(scaleValue)) {\n        rst = false;\n        return false;\n      }\n    });\n    return rst;\n  };\n\n  _proto._alignLegend = function _alignLegend(legend, pre, region, position) {\n    var self = this;\n    var viewTheme = self.viewTheme;\n    var container = self.container;\n    var canvas = container.get('canvas');\n    var width = canvas.get('width');\n    var height = canvas.get('height');\n    var totalRegion = self.totalRegion;\n    var plotRange = self.plotRange;\n    var backRange = self.getBackRange(); // 背景占得范围\n\n    var offsetX = legend.get('offset')[0] || 0;\n    var offsetY = legend.get('offset')[1] || 0; // const offset = Util.isNil(legend.get('offset')) ? MARGIN : legend.get('offset');\n\n    var legendHeight = legend.getHeight();\n    var legendWidth = legend.getWidth();\n    var borderMargin = viewTheme.legend.margin;\n    var innerMargin = viewTheme.legend.legendMargin;\n    var legendNum = self.legends[position].length;\n    var posArray = position.split('-');\n    var x = 0;\n    var y = 0;\n    var tempoRegion = legendNum > 1 ? totalRegion : region;\n\n    if (posArray[0] === 'left' || posArray[0] === 'right') {\n      height = plotRange.br.y;\n      x = self._getXAlign(posArray[0], width, region, backRange, legendWidth, borderMargin);\n\n      if (pre) {\n        // @2018-10-19 by blue.lb 由于legend中并不存在y属性，这里需要先获取group再获取y值\n        y = pre.get('group').get('y') + pre.getHeight() + innerMargin;\n      } else {\n        y = self._getYAlignVertical(posArray[1], height, tempoRegion, backRange, 0, borderMargin, canvas.get('height'));\n      }\n    } else if (posArray[0] === 'top' || posArray[0] === 'bottom') {\n      y = self._getYAlignHorizontal(posArray[0], height, region, backRange, legendHeight, borderMargin);\n\n      if (pre) {\n        var preWidth = pre.getWidth(); // @2018-10-19 by blue.lb 由于legend中并不存在x属性，这里需要先获取group再获取x值\n\n        x = pre.get('group').get('x') + preWidth + innerMargin;\n      } else {\n        x = self._getXAlign(posArray[1], width, tempoRegion, backRange, 0, borderMargin);\n        if (posArray[1] === 'right') x = plotRange.br.x - tempoRegion.totalWidth;\n      }\n    }\n\n    legend.move(x + offsetX, y + offsetY);\n  };\n\n  _proto._getXAlign = function _getXAlign(pos, width, region, backRange, legendWidth, borderMargin) {\n    var x = pos === 'left' ? backRange.minX - legendWidth - borderMargin[3] : backRange.maxX + borderMargin[1];\n\n    if (pos === 'center') {\n      x = (width - region.totalWidth) / 2;\n    }\n\n    return x;\n  };\n\n  _proto._getYAlignHorizontal = function _getYAlignHorizontal(pos, height, region, backRange, legendHeight, borderMargin) {\n    var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : backRange.maxY + borderMargin[2];\n    return y;\n  };\n\n  _proto._getYAlignVertical = function _getYAlignVertical(pos, height, region, backRange, legendHeight, borderMargin, canvasHeight) {\n    var y = pos === 'top' ? backRange.minY - legendHeight - borderMargin[0] : height - region.totalHeight;\n\n    if (pos === 'center') {\n      y = (canvasHeight - region.totalHeight) / 2;\n    }\n\n    return y;\n  };\n\n  _proto._getSubRegion = function _getSubRegion(legends) {\n    var maxWidth = 0;\n    var maxHeight = 0;\n    var totalWidth = 0;\n    var totalHeight = 0;\n    Util.each(legends, function (legend) {\n      var width = legend.getWidth();\n      var height = legend.getHeight();\n\n      if (maxWidth < width) {\n        maxWidth = width;\n      }\n\n      totalWidth += width;\n\n      if (maxHeight < height) {\n        maxHeight = height;\n      }\n\n      totalHeight += height;\n    });\n    return {\n      maxWidth: maxWidth,\n      totalWidth: totalWidth,\n      maxHeight: maxHeight,\n      totalHeight: totalHeight\n    };\n  };\n\n  _proto._getRegion = function _getRegion() {\n    var self = this;\n    var viewTheme = self.viewTheme;\n    var legends = self.legends;\n    var innerMargin = viewTheme.legend.legendMargin;\n    var subs = [];\n    var totalWidth = 0;\n    var totalHeight = 0;\n    Util.each(legends, function (legendItems) {\n      var subRegion = self._getSubRegion(legendItems);\n\n      subs.push(subRegion);\n      totalWidth += subRegion.totalWidth + innerMargin;\n      totalHeight += subRegion.totalHeight + innerMargin;\n    });\n    return {\n      totalWidth: totalWidth,\n      totalHeight: totalHeight,\n      subs: subs\n    };\n  };\n\n  _proto._addCategoryLegend = function _addCategoryLegend(scale, attr, geom, filterVals, position) {\n    var self = this;\n    var field = scale.field;\n    var legendOptions = self.options;\n    var fieldOption = legendOptions[field];\n\n    if (fieldOption) {\n      legendOptions = fieldOption;\n    }\n\n    var legends = self.legends;\n    legends[position] = legends[position] || [];\n    var container = self.container;\n    var items = [];\n    var ticks = scale.getTicks();\n    var isByAttr = true;\n    var shapeType = geom.get('shapeType') || 'point';\n    var shape = geom.getDefaultValue('shape') || 'circle';\n\n    if (legendOptions[field] && legendOptions[field].marker) {\n      // 用户为 field 对应的图例定义了 marker\n      shape = legendOptions[field].marker;\n      shapeType = 'point';\n      isByAttr = false;\n    } else if (legendOptions.marker) {\n      shape = legendOptions.marker;\n      shapeType = 'point';\n      isByAttr = false;\n    }\n\n    var chart = self.chart;\n    var viewTheme = self.viewTheme;\n    var canvas = chart.get('canvas');\n    var plotRange = self.plotRange;\n    var posArray = position.split('-');\n    var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');\n    Util.each(ticks, function (tick) {\n      var text = tick.text;\n      var name = text;\n      var scaleValue = tick.value;\n      var value = scale.invert(scaleValue);\n      var cfg = {\n        isInCircle: geom.isInCircle()\n      };\n      var checked = filterVals ? self._isFiltered(scale, filterVals, scaleValue) : true;\n      var colorAttr = geom.getAttr('color');\n      var shapeAttr = geom.getAttr('shape');\n\n      if (colorAttr) {\n        // 存在颜色映射\n        if (colorAttr.callback && colorAttr.callback.length > 1) {\n          // 多参数映射，阻止程序报错\n          var restArgs = Array(colorAttr.callback.length - 1).fill('');\n          cfg.color = colorAttr.mapping.apply(colorAttr, [value].concat(restArgs)).join('') || viewTheme.defaultColor;\n        } else {\n          cfg.color = colorAttr.mapping(value).join('') || viewTheme.defaultColor;\n        }\n      }\n\n      if (isByAttr && shapeAttr) {\n        // 存在形状映射\n        if (shapeAttr.callback && shapeAttr.callback.length > 1) {\n          // 多参数映射，阻止程序报错\n          var _restArgs = Array(shapeAttr.callback.length - 1).fill('');\n\n          shape = shapeAttr.mapping.apply(shapeAttr, [value].concat(_restArgs)).join('');\n        } else {\n          shape = shapeAttr.mapping(value).join('');\n        }\n      }\n\n      var shapeObject = Shape.getShapeFactory(shapeType);\n      var marker = shapeObject.getMarkerCfg(shape, cfg);\n\n      if (Util.isFunction(shape)) {\n        marker.symbol = shape;\n      }\n\n      items.push({\n        value: name,\n        // 图例项显示文本的内容\n        dataValue: value,\n        // 图例项对应原始数据中的数值\n        checked: checked,\n        marker: marker\n      });\n    });\n    var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions[field] || legendOptions, {\n      viewId: chart.get('_id'),\n      maxLength: maxLength,\n      items: items,\n      container: container,\n      position: [0, 0]\n    });\n\n    if (legendCfg.title) {\n      Util.deepMix(legendCfg, {\n        title: {\n          text: scale.alias || scale.field\n        }\n      });\n    }\n\n    var legend;\n\n    if (self._isTailLegend(legendOptions, geom)) {\n      legendCfg.chart = self.chart;\n      legendCfg.geom = geom;\n      legend = new Tail(legendCfg);\n    } else {\n      if (legendOptions.useHtml) {\n        var canvasEle = container.get('canvas').get('el');\n        container = legendOptions.container;\n\n        if (Util.isString(container) && /^\\#/.test(container)) {\n          // 如果传入 dom 节点的 id\n          var id = container.replace('#', '');\n          container = document.getElementById(id);\n        }\n\n        if (!container) {\n          container = canvasEle.parentNode;\n        }\n\n        legendCfg.container = container;\n        if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};\n        legendCfg.legendStyle.CONTAINER_CLASS = {\n          position: 'absolute',\n          overflow: 'auto',\n          'z-index': canvasEle.style.zIndex === '' ? 1 : parseInt(canvasEle.style.zIndex, 10) + 1\n        };\n\n        if (legendOptions.flipPage) {\n          legendCfg.legendStyle.CONTAINER_CLASS.height = posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto';\n          legendCfg.legendStyle.CONTAINER_CLASS.width = !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto';\n          legend = new Legend.CatPageHtml(legendCfg);\n        } else {\n          legend = new Legend.CatHtml(legendCfg);\n        }\n      } else {\n        legend = new Legend.Category(legendCfg);\n      }\n    }\n\n    self._bindClickEvent(legend, scale, filterVals);\n\n    legends[position].push(legend);\n    return legend;\n  };\n\n  _proto._bindChartMove = function _bindChartMove(scale) {\n    var chart = this.chart;\n    var legends = this.legends;\n    chart.on('plotmove', function (ev) {\n      var selected = false;\n\n      if (ev.target) {\n        var origin = ev.target.get('origin');\n\n        if (origin) {\n          var data = origin[FIELD_ORIGIN] || origin[0][FIELD_ORIGIN];\n          var field = scale.field;\n\n          if (data) {\n            var value = data[field];\n            Util.each(legends, function (legendItems) {\n              Util.each(legendItems, function (legend) {\n                selected = true;\n                !legend.destroyed && legend.activate(value);\n              });\n            });\n          }\n        }\n      }\n\n      if (!selected) {\n        Util.each(legends, function (legendItems) {\n          Util.each(legendItems, function (legend) {\n            !legend.destroyed && legend.deactivate();\n          });\n        });\n      }\n    });\n  };\n\n  _proto._addContinuousLegend = function _addContinuousLegend(scale, attr, position) {\n    var self = this;\n    var legends = self.legends;\n    legends[position] = legends[position] || [];\n    var container = self.container;\n    var field = scale.field;\n    var ticks = scale.getTicks();\n    var items = [];\n    var legend;\n    var minValue;\n    var maxValue;\n    var viewTheme = self.viewTheme;\n    Util.each(ticks, function (tick) {\n      var scaleValue = tick.value;\n      var invertValue = scale.invert(scaleValue);\n      var attrValue = attr.mapping(invertValue).join('');\n      items.push({\n        value: tick.tickValue,\n        // tick.text\n        attrValue: attrValue,\n        color: attrValue,\n        scaleValue: scaleValue\n      });\n\n      if (scaleValue === 0) {\n        minValue = true;\n      }\n\n      if (scaleValue === 1) {\n        maxValue = true;\n      }\n    });\n\n    if (!minValue) {\n      items.push({\n        value: scale.min,\n        attrValue: attr.mapping(0).join(''),\n        color: attr.mapping(0).join(''),\n        scaleValue: 0\n      });\n    }\n\n    if (!maxValue) {\n      items.push({\n        value: scale.max,\n        attrValue: attr.mapping(1).join(''),\n        color: attr.mapping(1).join(''),\n        scaleValue: 1\n      });\n    }\n\n    var options = self.options;\n    var posArray = position.split('-');\n    var defaultCfg = viewTheme.legend[posArray[0]];\n\n    if (options && options.slidable === false || options[field] && options[field].slidable === false) {\n      defaultCfg = Util.mix({}, defaultCfg, viewTheme.legend.gradient);\n    }\n\n    var legendCfg = Util.deepMix({}, defaultCfg, options[field] || options, {\n      items: items,\n      attr: attr,\n      formatter: scale.formatter,\n      container: container,\n      position: [0, 0]\n    });\n\n    if (legendCfg.title) {\n      Util.deepMix(legendCfg, {\n        title: {\n          text: scale.alias || scale.field\n        }\n      });\n    }\n\n    if (attr.type === 'color') {\n      legend = new Legend.Color(legendCfg);\n    } else if (attr.type === 'size') {\n      if (options && options.sizeType === 'circle') legend = new Legend.CircleSize(legendCfg);else legend = new Legend.Size(legendCfg);\n    } else {\n      return;\n    }\n\n    self._bindFilterEvent(legend, scale);\n\n    legends[position].push(legend);\n    return legend;\n  };\n\n  _proto._isTailLegend = function _isTailLegend(opt, geom) {\n    if (opt.hasOwnProperty('attachLast') && opt.attachLast) {\n      var geomType = geom.get('type');\n      if (geomType === 'line' || geomType === 'lineStack' || geomType === 'area' || geomType === 'areaStack') return true;\n    }\n\n    return false;\n  };\n\n  _proto._adjustPosition = function _adjustPosition(position, isTailLegend) {\n    var pos;\n\n    if (isTailLegend) {\n      pos = 'right-top';\n    } else if (Util.isArray(position)) {\n      pos = String(position[0]) + '-' + String(position[1]);\n    } else {\n      var posArr = position.split('-');\n\n      if (posArr.length === 1) {\n        // 只用了left/right/bottom/top一个位置定位\n        if (posArr[0] === 'left') pos = 'left-bottom';\n        if (posArr[0] === 'right') pos = 'right-bottom';\n        if (posArr[0] === 'top') pos = 'top-center';\n        if (posArr[0] === 'bottom') pos = 'bottom-center';\n      } else {\n        pos = position;\n      }\n    }\n\n    return pos;\n  };\n\n  _proto.addLegend = function addLegend(scale, attr, geom, filterVals) {\n    var self = this;\n    var legendOptions = self.options;\n    var field = scale.field;\n    var fieldOption = legendOptions[field];\n    var viewTheme = self.viewTheme;\n\n    if (fieldOption === false) {\n      // 如果不显示此图例\n      return null;\n    }\n\n    if (fieldOption && fieldOption.custom) {\n      self.addCustomLegend(field);\n    } else {\n      var position = legendOptions.position || viewTheme.defaultLegendPosition;\n      position = self._adjustPosition(position, self._isTailLegend(legendOptions, geom));\n\n      if (fieldOption && fieldOption.position) {\n        // 如果对某个图例单独设置 position，则对 position 重新赋值\n        position = self._adjustPosition(fieldOption.position, self._isTailLegend(fieldOption, geom));\n      }\n\n      var legend;\n\n      if (scale.isLinear) {\n        legend = self._addContinuousLegend(scale, attr, position);\n      } else {\n        legend = self._addCategoryLegend(scale, attr, geom, filterVals, position);\n      }\n\n      if (legend) {\n        self._bindHoverEvent(legend, field);\n\n        legendOptions.reactive && self._bindChartMove(scale);\n      }\n    }\n  };\n  /**\n   * 自定义图例\n   * @param {string} field 自定义图例的数据字段名，可以为空\n   * @return {object} legend 自定义图例实例\n   */\n\n\n  _proto.addCustomLegend = function addCustomLegend(field) {\n    var self = this;\n    var chart = self.chart;\n    var viewTheme = self.viewTheme;\n    var container = self.container;\n    var legendOptions = self.options;\n\n    if (field) {\n      legendOptions = legendOptions[field];\n    }\n\n    var position = legendOptions.position || viewTheme.defaultLegendPosition;\n    position = self._adjustPosition(position);\n    var legends = self.legends;\n    legends[position] = legends[position] || [];\n    var items = legendOptions.items;\n\n    if (!items) {\n      return;\n    }\n\n    var geoms = chart.getAllGeoms();\n    Util.each(items, function (item) {\n      var geom = findGeom(geoms, item.value);\n\n      if (!Util.isObject(item.marker)) {\n        item.marker = {\n          symbol: item.marker ? item.marker : 'circle',\n          fill: item.fill,\n          radius: MARKER_SIZE\n        };\n      } else {\n        item.marker.radius = item.marker.radius || MARKER_SIZE;\n      }\n\n      item.checked = Util.isNil(item.checked) ? true : item.checked;\n      item.geom = geom;\n    });\n    var canvas = chart.get('canvas');\n    var plotRange = self.plotRange;\n    var posArray = position.split('-');\n    var maxLength = posArray[0] === 'right' || posArray[0] === 'left' ? plotRange.bl.y - plotRange.tr.y : canvas.get('width');\n    var legendCfg = Util.deepMix({}, viewTheme.legend[posArray[0]], legendOptions, {\n      maxLength: maxLength,\n      items: items,\n      container: container,\n      position: [0, 0]\n    });\n    var legend;\n\n    if (legendOptions.useHtml) {\n      var htmlContainer = legendOptions.container;\n\n      if (/^\\#/.test(container)) {\n        // 如果传入 dom 节点的 id\n        var id = htmlContainer.replace('#', '');\n        htmlContainer = document.getElementById(id);\n      } else if (!htmlContainer) {\n        htmlContainer = container.get('canvas').get('el').parentNode;\n      }\n\n      legendCfg.container = htmlContainer;\n      if (legendCfg.legendStyle === undefined) legendCfg.legendStyle = {};\n\n      if (!legendCfg.legendStyle.CONTAINER_CLASS) {\n        legendCfg.legendStyle.CONTAINER_CLASS = {\n          height: posArray[0] === 'right' || posArray[0] === 'left' ? maxLength + 'px' : 'auto',\n          width: !(posArray[0] === 'right' || posArray[0] === 'left') ? maxLength + 'px' : 'auto',\n          position: 'absolute',\n          overflow: 'auto'\n        };\n      }\n\n      if (legendOptions.flipPage) legend = new Legend.CatPageHtml(legendCfg);else legend = new Legend.CatHtml(legendCfg);\n    } else legend = new Legend.Category(legendCfg);\n\n    legends[position].push(legend);\n    legend.on('itemclick', function (ev) {\n      if (legendOptions.onClick) {\n        // 用户自定义了图例点击事件\n        legendOptions.onClick(ev);\n      }\n    });\n\n    self._bindHoverEvent(legend);\n\n    return legend;\n  };\n\n  _proto.addMixedLegend = function addMixedLegend(scales, geoms) {\n    var self = this;\n    var items = [];\n    Util.each(scales, function (scale) {\n      var value = scale.field;\n      Util.each(geoms, function (geom) {\n        if (geom.getYScale() === scale && scale.values && scale.values.length > 0) {\n          var shapeType = geom.get('shapeType') || 'point';\n          var shape = geom.getDefaultValue('shape') || 'circle';\n          var shapeObject = Shape.getShapeFactory(shapeType);\n          var cfg = {\n            color: geom.getDefaultValue('color')\n          };\n          var marker = shapeObject.getMarkerCfg(shape, cfg);\n          var item = {\n            value: value,\n            marker: marker\n          };\n          items.push(item);\n        }\n      }); // end of geom loop\n    }); // end of scale loop\n\n    var options = {\n      custom: true,\n      items: items\n    };\n    self.options = Util.deepMix({}, options, self.options);\n    var legend = self.addCustomLegend();\n\n    self._bindClickEventForMix(legend);\n  };\n\n  _proto.alignLegends = function alignLegends() {\n    var self = this;\n    var legends = self.legends;\n\n    var totalRegion = self._getRegion(legends);\n\n    self.totalRegion = totalRegion;\n    var i = 0;\n    Util.each(legends, function (legendItems, position) {\n      var region =\n      /* self._getRegion(legendItems)*/\n      totalRegion.subs[i];\n      Util.each(legendItems, function (legend, index) {\n        var pre = legendItems[index - 1];\n\n        if (!(legend.get('useHtml') && !legend.get('autoPosition'))) {\n          self._alignLegend(legend, pre, region, position);\n        }\n      });\n      i++;\n    });\n    return this;\n  };\n\n  return LegendController;\n}();\n\nmodule.exports = LegendController;\n\n/***/ }),\n/* 352 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview The class of tail legend\n * @author Ye Liu\n */\nvar Util = __webpack_require__(0); // const Category = require('./category');\n\n\nvar Components = __webpack_require__(21);\n\nvar Global = __webpack_require__(7);\n\nvar Legend = Components.Legend;\nvar Category = Legend.Category;\n\nvar Tail =\n/*#__PURE__*/\nfunction (_Category) {\n  _inheritsLoose(Tail, _Category);\n\n  function Tail() {\n    return _Category.apply(this, arguments) || this;\n  }\n\n  var _proto = Tail.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Category.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      /**\n       * type标识\n       * @type {String}\n       */\n      type: 'tail-legend',\n\n      /**\n       * 布局方式\n       * horizontal 水平\n       * vertical 垂直\n       * @type {String}\n       */\n      layout: 'vertical',\n      autoLayout: true\n    });\n  };\n\n  _proto._addItem = function _addItem(item) {\n    var itemsGroup = this.get('itemsGroup');\n\n    var x = this._getNextX();\n\n    var y = 0;\n    var unCheckColor = this.get('unCheckColor');\n    var itemGroup = itemsGroup.addGroup({\n      x: 0,\n      y: 0,\n      value: item.value,\n      scaleValue: item.scaleValue,\n      checked: item.checked\n    });\n    itemGroup.translate(x, y);\n    itemGroup.set('viewId', itemsGroup.get('viewId'));\n    var textStyle = this.get('textStyle');\n    var wordSpace = this.get('_wordSpaceing');\n    var startX = 0;\n\n    if (item.marker) {\n      // 如果有marker添加marker\n      var markerAttrs = Util.mix({}, item.marker, {\n        x: item.marker.radius,\n        y: 0\n      });\n\n      if (!item.checked) {\n        if (markerAttrs.fill) {\n          markerAttrs.fill = unCheckColor;\n        }\n\n        if (markerAttrs.stroke) {\n          markerAttrs.stroke = unCheckColor;\n        }\n      }\n\n      var markerShape = itemGroup.addShape('marker', {\n        type: 'marker',\n        attrs: markerAttrs\n      });\n      markerShape.attr('cursor', 'pointer');\n      markerShape.name = 'legend-marker';\n      startX += markerShape.getBBox().width + wordSpace;\n    }\n\n    var textAttrs = Util.mix({}, textStyle, {\n      x: startX,\n      y: 0,\n      text: this._formatItemValue(item.value)\n    });\n\n    if (!item.checked) {\n      Util.mix(textAttrs, {\n        fill: unCheckColor\n      });\n    }\n\n    var textShape = itemGroup.addShape('text', {\n      attrs: textAttrs\n    });\n    textShape.attr('cursor', 'pointer');\n    textShape.name = 'legend-text';\n    this.get('appendInfo') && textShape.setSilent('appendInfo', this.get('appendInfo')); // 添加一个包围矩形，用于事件支持\n\n    var bbox = itemGroup.getBBox();\n    var itemWidth = this.get('itemWidth');\n    var wrapperShape = itemGroup.addShape('rect', {\n      attrs: {\n        x: x,\n        y: y - bbox.height / 2,\n        fill: '#fff',\n        fillOpacity: 0,\n        width: itemWidth || bbox.width,\n        height: bbox.height\n      }\n    });\n    wrapperShape.attr('cursor', 'pointer');\n    wrapperShape.setSilent('origin', item); // 保存图例项相关的数据，便于事件操作\n\n    wrapperShape.name = 'legend-item';\n    this.get('appendInfo') && wrapperShape.setSilent('appendInfo', this.get('appendInfo'));\n    itemGroup.name = 'legendGroup';\n    return itemGroup;\n  };\n\n  _proto._adjust = function _adjust() {\n    var self = this;\n    var geom = self.get('geom');\n\n    if (geom) {\n      var groupMatrix = self.get('group').attr('matrix');\n      groupMatrix[7] = 0;\n      var dataArray = self.get('geom').get('dataArray');\n      var groups = this.get('itemsGroup').get('children');\n      var index = 0;\n      Util.each(groups, function (groupItem) {\n        var dArray = dataArray[index];\n        var lastY = dArray[dArray.length - 1].y;\n\n        if (Util.isArray(lastY)) {\n          lastY = lastY[1];\n        }\n\n        var groupHeight = groupItem.getBBox().height;\n        var x = groupItem.get('x');\n        var y = lastY - groupHeight / 2;\n        groupItem.translate(x, y);\n        index++;\n      });\n\n      if (self.get('autoLayout')) {\n        self._antiCollision(groups);\n      }\n    }\n  };\n\n  _proto.render = function render() {\n    var _this = this;\n\n    _Category.prototype.render.call(this);\n\n    var chart = this.get('chart');\n    chart.once('afterpaint', function () {\n      _this._adjust();\n    });\n  };\n\n  _proto._getPreviousY = function _getPreviousY(item) {\n    var y = item.attr('matrix')[7];\n    var height = item.getBBox().height;\n    return y + height;\n  };\n\n  _proto._adjustDenote = function _adjustDenote(group, start, end) {\n    var margin = Global.legend.legendMargin;\n    var x0 = -2;\n    var x2 = -margin * 2;\n    group.addShape('path', {\n      attrs: {\n        path: 'M' + x0 + ',' + start + 'L' + x2 + ',' + (end + 3),\n        lineWidth: 1,\n        lineDash: [2, 2],\n        stroke: '#999999'\n      }\n    });\n  };\n\n  _proto._antiCollision = function _antiCollision(items) {\n    var self = this;\n    items.sort(function (a, b) {\n      var ay = a.attr('matrix')[7];\n      var by = b.attr('matrix')[7];\n      return ay - by;\n    });\n    var overlapping = true;\n    var plotRange = self.get('chart').get('plotRange');\n    var startY = plotRange.tl.y;\n    var totalHeight = Math.abs(startY - plotRange.bl.y);\n    var elementHeight = items[0].getBBox().height;\n    var minY = Number.MIN_VALUE;\n    var maxY = 0;\n    var boxes = items.map(function (item) {\n      var y = item.attr('matrix')[7];\n\n      if (y > maxY) {\n        maxY = y;\n      }\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      return {\n        size: item.getBBox().height,\n        targets: [y - startY]\n      };\n    });\n    minY -= startY;\n    var i = 0;\n\n    while (overlapping) {\n      for (var _i = 0; _i < boxes.length; _i++) {\n        var box = boxes[_i];\n        var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n        box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      }\n\n      overlapping = false;\n      i = boxes.length;\n\n      while (i--) {\n        if (i > 0) {\n          var previous = boxes[i - 1];\n          var current = boxes[i];\n\n          if (previous.pos + previous.size > current.pos) {\n            // overlapping\n            previous.size += current.size;\n            previous.targets = previous.targets.concat(current.targets);\n            boxes.splice(i, 1);\n            overlapping = true;\n          }\n        }\n      } // end of while i\n\n    } // end of while\n    // adjust y\n\n\n    i = 0;\n    var group = this.get('itemsGroup').addGroup();\n    boxes.forEach(function (b) {\n      var posInCompositeBox = startY + elementHeight;\n      b.targets.forEach(function () {\n        var origin_y = items[i].attr('matrix')[7];\n        var y = b.pos + posInCompositeBox - elementHeight / 2;\n        var dist = Math.abs(origin_y - y);\n\n        if (dist > elementHeight / 2) {\n          self._adjustDenote(group, y, origin_y - self.get('group').attr('matrix')[7] / 2);\n        }\n\n        items[i].translate(0, -origin_y);\n        items[i].translate(0, y);\n        posInCompositeBox += elementHeight;\n        i++;\n      });\n    });\n  }; // end of antiCollision\n\n\n  return Tail;\n}(Category);\n\nmodule.exports = Tail;\n\n/***/ }),\n/* 353 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The controller of tooltip\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar _require = __webpack_require__(21),\n    Tooltip = _require.Tooltip;\n\nvar MatrixUtil = Util.MatrixUtil;\nvar Vector2 = MatrixUtil.vec2;\nvar TYPE_SHOW_MARKERS = ['line', 'area', 'path', 'areaStack']; // 默认展示 tooltip marker 的几何图形\n\nvar TYPE_SHOW_CROSSHAIRS = ['line', 'area']; // 默认展示十字瞄准线的几何图形\n// TODO FIXME this is HARD CODING\n\nvar IGNORE_TOOLTIP_ITEM_PROPERTIES = ['marker', 'showMarker'];\n\nfunction _indexOfArray(items, item) {\n  var rst = -1;\n  Util.each(items, function (sub, index) {\n    var isEqual = true;\n\n    for (var key in item) {\n      if (item.hasOwnProperty(key) && IGNORE_TOOLTIP_ITEM_PROPERTIES.indexOf(key) === -1) {\n        if (!Util.isObject(item[key]) && item[key] !== sub[key]) {\n          isEqual = false;\n          break;\n        }\n      }\n    }\n\n    if (isEqual) {\n      rst = index;\n      return false;\n    }\n  });\n  return rst;\n} // 判断是否有样式\n\n\nfunction _hasClass(dom, className) {\n  if (!dom) {\n    return false;\n  }\n\n  var cls = '';\n  if (!dom.className) return false;\n\n  if (!Util.isNil(dom.className.baseVal)) {\n    cls = dom.className.baseVal;\n  } else {\n    cls = dom.className;\n  }\n\n  return cls.indexOf(className) !== -1;\n}\n\nfunction _isParent(dom, cls) {\n  var parent = dom.parentNode;\n  var rst = false;\n\n  while (parent && parent !== document.body) {\n    if (_hasClass(parent, cls)) {\n      rst = true;\n      break;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return rst;\n} // 去除重复的值, 去除不同图形相同数据，只展示一份即可\n\n\nfunction _uniqItems(items) {\n  var tmp = [];\n  Util.each(items, function (item) {\n    var index = _indexOfArray(tmp, item);\n\n    if (index === -1) {\n      tmp.push(item);\n    } else {\n      tmp[index] = item;\n    }\n  });\n  return tmp;\n}\n\nvar TooltipController =\n/*#__PURE__*/\nfunction () {\n  function TooltipController(cfg) {\n    Util.assign(this, cfg);\n    this.timeStamp = 0;\n  }\n\n  var _proto = TooltipController.prototype;\n\n  _proto._normalizeEvent = function _normalizeEvent(event) {\n    var chart = this.chart;\n\n    var canvas = this._getCanvas();\n\n    var point = canvas.getPointByClient(event.clientX, event.clientY);\n    var pixelRatio = canvas.get('pixelRatio');\n    point.x = point.x / pixelRatio;\n    point.y = point.y / pixelRatio;\n    var views = chart.getViewsByPoint(point);\n    point.views = views;\n    return point;\n  };\n\n  _proto._getCanvas = function _getCanvas() {\n    return this.chart.get('canvas');\n  };\n\n  _proto._getTriggerEvent = function _getTriggerEvent() {\n    var options = this.options;\n    var triggerOn = options.triggerOn;\n    var eventName;\n\n    if (!triggerOn || triggerOn === 'mousemove') {\n      eventName = 'plotmove';\n    } else if (triggerOn === 'click') {\n      eventName = 'plotclick';\n    } else if (triggerOn === 'none') {\n      eventName = null;\n    }\n\n    return eventName;\n  };\n\n  _proto._getDefaultTooltipCfg = function _getDefaultTooltipCfg() {\n    var self = this;\n    var chart = self.chart;\n    var viewTheme = self.viewTheme;\n    var options = self.options;\n    var defaultCfg = Util.mix({}, viewTheme.tooltip);\n    var geoms = chart.getAllGeoms().filter(function (geom) {\n      return geom.get('visible');\n    });\n    var shapes = [];\n    Util.each(geoms, function (geom) {\n      var type = geom.get('type');\n      var adjusts = geom.get('adjusts');\n      var isSymmetric = false;\n\n      if (adjusts) {\n        Util.each(adjusts, function (adjust) {\n          if (adjust.type === 'symmetric' || adjust.type === 'Symmetric') {\n            isSymmetric = true;\n            return false;\n          }\n        });\n      }\n\n      if (Util.indexOf(shapes, type) === -1 && !isSymmetric) {\n        shapes.push(type);\n      }\n    });\n    var isTransposed = geoms.length && geoms[0].get('coord') ? geoms[0].get('coord').isTransposed : false;\n    var crosshairsCfg;\n\n    if (geoms.length && geoms[0].get('coord') && geoms[0].get('coord').type === 'cartesian') {\n      if (shapes[0] === 'interval' && options.shared !== false) {\n        // 直角坐标系下 interval 的 crosshair 为矩形背景框\n        var crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsRect);\n        crosshairs.isTransposed = isTransposed;\n        crosshairsCfg = {\n          zIndex: 0,\n          // 矩形背景框不可覆盖 geom\n          crosshairs: crosshairs\n        };\n      } else if (Util.indexOf(TYPE_SHOW_CROSSHAIRS, shapes[0]) > -1) {\n        var _crosshairs = Util.mix({}, viewTheme.tooltipCrosshairsLine);\n\n        _crosshairs.isTransposed = isTransposed;\n        crosshairsCfg = {\n          crosshairs: _crosshairs\n        };\n      }\n    }\n\n    return Util.mix(defaultCfg, crosshairsCfg, {});\n  };\n\n  _proto._bindEvent = function _bindEvent() {\n    var chart = this.chart;\n\n    var triggerEvent = this._getTriggerEvent();\n\n    if (triggerEvent) {\n      chart.on(triggerEvent, Util.wrapBehavior(this, 'onMouseMove'));\n      chart.on('plotleave', Util.wrapBehavior(this, 'onMouseOut'));\n    }\n  };\n\n  _proto._offEvent = function _offEvent() {\n    var chart = this.chart;\n\n    var triggerEvent = this._getTriggerEvent();\n\n    if (triggerEvent) {\n      chart.off(triggerEvent, Util.getWrapBehavior(this, 'onMouseMove'));\n      chart.off('plotleave', Util.getWrapBehavior(this, 'onMouseOut'));\n    }\n  };\n\n  _proto._setTooltip = function _setTooltip(point, items, markersItems, target) {\n    var self = this;\n    var tooltip = self.tooltip;\n    var prePoint = self.prePoint;\n\n    if (!prePoint || prePoint.x !== point.x || prePoint.y !== point.y) {\n      items = _uniqItems(items);\n      self.prePoint = point;\n      var chart = self.chart;\n      var viewTheme = self.viewTheme;\n      var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;\n      var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;\n\n      if (!tooltip.get('visible')) {\n        chart.emit('tooltip:show', {\n          x: x,\n          y: y,\n          tooltip: tooltip\n        });\n      }\n\n      var first = items[0];\n      var title = first.title || first.name;\n\n      if (tooltip.isContentChange(title, items)) {\n        chart.emit('tooltip:change', {\n          tooltip: tooltip,\n          x: x,\n          y: y,\n          items: items\n        }); // bugfix: when set the title in the tooltip:change event does not take effect.\n\n        title = items[0].title || items[0].name;\n        tooltip.setContent(title, items);\n\n        if (!Util.isEmpty(markersItems)) {\n          if (self.options.hideMarkers === true) {\n            // 不展示 tooltip marker\n            tooltip.set('markerItems', markersItems); // 用于 tooltip 辅助线的定位\n          } else {\n            tooltip.setMarkers(markersItems, viewTheme.tooltipMarker);\n          }\n        } else {\n          tooltip.clearMarkers(); // clearMarkers 只会将 markerItems 从 markerGroup 中移除\n          // 所以我们还要将 markerItems 从 tooltip 中移除\n          // 这么做是为了防止上一次设置 marker 时的 markerItems 影响此次 tooltip 辅助线的定位\n\n          tooltip.set('markerItems', []);\n        }\n      }\n\n      var canvas = this._getCanvas();\n\n      if (target === canvas && tooltip.get('type') === 'mini') {\n        // filter mini tooltip\n        tooltip.hide();\n      } else {\n        tooltip.setPosition(x, y, target);\n        tooltip.show();\n      }\n    }\n  };\n\n  _proto.hideTooltip = function hideTooltip() {\n    var tooltip = this.tooltip;\n    var chart = this.chart;\n\n    var canvas = this._getCanvas();\n\n    this.prePoint = null;\n    tooltip.hide();\n    chart.emit('tooltip:hide', {\n      tooltip: tooltip\n    });\n    canvas.draw();\n  };\n\n  _proto.onMouseMove = function onMouseMove(ev) {\n    if (Util.isEmpty(ev.views)) {\n      return;\n    }\n\n    var lastTimeStamp = this.timeStamp;\n    var timeStamp = +new Date();\n    var point = {\n      x: ev.x,\n      y: ev.y\n    };\n\n    if (timeStamp - lastTimeStamp > 16 && !this.chart.get('stopTooltip')) {\n      this.showTooltip(point, ev.views, ev.shape);\n      this.timeStamp = timeStamp;\n    }\n  };\n\n  _proto.onMouseOut = function onMouseOut(ev) {\n    var tooltip = this.tooltip; // const canvas = this._getCanvas();\n\n    if (!tooltip.get('visible') || !tooltip.get('follow')) {\n      return;\n    } // 除非离开 plot 时鼠标依然在图形上，这段逻辑没有意义\n    // if (ev && ev.target !== canvas) {\n    //   return;\n    // }\n\n\n    if (ev && ev.toElement && (_hasClass(ev.toElement, 'g2-tooltip') || _isParent(ev.toElement, 'g2-tooltip'))) {\n      return;\n    }\n\n    this.hideTooltip();\n  };\n\n  _proto.renderTooltip = function renderTooltip() {\n    var self = this;\n\n    if (self.tooltip) {\n      // tooltip 对象已经创建\n      return;\n    }\n\n    var chart = self.chart;\n    var viewTheme = self.viewTheme;\n\n    var canvas = self._getCanvas();\n\n    var defaultCfg = self._getDefaultTooltipCfg();\n\n    var options = self.options;\n    options = Util.deepMix({\n      plotRange: chart.get('plotRange'),\n      capture: false,\n      canvas: canvas,\n      frontPlot: chart.get('frontPlot'),\n      viewTheme: viewTheme.tooltip,\n      backPlot: chart.get('backPlot')\n    }, defaultCfg, options);\n\n    if (options.crosshairs && options.crosshairs.type === 'rect') {\n      options.zIndex = 0; // toolip 背景框不可遮盖住 geom，防止用户配置了 crosshairs\n    }\n\n    options.visible = false; // @2018-09-13 by blue.lb 如果设置shared为false不需要指定position\n    // if (options.shared === false && Util.isNil(options.position)) {\n    //   options.position = 'top';\n    // }\n\n    var tooltip;\n\n    if (options.type === 'mini') {\n      options.crosshairs = false; // this.options.shared = false;\n\n      options.position = 'top';\n      tooltip = new Tooltip.Mini(options);\n    } else if (options.useHtml) {\n      tooltip = new Tooltip.Html(options);\n    } else {\n      tooltip = new Tooltip.Canvas(options);\n    }\n\n    self.tooltip = tooltip;\n\n    var triggerEvent = self._getTriggerEvent();\n\n    if (!tooltip.get('enterable') && triggerEvent === 'plotmove') {\n      // 鼠标不允许进入 tooltip 容器\n      var tooltipContainer = tooltip.get('container');\n\n      if (tooltipContainer) {\n        tooltipContainer.onmousemove = function (e) {\n          // 避免 tooltip 频繁闪烁\n          var eventObj = self._normalizeEvent(e);\n\n          chart.emit(triggerEvent, eventObj);\n        };\n      }\n    }\n\n    self._bindEvent();\n  };\n\n  _proto.showTooltip = function showTooltip(point, views, target) {\n    var self = this;\n\n    if (Util.isEmpty(views) || !point) {\n      return;\n    }\n\n    if (!this.tooltip) {\n      this.renderTooltip(); // 如果一开始 tooltip 关闭，用户重新调用的时候需要先生成 tooltip\n    }\n\n    var options = self.options;\n    var markersItems = [];\n    var items = [];\n    Util.each(views, function (view) {\n      if (!view.get('tooltipEnable')) {\n        // 如果不显示tooltip，则跳过\n        return true;\n      }\n\n      var geoms = view.get('geoms');\n      var coord = view.get('coord');\n      Util.each(geoms, function (geom) {\n        var type = geom.get('type');\n\n        if (geom.get('visible') && geom.get('tooltipCfg') !== false) {\n          var dataArray = geom.get('dataArray');\n\n          if (geom.isShareTooltip() || options.shared === false && Util.inArray(['area', 'line', 'path', 'polygon'], type)) {\n            Util.each(dataArray, function (obj) {\n              var tmpPoint = geom.findPoint(point, obj);\n\n              if (tmpPoint) {\n                var subItems = geom.getTipItems(tmpPoint, options.title);\n                Util.each(subItems, function (v) {\n                  var point = v.point;\n\n                  if (point && point.x && point.y) {\n                    // hotfix: make sure there is no null value\n                    var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;\n                    var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;\n                    point = coord.applyMatrix(x, y, 1);\n                    v.x = point[0];\n                    v.y = point[1];\n                    v.showMarker = true;\n\n                    var itemMarker = self._getItemMarker(geom, v.color);\n\n                    v.marker = itemMarker;\n\n                    if (Util.indexOf(TYPE_SHOW_MARKERS, type) !== -1) {\n                      markersItems.push(v);\n                    }\n                  }\n                });\n                items = items.concat(subItems);\n              }\n            });\n          } else {\n            var geomContainer = geom.get('shapeContainer');\n            var canvas = geomContainer.get('canvas');\n            var pixelRatio = canvas.get('pixelRatio');\n            var shape = geomContainer.getShape(point.x * pixelRatio, point.y * pixelRatio);\n\n            if (shape && shape.get('visible') && shape.get('origin')) {\n              items = geom.getTipItems(shape.get('origin'), options.title);\n            }\n          }\n        }\n      });\n      Util.each(items, function (item) {\n        var point = item.point;\n        var x = Util.isArray(point.x) ? point.x[point.x.length - 1] : point.x;\n        var y = Util.isArray(point.y) ? point.y[point.y.length - 1] : point.y;\n        point = coord.applyMatrix(x, y, 1);\n        item.x = point[0];\n        item.y = point[1];\n      });\n    });\n\n    if (items.length) {\n      var first = items[0]; // bugfix: multiple tooltip items with different titles\n\n      if (!items.every(function (item) {\n        return item.title === first.title;\n      })) {\n        var nearestItem = first;\n        var nearestDistance = Infinity;\n        items.forEach(function (item) {\n          var distance = Vector2.distance([point.x, point.y], [item.x, item.y]);\n\n          if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestItem = item;\n          }\n        });\n        items = items.filter(function (item) {\n          return item.title === nearestItem.title;\n        });\n        markersItems = markersItems.filter(function (item) {\n          return item.title === nearestItem.title;\n        });\n      }\n\n      if (options.shared === false && items.length > 1) {\n        var snapItem = items[0];\n        var min = Math.abs(point.y - snapItem.y);\n        Util.each(items, function (aItem) {\n          if (Math.abs(point.y - aItem.y) <= min) {\n            snapItem = aItem;\n            min = Math.abs(point.y - aItem.y);\n          }\n        });\n\n        if (snapItem && snapItem.x && snapItem.y) {\n          markersItems = [snapItem];\n        }\n\n        items = [snapItem];\n      } // 3.0 采用当前鼠标位置作为 tooltip 的参考点\n      // if (!Util.isEmpty(markersItems)) {\n      //   point = markersItems[0];\n      // }\n\n\n      self._setTooltip(point, items, markersItems, target);\n    } else {\n      self.hideTooltip();\n    }\n  };\n\n  _proto.clear = function clear() {\n    var tooltip = this.tooltip;\n    tooltip && tooltip.destroy();\n    this.tooltip = null;\n    this.prePoint = null;\n\n    this._offEvent();\n  };\n\n  _proto._getItemMarker = function _getItemMarker(geom, color) {\n    var shapeType = geom.get('shapeType') || 'point';\n    var shape = geom.getDefaultValue('shape') || 'circle';\n    var shapeObject = Shape.getShapeFactory(shapeType);\n    var cfg = {\n      color: color\n    };\n    var marker = shapeObject.getMarkerCfg(shape, cfg);\n    return marker;\n  };\n\n  return TooltipController;\n}();\n\nmodule.exports = TooltipController;\n\n/***/ }),\n/* 354 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The controller of chart's events\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nfunction isSameShape(shape1, shape2) {\n  if (Util.isNil(shape1) || Util.isNil(shape2)) {\n    return false;\n  }\n\n  var shape1Origin = shape1.get('origin');\n  var shape2Origin = shape2.get('origin'); // hotfix: if both shapes have no data，just compare shapes.\n\n  if (Util.isNil(shape1Origin) && Util.isNil(shape2Origin)) {\n    return Util.isEqual(shape1, shape2);\n  }\n\n  return Util.isEqual(shape1Origin, shape2Origin);\n}\n\nfunction registerData(eventObj) {\n  if (eventObj.shape && eventObj.shape.get('origin')) {\n    eventObj.data = eventObj.shape.get('origin');\n  }\n}\n\nvar EventController =\n/*#__PURE__*/\nfunction () {\n  function EventController(cfg) {\n    this.view = null;\n    this.canvas = null;\n    Util.assign(this, cfg);\n\n    this._init();\n  }\n\n  var _proto = EventController.prototype;\n\n  _proto._init = function _init() {\n    this.pixelRatio = this.canvas.get('pixelRatio');\n  };\n\n  _proto._getShapeEventObj = function _getShapeEventObj(ev) {\n    return {\n      x: ev.x / this.pixelRatio,\n      y: ev.y / this.pixelRatio,\n      target: ev.target,\n      // canvas 元素\n      toElement: ev.event.toElement || ev.event.relatedTarget\n    };\n  };\n\n  _proto._getShape = function _getShape(x, y) {\n    var view = this.view;\n    var container = view.get('canvas');\n    return container.getShape(x, y);\n  };\n\n  _proto._getPointInfo = function _getPointInfo(ev) {\n    var view = this.view;\n    var point = {\n      x: ev.x / this.pixelRatio,\n      y: ev.y / this.pixelRatio\n    };\n    var views = view.getViewsByPoint(point);\n    point.views = views;\n    return point;\n  };\n\n  _proto._getEventObj = function _getEventObj(ev, point, views) {\n    return {\n      x: point.x,\n      y: point.y,\n      target: ev.target,\n      // canvas 元素\n      toElement: ev.event.toElement || ev.event.relatedTarget,\n      // 目标元素\n      views: views\n    };\n  };\n\n  _proto.bindEvents = function bindEvents() {\n    var canvas = this.canvas;\n    canvas.on('mousedown', Util.wrapBehavior(this, 'onDown'));\n    canvas.on('mousemove', Util.wrapBehavior(this, 'onMove'));\n    canvas.on('mouseleave', Util.wrapBehavior(this, 'onOut'));\n    canvas.on('mouseup', Util.wrapBehavior(this, 'onUp'));\n    canvas.on('click', Util.wrapBehavior(this, 'onClick'));\n    canvas.on('dblclick', Util.wrapBehavior(this, 'onClick'));\n    canvas.on('touchstart', Util.wrapBehavior(this, 'onTouchstart'));\n    canvas.on('touchmove', Util.wrapBehavior(this, 'onTouchmove'));\n    canvas.on('touchend', Util.wrapBehavior(this, 'onTouchend'));\n  };\n\n  _proto._triggerShapeEvent = function _triggerShapeEvent(shape, eventName, eventObj) {\n    if (shape && shape.name && !shape.get('destroyed')) {\n      var view = this.view;\n\n      if (view.isShapeInView(shape)) {\n        var name = shape.name + ':' + eventName;\n        eventObj.view = view;\n        eventObj.appendInfo = shape.get('appendInfo'); // appendInfo is defined by user\n\n        view.emit(name, eventObj);\n        var parent = view.get('parent');\n\n        if (parent) {\n          // chart 上也需要抛出该事件，本期先不抛出\n          parent.emit(name, eventObj);\n        }\n      }\n    }\n  };\n\n  _proto.onDown = function onDown(ev) {\n    var view = this.view;\n\n    var eventObj = this._getShapeEventObj(ev);\n\n    eventObj.shape = this.currentShape;\n    registerData(eventObj);\n    view.emit('mousedown', eventObj);\n\n    this._triggerShapeEvent(this.currentShape, 'mousedown', eventObj);\n  };\n\n  _proto.onMove = function onMove(ev) {\n    var self = this;\n    var view = self.view;\n    var currentShape = self.currentShape; // 如果图形被销毁，则设置当前 shape 为空\n\n    if (currentShape && currentShape.get('destroyed')) {\n      currentShape = null;\n      self.currentShape = null;\n    }\n\n    var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;\n\n    var eventObj = self._getShapeEventObj(ev);\n\n    eventObj.shape = shape;\n    registerData(eventObj);\n    view.emit('mousemove', eventObj);\n\n    self._triggerShapeEvent(shape, 'mousemove', eventObj);\n\n    if (currentShape && !isSameShape(currentShape, shape)) {\n      var leaveObj = self._getShapeEventObj(ev);\n\n      leaveObj.shape = currentShape;\n      leaveObj.toShape = shape;\n      registerData(leaveObj);\n\n      self._triggerShapeEvent(currentShape, 'mouseleave', leaveObj);\n    }\n\n    if (shape && !isSameShape(currentShape, shape)) {\n      var enterObj = self._getShapeEventObj(ev);\n\n      enterObj.shape = shape;\n      enterObj.fromShape = currentShape;\n      registerData(enterObj);\n\n      self._triggerShapeEvent(shape, 'mouseenter', enterObj);\n    }\n\n    self.currentShape = shape;\n\n    var point = self._getPointInfo(ev);\n\n    var preViews = self.curViews || [];\n\n    if (preViews.length === 0 && point.views.length) {\n      view.emit('plotenter', self._getEventObj(ev, point, point.views));\n    } // point.views 是指当前 view 或者子 view，不会取跟当前 view 同一层级的兄弟元素（view)\n\n\n    if (preViews.length && point.views.length === 0) {\n      view.emit('plotleave', self._getEventObj(ev, point, preViews));\n    }\n\n    if (point.views.length) {\n      eventObj = self._getEventObj(ev, point, point.views);\n      eventObj.shape = shape;\n      registerData(eventObj);\n      view.emit('plotmove', eventObj);\n    }\n\n    self.curViews = point.views;\n  };\n\n  _proto.onOut = function onOut(ev) {\n    var self = this;\n    var view = self.view;\n\n    var point = self._getPointInfo(ev);\n\n    var preViews = self.curViews || [];\n\n    var evtObj = self._getEventObj(ev, point, preViews); // 只有没有padding 时，当前依然在 view 的 plotRange 情况下才会出现这个情况，保证 plotleave 触发\n\n\n    if (self.curViews && self.curViews.length !== 0 && (!evtObj.toElement || evtObj.toElement.tagName !== 'CANVAS')) {\n      view.emit('plotleave', evtObj);\n      self.curViews = []; // 清空\n    }\n  };\n\n  _proto.onUp = function onUp(ev) {\n    var view = this.view;\n\n    var eventObj = this._getShapeEventObj(ev);\n\n    eventObj.shape = this.currentShape;\n    view.emit('mouseup', eventObj);\n\n    this._triggerShapeEvent(this.currentShape, 'mouseup', eventObj);\n  };\n\n  _proto.onClick = function onClick(ev) {\n    var self = this;\n    var view = self.view;\n    var shape = self._getShape(ev.x, ev.y) || ev.currentTarget;\n\n    var shapeEventObj = self._getShapeEventObj(ev);\n\n    shapeEventObj.shape = shape;\n    registerData(shapeEventObj);\n    view.emit('click', shapeEventObj);\n\n    self._triggerShapeEvent(shape, ev.type, shapeEventObj);\n\n    self.currentShape = shape;\n\n    var point = self._getPointInfo(ev);\n\n    var views = point.views;\n\n    if (!Util.isEmpty(views)) {\n      var eventObj = self._getEventObj(ev, point, views);\n\n      if (self.currentShape) {\n        var _shape = self.currentShape;\n        eventObj.shape = _shape;\n        registerData(eventObj); // eventObj.data = shape.get('origin');\n      }\n\n      view.emit('plotclick', eventObj);\n\n      if (ev.type === 'dblclick') {\n        view.emit('plotdblclick', eventObj);\n        view.emit('dblclick', shapeEventObj);\n      }\n    }\n  };\n\n  _proto.onTouchstart = function onTouchstart(ev) {\n    var view = this.view;\n    var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;\n\n    var eventObj = this._getShapeEventObj(ev);\n\n    eventObj.shape = shape;\n    registerData(eventObj);\n    view.emit('touchstart', eventObj);\n\n    this._triggerShapeEvent(shape, 'touchstart', eventObj);\n\n    this.currentShape = shape;\n  };\n\n  _proto.onTouchmove = function onTouchmove(ev) {\n    var view = this.view;\n    var shape = this._getShape(ev.x, ev.y) || ev.currentTarget;\n\n    var eventObj = this._getShapeEventObj(ev);\n\n    eventObj.shape = shape;\n    registerData(eventObj);\n    view.emit('touchmove', eventObj);\n\n    this._triggerShapeEvent(shape, 'touchmove', eventObj);\n\n    this.currentShape = shape;\n  };\n\n  _proto.onTouchend = function onTouchend(ev) {\n    var view = this.view;\n\n    var eventObj = this._getShapeEventObj(ev);\n\n    eventObj.shape = this.currentShape;\n    registerData(eventObj);\n    view.emit('touchend', eventObj);\n\n    this._triggerShapeEvent(this.currentShape, 'touchend', eventObj);\n  };\n\n  _proto.clearEvents = function clearEvents() {\n    var canvas = this.canvas;\n    canvas.off('mousemove', Util.getWrapBehavior(this, 'onMove'));\n    canvas.off('mouseleave', Util.getWrapBehavior(this, 'onOut'));\n    canvas.off('mousedown', Util.getWrapBehavior(this, 'onDown'));\n    canvas.off('mouseup', Util.getWrapBehavior(this, 'onUp'));\n    canvas.off('click', Util.getWrapBehavior(this, 'onClick'));\n    canvas.off('dblclick', Util.getWrapBehavior(this, 'onClick'));\n    canvas.off('touchstart', Util.getWrapBehavior(this, 'onTouchstart'));\n    canvas.off('touchmove', Util.getWrapBehavior(this, 'onTouchmove'));\n    canvas.off('touchend', Util.getWrapBehavior(this, 'onTouchend'));\n  };\n\n  return EventController;\n}();\n\nmodule.exports = EventController;\n\n/***/ }),\n/* 355 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview The entry of chart's animation\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar Animate = __webpack_require__(126);\n\nvar MatrixUtil = Util.MatrixUtil;\nvar mat3 = MatrixUtil.mat3; // 获取图组内所有的shapes\n\nfunction getShapes(container, viewId) {\n  var shapes = [];\n\n  if (container.get('animate') === false) {\n    return [];\n  }\n\n  var children = container.get('children');\n  Util.each(children, function (child) {\n    if (child.isGroup) {\n      shapes = shapes.concat(getShapes(child, viewId));\n    } else if (child.isShape && child._id) {\n      var id = child._id;\n      id = id.split('-')[0];\n\n      if (id === viewId) {\n        shapes.push(child);\n      }\n    }\n  });\n  return shapes;\n}\n\nfunction cache(shapes) {\n  var rst = {};\n  Util.each(shapes, function (shape) {\n    if (!shape._id || shape.isClip) return;\n    var id = shape._id;\n    rst[id] = {\n      _id: id,\n      type: shape.get('type'),\n      attrs: Util.cloneDeep(shape.attr()),\n      // 原始属性\n      name: shape.name,\n      index: shape.get('index'),\n      animateCfg: shape.get('animateCfg'),\n      coord: shape.get('coord')\n    };\n  });\n  return rst;\n}\n\nfunction getAnimate(geomType, coord, animationType, animationName) {\n  var result;\n\n  if (animationName) {\n    result = Animate.Action[animationType][animationName];\n  } else {\n    result = Animate.getAnimation(geomType, coord, animationType);\n  }\n\n  return result;\n}\n\nfunction getAnimateCfg(geomType, animationType, animateCfg) {\n  var defaultCfg = Animate.getAnimateCfg(geomType, animationType);\n\n  if (animateCfg && animateCfg[animationType]) {\n    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);\n  }\n\n  return defaultCfg;\n}\n\nfunction addAnimate(cache, shapes, canvas, isUpdate) {\n  var animate;\n  var animateCfg;\n  var canvasDrawn = false;\n\n  if (isUpdate) {\n    // Step: leave -> update -> enter\n    var updateShapes = []; // 存储的是 shapes\n\n    var newShapes = []; // 存储的是 shapes\n\n    Util.each(shapes, function (shape) {\n      var result = cache[shape._id];\n\n      if (!result) {\n        newShapes.push(shape);\n      } else {\n        shape.setSilent('cacheShape', result);\n        updateShapes.push(shape);\n        delete cache[shape._id];\n      }\n    });\n    Util.each(cache, function (deletedShape) {\n      var name = deletedShape.name,\n          coord = deletedShape.coord,\n          _id = deletedShape._id,\n          attrs = deletedShape.attrs,\n          index = deletedShape.index,\n          type = deletedShape.type;\n      animateCfg = getAnimateCfg(name, 'leave', deletedShape.animateCfg);\n      animate = getAnimate(name, coord, 'leave', animateCfg.animation);\n\n      if (Util.isFunction(animate)) {\n        var tempShape = canvas.addShape(type, {\n          attrs: attrs,\n          index: index\n        });\n        tempShape._id = _id;\n        tempShape.name = name;\n\n        if (coord && name !== 'label') {\n          var tempShapeMatrix = tempShape.getMatrix();\n          var finalMatrix = mat3.multiply([], tempShapeMatrix, coord.matrix);\n          tempShape.setMatrix(finalMatrix);\n        }\n\n        canvasDrawn = true;\n        animate(tempShape, animateCfg, coord);\n      }\n    });\n    Util.each(updateShapes, function (updateShape) {\n      var name = updateShape.name;\n      var coord = updateShape.get('coord');\n      var cacheAttrs = updateShape.get('cacheShape').attrs; // 判断如果属性相同的话就不进行变换\n\n      if (!Util.isEqual(cacheAttrs, updateShape.attr())) {\n        animateCfg = getAnimateCfg(name, 'update', updateShape.get('animateCfg'));\n        animate = getAnimate(name, coord, 'update', animateCfg.animation);\n\n        if (Util.isFunction(animate)) {\n          animate(updateShape, animateCfg, coord);\n        } else {\n          var endState = Util.cloneDeep(updateShape.attr());\n          updateShape.attr(cacheAttrs);\n          updateShape.animate(endState, animateCfg.duration, animateCfg.easing, function () {\n            updateShape.setSilent('cacheShape', null);\n          });\n        }\n\n        canvasDrawn = true;\n      }\n    });\n    Util.each(newShapes, function (newShape) {\n      var name = newShape.name;\n      var coord = newShape.get('coord');\n      animateCfg = getAnimateCfg(name, 'enter', newShape.get('animateCfg'));\n      animate = getAnimate(name, coord, 'enter', animateCfg.animation);\n\n      if (Util.isFunction(animate)) {\n        animate(newShape, animateCfg, coord);\n        canvasDrawn = true;\n      }\n    });\n  } else {\n    Util.each(shapes, function (shape) {\n      var name = shape.name;\n      var coord = shape.get('coord');\n      animateCfg = getAnimateCfg(name, 'appear', shape.get('animateCfg'));\n      animate = getAnimate(name, coord, 'appear', animateCfg.animation);\n\n      if (Util.isFunction(animate)) {\n        animate(shape, animateCfg, coord);\n        canvasDrawn = true;\n      }\n    });\n  }\n\n  return canvasDrawn;\n}\n\nmodule.exports = {\n  execAnimation: function execAnimation(view, isUpdate) {\n    var viewContainer = view.get('middlePlot');\n    var axisContainer = view.get('backPlot');\n    var viewId = view.get('_id');\n    var canvas = view.get('canvas');\n    var caches = canvas.get(viewId + 'caches') || [];\n\n    if (caches.length === 0) {\n      isUpdate = false;\n    }\n\n    var shapes = getShapes(viewContainer, viewId);\n    var axisShapes = getShapes(axisContainer, viewId);\n    var cacheShapes = shapes.concat(axisShapes);\n    canvas.setSilent(viewId + 'caches', cache(cacheShapes));\n    var drawn;\n\n    if (isUpdate) {\n      drawn = addAnimate(caches, cacheShapes, canvas, isUpdate);\n    } else {\n      drawn = addAnimate(caches, shapes, canvas, isUpdate);\n    }\n\n    if (!drawn) {\n      canvas.draw();\n    }\n  }\n};\n\n/***/ }),\n/* 356 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview The class of canvas plot\n * @author sima.zhang\n */\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(16),\n    Group = _require.Group;\n\nvar AUTO_STR = 'auto';\n\nvar PlotBack =\n/*#__PURE__*/\nfunction (_Group) {\n  _inheritsLoose(PlotBack, _Group);\n\n  function PlotBack() {\n    return _Group.apply(this, arguments) || this;\n  }\n\n  var _proto = PlotBack.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * 类型\n       * @type {String}\n       */\n      type: 'plotBack',\n\n      /**\n       * 画布边距\n       * @type {Number | Array | Object | \"auto\"}\n       */\n      padding: null,\n\n      /**\n       * 大背景\n       * @type {Object}\n       */\n      background: null,\n\n      /**\n       * 绘图区域范围\n       * @type {Object}\n       */\n      plotRange: null,\n\n      /**\n       * 绘图区域背景\n       * @type {Object}\n       */\n      plotBackground: null\n    };\n  };\n\n  _proto._beforeRenderUI = function _beforeRenderUI() {\n    this._calculateRange();\n  };\n\n  _proto._renderUI = function _renderUI() {\n    this._renderBackground();\n\n    this._renderPlotBackground();\n  };\n\n  _proto._renderBackground = function _renderBackground() {\n    var self = this;\n    var background = self.get('background');\n\n    if (background) {\n      var canvas = this.get('canvas');\n      var width = self.get('width') || canvas.get('width');\n      var height = self.get('height') || canvas.get('height');\n      var cfg = {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      };\n      var rect = self.get('backgroundShape');\n\n      if (!rect) {\n        rect = this.addShape('rect', {\n          attrs: Util.mix(cfg, background)\n        });\n        this.set('backgroundShape', rect);\n      } else {\n        rect.attr(cfg);\n      }\n    } else {\n      return;\n    }\n  };\n\n  _proto._renderPlotBackground = function _renderPlotBackground() {\n    var self = this;\n    var plotBackground = self.get('plotBackground');\n\n    if (plotBackground) {\n      var plotRange = self.get('plotRange');\n      var width = plotRange.br.x - plotRange.bl.x;\n      var height = plotRange.br.y - plotRange.tr.y;\n      var tl = plotRange.tl;\n      var cfg = {\n        x: tl.x,\n        y: tl.y,\n        width: width,\n        height: height\n      };\n      var plotBackShape = self.get('plotBackShape');\n\n      if (!plotBackShape) {\n        if (plotBackground.image) {\n          cfg.img = plotBackground.image;\n          plotBackShape = self.addShape('image', {\n            attrs: cfg\n          });\n        } else {\n          // 矩形\n          Util.mix(cfg, plotBackground);\n          plotBackShape = self.addShape('rect', {\n            attrs: cfg\n          });\n        }\n\n        self.set('plotBackShape', plotBackShape);\n      } else {\n        plotBackShape.attr(cfg);\n      }\n    } else {\n      return;\n    }\n  };\n\n  _proto._convert = function _convert(val, isHorizontal) {\n    if (Util.isString(val)) {\n      if (val === AUTO_STR) {\n        val = 0;\n      } else if (val.indexOf('%') !== -1) {\n        var canvas = this.get('canvas');\n        var width = this.get('width') || canvas.get('width');\n        var height = this.get('height') || canvas.get('height');\n        val = parseInt(val, 10) / 100;\n        val = isHorizontal ? val * width : val * height;\n      }\n    }\n\n    return val;\n  };\n\n  _proto._calculateRange = function _calculateRange() {\n    var self = this;\n    var plotRange = self.get('plotRange');\n\n    if (Util.isNil(plotRange)) {\n      plotRange = {};\n    }\n\n    var padding = self.get('padding');\n    var canvas = this.get('canvas');\n    var width = self.get('width') || canvas.get('width');\n    var height = self.get('height') || canvas.get('height');\n    var allPadding = Util.toAllPadding(padding);\n\n    var top = self._convert(allPadding[0], false);\n\n    var right = self._convert(allPadding[1], true);\n\n    var bottom = self._convert(allPadding[2], false);\n\n    var left = self._convert(allPadding[3], true);\n\n    var minX = Math.min(left, width - right);\n    var maxX = Math.max(left, width - right);\n    var minY = Math.min(height - bottom, top);\n    var maxY = Math.max(height - bottom, top);\n    plotRange.tl = {\n      x: minX,\n      y: minY\n    }; // top-left\n\n    plotRange.tr = {\n      x: maxX,\n      y: minY\n    }; // top-right\n\n    plotRange.bl = {\n      x: minX,\n      y: maxY\n    }; // bottom-left\n\n    plotRange.br = {\n      x: maxX,\n      y: maxY\n    }; // bottom-right\n\n    plotRange.cc = {\n      x: (maxX + minX) / 2,\n      y: (maxY + minY) / 2\n    };\n    this.set('plotRange', plotRange);\n  };\n\n  _proto.repaint = function repaint() {\n    this._calculateRange();\n\n    this._renderBackground();\n\n    this._renderPlotBackground();\n\n    return this;\n  };\n\n  return PlotBack;\n}(Group);\n\nmodule.exports = PlotBack;\n\n/***/ }),\n/* 357 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 需要计算所占x轴上的宽度的辅助类\n * @author sima.zhang1990@gmail.com\n * @author dxq613@gmail.com\n */\nvar Global = __webpack_require__(7);\n\nvar Util = __webpack_require__(0); // 已经排序后的数据查找距离最小的\n\n\nfunction findMinDistance(arr, scale) {\n  var count = arr.length; // 日期类型的 values 经常上文本类型，所以需要转换一下\n\n  if (Util.isString(arr[0])) {\n    arr = arr.map(function (v) {\n      return scale.translate(v);\n    });\n  }\n\n  var distance = arr[1] - arr[0];\n\n  for (var i = 2; i < count; i++) {\n    var tmp = arr[i] - arr[i - 1];\n\n    if (distance > tmp) {\n      distance = tmp;\n    }\n  }\n\n  return distance;\n}\n\nvar SizeMixin = {\n  getDefaultSize: function getDefaultSize() {\n    var defaultSize = this.get('defaultSize');\n    var viewTheme = this.get('viewTheme') || Global;\n\n    if (!defaultSize) {\n      var coord = this.get('coord');\n      var xScale = this.getXScale();\n      var xValues = xScale.values;\n      var dataArray = this.get('dataArray');\n      var count;\n\n      if (xScale.isLinear && xValues.length > 1) {\n        xValues.sort();\n        var interval = findMinDistance(xValues, xScale);\n        count = (xScale.max - xScale.min) / interval;\n\n        if (xValues.length > count) {\n          count = xValues.length;\n        }\n      } else {\n        count = xValues.length;\n      }\n\n      var range = xScale.range;\n      var normalizeSize = 1 / count;\n      var widthRatio = 1;\n\n      if (this.isInCircle()) {\n        if (coord.isTransposed && count > 1) {\n          // 极坐标下多层环图\n          widthRatio = viewTheme.widthRatio.multiplePie;\n        } else {\n          widthRatio = viewTheme.widthRatio.rose;\n        }\n        /* if (dataArray.length > 1) {\n          normalizeSize *= (range[1] - range[0]);\n        } */\n\n      } else {\n        if (xScale.isLinear) {\n          normalizeSize *= range[1] - range[0];\n        }\n\n        widthRatio = viewTheme.widthRatio.column; // 柱状图要除以2\n      }\n\n      normalizeSize *= widthRatio;\n\n      if (this.hasAdjust('dodge')) {\n        var dodgeCount = this._getDodgeCount(dataArray);\n\n        normalizeSize = normalizeSize / dodgeCount;\n      }\n\n      defaultSize = normalizeSize;\n      this.set('defaultSize', defaultSize);\n    }\n\n    return defaultSize;\n  },\n  _getDodgeCount: function _getDodgeCount(dataArray) {\n    var adjusts = this.get('adjusts');\n    var dodgeBy;\n    var count = dataArray.length;\n    Util.each(adjusts, function (adjust) {\n      if (adjust.type === 'dodge') {\n        dodgeBy = adjust.dodgeBy;\n      }\n    });\n\n    if (dodgeBy) {\n      var mergeData = Util.Array.merge(dataArray);\n      var values = Util.Array.values(mergeData, dodgeBy);\n      count = values.length;\n    }\n\n    return count;\n  },\n  getDimWidth: function getDimWidth(dimName) {\n    var coord = this.get('coord');\n    var start = coord.convertPoint({\n      x: 0,\n      y: 0\n    });\n    var end = coord.convertPoint({\n      x: dimName === 'x' ? 1 : 0,\n      y: dimName === 'x' ? 0 : 1\n    });\n    var width = 0;\n\n    if (start && end) {\n      width = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n    }\n\n    return width;\n  },\n  _getWidth: function _getWidth() {\n    var coord = this.get('coord');\n    var width; // x轴的长度\n\n    if (this.isInCircle() && !coord.isTransposed) {\n      // 极坐标下 width 为弧长\n      width = (coord.endAngle - coord.startAngle) * coord.radius;\n    } else {\n      width = this.getDimWidth('x'); // 不需要判断transpose\n    }\n\n    return width;\n  },\n  _toNormalizedSize: function _toNormalizedSize(size) {\n    var width = this._getWidth();\n\n    return size / width;\n  },\n  _toCoordSize: function _toCoordSize(normalizeSize) {\n    var width = this._getWidth();\n\n    return width * normalizeSize;\n  },\n  getNormalizedSize: function getNormalizedSize(obj) {\n    var size = this.getAttrValue('size', obj);\n\n    if (Util.isNil(size)) {\n      size = this.getDefaultSize();\n    } else {\n      size = this._toNormalizedSize(size);\n    }\n\n    return size;\n  },\n  getSize: function getSize(obj) {\n    var size = this.getAttrValue('size', obj);\n\n    if (Util.isNil(size)) {\n      var normalizeSize = this.getDefaultSize();\n      size = this._toCoordSize(normalizeSize);\n    }\n\n    return size;\n  }\n};\nmodule.exports = SizeMixin;\n\n/***/ }),\n/* 358 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 分割数据用于处理存在 null 值的折线图、区域图\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(7);\n\nmodule.exports = {\n  splitData: function splitData(data) {\n    var viewTheme = this.get('viewTheme') || Global;\n    if (!data.length) return [];\n    var arr = [];\n    var tmp = [];\n    var yScale = this.getYScale();\n    var yDim = yScale.field;\n    var yValue;\n    Util.each(data, function (obj) {\n      yValue = obj._origin ? obj._origin[yDim] : obj[yDim];\n\n      if (viewTheme.connectNulls) {\n        // 如果忽视 Null 直接连接节点，则将 value = null 的数据过滤掉\n        if (!Util.isNil(yValue)) {\n          tmp.push(obj);\n        }\n      } else {\n        if (Util.isArray(yValue) && Util.isNil(yValue[0]) || Util.isNil(yValue)) {\n          if (tmp.length) {\n            arr.push(tmp);\n            tmp = [];\n          }\n        } else {\n          tmp.push(obj);\n        }\n      }\n    });\n\n    if (tmp.length) {\n      arr.push(tmp);\n    }\n\n    return arr;\n  }\n};\n\n/***/ }),\n/* 359 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview 路径图，无序的线图\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar SplitMixin = __webpack_require__(358);\n\nvar Util = __webpack_require__(0);\n\nvar Path =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Path, _GeomBase);\n\n  var _proto = Path.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'path';\n    cfg.shapeType = 'line';\n    return cfg;\n  };\n\n  function Path(cfg) {\n    var _this;\n\n    _this = _GeomBase.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), SplitMixin);\n    return _this;\n  }\n\n  _proto.getDrawCfg = function getDrawCfg(obj) {\n    var cfg = _GeomBase.prototype.getDrawCfg.call(this, obj);\n\n    cfg.isStack = this.hasStack();\n    return cfg;\n  };\n\n  _proto.draw = function draw(data, container, shapeFactory, index) {\n    var self = this;\n    var splitArray = this.splitData(data);\n    var cfg = this.getDrawCfg(data[0]);\n\n    self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);\n\n    cfg.origin = data; // path,line 等图的origin 是整个序列\n\n    Util.each(splitArray, function (subData, splitedIndex) {\n      if (!Util.isEmpty(subData)) {\n        cfg.splitedIndex = splitedIndex; // 传入分割片段索引 用于生成id\n\n        cfg.points = subData;\n        var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);\n        self.appendShapeInfo(geomShape, index + splitedIndex);\n      }\n    });\n  };\n\n  return Path;\n}(GeomBase);\n\nGeomBase.Path = Path;\nmodule.exports = Path;\n\n/***/ }),\n/* 360 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(370);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__namespaces__ = __webpack_require__(371);\n\n\n\nfunction creatorInherit(name) {\n  return function () {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === __WEBPACK_IMPORTED_MODULE_1__namespaces__[\"b\" /* xhtml */] && document.documentElement.namespaceURI === __WEBPACK_IMPORTED_MODULE_1__namespaces__[\"b\" /* xhtml */] ? document.createElement(name) : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function () {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__[\"a\" /* default */])(name);\n  return (fullname.local ? creatorFixed : creatorInherit)(fullname);\n});\n\n/***/ }),\n/* 361 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX, point.y = event.clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n});\n\n/***/ }),\n/* 362 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = tweenValue;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(70);\n\n\nfunction tweenRemove(id, name) {\n  var tween0, tween1;\n  return function () {\n    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id),\n        tween = schedule.tween; // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\nfunction tweenFunction(id, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\") throw new Error();\n  return function () {\n    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id),\n        tween = schedule.tween; // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n\n      for (var t = {\n        name: name,\n        value: value\n      }, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n\n      if (i === n) tween1.push(t);\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  var id = this._id;\n  name += \"\";\n\n  if (arguments.length < 2) {\n    var tween = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(this.node(), id).tween;\n\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n\n    return null;\n  }\n\n  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n});\nfunction tweenValue(transition, name, value) {\n  var id = transition._id;\n  transition.each(function () {\n    var schedule = Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n  return function (node) {\n    return Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(node, id).value[name];\n  };\n}\n\n/***/ }),\n/* 363 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview facets of chart\n * @author dxq613@gmail.com\n */\nvar Global = __webpack_require__(7);\n\nvar Util = __webpack_require__(0);\n\nvar assign = Util.assign;\nvar isNil = Util.isNil;\nvar isArray = Util.isArray;\nvar cloneDeep = Util.cloneDeep; // 绑定事件\n\nvar wrapBehavior = Util.wrapBehavior; // 获取绑定的事件\n\nvar getWrapBehavior = Util.getWrapBehavior;\n\nvar Base =\n/*#__PURE__*/\nfunction () {\n  var _proto = Base.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      chart: null,\n      group: null,\n\n      /**\n       * 是否默认显示每个分面的title\n       * @type {Boolean}\n       */\n      showTitle: true,\n\n      /**\n       * 是否自动修改坐标轴的信息\n       * @type {Boolean}\n       */\n      autoSetAxis: true,\n\n      /**\n       * View 的内边框\n       * @type {Number|Array}\n       */\n      padding: 10,\n\n      /**\n       * 遍历每个view 的回调函数\n       * @type {Function}\n       */\n      eachView: null,\n\n      /**\n       * 分面的字段名列表\n       * @type {Array}\n       */\n      fields: [],\n\n      /**\n       * 列值的的标题\n       * @type {Object}\n       */\n      colTitle: {\n        offsetY: -15,\n        style: {\n          fontSize: 14,\n          textAlign: 'center',\n          fill: '#666',\n          fontFamily: Global.fontFamily\n        }\n      },\n      rowTitle: {\n        offsetX: 15,\n        style: {\n          fontSize: 14,\n          textAlign: 'center',\n          rotate: 90,\n          fill: '#666',\n          fontFamily: Global.fontFamily\n        }\n      }\n    };\n  };\n\n  function Base(cfg) {\n    var defaultCfg = this.getDefaultCfg();\n    assign(this, defaultCfg, cfg);\n    this.init();\n  }\n\n  _proto.init = function init() {\n    if (!this.chart) {\n      throw new Error('Facets Error: please specify the chart!');\n    }\n\n    this._bindEvent();\n\n    this.initContainer();\n\n    if (this.chart.get('data')) {\n      this.initViews();\n    }\n  };\n\n  _proto.initContainer = function initContainer() {\n    var chart = this.chart;\n    var frontPlot = chart.get('frontPlot');\n    var group = frontPlot.addGroup();\n    this.group = group;\n  };\n\n  _proto.initViews = function initViews() {\n    var chart = this.chart;\n    var data = chart.get('data');\n    var eachView = this.eachView;\n    var facets = this.generateFacets(data);\n\n    for (var i = 0; i < facets.length; i++) {\n      var facet = facets[i];\n      var region = facet.region;\n      var view = chart.view({\n        start: region.start,\n        end: region.end,\n        padding: this.padding\n      });\n      view.source(facet.data);\n      this.beforeProcessView(view, facet);\n\n      if (eachView) {\n        eachView(view, facet);\n      }\n\n      this.afterProcessView(view, facet);\n      facet.view = view;\n    }\n\n    this.facets = facets;\n  };\n  /**\n   * 处理 view 前\n   * @protected\n   */\n\n\n  _proto.beforeProcessView = function beforeProcessView()\n  /* view, facet */\n  {};\n  /**\n   * 处理view\n   * @param {Object} view 视图\n   * @param {Object} facet 分面信息\n   * @protected\n   */\n\n\n  _proto.afterProcessView = function afterProcessView(view, facet) {\n    if (this.autoSetAxis) {\n      this.processAxis(view, facet);\n    }\n  };\n\n  _proto.processAxis = function processAxis(view, facet) {\n    var viewOptions = view.get('options');\n    var geoms = view.get('geoms');\n\n    if ((!viewOptions.coord.type || viewOptions.coord.type === 'rect') && geoms.length) {\n      var field = geoms[0].get('attrOptions').position.field;\n      var fields = isArray(field) ? field : field.split('*').map(function (str) {\n        return str.trim();\n      });\n      var xField = fields[0];\n      var yField = fields[1];\n\n      if (isNil(viewOptions.axes)) {\n        viewOptions.axes = {};\n      }\n\n      var axes = viewOptions.axes;\n\n      if (axes !== false) {\n        if (xField && axes[xField] !== false) {\n          axes[xField] = axes[xField] || {};\n          this.setXAxis(xField, axes, facet);\n        }\n\n        if (yField && axes[yField] !== false) {\n          axes[yField] = axes[yField] || {};\n          this.setYAxis(yField, axes, facet);\n        }\n      }\n    }\n  };\n\n  _proto.setXAxis = function setXAxis()\n  /* xField, axes, facet */\n  {};\n\n  _proto.setYAxis = function setYAxis()\n  /* yField, axes, facet */\n  {}; // 默认显示各列的标题\n\n\n  _proto.renderTitle = function renderTitle(view, facet) {\n    this.drawColTitle(view, facet);\n  };\n\n  _proto.getScaleText = function getScaleText(field, value, view) {\n    var rst;\n\n    if (field) {\n      var scales = view.get('scales');\n      var scale = scales[field];\n\n      if (!scale) {\n        scale = view.createScale(field);\n      }\n\n      rst = scale.getText(value);\n    } else {\n      rst = value;\n    }\n\n    return rst;\n  };\n\n  _proto.drawColTitle = function drawColTitle(view, facet) {\n    var text = this.getScaleText(facet.colField, facet.colValue, view);\n    var colTextCfg = assign({\n      position: ['50%', '0%'],\n      content: text\n    }, this.colTitle);\n    view.guide().text(colTextCfg);\n  };\n\n  _proto.drawRowTitle = function drawRowTitle(view, facet) {\n    var text = this.getScaleText(facet.rowField, facet.rowValue, view);\n    var rowTextCfg = assign({\n      position: ['100%', '50%'],\n      content: text\n    }, cloneDeep(this.rowTitle));\n    view.guide().text(rowTextCfg);\n  };\n  /**\n   * 数据过滤器\n   * @protected\n   * @param {Array} conditions 过滤条件\n   * @return {Function} 过滤函数\n   */\n\n\n  _proto.getFilter = function getFilter(conditions) {\n    var filter = function filter(obj) {\n      var filtered = true;\n      conditions.forEach(function (cond) {\n        var field = cond.field;\n        var value = cond.value; // const values = cond.values;\n\n        var tmp = true;\n\n        if (!isNil(value) && field) {\n          tmp = obj[field] === value;\n        }\n\n        filtered = filtered && tmp;\n      });\n      return filtered;\n    };\n\n    return filter;\n  };\n  /**\n   * 获取字段对应的值\n   * @protected\n   * @param  {String} field 字段名\n   * @param  {Array} data 数据\n   * @return {Array} 字段对应的值\n   */\n\n\n  _proto.getFieldValues = function getFieldValues(field, data) {\n    var rst = [];\n    var tmpMap = {};\n\n    for (var i = 0; i < data.length; i++) {\n      var obj = data[i];\n      var value = obj[field];\n\n      if (!isNil(value) && !tmpMap[value]) {\n        rst.push(value);\n        tmpMap[value] = true;\n      }\n    }\n\n    return rst;\n  };\n\n  _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {\n    var xWidth = 1 / cols; // x轴方向的每个分面的偏移\n\n    var yWidth = 1 / rows; // y轴方向的每个分面的偏移\n\n    var start = {\n      x: xWidth * xIndex,\n      y: yWidth * yIndex\n    };\n    var end = {\n      x: start.x + xWidth,\n      y: start.y + yWidth\n    };\n    return {\n      start: start,\n      end: end\n    };\n  };\n  /**\n   * 生成分面\n   * @protected\n   * @return {Array} 多个分面集合\n   */\n\n\n  _proto.generateFacets = function generateFacets()\n  /* data */\n  {\n    return [];\n  };\n\n  _proto._bindEvent = function _bindEvent() {\n    var chart = this.chart;\n    chart.on('afterchangedata', wrapBehavior(this, 'onDataChange'));\n    chart.on('beforeclear', wrapBehavior(this, 'onClear'));\n    chart.on('beforedestroy', wrapBehavior(this, 'destroy'));\n    chart.on('beforepaint', wrapBehavior(this, 'onPaint'));\n    chart.on('setdata', wrapBehavior(this, 'onDataChange'));\n  };\n\n  _proto._clearEvent = function _clearEvent() {\n    var chart = this.chart;\n\n    if (chart) {\n      chart.off('afterchangedata', getWrapBehavior(this, 'onDataChange'));\n      chart.off('beforeclear', getWrapBehavior(this, 'onClear'));\n      chart.off('beforedestroy', getWrapBehavior(this, 'destroy'));\n      chart.off('beforepaint', getWrapBehavior(this, 'onPaint'));\n      chart.off('setdata', getWrapBehavior(this, 'onDataChange'));\n    }\n  };\n\n  _proto._clearFacets = function _clearFacets() {\n    var facets = this.facets;\n    var chart = this.chart;\n\n    if (facets) {\n      for (var i = 0; i < facets.length; i++) {\n        var facet = facets[i];\n        chart.removeView(facet.view);\n      }\n    }\n\n    this.facets = null;\n  };\n\n  _proto.onClear = function onClear() {\n    this.onRemove();\n  };\n\n  _proto.onPaint = function onPaint() {\n    if (this.showTitle) {\n      var facets = this.facets;\n\n      for (var i = 0; i < facets.length; i++) {\n        var facet = facets[i];\n        var view = facet.view;\n        this.renderTitle(view, facet);\n      }\n    }\n  };\n\n  _proto.onDataChange = function onDataChange() {\n    this._clearFacets();\n\n    this.initViews();\n  };\n\n  _proto.onRemove = function onRemove() {\n    this._clearFacets();\n\n    this._clearEvent();\n\n    this.group && this.group.remove();\n    this.chart = null;\n    this.facets = null;\n    this.group = null;\n  };\n\n  _proto.destroy = function destroy() {\n    this.onRemove();\n    this.destroyed = true;\n  };\n\n  return Base;\n}();\n\nmodule.exports = Base;\n\n/***/ }),\n/* 364 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview interval geometry\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = __webpack_require__(357);\n\n__webpack_require__(365);\n\nvar Interval =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Interval, _GeomBase);\n\n  var _proto = Interval.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'interval';\n    cfg.shapeType = 'interval';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  function Interval(cfg) {\n    var _this;\n\n    _this = _GeomBase.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), SizeMixin);\n    return _this;\n  }\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);\n\n    cfg.size = this.getNormalizedSize(obj);\n    return cfg;\n  };\n\n  _proto.clearInner = function clearInner() {\n    _GeomBase.prototype.clearInner.call(this);\n\n    this.set('defaultSize', null);\n  };\n\n  return Interval;\n}(GeomBase);\n\nvar IntervalStack =\n/*#__PURE__*/\nfunction (_Interval) {\n  _inheritsLoose(IntervalStack, _Interval);\n\n  function IntervalStack() {\n    return _Interval.apply(this, arguments) || this;\n  }\n\n  var _proto2 = IntervalStack.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interval.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'stack'\n    }];\n    return cfg;\n  };\n\n  return IntervalStack;\n}(Interval);\n\nvar IntervalDodge =\n/*#__PURE__*/\nfunction (_Interval2) {\n  _inheritsLoose(IntervalDodge, _Interval2);\n\n  function IntervalDodge() {\n    return _Interval2.apply(this, arguments) || this;\n  }\n\n  var _proto3 = IntervalDodge.prototype;\n\n  _proto3.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interval2.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'dodge'\n    }];\n    return cfg;\n  };\n\n  return IntervalDodge;\n}(Interval);\n\nvar IntervalSymmetric =\n/*#__PURE__*/\nfunction (_Interval3) {\n  _inheritsLoose(IntervalSymmetric, _Interval3);\n\n  function IntervalSymmetric() {\n    return _Interval3.apply(this, arguments) || this;\n  }\n\n  var _proto4 = IntervalSymmetric.prototype;\n\n  _proto4.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interval3.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'symmetric'\n    }];\n    return cfg;\n  };\n\n  return IntervalSymmetric;\n}(Interval);\n\nInterval.Stack = IntervalStack;\nInterval.Dodge = IntervalDodge;\nInterval.Symmetric = IntervalSymmetric;\nGeomBase.Interval = Interval;\nGeomBase.IntervalStack = IntervalStack;\nGeomBase.IntervalDodge = IntervalDodge;\nGeomBase.IntervalSymmetric = IntervalSymmetric;\nmodule.exports = Interval;\n\n/***/ }),\n/* 365 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview interval shapes\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n * @author huangtonger@aliyun.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar PathUtil = __webpack_require__(22);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nvar G = __webpack_require__(16);\n\nvar GPathUtil = Util.PathUtil; // 获取柱状图的几个点\n\nfunction getRectPoints(cfg, isPyramid) {\n  var x = cfg.x;\n  var y = cfg.y;\n  var y0 = cfg.y0; // 0 点的位置\n\n  var width = cfg.size; // 有3种情况，\n  // 1. y，x都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n\n  var ymin = y0;\n  var ymax = y;\n\n  if (Util.isArray(y)) {\n    ymax = y[1];\n    ymin = y[0];\n  }\n\n  var xmin;\n  var xmax;\n\n  if (Util.isArray(x)) {\n    xmin = x[0];\n    xmax = x[1];\n  } else {\n    xmin = x - width / 2;\n    xmax = x + width / 2;\n  }\n\n  var points = [];\n  points.push({\n    x: xmin,\n    y: ymin\n  }, {\n    x: xmin,\n    y: ymax\n  });\n\n  if (isPyramid) {\n    points.push({\n      x: xmax,\n      y: (ymax + ymin) / 2\n    });\n  } else {\n    points.push({\n      x: xmax,\n      y: ymax\n    }, {\n      x: xmax,\n      y: ymin\n    });\n  }\n\n  return points;\n}\n\nfunction getRectPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (point) {\n      var action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  var first = points[0];\n  path.push(['L', first.x, first.y]);\n  path.push(['z']);\n  return path;\n}\n\nfunction getLinePoints(cfg) {\n  var x = cfg.x;\n  var y = cfg.y;\n  var y0 = cfg.y0; // 0 点的位置\n\n  var points = [];\n\n  if (Util.isArray(y)) {\n    Util.each(y, function (yItem, idx) {\n      points.push({\n        x: Util.isArray(x) ? x[idx] : x,\n        y: yItem\n      });\n    });\n  } else {\n    points.push({\n      x: x,\n      y: y\n    }, {\n      x: x,\n      y: y0\n    });\n  }\n\n  return points;\n}\n\nfunction getTickPoints(cfg) {\n  var x = cfg.x;\n  var y = Util.isArray(cfg.y) ? cfg.y[1] : cfg.y;\n  var y0 = Util.isArray(cfg.y) ? cfg.y[0] : cfg.y0;\n  var barWidth = cfg.size;\n  var points = [];\n  points.push({\n    x: x - barWidth / 2,\n    y: y\n  }, {\n    x: x + barWidth / 2,\n    y: y\n  }, {\n    x: x,\n    y: y\n  }, {\n    x: x,\n    y: y0\n  }, {\n    x: x - barWidth / 2,\n    y: y0\n  }, {\n    x: x + barWidth / 2,\n    y: y0\n  });\n  return points;\n}\n\nfunction getTickPath(points) {\n  var path = [];\n  path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]);\n  return path;\n}\n\nfunction getFillAttrs(cfg) {\n  var defaultAttrs = Global.shape.interval;\n  var attrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addFillAttrs(attrs, cfg);\n\n  if (cfg.color) {\n    attrs.stroke = attrs.stroke || cfg.color;\n  }\n\n  return attrs;\n}\n\nfunction getLineAttrs(cfg) {\n  var defaultAttrs = Global.shape.hollowInterval;\n  var attrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addStrokeAttrs(attrs, cfg);\n  return attrs;\n}\n\nfunction getFunnelPath(cfg, isFunnel) {\n  var path = [];\n  var points = cfg.points;\n  var nextPoints = cfg.nextPoints;\n\n  if (!Util.isNil(nextPoints)) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);\n  } else if (isFunnel) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);\n  } else {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);\n  }\n\n  return path;\n}\n\nfunction getThetaCfg(point, coord) {\n  var r = coord.getRadius();\n  var inner = coord.innerRadius;\n  var startAngle;\n  var endAngle;\n  var ir = r * inner;\n  var startPoint;\n  var endPoint;\n\n  if (!Util.isArray(point.x) && Util.isArray(point.y)) {\n    point.x = [point.x, point.x]; // 如果x是一个值，y是数组，将x转成数组\n  }\n\n  if (Util.isArray(point.x)) {\n    startPoint = {\n      x: point.x[0],\n      y: point.y[0]\n    };\n    endPoint = {\n      x: point.x[1],\n      y: point.y[1]\n    };\n    startAngle = PathUtil.getPointAngle(coord, startPoint);\n    endAngle = PathUtil.getPointAngle(coord, endPoint);\n\n    if (endAngle <= startAngle) {\n      // 考虑占比百分百的情形\n      endAngle = endAngle + Math.PI * 2;\n    }\n  } else {\n    endPoint = point;\n    startAngle = coord.startAngle;\n    endAngle = PathUtil.getPointAngle(coord, endPoint);\n  }\n\n  return {\n    r: r,\n    ir: ir,\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n} // 获取选中时的样式，当前仅支持饼图\n\n\nfunction _getSelectedCfg(type, cfg) {\n  var geom = cfg.geom;\n  var coord = geom.get('coord');\n  var point = cfg.point;\n  var r = 7.5;\n  var selectedCfg;\n\n  if (coord && coord.type === 'theta') {\n    var thetaCfg = getThetaCfg(point, coord);\n    var middleAngle = (thetaCfg.endAngle - thetaCfg.startAngle) / 2 + thetaCfg.startAngle;\n    var x = r * Math.cos(middleAngle);\n    var y = r * Math.sin(middleAngle);\n    selectedCfg = {\n      transform: [['t', x, y]]\n    };\n  }\n\n  return Util.mix({}, selectedCfg);\n}\n\nvar Interval = Shape.registerFactory('interval', {\n  defaultShapeType: 'rect',\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    if (!type || Util.inArray(['rect', 'funnel', 'pyramid'], type)) {\n      // 透明度降低 0.15\n      var fillOpacity = cfg.fillOpacity || cfg.opacity || 1;\n      return {\n        fillOpacity: fillOpacity - 0.15\n      };\n    }\n\n    var lineWidth = cfg.lineWidth || 0;\n    return {\n      lineWidth: lineWidth + 1\n    };\n  },\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return getRectPoints(pointInfo);\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    return _getSelectedCfg(type, cfg);\n  }\n}); // 默认柱状图\n\nShape.registerShape('interval', 'rect', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getFillAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n}); // 空心柱状图\n\nShape.registerShape('interval', 'hollowRect', {\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getLineAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n}); // 线形柱状图\n\nShape.registerShape('interval', 'line', {\n  getPoints: function getPoints(pointInfo) {\n    return getLinePoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    attrs.lineWidth = cfg.size || 1; // size 就是线的宽度\n\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var lineCfg = getLineAttrs(cfg);\n    return Util.mix({\n      symbol: 'line',\n      radius: 5\n    }, lineCfg);\n  }\n}); // 钉子形的柱状图\n\nShape.registerShape('interval', 'tick', {\n  getPoints: function getPoints(pointInfo) {\n    return getTickPoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg); // @2018-12-25 by blue.lb 经过测试发现size代表的是宽度，而style中的lineWidth才是设置线宽，放在interval暂时先特殊处理\n\n    if (!attrs.lineWidth) {\n      attrs.lineWidth = 2;\n    }\n\n    var path = getTickPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var lineCfg = getLineAttrs(cfg);\n    return Util.mix({\n      symbol: 'tick',\n      radius: 5\n    }, lineCfg);\n  }\n}); // 漏斗图\n\nShape.registerShape('interval', 'funnel', {\n  getPoints: function getPoints(pointInfo) {\n    pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍\n\n    return getRectPoints(pointInfo);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getFunnelPath(cfg, true);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var funnelCfg = getFillAttrs(cfg);\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, funnelCfg);\n  }\n}); // 金字塔图\n\nShape.registerShape('interval', 'pyramid', {\n  getPoints: function getPoints(pointInfo) {\n    pointInfo.size = pointInfo.size * 2; // 漏斗图的 size 是柱状图的两倍\n\n    return getRectPoints(pointInfo, true);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getFunnelPath(cfg, false);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var funnelCfg = getFillAttrs(cfg);\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, funnelCfg);\n  }\n}); // 水波图\n\n/**\n * 用贝塞尔曲线模拟正弦波\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n * @return {Array} 正弦片段曲线\n */\n\nfunction getWaterWavePositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  } else if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  } else if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  }\n\n  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n}\n/**\n * 获取水波路径\n * @param  {number} radius          半径\n * @param  {number} waterLevel      水位\n * @param  {number} waveLength      波长\n * @param  {number} phase           相位\n * @param  {number} amplitude       震幅\n * @param  {number} cx              圆心x\n * @param  {number} cy              圆心y\n * @return {Array}  path            路径\n * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135\n */\n\n\nfunction getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {\n  var curves = Math.ceil(2 * radius / waveLength * 4) * 2;\n  var path = []; // map phase to [-Math.PI * 2, 0]\n\n  while (phase < -Math.PI * 2) {\n    phase += Math.PI * 2;\n  }\n\n  while (phase > 0) {\n    phase -= Math.PI * 2;\n  }\n\n  phase = phase / Math.PI / 2 * waveLength;\n  var left = cx - radius + phase - radius * 2;\n  /**\n   * top-left corner as start point\n   *\n   * draws this point\n   *  |\n   * \\|/\n   *  ~~~~~~~~\n   *  |      |\n   *  +------+\n   */\n\n  path.push(['M', left, waterLevel]);\n  /**\n   * top wave\n   *\n   * ~~~~~~~~ <- draws this sine wave\n   * |      |\n   * +------+\n   */\n\n  var waveRight = 0;\n\n  for (var c = 0; c < curves; ++c) {\n    var stage = c % 4;\n    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);\n    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);\n\n    if (c === curves - 1) {\n      waveRight = pos[2][0];\n    }\n  }\n  /**\n   * top-right corner\n   *\n   *                       ~~~~~~~~\n   * 3. draws this line -> |      | <- 1. draws this line\n   *                       +------+\n   *                          ^\n   *                          |\n   *                  2. draws this line\n   */\n\n\n  path.push(['L', waveRight + left, cy + radius]);\n  path.push(['L', left, cy + radius]);\n  path.push(['L', left, waterLevel]);\n  return path;\n}\n/**\n * 添加水波\n * @param {number} x           中心x\n * @param {number} y           中心y\n * @param {number} level       水位等级 0～1\n * @param {number} waveCount   水波数\n * @param {number} colors      色值\n * @param {number} group       图组\n * @param {number} clip        用于剪切的图形\n * @param {number} radius      绘制图形的高度\n */\n\n\nfunction addWaterWave(x, y, level, waveCount, colors, group, clip, radius) {\n  var bbox = clip.getBBox();\n  var width = bbox.maxX - bbox.minX;\n  var height = bbox.maxY - bbox.minY;\n  var duration = 5000;\n  var delayDiff = 300;\n\n  for (var i = 0; i < waveCount; i++) {\n    var wave = group.addShape('path', {\n      attrs: {\n        path: getWaterWavePath(radius, bbox.minY + height * level, width / 4, 0, width / 64, x, y),\n        fill: colors[i],\n        clip: clip\n      }\n    }); // FIXME wave animation error in svg\n\n    if (Global.renderer === 'canvas') {\n      wave.animate({\n        transform: [['t', width / 2, 0]],\n        repeat: true\n      }, duration - i * delayDiff);\n    }\n  }\n}\n\nShape.registerShape('interval', 'liquid-fill-gauge', {\n  draw: function draw(cfg, container) {\n    var self = this;\n    var cy = 0.5;\n    var sumX = 0;\n    var minX = Infinity;\n    Util.each(cfg.points, function (p) {\n      if (p.x < minX) {\n        minX = p.x;\n      }\n\n      sumX += p.x;\n    });\n    var cx = sumX / cfg.points.length;\n    var cp = self.parsePoint({\n      x: cx,\n      y: cy\n    });\n    var minP = self.parsePoint({\n      x: minX,\n      y: 0.5\n    });\n    var xWidth = cp.x - minP.x;\n    var radius = Math.min(xWidth, minP.y);\n    var attrs = getFillAttrs(cfg);\n    var clipCircle = new G.Circle({\n      attrs: {\n        x: cp.x,\n        y: cp.y,\n        r: radius\n      }\n    });\n    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, clipCircle, radius * 4);\n    return container.addShape('circle', {\n      attrs: Util.mix(getLineAttrs(cfg), {\n        x: cp.x,\n        y: cp.y,\n        r: radius + radius / 8\n      })\n    });\n  }\n});\nvar pathMetaCache = {};\nShape.registerShape('interval', 'liquid-fill-path', {\n  draw: function draw(cfg, container) {\n    var self = this;\n    var attrs = Util.mix({}, getFillAttrs(cfg));\n    var path = cfg.shape[1];\n    var cy = 0.5;\n    var sumX = 0;\n    var minX = Infinity;\n    Util.each(cfg.points, function (p) {\n      if (p.x < minX) {\n        minX = p.x;\n      }\n\n      sumX += p.x;\n    });\n    var cx = sumX / cfg.points.length;\n    var cp = self.parsePoint({\n      x: cx,\n      y: cy\n    });\n    var minP = self.parsePoint({\n      x: minX,\n      y: 0.5\n    });\n    var xWidth = cp.x - minP.x;\n    var radius = Math.min(xWidth, minP.y);\n    var pathMeta;\n\n    if (pathMetaCache[path]) {\n      pathMeta = pathMetaCache[path];\n    } else {\n      var segments = GPathUtil.parsePathString(path);\n      pathMetaCache[path] = pathMeta = {\n        segments: segments\n      };\n    }\n\n    var transform = [];\n\n    if (attrs.rotate) {\n      transform.push(['r', attrs.rotate / 180 * Math.PI]);\n      delete attrs.rotate;\n    }\n\n    var shape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        fillOpacity: 0,\n        path: pathMeta.segments\n      })\n    });\n    var bbox = Util.cloneDeep(shape.getBBox());\n    var rangeX = bbox.maxX - bbox.minX;\n    var rangeY = bbox.maxY - bbox.minY;\n    var range = Math.max(rangeX, rangeY);\n    var scale = radius * 2 / range;\n    shape.transform(transform.concat([['s', scale, scale]]));\n    var dw = scale * rangeX / 2; // (bbox.maxX - bbox.minX) / 2;\n\n    var dh = scale * rangeY / 2; // (bbox.maxY - bbox.minY) / 2;\n\n    shape.transform([['t', cp.x - dw, cp.y - dh]]);\n    addWaterWave(cp.x, cp.y, cfg.y / (2 * cp.y), 1, [attrs.fill], container, shape, minP.y * 4);\n    var keyShape = container.addShape('path', {\n      attrs: Util.mix(getLineAttrs(cfg), {\n        path: pathMeta.segments\n      })\n    });\n    keyShape.transform(transform.concat([['s', scale, scale], ['t', cp.x - dw, cp.y - dh]]));\n    return keyShape;\n  }\n});\nShape.registerShape('interval', 'top-line', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var style = cfg.style || {};\n    var linePath = [['M', cfg.points[1].x, cfg.points[1].y], ['L', cfg.points[2].x, cfg.points[2].y]];\n    var lineAttrs = {\n      stroke: style.stroke || 'white',\n      lineWidth: style.lineWidth || 1,\n      path: this.parsePath(linePath)\n    };\n    var path = getRectPath(cfg.points);\n    path = this.parsePath(path);\n    delete attrs.stroke; // 不在柱子上绘制线\n\n    var rectShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        zIndex: 0,\n        path: path\n      })\n    });\n    container.addShape('path', {\n      zIndex: 1,\n      attrs: lineAttrs\n    });\n    return rectShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var rectCfg = getFillAttrs(cfg);\n    var isInCircle = cfg.isInCircle;\n    return Util.mix({\n      symbol: isInCircle ? 'circle' : 'square',\n      radius: isInCircle ? 4.5 : 4\n    }, rectCfg);\n  }\n});\nmodule.exports = Interval;\n\n/***/ }),\n/* 366 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview 线图\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Path = __webpack_require__(359);\n\n__webpack_require__(367);\n\nvar Line =\n/*#__PURE__*/\nfunction (_Path) {\n  _inheritsLoose(Line, _Path);\n\n  function Line() {\n    return _Path.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Path.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'line';\n    cfg.sortable = true;\n    return cfg;\n  };\n\n  return Line;\n}(Path);\n\nvar LineStack =\n/*#__PURE__*/\nfunction (_Line) {\n  _inheritsLoose(LineStack, _Line);\n\n  function LineStack() {\n    return _Line.apply(this, arguments) || this;\n  }\n\n  var _proto2 = LineStack.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Line.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'stack'\n    }];\n    return cfg;\n  };\n\n  return LineStack;\n}(Line);\n\nLine.Stack = LineStack;\nGeomBase.Line = Line;\nGeomBase.LineStack = LineStack;\nmodule.exports = Line;\n\n/***/ }),\n/* 367 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview line shapes\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n * @author huangtonger@aliyun.com\n */\nvar Util = __webpack_require__(0);\n\nvar PathUtil = __webpack_require__(22);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Shape = __webpack_require__(18);\n\nvar Global = __webpack_require__(7);\n\nvar DOT_ARR = [1, 1];\nvar DASH_ARR = [5.5, 1];\n\nfunction getAttrs(cfg) {\n  var defaultCfg = Global.shape.line;\n  var lineAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);\n\n  if (cfg.size) {\n    lineAttrs.lineWidth = cfg.size;\n  }\n\n  return lineAttrs;\n}\n\nfunction getMarkerAttrs(cfg) {\n  var defaultCfg = Global.shape.line;\n  var lineAttrs = Util.mix({\n    lineWidth: 2,\n    radius: 6\n  }, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);\n  return lineAttrs;\n} // 获取带有上下区间的 path\n\n\nfunction getRangePath(points, smooth, isInCircle, cfg) {\n  var topPoints = [];\n  var isStack = cfg.isStack;\n  var bottomPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var tmp = ShapeUtil.splitPoints(point);\n    bottomPoints.push(tmp[0]);\n    topPoints.push(tmp[1]);\n  }\n\n  var topPath = getSinglePath(topPoints, smooth, isInCircle, cfg);\n  var bottomPath = getSinglePath(bottomPoints, smooth, isInCircle, cfg);\n\n  if (isStack) {\n    return topPath;\n  }\n\n  return topPath.concat(bottomPath);\n} // 单条 path\n\n\nfunction getSinglePath(points, smooth, isInCircle, cfg) {\n  var path;\n\n  if (!smooth) {\n    path = PathUtil.getLinePath(points, false);\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    var constraint = cfg.constraint;\n\n    if (isInCircle && points.length) {\n      points.push({\n        x: points[0].x,\n        y: points[0].y\n      });\n    }\n\n    path = PathUtil.getSplinePath(points, false, constraint);\n  }\n\n  return path;\n} // get line path\n\n\nfunction getPath(cfg, smooth) {\n  var path;\n  var points = cfg.points;\n  var isInCircle = cfg.isInCircle;\n  var first = points[0];\n\n  if (Util.isArray(first.y)) {\n    path = getRangePath(points, smooth, isInCircle, cfg);\n  } else {\n    path = getSinglePath(points, smooth, isInCircle, cfg);\n  }\n\n  return path;\n}\n\nfunction _interpPoints(points, fn) {\n  var tmpPoints = [];\n  Util.each(points, function (point, index) {\n    var nextPoint = points[index + 1];\n    tmpPoints.push(point);\n\n    if (nextPoint) {\n      tmpPoints = tmpPoints.concat(fn(point, nextPoint));\n    }\n  });\n  return tmpPoints;\n} // 插值的图形path，不考虑null\n\n\nfunction _getInterPath(points) {\n  var path = [];\n  Util.each(points, function (point, index) {\n    var subPath = index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];\n    path.push(subPath);\n  });\n  return path;\n} // 插值的图形\n\n\nfunction _getInterPointShapeCfg(cfg, fn) {\n  var points = _interpPoints(cfg.points, fn);\n\n  return _getInterPath(points);\n}\n\nfunction _markerFn(x, y, r) {\n  return [['M', x - r, y], ['L', x + r, y]];\n}\n\nfunction _smoothMarkerFn(x, y, r) {\n  return [['M', x - r, y], ['A', r / 2, r / 2, 0, 1, 1, x, y], ['A', r / 2, r / 2, 0, 1, 0, x + r, y]];\n} // get marker cfg\n\n\nfunction _getMarkerCfg(cfg, smooth) {\n  return Util.mix({\n    symbol: smooth ? _smoothMarkerFn : _markerFn\n  }, getMarkerAttrs(cfg));\n}\n\nfunction _getInterMarkerCfg(cfg, fn) {\n  return Util.mix({\n    symbol: fn\n  }, getMarkerAttrs(cfg));\n} // 当只有一个数据时绘制点\n\n\nfunction drawPointShape(shapeObj, cfg, container) {\n  var point = cfg.points[0];\n  return container.addShape('circle', {\n    attrs: Util.mix({\n      x: point.x,\n      y: point.y,\n      r: 2,\n      fill: cfg.color\n    }, cfg.style)\n  });\n} // regist line geom\n\n\nvar Line = Shape.registerFactory('line', {\n  // 默认的shape\n  defaultShapeType: 'line',\n\n  /* getMarkerCfg(type, cfg) {\n    const lineObj = Line[type] || Line.line;\n    return lineObj.getMarkerCfg(cfg);\n  }, */\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    var lineWidth = cfg.lineWidth || 0;\n    return {\n      lineWidth: lineWidth + 1\n    };\n  },\n  // 计算点 如果存在多个点，分割成单个的点, 不考虑多个x对应一个y的情况\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return ShapeUtil.splitPoints(pointInfo);\n  },\n  drawShape: function drawShape(type, cfg, container) {\n    var shape = this.getShape(type);\n    var gShape;\n\n    if (cfg.points.length === 1 && Global.showSinglePoint) {\n      gShape = drawPointShape(this, cfg, container);\n    } else {\n      gShape = shape.draw(cfg, container);\n    }\n\n    if (gShape) {\n      gShape.set('origin', cfg.origin);\n      gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;\n      gShape.name = this.name;\n    }\n\n    return gShape;\n  }\n}); // draw line shape\n\nShape.registerShape('line', 'line', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getPath(cfg, false);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg);\n  }\n}); // 点线 ···\n\nShape.registerShape('line', 'dot', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getPath(cfg, false);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path,\n        lineDash: DOT_ARR\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var tmp = _getMarkerCfg(cfg, false);\n\n    tmp.lineDash = DOT_ARR;\n    return tmp;\n  }\n}); // 断线 - - -\n\nShape.registerShape('line', 'dash', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getPath(cfg, false);\n    return container.addShape('path', {\n      attrs: Util.mix({\n        path: path,\n        lineDash: DASH_ARR\n      }, attrs)\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var tmp = _getMarkerCfg(cfg, false);\n\n    tmp.lineDash = tmp.lineDash || DASH_ARR;\n    return tmp;\n  }\n}); // draw smooth line shape\n\nShape.registerShape('line', 'smooth', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var coord = this._coord; // 曲线的限制\n\n    cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];\n    var path = getPath(cfg, true);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg, true);\n  }\n});\nShape.registerShape('line', 'hv', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n\n    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {\n      var tmp = [];\n      tmp.push({\n        x: nextPoint.x,\n        y: point.y\n      });\n      return tmp;\n    });\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getInterMarkerCfg(cfg, function (x, y, r) {\n      return [['M', x - r - 1, y - 2.5], ['L', x, y - 2.5], ['L', x, y + 2.5], ['L', x + r + 1, y + 2.5]];\n    });\n  }\n});\nShape.registerShape('line', 'vh', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n\n    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {\n      var tmp = [];\n      tmp.push({\n        x: point.x,\n        y: nextPoint.y\n      });\n      return tmp;\n    });\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getInterMarkerCfg(cfg, function (x, y, r) {\n      return [['M', x - r - 1, y + 2.5], ['L', x, y + 2.5], ['L', x, y - 2.5], ['L', x + r + 1, y - 2.5]];\n    });\n  }\n});\nShape.registerShape('line', 'hvh', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n\n    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {\n      var tmp = [];\n      var middlex = (nextPoint.x - point.x) / 2 + point.x;\n      tmp.push({\n        x: middlex,\n        y: point.y\n      });\n      tmp.push({\n        x: middlex,\n        y: nextPoint.y\n      });\n      return tmp;\n    });\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getInterMarkerCfg(cfg, function (x, y, r) {\n      return [['M', x - (r + 1), y + 2.5], ['L', x - r / 2, y + 2.5], ['L', x - r / 2, y - 2.5], ['L', x + r / 2, y - 2.5], ['L', x + r / 2, y + 2.5], ['L', x + r + 1, y + 2.5]];\n    });\n  }\n});\nShape.registerShape('line', 'vhv', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n\n    var path = _getInterPointShapeCfg(cfg, function (point, nextPoint) {\n      var tmp = [];\n      var middley = (nextPoint.y - point.y) / 2 + point.y;\n      tmp.push({\n        x: point.x,\n        y: middley\n      });\n      tmp.push({\n        x: nextPoint.x,\n        y: middley\n      });\n      return tmp;\n    });\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getInterMarkerCfg(cfg, function (x, y) {\n      // 宽 13px，高 8px\n      return [['M', x - 5, y + 2.5], ['L', x - 5, y], ['L', x, y], ['L', x, y - 3], ['L', x, y + 3], ['L', x + 6.5, y + 3]];\n    });\n  }\n});\nLine.spline = Line.smooth;\nmodule.exports = Line;\n\n/***/ }),\n/* 368 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview 点图\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(369);\n\nvar Point =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Point, _GeomBase);\n\n  function Point() {\n    return _GeomBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Point.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'point';\n    cfg.shapeType = 'point';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  _proto.drawPoint = function drawPoint(obj, container, shapeFactory, index) {\n    var self = this;\n    var shape = obj.shape;\n    var cfg = self.getDrawCfg(obj);\n\n    self._applyViewThemeShapeStyle(cfg, shape, shapeFactory);\n\n    var geomShape;\n\n    if (Util.isArray(obj.y)) {\n      var hasAdjust = self.hasStack();\n      Util.each(obj.y, function (y, idx) {\n        cfg.y = y;\n        cfg.yIndex = idx;\n\n        if (!hasAdjust || idx !== 0) {\n          geomShape = shapeFactory.drawShape(shape, cfg, container);\n          self.appendShapeInfo(geomShape, index + idx);\n        }\n      });\n    } else if (!Util.isNil(obj.y)) {\n      geomShape = shapeFactory.drawShape(shape, cfg, container);\n      self.appendShapeInfo(geomShape, index);\n    }\n  };\n\n  return Point;\n}(GeomBase);\n\nvar PointJitter =\n/*#__PURE__*/\nfunction (_Point) {\n  _inheritsLoose(PointJitter, _Point);\n\n  function PointJitter() {\n    return _Point.apply(this, arguments) || this;\n  }\n\n  var _proto2 = PointJitter.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Point.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'jitter'\n    }];\n    return cfg;\n  };\n\n  return PointJitter;\n}(Point);\n\nvar PointStack =\n/*#__PURE__*/\nfunction (_Point2) {\n  _inheritsLoose(PointStack, _Point2);\n\n  function PointStack() {\n    return _Point2.apply(this, arguments) || this;\n  }\n\n  var _proto3 = PointStack.prototype;\n\n  _proto3.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Point2.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'stack'\n    }];\n    return cfg;\n  };\n\n  return PointStack;\n}(Point);\n\nPoint.Jitter = PointJitter;\nPoint.Stack = PointStack;\nGeomBase.Point = Point;\nGeomBase.PointJitter = PointJitter;\nGeomBase.PointStack = PointStack;\nmodule.exports = Point;\n\n/***/ }),\n/* 369 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview point shapes\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n * @author huangtonger@aliyun.com\n */\nvar Util = __webpack_require__(0);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nvar Shape = __webpack_require__(18); // const svgpath = require('svgpath');\n\n\nvar _require = __webpack_require__(16),\n    Marker = _require.Marker;\n\nvar PathUtil = Util.PathUtil;\nvar SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];\nvar HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line', 'pointerLine', 'pointerArrow'];\nvar SQRT_3 = Math.sqrt(3); // 增加marker\n\nUtil.mix(Marker.Symbols, {\n  hexagon: function hexagon(x, y, r) {\n    var diffX = r / 2 * SQRT_3;\n    return [['M', x, y - r], ['L', x + diffX, y - r / 2], ['L', x + diffX, y + r / 2], ['L', x, y + r], ['L', x - diffX, y + r / 2], ['L', x - diffX, y - r / 2], ['Z']];\n  },\n  bowtie: function bowtie(x, y, r) {\n    var diffY = r - 1.5;\n    return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];\n  },\n  cross: function cross(x, y, r) {\n    return [['M', x - r, y - r], ['L', x + r, y + r], ['M', x + r, y - r], ['L', x - r, y + r]];\n  },\n  tick: function tick(x, y, r) {\n    return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];\n  },\n  plus: function plus(x, y, r) {\n    return [['M', x - r, y], ['L', x + r, y], ['M', x, y - r], ['L', x, y + r]];\n  },\n  hyphen: function hyphen(x, y, r) {\n    return [['M', x - r, y], ['L', x + r, y]];\n  },\n  line: function line(x, y, r) {\n    return [['M', x, y - r], ['L', x, y + r]];\n  }\n});\n\nfunction getFillAttrs(cfg) {\n  var defaultAttrs = Global.shape.point;\n  var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addFillAttrs(pointAttrs, cfg);\n\n  if (Util.isNumber(cfg.size)) {\n    pointAttrs.radius = cfg.size;\n  }\n\n  return pointAttrs;\n}\n\nfunction getLineAttrs(cfg) {\n  var defaultAttrs = Global.shape.hollowPoint;\n  var pointAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addStrokeAttrs(pointAttrs, cfg);\n\n  if (Util.isNumber(cfg.size)) {\n    pointAttrs.radius = cfg.size;\n  }\n\n  return pointAttrs;\n}\n\nvar Point = Shape.registerFactory('point', {\n  defaultShapeType: 'hollowCircle',\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    // 点放大 + 颜色加亮\n    var radius = cfg.radius;\n    var color;\n\n    if (type && (type.indexOf('hollow') === 0 || Util.indexOf(HOLLOW_SHAPES, type) !== -1) || !type) {\n      color = cfg.stroke || cfg.strokeStyle;\n    } else {\n      color = cfg.fill || cfg.fillStyle;\n    }\n\n    return {\n      radius: radius + 1,\n      shadowBlur: radius,\n      shadowColor: color,\n      stroke: color,\n      strokeOpacity: 1,\n      lineWidth: 1\n    };\n  },\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return ShapeUtil.splitPoints(pointInfo);\n  }\n});\n\nfunction getRectPath(cfg) {\n  var x = cfg.points[0].x;\n  var y = cfg.points[0].y;\n  var w = cfg.size[0];\n  var h = cfg.size[1];\n  var path = [['M', x - 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y - 0.5 * h], ['L', x + 0.5 * w, y + 0.5 * h], ['L', x - 0.5 * w, y + 0.5 * h], ['z']];\n  return path;\n} // 用于桑基图的节点\n\n\nShape.registerShape('point', 'rect', {\n  draw: function draw(cfg, container) {\n    var rectAttrs = getFillAttrs(cfg);\n    var path = getRectPath(cfg);\n    path = this.parsePath(path);\n    var gShape = container.addShape('path', {\n      attrs: Util.mix(rectAttrs, {\n        path: path\n      })\n    });\n    return gShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    var attrs = getFillAttrs(cfg);\n    attrs.symbol = 'rect';\n    attrs.radius = 4.5;\n    return attrs;\n  }\n}); // 添加shapes\n\nUtil.each(SHAPES, function (shape) {\n  Shape.registerShape('point', shape, {\n    draw: function draw(cfg, container) {\n      // cfg.points = this.parsePoints(cfg.points);\n      var attrs = getFillAttrs(cfg);\n      return container.addShape('Marker', {\n        attrs: Util.mix(attrs, {\n          symbol: shape,\n          x: cfg.x,\n          y: cfg.y\n        })\n      });\n    },\n    getMarkerCfg: function getMarkerCfg(cfg) {\n      var attrs = getFillAttrs(cfg);\n      attrs.symbol = shape;\n      attrs.radius = 4.5;\n      return attrs;\n    }\n  }); // 添加该 shape 对应的 hollowShape\n\n  Shape.registerShape('point', 'hollow' + Util.upperFirst(shape), {\n    draw: function draw(cfg, container) {\n      // cfg.points = this.parsePoints(cfg.points);\n      var attrs = getLineAttrs(cfg);\n      return container.addShape('Marker', {\n        attrs: Util.mix(attrs, {\n          symbol: shape,\n          x: cfg.x,\n          y: cfg.y\n        })\n      });\n    },\n    getMarkerCfg: function getMarkerCfg(cfg) {\n      var attrs = getLineAttrs(cfg);\n      attrs.symbol = shape;\n      attrs.radius = 4.5;\n      return attrs;\n    }\n  });\n}); // 添加 hollowShapes\n\nUtil.each(HOLLOW_SHAPES, function (shape) {\n  Shape.registerShape('point', shape, {\n    draw: function draw(cfg, container) {\n      var attrs = getLineAttrs(cfg);\n      return container.addShape('Marker', {\n        attrs: Util.mix(attrs, {\n          symbol: shape,\n          x: cfg.x,\n          y: cfg.y\n        })\n      });\n    },\n    getMarkerCfg: function getMarkerCfg(cfg) {\n      var attrs = getLineAttrs(cfg);\n      attrs.symbol = shape;\n      attrs.radius = 4.5;\n      return attrs;\n    }\n  });\n}); // image\n\nShape.registerShape('point', 'image', {\n  draw: function draw(cfg, container) {\n    cfg.points = this.parsePoints(cfg.points);\n    return container.addShape('image', {\n      attrs: {\n        x: cfg.points[0].x - cfg.size / 2,\n        y: cfg.points[0].y - cfg.size,\n        width: cfg.size,\n        height: cfg.size,\n        img: cfg.shape[1]\n      }\n    });\n  }\n}); // path\n\nvar pathMetaCache = {};\nShape.registerShape('point', 'path', {\n  draw: function draw(cfg, container) {\n    var attrs = Util.mix({}, getLineAttrs(cfg), getFillAttrs(cfg));\n    var path = cfg.shape[1];\n    var size = cfg.size || 10;\n    var pathMeta;\n\n    if (pathMetaCache[path]) {\n      pathMeta = pathMetaCache[path];\n    } else {\n      var segments = PathUtil.parsePathString(path);\n      var nums = Util.flatten(segments).filter(function (num) {\n        return Util.isNumber(num);\n      });\n      pathMetaCache[path] = pathMeta = {\n        range: Math.max.apply(null, nums) - Math.min.apply(null, nums),\n        segments: segments\n      };\n    }\n\n    var scale = size / pathMeta.range;\n    var transform = [];\n\n    if (attrs.rotate) {\n      transform.push(['r', attrs.rotate / 180 * Math.PI]);\n      delete attrs.rotate;\n    }\n\n    var shape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: pathMeta.segments\n      })\n    });\n    transform.push(['s', scale, scale], ['t', cfg.x, cfg.y]);\n    shape.transform(transform);\n    return shape;\n  }\n});\nmodule.exports = Point;\n\n/***/ }),\n/* 370 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespaces__ = __webpack_require__(371);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  var prefix = name += \"\",\n      i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n  return __WEBPACK_IMPORTED_MODULE_0__namespaces__[\"a\" /* default */].hasOwnProperty(prefix) ? {\n    space: __WEBPACK_IMPORTED_MODULE_0__namespaces__[\"a\" /* default */][prefix],\n    local: name\n  } : name;\n});\n\n/***/ }),\n/* 371 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return xhtml; });\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n});\n\n/***/ }),\n/* 372 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction none() {}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selector) {\n  return selector == null ? none : function () {\n    return this.querySelector(selector);\n  };\n});\n\n/***/ }),\n/* 373 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node) {\n  return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node\n  node.document && node // node is a Window\n  || node.defaultView; // node is a Document\n});\n\n/***/ }),\n/* 374 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return event; });\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = customEvent;\nvar filterEvents = {};\nvar event = null;\n\nif (typeof document !== \"undefined\") {\n  var element = document.documentElement;\n\n  if (!(\"onmouseenter\" in element)) {\n    filterEvents = {\n      mouseenter: \"mouseover\",\n      mouseleave: \"mouseout\"\n    };\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function (event) {\n    var related = event.relatedTarget;\n\n    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function (event1) {\n    var event0 = event; // Events can be reentrant (e.g., focus).\n\n    event = event1;\n\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      event = event0;\n    }\n  };\n}\n\nfunction parseTypenames(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function (t) {\n    var name = \"\",\n        i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {\n      type: t,\n      name: name\n    };\n  });\n}\n\nfunction onRemove(typename) {\n  return function () {\n    var on = this.__on;\n    if (!on) return;\n\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n\n    if (++i) on.length = i;else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;\n  return function (d, i, group) {\n    var on = this.__on,\n        o,\n        listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {\n      type: typename.type,\n      name: typename.name,\n      value: value,\n      listener: listener,\n      capture: capture\n    };\n    if (!on) this.__on = [o];else on.push(o);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (function (typename, value, capture) {\n  var typenames = parseTypenames(typename + \"\"),\n      i,\n      n = typenames.length,\n      t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value ? onAdd : onRemove;\n  if (capture == null) capture = false;\n\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n\n  return this;\n});\nfunction customEvent(event1, listener, that, args) {\n  var event0 = event;\n  event1.sourceEvent = event;\n  event = event1;\n\n  try {\n    return listener.apply(that, args);\n  } finally {\n    event = event0;\n  }\n}\n\n/***/ }),\n/* 375 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_on__ = __webpack_require__(374);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var current = __WEBPACK_IMPORTED_MODULE_0__selection_on__[\"c\" /* event */],\n      source;\n\n  while (source = current.sourceEvent) current = source;\n\n  return current;\n});\n\n/***/ }),\n/* 376 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (chart) {\n  var scaleController = chart.get('scaleController') || {};\n  return scaleController.defs;\n};\n\n/***/ }),\n/* 377 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getColDefs = __webpack_require__(376);\n\nmodule.exports = function (chart, field) {\n  var colDefs = getColDefs(chart);\n\n  if (colDefs && colDefs[field]) {\n    return colDefs[field];\n  }\n};\n\n/***/ }),\n/* 378 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar TimeUtil = __webpack_require__(71);\n\nmodule.exports = function (data, scale) {\n  var result;\n  var field = scale.field,\n      type = scale.type;\n  var values = Util.Array.values(data, field);\n\n  if (type === 'linear') {\n    result = Util.Array.getRange(values);\n\n    if (scale.min < result.min) {\n      result.min = scale.min;\n    }\n\n    if (scale.max > result.max) {\n      result.max = scale.max;\n    }\n  } else if (type === 'timeCat') {\n    Util.each(values, function (v, i) {\n      values[i] = TimeUtil.toTimeStamp(v);\n    });\n    values.sort(function (v1, v2) {\n      return v1 - v2;\n    });\n    result = values;\n  } else {\n    result = values;\n  }\n\n  return result;\n};\n\n/***/ }),\n/* 379 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(69);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selector) {\n  return typeof selector === \"string\" ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"a\" /* Selection */]([[document.querySelector(selector)]], [document.documentElement]) : new __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"a\" /* Selection */]([[selector]], __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"c\" /* root */]);\n});\n\n/***/ }),\n/* 380 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction empty() {\n  return [];\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selector) {\n  return selector == null ? empty : function () {\n    return this.querySelectorAll(selector);\n  };\n});\n\n/***/ }),\n/* 381 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar matcher = function (selector) {\n  return function () {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document !== \"undefined\") {\n  var element = document.documentElement;\n\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;\n\n    matcher = function (selector) {\n      return function () {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (matcher);\n\n/***/ }),\n/* 382 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = EnterNode;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(383);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(69);\n\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (function () {\n  return new __WEBPACK_IMPORTED_MODULE_1__index__[\"a\" /* Selection */](this._enter || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__[\"a\" /* default */]), this._parents);\n});\nfunction EnterNode(parent, datum) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum;\n}\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function (child) {\n    return this._parent.insertBefore(child, this._next);\n  },\n  insertBefore: function (child, next) {\n    return this._parent.insertBefore(child, next);\n  },\n  querySelector: function (selector) {\n    return this._parent.querySelector(selector);\n  },\n  querySelectorAll: function (selector) {\n    return this._parent.querySelectorAll(selector);\n  }\n};\n\n/***/ }),\n/* 383 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (update) {\n  return new Array(update.length);\n});\n\n/***/ }),\n/* 384 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = styleValue;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(373);\n\n\nfunction styleRemove(name) {\n  return function () {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, value, priority) {\n  return function () {\n    this.style.setProperty(name, value, priority);\n  };\n}\n\nfunction styleFunction(name, value, priority) {\n  return function () {\n    var v = value.apply(this, arguments);\n    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value, priority) {\n  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === \"function\" ? styleFunction : styleConstant)(name, value, priority == null ? \"\" : priority)) : styleValue(this.node(), name);\n});\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name) || Object(__WEBPACK_IMPORTED_MODULE_0__window__[\"a\" /* default */])(node).getComputedStyle(node, null).getPropertyValue(name);\n}\n\n/***/ }),\n/* 385 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_schedule__ = __webpack_require__(70);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node, name) {\n  var schedules = node.__transition,\n      schedule,\n      active,\n      empty = true,\n      i;\n  if (!schedules) return;\n  name = name == null ? null : name + \"\";\n\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) {\n      empty = false;\n      continue;\n    }\n\n    active = schedule.state > __WEBPACK_IMPORTED_MODULE_0__transition_schedule__[\"d\" /* STARTING */] && schedule.state < __WEBPACK_IMPORTED_MODULE_0__transition_schedule__[\"b\" /* ENDING */];\n    schedule.state = __WEBPACK_IMPORTED_MODULE_0__transition_schedule__[\"a\" /* ENDED */];\n    schedule.timer.stop();\n    if (active) schedule.on.call(\"interrupt\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n\n  if (empty) delete node.__transition;\n});\n\n/***/ }),\n/* 386 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_color__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__ = __webpack_require__(117);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (a, b) {\n  var c;\n  return (typeof b === \"number\" ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__[\"interpolateNumber\"] : b instanceof __WEBPACK_IMPORTED_MODULE_0_d3_color__[\"a\" /* color */] ? __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__[\"interpolateRgb\"] : (c = Object(__WEBPACK_IMPORTED_MODULE_0_d3_color__[\"a\" /* color */])(b)) ? (b = c, __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__[\"interpolateRgb\"]) : __WEBPACK_IMPORTED_MODULE_1_d3_interpolate__[\"interpolateString\"])(a, b);\n});\n\n/***/ }),\n/* 387 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview 分面的基类\n * @author dxq613@gmail.com\n */\nvar Base = __webpack_require__(363);\n/**\n * 矩形的 facet 有以下属性：\n * - colField 列的字段\n * - rowField 行的字段\n * - colValue 列字段的值\n * - rowValue 行字段的值\n * - cols 列数\n * - rows 行数\n * - colIndex 列的序号\n * - rowIndex 行的序号\n */\n\n/**\n * 用于生成分面的类\n * @class Facets.Rect\n */\n\n\nvar Rect =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Rect, _Base);\n\n  function Rect() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Rect.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'rect';\n    return cfg;\n  };\n\n  _proto.generateFacets = function generateFacets(data) {\n    var self = this;\n    var fields = self.fields; // var defs = self.defs;\n\n    var rst = [];\n    var rows = 1;\n    var cols = 1;\n    var colField = fields[0];\n    var rowField = fields[1];\n    var colValues = [''];\n    var rowValues = [''];\n\n    if (colField) {\n      colValues = self.getFieldValues(colField, data);\n      cols = colValues.length;\n    }\n\n    if (rowField) {\n      rowValues = self.getFieldValues(rowField, data);\n      rows = rowValues.length;\n    } // 获取每个维度对应的frame\n\n\n    colValues.forEach(function (xVal, xIndex) {\n      rowValues.forEach(function (yVal, yIndex) {\n        var conditions = [{\n          field: colField,\n          value: xVal,\n          values: colValues\n        }, {\n          field: rowField,\n          value: yVal,\n          values: rowValues\n        }];\n        var filter = self.getFilter(conditions);\n        var subData = data.filter(filter);\n        var facet = {\n          type: self.type,\n          colValue: xVal,\n          rowValue: yVal,\n          colField: colField,\n          rowField: rowField,\n          colIndex: xIndex,\n          rowIndex: yIndex,\n          cols: cols,\n          rows: rows,\n          data: subData,\n          region: self.getRegion(rows, cols, xIndex, yIndex)\n        };\n        rst.push(facet);\n      });\n    });\n    return rst;\n  }; // 设置 x 坐标轴的文本、title 是否显示\n\n\n  _proto.setXAxis = function setXAxis(xField, axes, facet) {\n    if (facet.rowIndex !== facet.rows - 1) {\n      axes[xField].title = null;\n      axes[xField].label = null;\n    } else if (facet.colIndex !== parseInt((facet.cols - 1) / 2)) {\n      axes[xField].title = null;\n    }\n  }; // 设置 y 坐标轴的文本、title 是否显示\n\n\n  _proto.setYAxis = function setYAxis(yField, axes, facet) {\n    if (facet.colIndex !== 0) {\n      axes[yField].title = null;\n      axes[yField].label = null;\n    } else if (facet.rowIndex !== parseInt((facet.rows - 1) / 2)) {\n      axes[yField].title = null;\n    }\n  };\n\n  _proto.renderTitle = function renderTitle(view, facet) {\n    if (facet.rowIndex === 0) {\n      this.drawColTitle(view, facet);\n    }\n\n    if (facet.colIndex === facet.cols - 1) {\n      this.drawRowTitle(view, facet);\n    }\n  };\n\n  return Rect;\n}(Base);\n\nmodule.exports = Rect;\n\n/***/ }),\n/* 388 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview list facets, support cols\n */\nvar Base = __webpack_require__(363);\n/**\n * 用于生成分面的类\n * @class Facets.List\n */\n\n\nvar List =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(List, _Base);\n\n  function List() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = List.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'list';\n    cfg.cols = null; // 用户不设置时就显示一行\n\n    return cfg;\n  };\n\n  _proto.generateFacets = function generateFacets(data) {\n    var self = this;\n    var fields = self.fields;\n    var colField = fields[0];\n\n    if (!colField) {\n      throw 'Please specify for the field for facet!';\n    }\n\n    var colValues = self.getFieldValues(colField, data);\n    var count = colValues.length;\n    var cols = self.cols || count;\n    var rows = parseInt((count + cols - 1) / cols);\n    var rst = [];\n    colValues.forEach(function (xVal, index) {\n      var row = parseInt(index / cols);\n      var col = index % cols;\n      var conditions = [{\n        field: colField,\n        value: xVal,\n        values: colValues\n      }];\n      var filter = self.getFilter(conditions);\n      var subData = data.filter(filter);\n      var facet = {\n        type: self.type,\n        count: count,\n        colValue: xVal,\n        colField: colField,\n        rowField: null,\n        rowValue: xVal,\n        colIndex: col,\n        rowIndex: row,\n        cols: cols,\n        rows: rows,\n        data: subData,\n        region: self.getRegion(rows, cols, col, row)\n      };\n      rst.push(facet);\n    });\n    return rst;\n  }; // 设置 x 坐标轴的文本、title 是否显示\n\n\n  _proto.setXAxis = function setXAxis(xField, axes, facet) {\n    // 当是最后一行或者下面没有 view 时文本不显示\n    if (facet.rowIndex !== facet.rows - 1 && facet.cols * facet.rowIndex + facet.colIndex + 1 + facet.cols <= facet.count) {\n      axes[xField].label = null;\n      axes[xField].title = null;\n    }\n  }; // 设置 y 坐标轴的文本、title 是否显示\n\n\n  _proto.setYAxis = function setYAxis(yField, axes, facet) {\n    if (facet.colIndex !== 0) {\n      axes[yField].title = null;\n      axes[yField].label = null;\n    }\n  };\n\n  return List;\n}(Base);\n\nmodule.exports = List;\n\n/***/ }),\n/* 389 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar G2 = __webpack_require__(172); // geoms\n\n\n__webpack_require__(390);\n\n__webpack_require__(392);\n\n__webpack_require__(394);\n\n__webpack_require__(364);\n\n__webpack_require__(366);\n\n__webpack_require__(359);\n\n__webpack_require__(368);\n\n__webpack_require__(395);\n\n__webpack_require__(397);\n\n__webpack_require__(399);\n\n__webpack_require__(459); // facets\n\n\n__webpack_require__(461); // interaction\n\n\n__webpack_require__(466);\n\nmodule.exports = G2;\n\n/***/ }),\n/* 390 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview 面积图\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar SplitMixin = __webpack_require__(358);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(391);\n\nvar Area =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Area, _GeomBase);\n\n  var _proto = Area.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'area';\n    cfg.shapeType = 'area';\n    cfg.generatePoints = true;\n    cfg.sortable = true;\n    return cfg;\n  };\n\n  function Area(cfg) {\n    var _this;\n\n    _this = _GeomBase.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), SplitMixin);\n    return _this;\n  }\n\n  _proto.draw = function draw(data, container, shapeFactory, index) {\n    var self = this;\n    var cfg = this.getDrawCfg(data[0]);\n\n    self._applyViewThemeShapeStyle(cfg, cfg.shape, shapeFactory);\n\n    var splitArray = this.splitData(data);\n    cfg.origin = data; // path,line,area 等图的origin 是整个序列\n\n    Util.each(splitArray, function (subData, splitedIndex) {\n      cfg.splitedIndex = splitedIndex; // 传入分割片段索引 用于生成id\n\n      var points = subData.map(function (obj) {\n        return obj.points;\n      });\n      cfg.points = points;\n      var geomShape = shapeFactory.drawShape(cfg.shape, cfg, container);\n      self.appendShapeInfo(geomShape, index + splitedIndex);\n    });\n  };\n\n  return Area;\n}(GeomBase);\n\nvar AreaStack =\n/*#__PURE__*/\nfunction (_Area) {\n  _inheritsLoose(AreaStack, _Area);\n\n  function AreaStack() {\n    return _Area.apply(this, arguments) || this;\n  }\n\n  var _proto2 = AreaStack.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Area.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'stack'\n    }];\n    return cfg;\n  };\n\n  return AreaStack;\n}(Area);\n\nArea.Stack = AreaStack;\nGeomBase.Area = Area;\nGeomBase.AreaStack = AreaStack;\nmodule.exports = Area;\n\n/***/ }),\n/* 391 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview area shape\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar PathUtil = __webpack_require__(22);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nfunction getLineAttrs(cfg) {\n  var defaultAttrs = Global.shape.hollowArea;\n  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);\n\n  if (Util.isNumber(cfg.size)) {\n    lineAttrs.lineWidth = cfg.size;\n  }\n\n  return lineAttrs;\n}\n\nfunction getFillAttrs(cfg) {\n  var defaultAttrs = Global.shape.area;\n  var areaAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addFillAttrs(areaAttrs, cfg);\n\n  if (cfg.color) {\n    areaAttrs.stroke = areaAttrs.stroke || cfg.color;\n  }\n\n  if (Util.isNumber(cfg.size)) {\n    areaAttrs.lineWidth = cfg.size;\n  }\n\n  return areaAttrs;\n}\n\nfunction getPath(cfg, smooth, shape) {\n  var path = [];\n  var pointsArr = [];\n  var topLinePoints = []; // area 区域上部分\n\n  var bottomLinePoints = []; // area 区域下部分\n\n  var isInCircle = cfg.isInCircle;\n  Util.each(cfg.points, function (point) {\n    topLinePoints.push(point[1]);\n    bottomLinePoints.push(point[0]);\n  }); // if (!isInCircle) {\n\n  bottomLinePoints = bottomLinePoints.reverse(); // }\n\n  pointsArr.push(topLinePoints, bottomLinePoints);\n  Util.each(pointsArr, function (points, index) {\n    var subPath = [];\n    points = shape.parsePoints(points);\n    var p1 = points[0];\n\n    if (isInCircle) {\n      points.push({\n        x: p1.x,\n        y: p1.y\n      });\n    }\n\n    if (smooth) {\n      subPath = PathUtil.getSplinePath(points, false, cfg.constraint);\n    } else {\n      subPath = PathUtil.getLinePath(points, false);\n    }\n\n    if (index > 0) {\n      subPath[0][0] = 'L';\n    }\n\n    path = path.concat(subPath);\n  });\n  path.push(['Z']);\n  return path;\n} // get marker cfg\n\n\nfunction _getMarkerCfg(cfg) {\n  return {\n    symbol: function symbol(x, y) {\n      return [['M', x - 5.5, y - 4], ['L', x + 5.5, y - 4], ['L', x + 5.5, y + 4], ['L', x - 5.5, y + 4], ['Z']];\n    },\n    radius: 5,\n    fill: cfg.color,\n    fillOpacity: 0.6\n  };\n} // 鼠标悬浮触发active状态\n\n\nfunction _getActiveCfg(type, cfg) {\n  if (type === 'line' || type === 'smoothLine') {\n    // 线加粗\n    var lineWidth = cfg.lineWidth || 0;\n    return {\n      lineWidth: lineWidth + 1\n    };\n  }\n\n  var opacity = cfg.fillOpacity || cfg.opacity || 1;\n  return {\n    fillOpacity: opacity - 0.15,\n    strokeOpacity: opacity - 0.15\n  };\n} // 当只有一个数据时绘制点\n\n\nfunction drawPointShape(shapeObj, cfg, container) {\n  var coord = shapeObj._coord;\n  var point = coord.convertPoint(cfg.points[0][1]);\n  return container.addShape('circle', {\n    attrs: Util.mix({\n      x: point.x,\n      y: point.y,\n      r: 2,\n      fill: cfg.color\n    }, cfg.style)\n  });\n}\n\nvar Area = Shape.registerFactory('area', {\n  defaultShapeType: 'area',\n\n  /**\n   * @override\n   * @protected\n   * 计算点 如果存在多个点，分割成单个的点, 不考虑多个x对应一个y的情况\n   * 单点则补上y0点\n   */\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    var points = [];\n    var x = pointInfo.x;\n    var y = pointInfo.y;\n    var y0 = pointInfo.y0;\n    y = Util.isArray(y) ? y : [y0, y];\n    Util.each(y, function (yItem) {\n      points.push({\n        x: x,\n        y: yItem\n      });\n    });\n    return points;\n  },\n  // 获取激活的图形属性\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    return _getActiveCfg(type, cfg);\n  },\n  drawShape: function drawShape(type, cfg, container) {\n    var shape = this.getShape(type);\n    var gShape;\n\n    if (cfg.points.length === 1 && Global.showSinglePoint) {\n      gShape = drawPointShape(this, cfg, container);\n    } else {\n      gShape = shape.draw(cfg, container);\n    }\n\n    if (gShape) {\n      gShape.set('origin', cfg.origin);\n      gShape._id = cfg.splitedIndex ? cfg._id + cfg.splitedIndex : cfg._id;\n      gShape.name = this.name;\n    }\n\n    return gShape;\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    if (cfg && cfg.style) {\n      return cfg.style;\n    }\n\n    return this.getActiveCfg(type, cfg);\n  }\n}); // 默认：填充区域图\n\nShape.registerShape('area', 'area', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getPath(cfg, false, this); // path = this.parsePath(path, false);\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg);\n  }\n}); // 填充平滑区域图\n\nShape.registerShape('area', 'smooth', {\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var coord = this._coord; // 曲线的限制\n\n    cfg.constraint = [[coord.start.x, coord.end.y], [coord.end.x, coord.start.y]];\n    var path = getPath(cfg, true, this); // path = this.parsePath(path, false);\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg);\n  }\n}); // 封闭的折线\n\nShape.registerShape('area', 'line', {\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    var path = getPath(cfg, false, this); // path = this.parsePath(path, false);\n\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg);\n  }\n}); // 封闭的平滑线\n\nShape.registerShape('area', 'smoothLine', {\n  draw: function draw(cfg, container) {\n    var attrs = getLineAttrs(cfg);\n    var path = getPath(cfg, true, this);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return _getMarkerCfg(cfg);\n  }\n});\nArea.spline = Area.smooth;\nmodule.exports = Area;\n\n/***/ }),\n/* 392 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview 边，用于关系图的边\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\n__webpack_require__(393);\n\nvar Edge =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Edge, _GeomBase);\n\n  function Edge() {\n    return _GeomBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Edge.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'edge';\n    cfg.shapeType = 'edge';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  return Edge;\n}(GeomBase);\n\nGeomBase.Edge = Edge;\nmodule.exports = Edge;\n\n/***/ }),\n/* 393 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 边的 shape\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nvar PathUtil = __webpack_require__(22);\n\nvar CORNER_PERCENT = 1 / 3;\n\nfunction getAttrs(cfg) {\n  var defaultCfg = Global.shape.edge;\n  var lineAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);\n  return lineAttrs;\n}\n\nvar Edge = Shape.registerFactory('edge', {\n  defaultShapeType: 'line',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return ShapeUtil.splitPoints(pointInfo);\n  },\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    var lineWidth = cfg.lineWidth || 0;\n    return {\n      lineWidth: lineWidth + 1\n    };\n  }\n});\n\nfunction getCPath(from, to) {\n  var points = [];\n  points.push({\n    x: from.x,\n    y: from.y * (1 - 1 / 2) + to.y * 1 / 2\n  });\n  points.push({\n    y: from.y * (1 - 1 / 2) + to.y * 1 / 2,\n    x: to.x\n  });\n  points.push(to);\n  var sub = ['C'];\n  Util.each(points, function (point) {\n    sub.push(point.x, point.y);\n  });\n  return sub;\n}\n\nfunction getQPath(to, center) {\n  var points = [];\n  points.push({\n    x: center.x,\n    y: center.y\n  });\n  points.push(to);\n  var sub = ['Q'];\n  Util.each(points, function (point) {\n    sub.push(point.x, point.y);\n  });\n  return sub;\n}\n\nfunction createSmoothPath(from, to) {\n  var sub = getCPath(from, to);\n  var path = [['M', from.x, from.y]];\n  path.push(sub);\n  return path;\n}\n\nfunction createArcPath(from, to, center) {\n  var sub = getQPath(to, center);\n  var path = [['M', from.x, from.y]];\n  path.push(sub);\n  return path;\n}\n\nfunction createArcWeightPath(points, center) {\n  var arc1 = getQPath(points[1], center);\n  var arc2 = getQPath(points[3], center);\n  var path = [['M', points[0].x, points[0].y]];\n  path.push(arc2);\n  path.push(['L', points[3].x, points[3].y]);\n  path.push(['L', points[2].x, points[2].y]);\n  path.push(arc1);\n  path.push(['L', points[1].x, points[1].y]);\n  path.push(['L', points[0].x, points[0].y]);\n  path.push(['Z']);\n  return path;\n}\n\nfunction createRectPath(from, to) {\n  var points = [];\n  points.push({\n    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,\n    x: from.x\n  });\n  points.push({\n    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,\n    x: to.x\n  });\n  points.push(to);\n  var path = [['M', from.x, from.y]];\n  Util.each(points, function (point) {\n    path.push(['L', point.x, point.y]);\n  });\n  return path;\n}\n\nShape.registerShape('edge', 'line', {\n  draw: function draw(cfg, container) {\n    var points = this.parsePoints(cfg.points);\n    var attrCfg = getAttrs(cfg);\n    var path = PathUtil.getLinePath(points);\n    var line = container.addShape('path', {\n      attrs: Util.mix(attrCfg, {\n        path: path\n      })\n    });\n    return line;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4.5\n    }, getAttrs(cfg));\n  }\n});\nShape.registerShape('edge', 'vhv', {\n  draw: function draw(cfg, container) {\n    var points = cfg.points;\n    var attrCfg = getAttrs(cfg);\n    var path = createRectPath(points[0], points[1]);\n    path = this.parsePath(path);\n    var line = container.addShape('path', {\n      attrs: Util.mix(attrCfg, {\n        path: path\n      })\n    });\n    return line;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4.5\n    }, getAttrs(cfg));\n  }\n});\nShape.registerShape('edge', 'smooth', {\n  draw: function draw(cfg, container) {\n    var points = cfg.points;\n    var attrCfg = getAttrs(cfg);\n    var path = createSmoothPath(points[0], points[1]);\n    path = this.parsePath(path);\n    var line = container.addShape('path', {\n      attrs: Util.mix(attrCfg, {\n        path: path\n      })\n    });\n    return line;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4.5\n    }, getAttrs(cfg));\n  }\n}); //  弧线包括笛卡尔坐标系下的半圆弧线、极坐标系下以圆心为控制点的二阶曲线、笛卡尔坐标系下带权重的三阶曲线、极坐标系下带权重的以圆心为控制点的二阶曲线\n\nShape.registerShape('edge', 'arc', {\n  draw: function draw(cfg, container) {\n    var points = cfg.points;\n    var type = points.length > 2 ? 'weight' : 'normal';\n    var attrCfg = getAttrs(cfg);\n    var line;\n    var path;\n\n    if (cfg.isInCircle) {\n      var center = {\n        x: 0,\n        y: 1\n      };\n\n      if (type === 'normal') {\n        path = createArcPath(points[0], points[1], center);\n      } else {\n        attrCfg.fill = attrCfg.stroke;\n        path = createArcWeightPath(points, center);\n      }\n\n      path = this.parsePath(path);\n      line = container.addShape('path', {\n        attrs: Util.mix(attrCfg, {\n          path: path\n        })\n      });\n    } else {\n      if (type === 'normal') {\n        points = this.parsePoints(points);\n        line = container.addShape('arc', {\n          attrs: Util.mix(attrCfg, {\n            x: (points[1].x + points[0].x) / 2,\n            y: points[0].y,\n            r: Math.abs(points[1].x - points[0].x) / 2,\n            startAngle: Math.PI,\n            endAngle: Math.PI * 2\n          })\n        });\n      } else {\n        path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y]];\n        var c1 = getCPath(points[1], points[3]);\n        var c2 = getCPath(points[2], points[0]);\n        path.push(c1);\n        path.push(['L', points[3].x, points[3].y]);\n        path.push(['L', points[2].x, points[2].y]);\n        path.push(c2);\n        path.push(['Z']);\n        path = this.parsePath(path);\n        attrCfg.fill = attrCfg.stroke;\n        line = container.addShape('path', {\n          attrs: Util.mix(attrCfg, {\n            path: path\n          })\n        });\n      }\n    }\n\n    return line;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4.5\n    }, getAttrs(cfg));\n  }\n});\nmodule.exports = Edge;\n\n/***/ }),\n/* 394 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview heatmap\n * @author leungwensen@gmail.com\n */\nvar _require = __webpack_require__(73),\n    ColorUtil = _require.ColorUtil; // TODO: ColorUtil 独立成包，从 attr 包中抽离\n\n\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar ORIGIN_FIELD = '_origin';\nvar SHADOW_CANVAS = 'shadowCanvas';\nvar VALUE_RANGE = 'valueRange';\nvar IMAGE_SHAPE = 'imageShape';\nvar MAPPED_DATA = 'mappedData';\nvar GRAY_SCALE_BLURRED_CANVAS = 'grayScaleBlurredCanvas';\nvar HEATMAP_SIZE = 'heatmapSize';\n\nvar Heatmap =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Heatmap, _GeomBase);\n\n  function Heatmap() {\n    return _GeomBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Heatmap.prototype;\n\n  /**\n   * get default configuration\n   * @protected\n   * @return {Object} configuration\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'heatmap';\n    cfg.paletteCache = {}; // cfg.shapeType = 'heatmap';\n\n    return cfg;\n  };\n\n  _proto._prepareRange = function _prepareRange() {\n    var self = this;\n    var data = self.get(MAPPED_DATA);\n    var colorAttr = self.getAttr('color');\n    var colorField = colorAttr.field;\n    var min = Infinity;\n    var max = -Infinity;\n    data.forEach(function (row) {\n      var value = row[ORIGIN_FIELD][colorField];\n\n      if (value > max) {\n        max = value;\n      }\n\n      if (value < min) {\n        min = value;\n      }\n    });\n\n    if (min === max) {\n      min = max - 1;\n    }\n\n    var range = [min, max];\n    self.set(VALUE_RANGE, range);\n  };\n\n  _proto._prepareSize = function _prepareSize() {\n    var self = this;\n    var radius = self.getDefaultValue('size');\n\n    if (!Util.isNumber(radius)) {\n      radius = self._getDefaultSize();\n    }\n\n    var styleOptions = self.get('styleOptions');\n    var blur = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.blur : null;\n\n    if (!Util.isFinite(blur) || blur === null) {\n      blur = radius / 2;\n    }\n\n    self.set(HEATMAP_SIZE, {\n      blur: blur,\n      radius: radius\n    });\n  };\n\n  _proto._getDefaultSize = function _getDefaultSize() {\n    var self = this;\n    var position = self.getAttr('position');\n    var coord = self.get('coord');\n    var radius = Math.min(coord.width / (position.scales[0].ticks.length * 4), coord.height / (position.scales[1].ticks.length * 4));\n    return radius;\n  };\n\n  _proto._colorize = function _colorize(img) {\n    var self = this;\n    var colorAttr = self.getAttr('color');\n    var pixels = img.data;\n    var paletteCache = self.get('paletteCache');\n\n    for (var i = 3; i < pixels.length; i += 4) {\n      var alpha = pixels[i]; // get gradient color from opacity value\n\n      if (alpha) {\n        var palette = void 0;\n\n        if (paletteCache[alpha]) {\n          palette = paletteCache[alpha];\n        } else {\n          palette = ColorUtil.rgb2arr(colorAttr.gradient(alpha / 256));\n          paletteCache[alpha] = palette;\n        } // const palette = colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));\n\n\n        pixels[i - 3] = palette[0];\n        pixels[i - 2] = palette[1];\n        pixels[i - 1] = palette[2];\n        pixels[i] = alpha;\n      }\n    }\n  };\n\n  _proto._prepareGreyScaleBlurredCircle = function _prepareGreyScaleBlurredCircle(r, blur) {\n    var self = this;\n    var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);\n\n    if (!circleCanvas) {\n      circleCanvas = document.createElement('canvas');\n      self.set(GRAY_SCALE_BLURRED_CANVAS, circleCanvas);\n    }\n\n    var r2 = r + blur;\n    var ctx = circleCanvas.getContext('2d');\n    circleCanvas.width = circleCanvas.height = r2 * 2;\n    ctx.clearRect(0, 0, circleCanvas.width, circleCanvas.height); // ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n\n    ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n    ctx.shadowBlur = blur;\n    ctx.shadowColor = 'black';\n    ctx.beginPath();\n    ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n  };\n\n  _proto._drawGrayScaleBlurredCircle = function _drawGrayScaleBlurredCircle(x, y, r, alpha, ctx) {\n    var self = this;\n    var circleCanvas = self.get(GRAY_SCALE_BLURRED_CANVAS);\n    ctx.globalAlpha = alpha;\n    ctx.drawImage(circleCanvas, x - r, y - r);\n  };\n\n  _proto._getShadowCanvasCtx = function _getShadowCanvasCtx() {\n    var self = this;\n    var canvas = self.get(SHADOW_CANVAS);\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      self.set(SHADOW_CANVAS, canvas);\n    }\n\n    var _self$get = self.get('coord'),\n        width = _self$get.width,\n        height = _self$get.height;\n\n    canvas.width = width;\n    canvas.height = height;\n    return canvas.getContext('2d');\n  };\n\n  _proto._clearShadowCanvasCtx = function _clearShadowCanvasCtx() {\n    var ctx = this._getShadowCanvasCtx();\n\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  };\n\n  _proto._getImageShape = function _getImageShape() {\n    var self = this;\n    var imageShape = self.get(IMAGE_SHAPE);\n\n    if (imageShape) {\n      return imageShape;\n    }\n\n    var container = self.get('container');\n    imageShape = container.addShape('Image', {});\n    self.set(IMAGE_SHAPE, imageShape);\n    return imageShape;\n  };\n\n  _proto.drawWithRange = function drawWithRange(range) {\n    var self = this; // canvas size\n\n    var _self$get2 = self.get('coord'),\n        start = _self$get2.start,\n        end = _self$get2.end,\n        width = _self$get2.width,\n        height = _self$get2.height; // value, range, etc\n\n\n    var valueField = self.getAttr('color').field;\n    var size = self.get(HEATMAP_SIZE); // prepare shadow canvas context\n\n    self._clearShadowCanvasCtx();\n\n    var ctx = self._getShadowCanvasCtx(); // filter data\n\n\n    var data = self.get(MAPPED_DATA);\n\n    if (range) {\n      data = data.filter(function (row) {\n        return row[ORIGIN_FIELD][valueField] <= range[1] && row[ORIGIN_FIELD][valueField] >= range[0];\n      });\n    } // step1. draw points with shadow\n\n\n    var scale = self._getScale(valueField);\n\n    for (var i = 0; i < data.length; i++) {\n      var obj = data[i];\n      var cfg = self.getDrawCfg(obj);\n      var alpha = scale.scale(obj[ORIGIN_FIELD][valueField]);\n\n      self._drawGrayScaleBlurredCircle(cfg.x - start.x, cfg.y - end.y, size.radius + size.blur, alpha, ctx);\n    } // step2. convert pixels\n\n\n    var colored = ctx.getImageData(0, 0, width, height);\n\n    self._clearShadowCanvasCtx();\n\n    self._colorize(colored);\n\n    ctx.putImageData(colored, 0, 0);\n\n    var imageShape = self._getImageShape();\n\n    imageShape.attr('x', start.x);\n    imageShape.attr('y', end.y);\n    imageShape.attr('width', width);\n    imageShape.attr('height', height);\n    imageShape.attr('img', ctx.canvas);\n  };\n\n  _proto.draw = function draw(data\n  /* , container, shapeFactory, index */\n  ) {\n    var self = this;\n    self.set(MAPPED_DATA, data);\n\n    self._prepareRange();\n\n    self._prepareSize();\n\n    var size = self.get(HEATMAP_SIZE);\n\n    self._prepareGreyScaleBlurredCircle(size.radius, size.blur);\n\n    var range = self.get(VALUE_RANGE);\n    self.drawWithRange(range); // super.draw(data, container, shapeFactory, index);\n  };\n\n  return Heatmap;\n}(GeomBase);\n\nGeomBase.Heatmap = Heatmap;\nmodule.exports = Heatmap;\n\n/***/ }),\n/* 395 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview 多边形\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(396);\n\nvar Polygon =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Polygon, _GeomBase);\n\n  function Polygon() {\n    return _GeomBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Polygon.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'polygon';\n    cfg.shapeType = 'polygon';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);\n\n    var self = this;\n    var x = cfg.x;\n    var y = cfg.y;\n    var temp;\n\n    if (!(Util.isArray(x) && Util.isArray(y))) {\n      // x y 都是数组时，不做处理\n      var xScale = self.getXScale();\n      var yScale = self.getYScale();\n      var xCount = xScale.values ? xScale.values.length : xScale.ticks.length;\n      var yCount = yScale.values ? yScale.values.length : yScale.ticks.length;\n      var xOffset = 0.5 * 1 / xCount;\n      var yOffset = 0.5 * 1 / yCount;\n\n      if (xScale.isCategory && yScale.isCategory) {\n        // 如果x,y都是分类\n        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];\n        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];\n      } else if (Util.isArray(x)) {\n        // x 是数组\n        temp = x;\n        x = [temp[0], temp[0], temp[1], temp[1]];\n        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];\n      } else if (Util.isArray(y)) {\n        // y 是数组\n        temp = y;\n        y = [temp[0], temp[1], temp[1], temp[0]];\n        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];\n      }\n\n      cfg.x = x;\n      cfg.y = y;\n    }\n\n    return cfg;\n  };\n\n  return Polygon;\n}(GeomBase);\n\nGeomBase.Polygon = Polygon;\nmodule.exports = Polygon;\n\n/***/ }),\n/* 396 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview line shapes\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n * @author huangtonger@aliyun.com\n # @author liuye10@yahoo.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nfunction getAttrs(cfg) {\n  var defaultCfg = Global.shape.polygon;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addFillAttrs(pathAttrs, cfg);\n  return pathAttrs;\n}\n\nfunction getHollowAttrs(cfg) {\n  var defaultCfg = Global.shape.hollowPolygon;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);\n  return pathAttrs;\n}\n\nfunction getPath(points) {\n  var flag = points[0];\n  var i = 1;\n  var path = [['M', flag.x, flag.y]];\n\n  while (i < points.length) {\n    var c = points[i];\n\n    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {\n      path.push(['L', c.x, c.y]);\n\n      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {\n        flag = points[i + 1];\n        path.push(['Z']);\n        path.push(['M', flag.x, flag.y]);\n        i++;\n      }\n    }\n\n    i++;\n  }\n\n  if (!Util.isEqual(path[path.length - 1], flag)) {\n    path.push(['L', flag.x, flag.y]);\n  }\n\n  path.push(['Z']);\n  return path;\n} // regist line geom\n\n\nvar Polygon = Shape.registerFactory('polygon', {\n  defaultShapeType: 'polygon',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    var points = [];\n    Util.each(pointInfo.x, function (subX, index) {\n      var subY = pointInfo.y[index];\n      points.push({\n        x: subX,\n        y: subY\n      });\n    });\n    return points;\n  },\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    var lineWidth = cfg.lineWidth || 1;\n\n    if (type === 'hollow') {\n      return {\n        lineWidth: lineWidth + 1\n      };\n    }\n\n    var opacity = cfg.fillOpacity || cfg.opacity || 1;\n    return {\n      // lineWidth,\n      fillOpacity: opacity - 0.08\n    };\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    if (cfg && cfg.style) {\n      return cfg.style;\n    }\n\n    return this.getActiveCfg(type, cfg);\n  }\n});\nShape.registerShape('polygon', 'polygon', {\n  draw: function draw(cfg, container) {\n    if (!Util.isEmpty(cfg.points)) {\n      var attrs = getAttrs(cfg);\n      var path = getPath(cfg.points);\n      path = this.parsePath(path);\n      return container.addShape('path', {\n        attrs: Util.mix(attrs, {\n          path: path\n        })\n      });\n    }\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n});\nShape.registerShape('polygon', 'hollow', {\n  draw: function draw(cfg, container) {\n    if (!Util.isEmpty(cfg.points)) {\n      var attrs = getHollowAttrs(cfg);\n      var path = getPath(cfg.points);\n      path = this.parsePath(path);\n      return container.addShape('path', {\n        attrs: Util.mix(attrs, {\n          path: path\n        })\n      });\n    }\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'square',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n});\nmodule.exports = Polygon;\n\n/***/ }),\n/* 397 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview 自定义图形\n * @author dxq613@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = __webpack_require__(357);\n\n__webpack_require__(398);\n\nvar Schema =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Schema, _GeomBase);\n\n  var _proto = Schema.prototype;\n\n  /**\n   * 获取默认的配置属性\n   * @protected\n   * @return {Object} 默认属性\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'schema';\n    cfg.shapeType = 'schema';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  function Schema(cfg) {\n    var _this;\n\n    _this = _GeomBase.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), SizeMixin);\n    return _this;\n  }\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);\n\n    cfg.size = this.getNormalizedSize(obj);\n    return cfg;\n  };\n\n  return Schema;\n}(GeomBase);\n\nvar SchemaDodge =\n/*#__PURE__*/\nfunction (_Schema) {\n  _inheritsLoose(SchemaDodge, _Schema);\n\n  function SchemaDodge() {\n    return _Schema.apply(this, arguments) || this;\n  }\n\n  var _proto2 = SchemaDodge.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Schema.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'dodge'\n    }];\n    return cfg;\n  };\n\n  return SchemaDodge;\n}(Schema);\n\nSchema.Dodge = SchemaDodge;\nGeomBase.Schema = Schema;\nGeomBase.SchemaDodge = SchemaDodge;\nmodule.exports = Schema;\n\n/***/ }),\n/* 398 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 自定义的 shape\n * @author dxq613@gmail.com\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nfunction _parseValue(value) {\n  if (!Util.isArray(value)) {\n    value = [value];\n  }\n\n  var min = value[0]; // 最小值\n\n  var max = value[value.length - 1]; // 最大值\n\n  var min1 = value.length > 1 ? value[1] : min;\n  var max1 = value.length > 3 ? value[3] : max;\n  var median = value.length > 2 ? value[2] : min1;\n  return {\n    min: min,\n    // 最小值\n    max: max,\n    // 最大值\n    min1: min1,\n    max1: max1,\n    median: median\n  };\n}\n\nfunction addPoints(from, to) {\n  Util.each(from, function (subArr) {\n    to.push({\n      x: subArr[0],\n      y: subArr[1]\n    });\n  });\n}\n\nfunction getAttrs(cfg) {\n  var defaultAttrs = Global.shape.schema;\n  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addStrokeAttrs(lineAttrs, cfg);\n  return lineAttrs;\n}\n\nfunction getFillAttrs(cfg) {\n  var defaultAttrs = Global.shape.schema;\n  var lineAttrs = Util.mix({}, defaultAttrs, cfg.style);\n  ShapeUtil.addFillAttrs(lineAttrs, cfg);\n\n  if (cfg.color) {\n    lineAttrs.stroke = lineAttrs.stroke || cfg.color;\n  }\n\n  return lineAttrs;\n}\n\nfunction getBoxPoints(x, y, width) {\n  var points = [];\n  var pointsArray;\n  var obj;\n\n  if (Util.isArray(y)) {\n    // 2维\n    obj = _parseValue(y);\n    pointsArray = [[x - width / 2, obj.max], [x + width / 2, obj.max], [x, obj.max], [x, obj.max1], [x - width / 2, obj.min1], [x - width / 2, obj.max1], [x + width / 2, obj.max1], [x + width / 2, obj.min1], [x, obj.min1], [x, obj.min], [x - width / 2, obj.min], [x + width / 2, obj.min], [x - width / 2, obj.median], [x + width / 2, obj.median]];\n  } else {\n    // 只有一个维度\n    y = y || 0.5;\n    obj = _parseValue(x);\n    pointsArray = [[obj.min, y - width / 2], [obj.min, y + width / 2], [obj.min, y], [obj.min1, y], [obj.min1, y - width / 2], [obj.min1, y + width / 2], [obj.max1, y + width / 2], [obj.max1, y - width / 2], [obj.max1, y], [obj.max, y], [obj.max, y - width / 2], [obj.max, y + width / 2], [obj.median, y - width / 2], [obj.median, y + width / 2]];\n  }\n\n  addPoints(pointsArray, points);\n  return points;\n}\n\nfunction _sortValue(value) {\n  if (!Util.isArray(value)) {\n    value = [value];\n  } // 从大到小排序\n\n\n  var sorted = value.sort(function (a, b) {\n    return a < b ? 1 : -1;\n  });\n  var length = sorted.length;\n\n  if (length < 4) {\n    var min = sorted[length - 1];\n\n    for (var i = 0; i < 4 - length; i++) {\n      sorted.push(min);\n    }\n  }\n\n  return sorted;\n} // 获取K线图的points\n\n\nfunction getCandlePoints(x, y, width) {\n  var yValues = _sortValue(y);\n\n  var points = [{\n    x: x,\n    y: yValues[0]\n  }, {\n    x: x,\n    y: yValues[1]\n  }, {\n    x: x - width / 2,\n    y: yValues[2]\n  }, {\n    x: x - width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[2]\n  }, {\n    x: x,\n    y: yValues[2]\n  }, {\n    x: x,\n    y: yValues[3]\n  }]; // 按照顺时针连接\n\n  return points;\n}\n\nfunction getBoxPath(points) {\n  var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], // 封闭 z\n  ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x, points[10].y], ['L', points[11].x, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];\n  return path;\n}\n\nfunction getCandlePath(points) {\n  var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];\n  return path;\n}\n\nvar Schema = Shape.registerFactory('schema', {\n  defaultShapeType: '',\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    if (type === 'box') {\n      var lineWidth = cfg.lineWidth || 1;\n      return {\n        lineWidth: lineWidth + 1\n      };\n    }\n\n    var opacity = cfg.fillOpacity || cfg.opacity || 1;\n    return {\n      fillOpacity: opacity - 0.15,\n      strokeOpacity: opacity - 0.15\n    };\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    if (cfg && cfg.style) {\n      return cfg.style;\n    }\n\n    return this.getActiveCfg(type, cfg);\n  }\n}); // 箱线图\n\nShape.registerShape('schema', 'box', {\n  getPoints: function getPoints(pointInfo) {\n    return getBoxPoints(pointInfo.x, pointInfo.y, pointInfo.size);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getBoxPath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return {\n      symbol: function symbol(x, y, r) {\n        var yValues = [y - 6, y - 3, y, y + 3, y + 6];\n        var points = getBoxPoints(x, yValues, r);\n        return [['M', points[0].x + 1, points[0].y], ['L', points[1].x - 1, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x + 1, points[10].y], ['L', points[11].x - 1, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];\n      },\n      radius: 6,\n      lineWidth: 1,\n      stroke: cfg.color\n    };\n  }\n}); // K线\n\nShape.registerShape('schema', 'candle', {\n  getPoints: function getPoints(pointInfo) {\n    return getCandlePoints(pointInfo.x, pointInfo.y, pointInfo.size);\n  },\n  draw: function draw(cfg, container) {\n    var attrs = getFillAttrs(cfg);\n    var path = getCandlePath(cfg.points);\n    path = this.parsePath(path);\n    return container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return {\n      symbol: function symbol(x, y, r) {\n        y = [y + 7.5, y + 3, y - 3, y - 7.5];\n        var points = getCandlePoints(x, y, r);\n        return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];\n      },\n      lineWidth: 1,\n      stroke: cfg.color,\n      fill: cfg.color,\n      radius: 6\n    };\n  }\n});\nmodule.exports = Schema;\n\n/***/ }),\n/* 399 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview Venn Diagram\n * @author leungwensen@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(400),\n    venn = _require.venn,\n    scaleSolution = _require.scaleSolution,\n    circlePath = _require.circlePath,\n    intersectionAreaPath = _require.intersectionAreaPath,\n    computeTextCentres = _require.computeTextCentres;\n\n__webpack_require__(458);\n\nvar Venn =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Venn, _GeomBase);\n\n  function Venn() {\n    return _GeomBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Venn.prototype;\n\n  /**\n   * get default configuration\n   * @protected\n   * @return {Object} configuration\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'venn';\n    cfg.shapeType = 'venn';\n    cfg.generatePoints = true; // super.draw(data, container, shapeFactory, index);\n\n    return cfg;\n  };\n\n  _proto._initAttrs = function _initAttrs() {\n    var self = this;\n    var attrOptions = self.get('attrOptions');\n    var labelCfg = self.get('labelCfg');\n    var data = self.get('data');\n    var sizeField = attrOptions.size ? attrOptions.size.field : 'size';\n    var labelField = labelCfg ? labelCfg.fields[0] : 'sets';\n    self.set('labelCfg', null); // prepare data\n\n    data.forEach(function (row) {\n      row.sets = row[labelField];\n      row.size = row[sizeField];\n    });\n    var solution = venn(data); // scaling\n\n    var coord = self.get('coord');\n    var xRange = [Math.min(coord.x.end, coord.x.start), Math.max(coord.x.end, coord.x.start)];\n    var yRange = [Math.min(coord.y.end, coord.y.start), Math.max(coord.y.end, coord.y.start)];\n    var width = xRange[1] - xRange[0];\n    var height = yRange[1] - yRange[0];\n    var styleOptions = self.get('styleOptions');\n    var padding = styleOptions && Util.isObject(styleOptions.style) ? styleOptions.style.padding : 0;\n\n    if (!Util.isFinite(padding)) {\n      padding = 0;\n    }\n\n    var circles = scaleSolution(solution, width, height, padding);\n    var textCenters = computeTextCentres(circles, data);\n    data.forEach(function (row) {\n      var sets = row.sets;\n      var id = sets.join(',');\n      row.id = id;\n\n      if (sets.length === 1) {\n        var circle = circles[id];\n        row.path = circlePath(circle.x, circle.y, circle.radius);\n        Util.assign(row, circle);\n      } else {\n        var setCircles = sets.map(function (set) {\n          return circles[set];\n        });\n        var path = intersectionAreaPath(setCircles);\n\n        if (!/[zZ]$/.test(path)) {\n          path += 'Z';\n        }\n\n        row.path = path;\n        var center = textCenters[id] || {\n          x: 0,\n          y: 0\n        };\n        Util.assign(row, center);\n      }\n    }); // x, y scales\n\n    self.position('x*y');\n\n    _GeomBase.prototype._initAttrs.call(this);\n  };\n\n  _proto.paint = function paint() {\n    _GeomBase.prototype.paint.call(this);\n\n    var self = this;\n    var dataArray = self.get('dataArray');\n    var shapeContainer = self.get('shapeContainer'); // add labels\n\n    dataArray.forEach(function (row) {\n      var cfg = self.getDrawCfg(row[0]);\n      var origin = cfg.origin._origin;\n      shapeContainer.addShape('text', {\n        attrs: Util.mix({}, {\n          x: origin.x,\n          y: origin.y,\n          text: origin.label || '',\n          fontSize: 18,\n          fill: cfg.shape === 'hollow' ? cfg.color : '#666',\n          textAlign: 'center',\n          textBaseline: 'middle'\n        }, cfg.style ? cfg.style.textStyle : {})\n      });\n    });\n  };\n\n  return Venn;\n}(GeomBase);\n\nGeomBase.Venn = Venn;\nmodule.exports = Venn;\n\n/***/ }),\n/* 400 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(72), __webpack_require__(435)) : undefined;\n})(this, function (exports, d3Selection, d3Transition) {\n  'use strict';\n\n  var SMALL = 1e-10;\n  /** Returns the intersection area of a bunch of circles (where each circle\n   is an object having an x,y and radius property) */\n\n  function intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles\n\n    var innerPoints = intersectionPoints.filter(function (p) {\n      return containedInCircles(p, circles);\n    });\n    var arcArea = 0,\n        polygonArea = 0,\n        arcs = [],\n        i; // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n\n    if (innerPoints.length > 1) {\n      // sort the points by angle from the center of the polygon, which lets\n      // us just iterate over points to get the edges\n      var center = getCenter(innerPoints);\n\n      for (i = 0; i < innerPoints.length; ++i) {\n        var p = innerPoints[i];\n        p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n      }\n\n      innerPoints.sort(function (a, b) {\n        return b.angle - a.angle;\n      }); // iterate over all points, get arc between the points\n      // and update the areas\n\n      var p2 = innerPoints[innerPoints.length - 1];\n\n      for (i = 0; i < innerPoints.length; ++i) {\n        var p1 = innerPoints[i]; // polygon area updates easily ...\n\n        polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved\n\n        var midPoint = {\n          x: (p1.x + p2.x) / 2,\n          y: (p1.y + p2.y) / 2\n        },\n            arc = null;\n\n        for (var j = 0; j < p1.parentIndex.length; ++j) {\n          if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n            // figure out the angle halfway between the two points\n            // on the current circle\n            var circle = circles[p1.parentIndex[j]],\n                a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n            var angleDiff = a2 - a1;\n\n            if (angleDiff < 0) {\n              angleDiff += 2 * Math.PI;\n            } // and use that angle to figure out the width of the\n            // arc\n\n\n            var a = a2 - angleDiff / 2,\n                width = distance(midPoint, {\n              x: circle.x + circle.radius * Math.sin(a),\n              y: circle.y + circle.radius * Math.cos(a)\n            }); // clamp the width to the largest is can actually be\n            // (sometimes slightly overflows because of FP errors)\n\n            if (width > circle.radius * 2) {\n              width = circle.radius * 2;\n            } // pick the circle whose arc has the smallest width\n\n\n            if (arc === null || arc.width > width) {\n              arc = {\n                circle: circle,\n                width: width,\n                p1: p1,\n                p2: p2\n              };\n            }\n          }\n        }\n\n        if (arc !== null) {\n          arcs.push(arc);\n          arcArea += circleArea(arc.circle.radius, arc.width);\n          p2 = p1;\n        }\n      }\n    } else {\n      // no intersection points, is either disjoint - or is completely\n      // overlapped. figure out which by examining the smallest circle\n      var smallest = circles[0];\n\n      for (i = 1; i < circles.length; ++i) {\n        if (circles[i].radius < smallest.radius) {\n          smallest = circles[i];\n        }\n      } // make sure the smallest circle is completely contained in all\n      // the other circles\n\n\n      var disjoint = false;\n\n      for (i = 0; i < circles.length; ++i) {\n        if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n          disjoint = true;\n          break;\n        }\n      }\n\n      if (disjoint) {\n        arcArea = polygonArea = 0;\n      } else {\n        arcArea = smallest.radius * smallest.radius * Math.PI;\n        arcs.push({\n          circle: smallest,\n          p1: {\n            x: smallest.x,\n            y: smallest.y + smallest.radius\n          },\n          p2: {\n            x: smallest.x - SMALL,\n            y: smallest.y + smallest.radius\n          },\n          width: smallest.radius * 2\n        });\n      }\n    }\n\n    polygonArea /= 2;\n\n    if (stats) {\n      stats.area = arcArea + polygonArea;\n      stats.arcArea = arcArea;\n      stats.polygonArea = polygonArea;\n      stats.arcs = arcs;\n      stats.innerPoints = innerPoints;\n      stats.intersectionPoints = intersectionPoints;\n    }\n\n    return arcArea + polygonArea;\n  }\n  /** returns whether a point is contained by all of a list of circles */\n\n\n  function containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n      if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** Gets all intersection points between a bunch of circles */\n\n\n  function getIntersectionPoints(circles) {\n    var ret = [];\n\n    for (var i = 0; i < circles.length; ++i) {\n      for (var j = i + 1; j < circles.length; ++j) {\n        var intersect = circleCircleIntersection(circles[i], circles[j]);\n\n        for (var k = 0; k < intersect.length; ++k) {\n          var p = intersect[k];\n          p.parentIndex = [i, j];\n          ret.push(p);\n        }\n      }\n    }\n\n    return ret;\n  }\n  /** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\n\n\n  function circleArea(r, width) {\n    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n  }\n  /** euclidean distance between two points */\n\n\n  function distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n  }\n  /** Returns the overlap area of two circles of radius r1 and r2 - that\n  have their centers separated by distance d. Simpler faster\n  circle intersection for only two circles */\n\n\n  function circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n      return 0;\n    } // completely overlapped\n\n\n    if (d <= Math.abs(r1 - r2)) {\n      return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n  }\n  /** Given two circles (containing a x/y/radius attributes),\n  returns the intersecting points if possible.\n  note: doesn't handle cases where there are infinitely many\n  intersection points (circles are equivalent):, or only one intersection point*/\n\n\n  function circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n        r1 = p1.radius,\n        r2 = p2.radius; // if to far away, or self contained - can't be done\n\n    if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n      return [];\n    }\n\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n        h = Math.sqrt(r1 * r1 - a * a),\n        x0 = p1.x + a * (p2.x - p1.x) / d,\n        y0 = p1.y + a * (p2.y - p1.y) / d,\n        rx = -(p2.y - p1.y) * (h / d),\n        ry = -(p2.x - p1.x) * (h / d);\n    return [{\n      x: x0 + rx,\n      y: y0 - ry\n    }, {\n      x: x0 - rx,\n      y: y0 + ry\n    }];\n  }\n  /** Returns the center of a bunch of points */\n\n\n  function getCenter(points) {\n    var center = {\n      x: 0,\n      y: 0\n    };\n\n    for (var i = 0; i < points.length; ++i) {\n      center.x += points[i].x;\n      center.y += points[i].y;\n    }\n\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n  }\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n\n\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n          fMid = f(mid);\n\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n\n    return a + delta;\n  } // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n\n\n  function zeros(x) {\n    var r = new Array(x);\n\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n\n    return r;\n  }\n\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n\n  function dot(a, b) {\n    var ret = 0;\n\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n\n    return ret;\n  }\n\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n  /** minimizes a function using the downhill simplex method */\n\n\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = parameters.rho !== undefined ? parameters.rho : 1,\n        chi = parameters.chi !== undefined ? parameters.chi : 2,\n        psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n        sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n        maxDiff; // initialize simplex.\n\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n\n      simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function (a, b) {\n      return a.fx - b.fx;\n    };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n\n      maxDiff = 0;\n\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      } // compute the centroid of all but the worst point in the simplex\n\n\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n\n        centroid[i] /= N;\n      } // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n\n\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected); // if the reflected point is the best seen, then possibly expand\n\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      } // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n          var shouldReduce = false;\n\n          if (reflected.fx > worst.fx) {\n            // do an inside contraction\n            weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n            contracted.fx = f(contracted);\n\n            if (contracted.fx < worst.fx) {\n              updateSimplex(contracted);\n            } else {\n              shouldReduce = true;\n            }\n          } else {\n            // do an outside contraction\n            weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n            contracted.fx = f(contracted);\n\n            if (contracted.fx < reflected.fx) {\n              updateSimplex(contracted);\n            } else {\n              shouldReduce = true;\n            }\n          }\n\n          if (shouldReduce) {\n            // if we don't contract here, we're done\n            if (sigma >= 1) break; // do a reduction\n\n            for (i = 1; i < simplex.length; ++i) {\n              weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n              simplex[i].fx = f(simplex[i]);\n            }\n          }\n        } else {\n          updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  } /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n\n\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n        phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0,\n        phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n\n      return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n\n    return a;\n  }\n\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        next = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        yk = initial.slice(),\n        pk,\n        temp,\n        a = 1,\n        maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a); // todo: history in wrong spot?\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polak–Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n            beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n\n    return current;\n  }\n  /** given a list of set objects, and their corresponding overlaps.\n  updates the (x, y, radius) attribute on each set such that their positions\n  roughly correspond to the desired overlaps */\n\n\n  function venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size\n\n    areas = addMissingAreas(areas); // initial layout is done greedily\n\n    var circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize\n\n    var initial = [],\n        setids = [],\n        setid;\n\n    for (setid in circles) {\n      if (circles.hasOwnProperty(setid)) {\n        initial.push(circles[setid].x);\n        initial.push(circles[setid].y);\n        setids.push(setid);\n      }\n    } // optimize initial layout from our loss function\n\n\n    var solution = nelderMead(function (values) {\n      var current = {};\n\n      for (var i = 0; i < setids.length; ++i) {\n        var setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius // size : circles[setid].size\n\n        };\n      }\n\n      return loss(current, areas);\n    }, initial, parameters); // transform solution vector back to x/y points\n\n    var positions = solution.x;\n\n    for (var i = 0; i < setids.length; ++i) {\n      setid = setids[i];\n      circles[setid].x = positions[2 * i];\n      circles[setid].y = positions[2 * i + 1];\n    }\n\n    return circles;\n  }\n\n  var SMALL$1 = 1e-10;\n  /** Returns the distance necessary for two circles of radius r1 + r2 to\n  have the overlap area 'overlap' */\n\n  function distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n      return Math.abs(r1 - r2);\n    }\n\n    return bisect(function (distance$$1) {\n      return circleOverlap(r1, r2, distance$$1) - overlap;\n    }, 0, r1 + r2);\n  }\n  /** Missing pair-wise intersection area data can cause problems:\n   treating as an unknown means that sets will be laid out overlapping,\n   which isn't what people expect. To reflect that we want disjoint sets\n   here, set the overlap to 0 for all missing pairwise set intersections */\n\n\n  function addMissingAreas(areas) {\n    areas = areas.slice(); // two circle intersections that aren't defined\n\n    var ids = [],\n        pairs = {},\n        i,\n        j,\n        a,\n        b;\n\n    for (i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n\n      if (area.sets.length == 1) {\n        ids.push(area.sets[0]);\n      } else if (area.sets.length == 2) {\n        a = area.sets[0];\n        b = area.sets[1];\n        pairs[[a, b]] = true;\n        pairs[[b, a]] = true;\n      }\n    }\n\n    ids.sort(function (a, b) {\n      return a > b;\n    });\n\n    for (i = 0; i < ids.length; ++i) {\n      a = ids[i];\n\n      for (j = i + 1; j < ids.length; ++j) {\n        b = ids[j];\n\n        if (!([a, b] in pairs)) {\n          areas.push({\n            'sets': [a, b],\n            'size': 0\n          });\n        }\n      }\n    }\n\n    return areas;\n  } /// Returns two matrices, one of the euclidean distances between the sets\n  /// and the other indicating if there are subset or disjoint set relationships\n\n\n  function getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n        constraints = zerosM(sets.length, sets.length); // compute required distances between all the sets such that\n    // the areas match\n\n    areas.filter(function (x) {\n      return x.sets.length == 2;\n    }).map(function (current) {\n      var left = setids[current.sets[0]],\n          right = setids[current.sets[1]],\n          r1 = Math.sqrt(sets[left].size / Math.PI),\n          r2 = Math.sqrt(sets[right].size / Math.PI),\n          distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\n      distances[left][right] = distances[right][left] = distance$$1; // also update constraints to indicate if its a subset or disjoint\n      // relationship\n\n      var c = 0;\n\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n\n      constraints[left][right] = constraints[right][left] = c;\n    });\n    return {\n      distances: distances,\n      constraints: constraints\n    };\n  } /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n\n\n  function constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0,\n        i;\n\n    for (i = 0; i < fxprime.length; ++i) {\n      fxprime[i] = 0;\n    }\n\n    for (i = 0; i < distances.length; ++i) {\n      var xi = x[2 * i],\n          yi = x[2 * i + 1];\n\n      for (var j = i + 1; j < distances.length; ++j) {\n        var xj = x[2 * j],\n            yj = x[2 * j + 1],\n            dij = distances[i][j],\n            constraint = constraints[i][j];\n        var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n            distance$$1 = Math.sqrt(squaredDistance),\n            delta = squaredDistance - dij * dij;\n\n        if (constraint > 0 && distance$$1 <= dij || constraint < 0 && distance$$1 >= dij) {\n          continue;\n        }\n\n        loss += 2 * delta * delta;\n        fxprime[2 * i] += 4 * delta * (xi - xj);\n        fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n        fxprime[2 * j] += 4 * delta * (xj - xi);\n        fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n      }\n    }\n\n    return loss;\n  } /// takes the best working variant of either constrained MDS or greedy\n\n\n  function bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n\n    if (areas.length >= 8) {\n      var constrained = constrainedMDSLayout(areas, params),\n          constrainedLoss = loss(constrained, areas),\n          greedyLoss = loss(initial, areas);\n\n      if (constrainedLoss + 1e-8 < greedyLoss) {\n        initial = constrained;\n      }\n    }\n\n    return initial;\n  } /// use the constrained MDS variant to generate an initial layout\n\n\n  function constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)\n\n    var sets = [],\n        setids = {},\n        i;\n\n    for (i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n\n      if (area.sets.length == 1) {\n        setids[area.sets[0]] = sets.length;\n        sets.push(area);\n      }\n    }\n\n    var matrices = getDistanceMatrices(areas, sets, setids),\n        distances = matrices.distances,\n        constraints = matrices.constraints; // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n\n    var norm = norm2(distances.map(norm2)) / distances.length;\n    distances = distances.map(function (row) {\n      return row.map(function (value) {\n        return value / norm;\n      });\n    });\n\n    var obj = function (x, fxprime) {\n      return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n\n    var best, current;\n\n    for (i = 0; i < restarts; ++i) {\n      var initial = zeros(distances.length * 2).map(Math.random);\n      current = conjugateGradient(obj, initial, params);\n\n      if (!best || current.fx < best.fx) {\n        best = current;\n      }\n    }\n\n    var positions = best.x; // translate rows back to (x,y,radius) coordinates\n\n    var circles = {};\n\n    for (i = 0; i < sets.length; ++i) {\n      var set = sets[i];\n      circles[set.sets[0]] = {\n        x: positions[2 * i] * norm,\n        y: positions[2 * i + 1] * norm,\n        radius: Math.sqrt(set.size / Math.PI)\n      };\n    }\n\n    if (params.history) {\n      for (i = 0; i < params.history.length; ++i) {\n        scale(params.history[i].x, norm);\n      }\n    }\n\n    return circles;\n  }\n  /** Lays out a Venn diagram greedily, going from most overlapped sets to\n  least overlapped, attempting to position each new set such that the\n  overlapping areas to already positioned sets are basically right */\n\n\n  function greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set\n\n    var circles = {},\n        setOverlaps = {},\n        set;\n\n    for (var i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n\n      if (area.sets.length == 1) {\n        set = area.sets[0];\n        circles[set] = {\n          x: 1e10,\n          y: 1e10,\n          rowid: circles.length,\n          size: area.size,\n          radius: Math.sqrt(area.size / Math.PI)\n        };\n        setOverlaps[set] = [];\n      }\n    }\n\n    areas = areas.filter(function (a) {\n      return a.sets.length == 2;\n    }); // map each set to a list of all the other sets that overlap it\n\n    for (i = 0; i < areas.length; ++i) {\n      var current = areas[i];\n      var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n      var left = current.sets[0],\n          right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here\n\n      if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\n        weight = 0;\n      }\n\n      setOverlaps[left].push({\n        set: right,\n        size: current.size,\n        weight: weight\n      });\n      setOverlaps[right].push({\n        set: left,\n        size: current.size,\n        weight: weight\n      });\n    } // get list of most overlapped sets\n\n\n    var mostOverlapped = [];\n\n    for (set in setOverlaps) {\n      if (setOverlaps.hasOwnProperty(set)) {\n        var size = 0;\n\n        for (i = 0; i < setOverlaps[set].length; ++i) {\n          size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n        }\n\n        mostOverlapped.push({\n          set: set,\n          size: size\n        });\n      }\n    } // sort by size desc\n\n\n    function sortOrder(a, b) {\n      return b.size - a.size;\n    }\n\n    mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out\n\n    var positioned = {};\n\n    function isPositioned(element) {\n      return element.set in positioned;\n    } // adds a point to the output\n\n\n    function positionSet(point, index) {\n      circles[index].x = point.x;\n      circles[index].y = point.y;\n      positioned[index] = true;\n    } // add most overlapped set at (0,0)\n\n\n    positionSet({\n      x: 0,\n      y: 0\n    }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n\n    for (i = 1; i < mostOverlapped.length; ++i) {\n      var setIndex = mostOverlapped[i].set,\n          overlap = setOverlaps[setIndex].filter(isPositioned);\n      set = circles[setIndex];\n      overlap.sort(sortOrder);\n\n      if (overlap.length === 0) {\n        // this shouldn't happen anymore with addMissingAreas\n        throw \"ERROR: missing pairwise overlap information\";\n      }\n\n      var points = [];\n\n      for (var j = 0; j < overlap.length; ++j) {\n        // get appropriate distance from most overlapped already added set\n        var p1 = circles[overlap[j].set],\n            d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics\n\n        points.push({\n          x: p1.x + d1,\n          y: p1.y\n        });\n        points.push({\n          x: p1.x - d1,\n          y: p1.y\n        });\n        points.push({\n          y: p1.y + d1,\n          x: p1.x\n        });\n        points.push({\n          y: p1.y - d1,\n          x: p1.x\n        }); // if we have at least 2 overlaps, then figure out where the\n        // set should be positioned analytically and try those too\n\n        for (var k = j + 1; k < overlap.length; ++k) {\n          var p2 = circles[overlap[k].set],\n              d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n          var extraPoints = circleCircleIntersection({\n            x: p1.x,\n            y: p1.y,\n            radius: d1\n          }, {\n            x: p2.x,\n            y: p2.y,\n            radius: d2\n          });\n\n          for (var l = 0; l < extraPoints.length; ++l) {\n            points.push(extraPoints[l]);\n          }\n        }\n      } // we have some candidate positions for the set, examine loss\n      // at each position to figure out where to put it at\n\n\n      var bestLoss = 1e50,\n          bestPoint = points[0];\n\n      for (j = 0; j < points.length; ++j) {\n        circles[setIndex].x = points[j].x;\n        circles[setIndex].y = points[j].y;\n        var localLoss = loss(circles, areas);\n\n        if (localLoss < bestLoss) {\n          bestLoss = localLoss;\n          bestPoint = points[j];\n        }\n      }\n\n      positionSet(bestPoint, setIndex);\n    }\n\n    return circles;\n  }\n  /** Given a bunch of sets, and the desired overlaps between these sets - computes\n  the distance from the actual overlaps to the desired overlaps. Note that\n  this method ignores overlaps of more than 2 circles */\n\n\n  function lossFunction(sets, overlaps) {\n    var output = 0;\n\n    function getCircles(indices) {\n      return indices.map(function (i) {\n        return sets[i];\n      });\n    }\n\n    for (var i = 0; i < overlaps.length; ++i) {\n      var area = overlaps[i],\n          overlap;\n\n      if (area.sets.length == 1) {\n        continue;\n      } else if (area.sets.length == 2) {\n        var left = sets[area.sets[0]],\n            right = sets[area.sets[1]];\n        overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n      } else {\n        overlap = intersectionArea(getCircles(area.sets));\n      }\n\n      var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n      output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n\n    return output;\n  } // orientates a bunch of circles to point in orientation\n\n\n  function orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n      circles.sort(function (a, b) {\n        return b.radius - a.radius;\n      });\n    } else {\n      circles.sort(orientationOrder);\n    }\n\n    var i; // shift circles so largest circle is at (0, 0)\n\n    if (circles.length > 0) {\n      var largestX = circles[0].x,\n          largestY = circles[0].y;\n\n      for (i = 0; i < circles.length; ++i) {\n        circles[i].x -= largestX;\n        circles[i].y -= largestY;\n      }\n    }\n\n    if (circles.length == 2) {\n      // if the second circle is a subset of the first, arrange so that\n      // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n      var dist = distance(circles[0], circles[1]);\n\n      if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n        circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n        circles[1].y = circles[0].y;\n      }\n    } // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n\n\n    if (circles.length > 1) {\n      var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n          c = Math.cos(rotation),\n          s = Math.sin(rotation),\n          x,\n          y;\n\n      for (i = 0; i < circles.length; ++i) {\n        x = circles[i].x;\n        y = circles[i].y;\n        circles[i].x = c * x - s * y;\n        circles[i].y = s * x + c * y;\n      }\n    } // mirror solution if third solution is above plane specified by\n    // first two circles\n\n\n    if (circles.length > 2) {\n      var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n\n      while (angle < 0) {\n        angle += 2 * Math.PI;\n      }\n\n      while (angle > 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n      }\n\n      if (angle > Math.PI) {\n        var slope = circles[1].y / (1e-10 + circles[1].x);\n\n        for (i = 0; i < circles.length; ++i) {\n          var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\n          circles[i].x = 2 * d - circles[i].x;\n          circles[i].y = 2 * d * slope - circles[i].y;\n        }\n      }\n    }\n  }\n\n  function disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function (circle) {\n      circle.parent = circle;\n    }); // path compression step in union find\n\n    function find(circle) {\n      if (circle.parent !== circle) {\n        circle.parent = find(circle.parent);\n      }\n\n      return circle.parent;\n    }\n\n    function union(x, y) {\n      var xRoot = find(x),\n          yRoot = find(y);\n      xRoot.parent = yRoot;\n    } // get the union of all overlapping sets\n\n\n    for (var i = 0; i < circles.length; ++i) {\n      for (var j = i + 1; j < circles.length; ++j) {\n        var maxDistance = circles[i].radius + circles[j].radius;\n\n        if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n          union(circles[j], circles[i]);\n        }\n      }\n    } // find all the disjoint clusters and group them together\n\n\n    var disjointClusters = {},\n        setid;\n\n    for (i = 0; i < circles.length; ++i) {\n      setid = find(circles[i]).parent.setid;\n\n      if (!(setid in disjointClusters)) {\n        disjointClusters[setid] = [];\n      }\n\n      disjointClusters[setid].push(circles[i]);\n    } // cleanup bookkeeping\n\n\n    circles.map(function (circle) {\n      delete circle.parent;\n    }); // return in more usable form\n\n    var ret = [];\n\n    for (setid in disjointClusters) {\n      if (disjointClusters.hasOwnProperty(setid)) {\n        ret.push(disjointClusters[setid]);\n      }\n    }\n\n    return ret;\n  }\n\n  function getBoundingBox(circles) {\n    var minMax = function (d) {\n      var hi = Math.max.apply(null, circles.map(function (c) {\n        return c[d] + c.radius;\n      })),\n          lo = Math.min.apply(null, circles.map(function (c) {\n        return c[d] - c.radius;\n      }));\n      return {\n        max: hi,\n        min: lo\n      };\n    };\n\n    return {\n      xRange: minMax('x'),\n      yRange: minMax('y')\n    };\n  }\n\n  function normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null) {\n      orientation = Math.PI / 2;\n    } // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n\n\n    var circles = [],\n        i,\n        setid;\n\n    for (setid in solution) {\n      if (solution.hasOwnProperty(setid)) {\n        var previous = solution[setid];\n        circles.push({\n          x: previous.x,\n          y: previous.y,\n          radius: previous.radius,\n          setid: setid\n        });\n      }\n    } // get all the disjoint clusters\n\n\n    var clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes\n\n    for (i = 0; i < clusters.length; ++i) {\n      orientateCircles(clusters[i], orientation, orientationOrder);\n      var bounds = getBoundingBox(clusters[i]);\n      clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n      clusters[i].bounds = bounds;\n    }\n\n    clusters.sort(function (a, b) {\n      return b.size - a.size;\n    }); // orientate the largest at 0,0, and get the bounds\n\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n    function addCluster(cluster, right, bottom) {\n      if (!cluster) return;\n      var bounds = cluster.bounds,\n          xOffset,\n          yOffset,\n          centreing;\n\n      if (right) {\n        xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n      } else {\n        xOffset = returnBounds.xRange.max - bounds.xRange.max;\n        centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n        if (centreing < 0) xOffset += centreing;\n      }\n\n      if (bottom) {\n        yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n      } else {\n        yOffset = returnBounds.yRange.max - bounds.yRange.max;\n        centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n        if (centreing < 0) yOffset += centreing;\n      }\n\n      for (var j = 0; j < cluster.length; ++j) {\n        cluster[j].x += xOffset;\n        cluster[j].y += yOffset;\n        circles.push(cluster[j]);\n      }\n    }\n\n    var index = 1;\n\n    while (index < clusters.length) {\n      addCluster(clusters[index], true, false);\n      addCluster(clusters[index + 1], false, true);\n      addCluster(clusters[index + 2], true, true);\n      index += 3; // have one cluster (in top left). lay out next three relative\n      // to it in a grid\n\n      returnBounds = getBoundingBox(circles);\n    } // convert back to solution form\n\n\n    var ret = {};\n\n    for (i = 0; i < circles.length; ++i) {\n      ret[circles[i].setid] = circles[i];\n    }\n\n    return ret;\n  }\n  /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n  a rectangle of width/height - with padding around the borders. also\n  centers the diagram in the available space at the same time */\n\n\n  function scaleSolution(solution, width, height, padding) {\n    var circles = [],\n        setids = [];\n\n    for (var setid in solution) {\n      if (solution.hasOwnProperty(setid)) {\n        setids.push(setid);\n        circles.push(solution[setid]);\n      }\n    }\n\n    width -= 2 * padding;\n    height -= 2 * padding;\n    var bounds = getBoundingBox(circles),\n        xRange = bounds.xRange,\n        yRange = bounds.yRange;\n\n    if (xRange.max == xRange.min || yRange.max == yRange.min) {\n      console.log(\"not scaling solution: zero size detected\");\n      return solution;\n    }\n\n    var xScaling = width / (xRange.max - xRange.min),\n        yScaling = height / (yRange.max - yRange.min),\n        scaling = Math.min(yScaling, xScaling),\n        // while we're at it, center the diagram too\n    xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,\n        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n    var scaled = {};\n\n    for (var i = 0; i < circles.length; ++i) {\n      var circle = circles[i];\n      scaled[setids[i]] = {\n        radius: scaling * circle.radius,\n        x: padding + xOffset + (circle.x - xRange.min) * scaling,\n        y: padding + yOffset + (circle.y - yRange.min) * scaling\n      };\n    }\n\n    return scaled;\n  }\n  /*global console:true*/\n\n\n  function VennDiagram() {\n    var width = 600,\n        height = 350,\n        padding = 15,\n        duration = 1000,\n        orientation = Math.PI / 2,\n        normalize = true,\n        wrap = true,\n        styled = true,\n        fontSize = null,\n        orientationOrder = null,\n        // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n        colourIndex = 0,\n        colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n\n      var ret = colourMap[key] = colourScheme[colourIndex];\n      colourIndex += 1;\n\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n\n      return ret;\n    },\n        layoutFunction = venn,\n        loss = lossFunction;\n\n    function chart(selection) {\n      var data = selection.datum(); // handle 0-sized sets by removing from input\n\n      var toremove = {};\n      data.forEach(function (datum) {\n        if (datum.size == 0 && datum.sets.length == 1) {\n          toremove[datum.sets[0]] = 1;\n        }\n      });\n      data = data.filter(function (datum) {\n        return !datum.sets.some(function (set) {\n          return set in toremove;\n        });\n      });\n      var circles = {};\n      var textCentres = {};\n\n      if (data.length > 0) {\n        var solution = layoutFunction(data, {\n          lossFunction: loss\n        });\n\n        if (normalize) {\n          solution = normalizeSolution(solution, orientation, orientationOrder);\n        }\n\n        circles = scaleSolution(solution, width, height, padding);\n        textCentres = computeTextCentres(circles, data);\n      } // Figure out the current label for each set. These can change\n      // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n\n\n      var labels = {};\n      data.forEach(function (datum) {\n        if (datum.label) {\n          labels[datum.sets] = datum.label;\n        }\n      });\n\n      function label(d) {\n        if (d.sets in labels) {\n          return labels[d.sets];\n        }\n\n        if (d.sets.length == 1) {\n          return '' + d.sets[0];\n        }\n      } // create svg if not already existing\n\n\n      selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n      var svg = selection.select(\"svg\").attr(\"width\", width).attr(\"height\", height); // to properly transition intersection areas, we need the\n      // previous circles locations. load from elements\n\n      var previous = {},\n          hasPrevious = false;\n      svg.selectAll(\".venn-area path\").each(function (d) {\n        var path = d3Selection.select(this).attr(\"d\");\n\n        if (d.sets.length == 1 && path) {\n          hasPrevious = true;\n          previous[d.sets[0]] = circleFromPath(path);\n        }\n      }); // interpolate intersection area paths between previous and\n      // current paths\n\n      var pathTween = function (d) {\n        return function (t) {\n          var c = d.sets.map(function (set) {\n            var start = previous[set],\n                end = circles[set];\n\n            if (!start) {\n              start = {\n                x: width / 2,\n                y: height / 2,\n                radius: 1\n              };\n            }\n\n            if (!end) {\n              end = {\n                x: width / 2,\n                y: height / 2,\n                radius: 1\n              };\n            }\n\n            return {\n              'x': start.x * (1 - t) + end.x * t,\n              'y': start.y * (1 - t) + end.y * t,\n              'radius': start.radius * (1 - t) + end.radius * t\n            };\n          });\n          return intersectionAreaPath(c);\n        };\n      }; // update data, joining on the set ids\n\n\n      var nodes = svg.selectAll(\".venn-area\").data(data, function (d) {\n        return d.sets;\n      }); // create new nodes\n\n      var enter = nodes.enter().append('g').attr(\"class\", function (d) {\n        return \"venn-area venn-\" + (d.sets.length == 1 ? \"circle\" : \"intersection\");\n      }).attr(\"data-venn-sets\", function (d) {\n        return d.sets.join(\"_\");\n      });\n      var enterPath = enter.append(\"path\"),\n          enterText = enter.append(\"text\").attr(\"class\", \"label\").text(function (d) {\n        return label(d);\n      }).attr(\"text-anchor\", \"middle\").attr(\"dy\", \".35em\").attr(\"x\", width / 2).attr(\"y\", height / 2); // apply minimal style if wanted\n\n      if (styled) {\n        enterPath.style(\"fill-opacity\", \"0\").filter(function (d) {\n          return d.sets.length == 1;\n        }).style(\"fill\", function (d) {\n          return colours(d.sets);\n        }).style(\"fill-opacity\", \".25\");\n        enterText.style(\"fill\", function (d) {\n          return d.sets.length == 1 ? colours(d.sets) : \"#444\";\n        });\n      } // update existing, using pathTween if necessary\n\n\n      var update = selection;\n\n      if (hasPrevious) {\n        update = selection.transition(\"venn\").duration(duration);\n        update.selectAll(\"path\").attrTween(\"d\", pathTween);\n      } else {\n        update.selectAll(\"path\").attr(\"d\", function (d) {\n          return intersectionAreaPath(d.sets.map(function (set) {\n            return circles[set];\n          }));\n        });\n      }\n\n      var updateText = update.selectAll(\"text\").filter(function (d) {\n        return d.sets in textCentres;\n      }).text(function (d) {\n        return label(d);\n      }).attr(\"x\", function (d) {\n        return Math.floor(textCentres[d.sets].x);\n      }).attr(\"y\", function (d) {\n        return Math.floor(textCentres[d.sets].y);\n      });\n\n      if (wrap) {\n        if (hasPrevious) {\n          // d3 4.0 uses 'on' for events on transitions,\n          // but d3 3.0 used 'each' instead. switch appropiately\n          if ('on' in updateText) {\n            updateText.on(\"end\", wrapText(circles, label));\n          } else {\n            updateText.each(\"end\", wrapText(circles, label));\n          }\n        } else {\n          updateText.each(wrapText(circles, label));\n        }\n      } // remove old\n\n\n      var exit = nodes.exit().transition('venn').duration(duration).remove();\n      exit.selectAll(\"path\").attrTween(\"d\", pathTween);\n      var exitText = exit.selectAll(\"text\").attr(\"x\", width / 2).attr(\"y\", height / 2); // if we've been passed a fontSize explicitly, use it to\n      // transition\n\n      if (fontSize !== null) {\n        enterText.style(\"font-size\", \"0px\");\n        updateText.style(\"font-size\", fontSize);\n        exitText.style(\"font-size\", \"0px\");\n      }\n\n      return {\n        'circles': circles,\n        'textCentres': textCentres,\n        'nodes': nodes,\n        'enter': enter,\n        'update': update,\n        'exit': exit\n      };\n    }\n\n    chart.wrap = function (_) {\n      if (!arguments.length) return wrap;\n      wrap = _;\n      return chart;\n    };\n\n    chart.width = function (_) {\n      if (!arguments.length) return width;\n      width = _;\n      return chart;\n    };\n\n    chart.height = function (_) {\n      if (!arguments.length) return height;\n      height = _;\n      return chart;\n    };\n\n    chart.padding = function (_) {\n      if (!arguments.length) return padding;\n      padding = _;\n      return chart;\n    };\n\n    chart.colours = function (_) {\n      if (!arguments.length) return colours;\n      colours = _;\n      return chart;\n    };\n\n    chart.fontSize = function (_) {\n      if (!arguments.length) return fontSize;\n      fontSize = _;\n      return chart;\n    };\n\n    chart.duration = function (_) {\n      if (!arguments.length) return duration;\n      duration = _;\n      return chart;\n    };\n\n    chart.layoutFunction = function (_) {\n      if (!arguments.length) return layoutFunction;\n      layoutFunction = _;\n      return chart;\n    };\n\n    chart.normalize = function (_) {\n      if (!arguments.length) return normalize;\n      normalize = _;\n      return chart;\n    };\n\n    chart.styled = function (_) {\n      if (!arguments.length) return styled;\n      styled = _;\n      return chart;\n    };\n\n    chart.orientation = function (_) {\n      if (!arguments.length) return orientation;\n      orientation = _;\n      return chart;\n    };\n\n    chart.orientationOrder = function (_) {\n      if (!arguments.length) return orientationOrder;\n      orientationOrder = _;\n      return chart;\n    };\n\n    chart.lossFunction = function (_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n\n    return chart;\n  } // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n  // the text here such that it fits\n  // todo: looks like this might be merged into d3 (\n  // https://github.com/mbostock/d3/issues/1642),\n  // also worth checking out is\n  // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n  // this seems to be one of those things that should be easy but isn't\n\n\n  function wrapText(circles, labeller) {\n    return function () {\n      var text = d3Selection.select(this),\n          data = text.datum(),\n          width = circles[data.sets[0]].radius || 50,\n          label = labeller(data) || '';\n      var words = label.split(/\\s+/).reverse(),\n          maxLines = 3,\n          minChars = (label.length + words.length) / maxLines,\n          word = words.pop(),\n          line = [word],\n          joined,\n          lineNumber = 0,\n          lineHeight = 1.1,\n          // ems\n      tspan = text.text(null).append(\"tspan\").text(word);\n\n      while (true) {\n        word = words.pop();\n        if (!word) break;\n        line.push(word);\n        joined = line.join(\" \");\n        tspan.text(joined);\n\n        if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n          line.pop();\n          tspan.text(line.join(\" \"));\n          line = [word];\n          tspan = text.append(\"tspan\").text(word);\n          lineNumber++;\n        }\n      }\n\n      var initial = 0.35 - lineNumber * lineHeight / 2,\n          x = text.attr(\"x\"),\n          y = text.attr(\"y\");\n      text.selectAll(\"tspan\").attr(\"x\", x).attr(\"y\", y).attr(\"dy\", function (d, i) {\n        return initial + i * lineHeight + \"em\";\n      });\n    };\n  }\n\n  function circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current),\n        i,\n        m;\n\n    for (i = 1; i < interior.length; ++i) {\n      m = interior[i].radius - distance(interior[i], current);\n\n      if (m <= margin) {\n        margin = m;\n      }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n      m = distance(exterior[i], current) - exterior[i].radius;\n\n      if (m <= margin) {\n        margin = m;\n      }\n    }\n\n    return margin;\n  } // compute the center of some circles by maximizing the margin of\n  // the center point relative to the circles (interior) after subtracting\n  // nearby circles (exterior)\n\n\n  function computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [],\n        i;\n\n    for (i = 0; i < interior.length; ++i) {\n      var c = interior[i];\n      points.push({\n        x: c.x,\n        y: c.y\n      });\n      points.push({\n        x: c.x + c.radius / 2,\n        y: c.y\n      });\n      points.push({\n        x: c.x - c.radius / 2,\n        y: c.y\n      });\n      points.push({\n        x: c.x,\n        y: c.y + c.radius / 2\n      });\n      points.push({\n        x: c.x,\n        y: c.y - c.radius / 2\n      });\n    }\n\n    var initial = points[0],\n        margin = circleMargin(points[0], interior, exterior);\n\n    for (i = 1; i < points.length; ++i) {\n      var m = circleMargin(points[i], interior, exterior);\n\n      if (m >= margin) {\n        initial = points[i];\n        margin = m;\n      }\n    } // maximize the margin numerically\n\n\n    var solution = nelderMead(function (p) {\n      return -1 * circleMargin({\n        x: p[0],\n        y: p[1]\n      }, interior, exterior);\n    }, [initial.x, initial.y], {\n      maxIterations: 500,\n      minErrorDelta: 1e-10\n    }).x;\n    var ret = {\n      x: solution[0],\n      y: solution[1]\n    }; // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n\n    var valid = true;\n\n    for (i = 0; i < interior.length; ++i) {\n      if (distance(ret, interior[i]) > interior[i].radius) {\n        valid = false;\n        break;\n      }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n      if (distance(ret, exterior[i]) < exterior[i].radius) {\n        valid = false;\n        break;\n      }\n    }\n\n    if (!valid) {\n      if (interior.length == 1) {\n        ret = {\n          x: interior[0].x,\n          y: interior[0].y\n        };\n      } else {\n        var areaStats = {};\n        intersectionArea(interior, areaStats);\n\n        if (areaStats.arcs.length === 0) {\n          ret = {\n            'x': 0,\n            'y': -1000,\n            disjoint: true\n          };\n        } else if (areaStats.arcs.length == 1) {\n          ret = {\n            'x': areaStats.arcs[0].circle.x,\n            'y': areaStats.arcs[0].circle.y\n          };\n        } else if (exterior.length) {\n          // try again without other circles\n          ret = computeTextCentre(interior, []);\n        } else {\n          // take average of all the points in the intersection\n          // polygon. this should basically never happen\n          // and has some issues:\n          // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n          ret = getCenter(areaStats.arcs.map(function (a) {\n            return a.p1;\n          }));\n        }\n      }\n    }\n\n    return ret;\n  } // given a dictionary of {setid : circle}, returns\n  // a dictionary of setid to list of circles that completely overlap it\n\n\n  function getOverlappingCircles(circles) {\n    var ret = {},\n        circleids = [];\n\n    for (var circleid in circles) {\n      circleids.push(circleid);\n      ret[circleid] = [];\n    }\n\n    for (var i = 0; i < circleids.length; i++) {\n      var a = circles[circleids[i]];\n\n      for (var j = i + 1; j < circleids.length; ++j) {\n        var b = circles[circleids[j]],\n            d = distance(a, b);\n\n        if (d + b.radius <= a.radius + 1e-10) {\n          ret[circleids[j]].push(circleids[i]);\n        } else if (d + a.radius <= b.radius + 1e-10) {\n          ret[circleids[i]].push(circleids[j]);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  function computeTextCentres(circles, areas) {\n    var ret = {},\n        overlapped = getOverlappingCircles(circles);\n\n    for (var i = 0; i < areas.length; ++i) {\n      var area = areas[i].sets,\n          areaids = {},\n          exclude = {};\n\n      for (var j = 0; j < area.length; ++j) {\n        areaids[area[j]] = true;\n        var overlaps = overlapped[area[j]]; // keep track of any circles that overlap this area,\n        // and don't consider for purposes of computing the text\n        // centre\n\n        for (var k = 0; k < overlaps.length; ++k) {\n          exclude[overlaps[k]] = true;\n        }\n      }\n\n      var interior = [],\n          exterior = [];\n\n      for (var setid in circles) {\n        if (setid in areaids) {\n          interior.push(circles[setid]);\n        } else if (!(setid in exclude)) {\n          exterior.push(circles[setid]);\n        }\n      }\n\n      var centre = computeTextCentre(interior, exterior);\n      ret[area] = centre;\n\n      if (centre.disjoint && areas[i].size > 0) {\n        console.log(\"WARNING: area \" + area + \" not represented on screen\");\n      }\n    }\n\n    return ret;\n  } // sorts all areas in the venn diagram, so that\n  // a particular area is on top (relativeTo) - and\n  // all other areas are so that the smallest areas are on top\n\n\n  function sortAreas(div, relativeTo) {\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n      var check = relativeTo.sets[i];\n\n      for (var setid in overlaps) {\n        var overlap = overlaps[setid];\n\n        for (var j = 0; j < overlap.length; ++j) {\n          if (overlap[j] == check) {\n            exclude[setid] = true;\n            break;\n          }\n        }\n      }\n    } // checks that all sets are in exclude;\n\n\n    function shouldExclude(sets) {\n      for (var i = 0; i < sets.length; ++i) {\n        if (!(sets[i] in exclude)) {\n          return false;\n        }\n      }\n\n      return true;\n    } // need to sort div's so that Z order is correct\n\n\n    div.selectAll(\"g\").sort(function (a, b) {\n      // highest order set intersections first\n      if (a.sets.length != b.sets.length) {\n        return a.sets.length - b.sets.length;\n      }\n\n      if (a == relativeTo) {\n        return shouldExclude(b.sets) ? -1 : 1;\n      }\n\n      if (b == relativeTo) {\n        return shouldExclude(a.sets) ? 1 : -1;\n      } // finally by size\n\n\n      return b.size - a.size;\n    });\n  }\n\n  function circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r * 2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, -r * 2, 0);\n    return ret.join(\" \");\n  } // inverse of the circlePath function, returns a circle object from an svg path\n\n\n  function circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {\n      'x': parseFloat(tokens[1]),\n      'y': parseFloat(tokens[2]),\n      'radius': -parseFloat(tokens[4])\n    };\n  }\n  /** returns a svg path of the intersection area of a bunch of circles */\n\n\n  function intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n\n    if (arcs.length === 0) {\n      return \"M 0 0\";\n    } else if (arcs.length == 1) {\n      var circle = arcs[0].circle;\n      return circlePath(circle.x, circle.y, circle.radius);\n    } else {\n      // draw path around arcs\n      var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n\n      for (var i = 0; i < arcs.length; ++i) {\n        var arc = arcs[i],\n            r = arc.circle.radius,\n            wide = arc.width > r;\n        ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n      }\n\n      return ret.join(\" \");\n    }\n  }\n\n  exports.intersectionArea = intersectionArea;\n  exports.circleCircleIntersection = circleCircleIntersection;\n  exports.circleOverlap = circleOverlap;\n  exports.circleArea = circleArea;\n  exports.distance = distance;\n  exports.venn = venn;\n  exports.greedyLayout = greedyLayout;\n  exports.scaleSolution = scaleSolution;\n  exports.normalizeSolution = normalizeSolution;\n  exports.bestInitialLayout = bestInitialLayout;\n  exports.lossFunction = lossFunction;\n  exports.disjointCluster = disjointCluster;\n  exports.distanceFromIntersectArea = distanceFromIntersectArea;\n  exports.VennDiagram = VennDiagram;\n  exports.wrapText = wrapText;\n  exports.computeTextCentres = computeTextCentres;\n  exports.computeTextCentre = computeTextCentre;\n  exports.sortAreas = sortAreas;\n  exports.circlePath = circlePath;\n  exports.circleFromPath = circleFromPath;\n  exports.intersectionAreaPath = intersectionAreaPath;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n\n/***/ }),\n/* 401 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(360);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__select__ = __webpack_require__(379);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  return Object(__WEBPACK_IMPORTED_MODULE_1__select__[\"a\" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__creator__[\"a\" /* default */])(name).call(document.documentElement));\n});\n\n/***/ }),\n/* 402 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(372);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (select) {\n  if (typeof select !== \"function\") select = Object(__WEBPACK_IMPORTED_MODULE_1__selector__[\"a\" /* default */])(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](subgroups, this._parents);\n});\n\n/***/ }),\n/* 403 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selectorAll__ = __webpack_require__(380);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (select) {\n  if (typeof select !== \"function\") select = Object(__WEBPACK_IMPORTED_MODULE_1__selectorAll__[\"a\" /* default */])(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        subgroups.push(select.call(node, node.__data__, i, group));\n        parents.push(node);\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](subgroups, parents);\n});\n\n/***/ }),\n/* 404 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matcher__ = __webpack_require__(381);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (match) {\n  if (typeof match !== \"function\") match = Object(__WEBPACK_IMPORTED_MODULE_1__matcher__[\"a\" /* default */])(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](subgroups, this._parents);\n});\n\n/***/ }),\n/* 405 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__enter__ = __webpack_require__(382);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constant__ = __webpack_require__(406);\n\n\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length; // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__[\"a\" /* EnterNode */](parent, data[i]);\n    }\n  } // Put any non-null nodes that don’t fit into exit.\n\n\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue; // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  } // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n\n\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new __WEBPACK_IMPORTED_MODULE_1__enter__[\"a\" /* EnterNode */](parent, data[i]);\n    }\n  } // Add any remaining nodes that were not bound to data to exit.\n\n\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {\n      exit[i] = node;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function (d) {\n      data[++j] = d;\n    });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n  if (typeof value !== \"function\") value = Object(__WEBPACK_IMPORTED_MODULE_2__constant__[\"a\" /* default */])(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n});\n\n/***/ }),\n/* 406 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (x) {\n  return function () {\n    return x;\n  };\n});\n\n/***/ }),\n/* 407 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sparse__ = __webpack_require__(383);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(69);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return new __WEBPACK_IMPORTED_MODULE_1__index__[\"a\" /* Selection */](this._exit || this._groups.map(__WEBPACK_IMPORTED_MODULE_0__sparse__[\"a\" /* default */]), this._parents);\n});\n\n/***/ }),\n/* 408 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selection) {\n  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](merges, this._parents);\n});\n\n/***/ }),\n/* 409 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {\n    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n\n  return this;\n});\n\n/***/ }),\n/* 410 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(69);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (compare) {\n  if (!compare) compare = ascending;\n\n  function compareNode(a, b) {\n    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n  }\n\n  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        sortgroup[i] = node;\n      }\n    }\n\n    sortgroup.sort(compareNode);\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Selection */](sortgroups, this._parents).order();\n});\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\n/***/ }),\n/* 411 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n});\n\n/***/ }),\n/* 412 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var nodes = new Array(this.size()),\n      i = -1;\n  this.each(function () {\n    nodes[++i] = this;\n  });\n  return nodes;\n});\n\n/***/ }),\n/* 413 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n\n  return null;\n});\n\n/***/ }),\n/* 414 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var size = 0;\n  this.each(function () {\n    ++size;\n  });\n  return size;\n});\n\n/***/ }),\n/* 415 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return !this.node();\n});\n\n/***/ }),\n/* 416 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (callback) {\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) callback.call(node, node.__data__, i, group);\n    }\n  }\n\n  return this;\n});\n\n/***/ }),\n/* 417 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(370);\n\n\nfunction attrRemove(name) {\n  return function () {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function () {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, value) {\n  return function () {\n    this.setAttribute(name, value);\n  };\n}\n\nfunction attrConstantNS(fullname, value) {\n  return function () {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\n\nfunction attrFunction(name, value) {\n  return function () {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);\n  };\n}\n\nfunction attrFunctionNS(fullname, value) {\n  return function () {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0__namespace__[\"a\" /* default */])(name);\n\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);\n  }\n\n  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === \"function\" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));\n});\n\n/***/ }),\n/* 418 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction propertyRemove(name) {\n  return function () {\n    delete this[name];\n  };\n}\n\nfunction propertyConstant(name, value) {\n  return function () {\n    this[name] = value;\n  };\n}\n\nfunction propertyFunction(name, value) {\n  return function () {\n    var v = value.apply(this, arguments);\n    if (v == null) delete this[name];else this[name] = v;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === \"function\" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];\n});\n\n/***/ }),\n/* 419 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction classArray(string) {\n  return string.trim().split(/^|\\s+/);\n}\n\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\n\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\n\nClassList.prototype = {\n  add: function (name) {\n    var i = this._names.indexOf(name);\n\n    if (i < 0) {\n      this._names.push(name);\n\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function (name) {\n    var i = this._names.indexOf(name);\n\n    if (i >= 0) {\n      this._names.splice(i, 1);\n\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function (name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\n\nfunction classedAdd(node, names) {\n  var list = classList(node),\n      i = -1,\n      n = names.length;\n\n  while (++i < n) list.add(names[i]);\n}\n\nfunction classedRemove(node, names) {\n  var list = classList(node),\n      i = -1,\n      n = names.length;\n\n  while (++i < n) list.remove(names[i]);\n}\n\nfunction classedTrue(names) {\n  return function () {\n    classedAdd(this, names);\n  };\n}\n\nfunction classedFalse(names) {\n  return function () {\n    classedRemove(this, names);\n  };\n}\n\nfunction classedFunction(names, value) {\n  return function () {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  var names = classArray(name + \"\");\n\n  if (arguments.length < 2) {\n    var list = classList(this.node()),\n        i = -1,\n        n = names.length;\n\n    while (++i < n) if (!list.contains(names[i])) return false;\n\n    return true;\n  }\n\n  return this.each((typeof value === \"function\" ? classedFunction : value ? classedTrue : classedFalse)(names, value));\n});\n\n/***/ }),\n/* 420 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction textRemove() {\n  this.textContent = \"\";\n}\n\nfunction textConstant(value) {\n  return function () {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function () {\n    var v = value.apply(this, arguments);\n    this.textContent = v == null ? \"\" : v;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  return arguments.length ? this.each(value == null ? textRemove : (typeof value === \"function\" ? textFunction : textConstant)(value)) : this.node().textContent;\n});\n\n/***/ }),\n/* 421 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\n\nfunction htmlConstant(value) {\n  return function () {\n    this.innerHTML = value;\n  };\n}\n\nfunction htmlFunction(value) {\n  return function () {\n    var v = value.apply(this, arguments);\n    this.innerHTML = v == null ? \"\" : v;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === \"function\" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;\n});\n\n/***/ }),\n/* 422 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction raise() {\n  if (this.nextSibling) this.parentNode.appendChild(this);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return this.each(raise);\n});\n\n/***/ }),\n/* 423 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction lower() {\n  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return this.each(lower);\n});\n\n/***/ }),\n/* 424 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(360);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  var create = typeof name === \"function\" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__[\"a\" /* default */])(name);\n  return this.select(function () {\n    return this.appendChild(create.apply(this, arguments));\n  });\n});\n\n/***/ }),\n/* 425 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__creator__ = __webpack_require__(360);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__selector__ = __webpack_require__(372);\n\n\n\nfunction constantNull() {\n  return null;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, before) {\n  var create = typeof name === \"function\" ? name : Object(__WEBPACK_IMPORTED_MODULE_0__creator__[\"a\" /* default */])(name),\n      select = before == null ? constantNull : typeof before === \"function\" ? before : Object(__WEBPACK_IMPORTED_MODULE_1__selector__[\"a\" /* default */])(before);\n  return this.select(function () {\n    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);\n  });\n});\n\n/***/ }),\n/* 426 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return this.each(remove);\n});\n\n/***/ }),\n/* 427 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction selection_cloneShallow() {\n  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);\n}\n\nfunction selection_cloneDeep() {\n  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (deep) {\n  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);\n});\n\n/***/ }),\n/* 428 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  return arguments.length ? this.property(\"__data__\", value) : this.node().__data__;\n});\n\n/***/ }),\n/* 429 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__window__ = __webpack_require__(373);\n\n\nfunction dispatchEvent(node, type, params) {\n  var window = Object(__WEBPACK_IMPORTED_MODULE_0__window__[\"a\" /* default */])(node),\n      event = window.CustomEvent;\n\n  if (typeof event === \"function\") {\n    event = new event(type, params);\n  } else {\n    event = window.document.createEvent(\"Event\");\n    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);\n  }\n\n  node.dispatchEvent(event);\n}\n\nfunction dispatchConstant(type, params) {\n  return function () {\n    return dispatchEvent(this, type, params);\n  };\n}\n\nfunction dispatchFunction(type, params) {\n  return function () {\n    return dispatchEvent(this, type, params.apply(this, arguments));\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (type, params) {\n  return this.each((typeof params === \"function\" ? dispatchFunction : dispatchConstant)(type, params));\n});\n\n/***/ }),\n/* 430 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = local;\nvar nextId = 0;\nfunction local() {\n  return new Local();\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function (node) {\n    var id = this._;\n\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n\n    return node[id];\n  },\n  set: function (node, value) {\n    return node[this._] = value;\n  },\n  remove: function (node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function () {\n    return this._;\n  }\n};\n\n/***/ }),\n/* 431 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(375);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(361);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node) {\n  var event = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__[\"a\" /* default */])();\n  if (event.changedTouches) event = event.changedTouches[0];\n  return Object(__WEBPACK_IMPORTED_MODULE_1__point__[\"a\" /* default */])(node, event);\n});\n\n/***/ }),\n/* 432 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__selection_index__ = __webpack_require__(69);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (selector) {\n  return typeof selector === \"string\" ? new __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"a\" /* Selection */]([document.querySelectorAll(selector)], [document.documentElement]) : new __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"a\" /* Selection */]([selector == null ? [] : selector], __WEBPACK_IMPORTED_MODULE_0__selection_index__[\"c\" /* root */]);\n});\n\n/***/ }),\n/* 433 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(375);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(361);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node, touches, identifier) {\n  if (arguments.length < 3) identifier = touches, touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__[\"a\" /* default */])().changedTouches;\n\n  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {\n    if ((touch = touches[i]).identifier === identifier) {\n      return Object(__WEBPACK_IMPORTED_MODULE_1__point__[\"a\" /* default */])(node, touch);\n    }\n  }\n\n  return null;\n});\n\n/***/ }),\n/* 434 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sourceEvent__ = __webpack_require__(375);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__point__ = __webpack_require__(361);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node, touches) {\n  if (touches == null) touches = Object(__WEBPACK_IMPORTED_MODULE_0__sourceEvent__[\"a\" /* default */])().touches;\n\n  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {\n    points[i] = Object(__WEBPACK_IMPORTED_MODULE_1__point__[\"a\" /* default */])(node, touches[i]);\n  }\n\n  return points;\n});\n\n/***/ }),\n/* 435 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_selection_index__ = __webpack_require__(436);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_transition_index__ = __webpack_require__(169);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"transition\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_transition_index__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_active__ = __webpack_require__(457);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"active\", function() { return __WEBPACK_IMPORTED_MODULE_2__src_active__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_interrupt__ = __webpack_require__(385);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"interrupt\", function() { return __WEBPACK_IMPORTED_MODULE_3__src_interrupt__[\"a\"]; });\n\n\n\n\n\n/***/ }),\n/* 436 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__interrupt__ = __webpack_require__(437);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__transition__ = __webpack_require__(440);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selection\"].prototype.interrupt = __WEBPACK_IMPORTED_MODULE_1__interrupt__[\"a\" /* default */];\n__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selection\"].prototype.transition = __WEBPACK_IMPORTED_MODULE_2__transition__[\"a\" /* default */];\n\n/***/ }),\n/* 437 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__interrupt__ = __webpack_require__(385);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  return this.each(function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__interrupt__[\"a\" /* default */])(this, name);\n  });\n});\n\n/***/ }),\n/* 438 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_dispatch__ = __webpack_require__(439);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_dispatch__[\"a\"]; });\n\n\n/***/ }),\n/* 439 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar noop = {\n  value: function () {}\n};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || t in _) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function (t) {\n    var name = \"\",\n        i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {\n      type: t,\n      name: name\n    };\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function (typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length; // If no callback was specified, return the callback of the given type and name.\n\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n\n      return;\n    } // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n\n\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function () {\n    var copy = {},\n        _ = this._;\n\n    for (var t in _) copy[t] = _[t].slice();\n\n    return new Dispatch(copy);\n  },\n  call: function (type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function (type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n\n  if (callback != null) type.push({\n    name: name,\n    value: callback\n  });\n  return type;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (dispatch);\n\n/***/ }),\n/* 440 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_d3_ease__ = __webpack_require__(173);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_d3_timer__ = __webpack_require__(170);\n\n\n\n\nvar defaultTiming = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: __WEBPACK_IMPORTED_MODULE_2_d3_ease__[\"easeCubicInOut\"]\n};\n\nfunction inherit(node, id) {\n  var timing;\n\n  while (!(timing = node.__transition) || !(timing = timing[id])) {\n    if (!(node = node.parentNode)) {\n      return defaultTiming.time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__[\"now\"])(), defaultTiming;\n    }\n  }\n\n  return timing;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name) {\n  var id, timing;\n\n  if (name instanceof __WEBPACK_IMPORTED_MODULE_0__transition_index__[\"a\" /* Transition */]) {\n    id = name._id, name = name._name;\n  } else {\n    id = Object(__WEBPACK_IMPORTED_MODULE_0__transition_index__[\"c\" /* newId */])(), (timing = defaultTiming).time = Object(__WEBPACK_IMPORTED_MODULE_3_d3_timer__[\"now\"])(), name = name == null ? null : name + \"\";\n  }\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        Object(__WEBPACK_IMPORTED_MODULE_1__transition_schedule__[\"e\" /* default */])(node, name, id, i, group, timing || inherit(node, id));\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__transition_index__[\"a\" /* Transition */](groups, this._parents, name, id);\n});\n\n/***/ }),\n/* 441 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(117);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(362);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(386);\n\n\n\n\n\nfunction attrRemove(name) {\n  return function () {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function () {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, interpolate, value1) {\n  var value00, interpolate0;\n  return function () {\n    var value0 = this.getAttribute(name);\n    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);\n  };\n}\n\nfunction attrConstantNS(fullname, interpolate, value1) {\n  var value00, interpolate0;\n  return function () {\n    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);\n  };\n}\n\nfunction attrFunction(name, interpolate, value) {\n  var value00, value10, interpolate0;\n  return function () {\n    var value0,\n        value1 = value(this);\n    if (value1 == null) return void this.removeAttribute(name);\n    value0 = this.getAttribute(name);\n    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);\n  };\n}\n\nfunction attrFunctionNS(fullname, interpolate, value) {\n  var value00, value10, interpolate0;\n  return function () {\n    var value0,\n        value1 = value(this);\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  var fullname = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"namespace\"])(name),\n      i = fullname === \"transform\" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__[\"interpolateTransformSvg\"] : __WEBPACK_IMPORTED_MODULE_3__interpolate__[\"a\" /* default */];\n  return this.attrTween(name, typeof value === \"function\" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__[\"b\" /* tweenValue */])(this, \"attr.\" + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + \"\"));\n});\n\n/***/ }),\n/* 442 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n\n\nfunction attrTweenNS(fullname, value) {\n  function tween() {\n    var node = this,\n        i = value.apply(node, arguments);\n    return i && function (t) {\n      node.setAttributeNS(fullname.space, fullname.local, i(t));\n    };\n  }\n\n  tween._value = value;\n  return tween;\n}\n\nfunction attrTween(name, value) {\n  function tween() {\n    var node = this,\n        i = value.apply(node, arguments);\n    return i && function (t) {\n      node.setAttribute(name, i(t));\n    };\n  }\n\n  tween._value = value;\n  return tween;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error();\n  var fullname = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"namespace\"])(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n});\n\n/***/ }),\n/* 443 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(70);\n\n\nfunction delayFunction(id, value) {\n  return function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"g\" /* init */])(this, id).delay = +value.apply(this, arguments);\n  };\n}\n\nfunction delayConstant(id, value) {\n  return value = +value, function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"g\" /* init */])(this, id).delay = value;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  var id = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? delayFunction : delayConstant)(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(this.node(), id).delay;\n});\n\n/***/ }),\n/* 444 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(70);\n\n\nfunction durationFunction(id, value) {\n  return function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id).duration = +value.apply(this, arguments);\n  };\n}\n\nfunction durationConstant(id, value) {\n  return value = +value, function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id).duration = value;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  var id = this._id;\n  return arguments.length ? this.each((typeof value === \"function\" ? durationFunction : durationConstant)(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(this.node(), id).duration;\n});\n\n/***/ }),\n/* 445 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(70);\n\n\nfunction easeConstant(id, value) {\n  if (typeof value !== \"function\") throw new Error();\n  return function () {\n    Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */])(this, id).ease = value;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  var id = this._id;\n  return arguments.length ? this.each(easeConstant(id, value)) : Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(this.node(), id).ease;\n});\n\n/***/ }),\n/* 446 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(169);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (match) {\n  if (typeof match !== \"function\") match = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"matcher\"])(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_1__index__[\"a\" /* Transition */](subgroups, this._parents, this._name, this._id);\n});\n\n/***/ }),\n/* 447 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(169);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (transition) {\n  if (transition._id !== this._id) throw new Error();\n\n  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Transition */](merges, this._parents, this._name, this._id);\n});\n\n/***/ }),\n/* 448 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__schedule__ = __webpack_require__(70);\n\n\nfunction start(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function (t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\n\nfunction onFunction(id, name, listener) {\n  var on0,\n      on1,\n      sit = start(name) ? __WEBPACK_IMPORTED_MODULE_0__schedule__[\"g\" /* init */] : __WEBPACK_IMPORTED_MODULE_0__schedule__[\"h\" /* set */];\n  return function () {\n    var schedule = sit(this, id),\n        on = schedule.on; // If this node shared a dispatch with the previous node,\n    // just assign the updated shared dispatch and we’re done!\n    // Otherwise, copy-on-write.\n\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n    schedule.on = on1;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, listener) {\n  var id = this._id;\n  return arguments.length < 2 ? Object(__WEBPACK_IMPORTED_MODULE_0__schedule__[\"f\" /* get */])(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));\n});\n\n/***/ }),\n/* 449 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction removeFunction(id) {\n  return function () {\n    var parent = this.parentNode;\n\n    for (var i in this.__transition) if (+i !== id) return;\n\n    if (parent) parent.removeChild(this);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return this.on(\"end.remove\", removeFunction(this._id));\n});\n\n/***/ }),\n/* 450 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(70);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (select) {\n  var name = this._name,\n      id = this._id;\n  if (typeof select !== \"function\") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selector\"])(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        Object(__WEBPACK_IMPORTED_MODULE_2__schedule__[\"e\" /* default */])(subgroup[i], name, id, i, subgroup, Object(__WEBPACK_IMPORTED_MODULE_2__schedule__[\"f\" /* get */])(node, id));\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_1__index__[\"a\" /* Transition */](subgroups, this._parents, name, id);\n});\n\n/***/ }),\n/* 451 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__index__ = __webpack_require__(169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__schedule__ = __webpack_require__(70);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (select) {\n  var name = this._name,\n      id = this._id;\n  if (typeof select !== \"function\") select = Object(__WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selectorAll\"])(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(__WEBPACK_IMPORTED_MODULE_2__schedule__[\"f\" /* get */])(node, id), k = 0, l = children.length; k < l; ++k) {\n          if (child = children[k]) {\n            Object(__WEBPACK_IMPORTED_MODULE_2__schedule__[\"e\" /* default */])(child, name, id, k, children, inherit);\n          }\n        }\n\n        subgroups.push(children);\n        parents.push(node);\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_1__index__[\"a\" /* Transition */](subgroups, parents, name, id);\n});\n\n/***/ }),\n/* 452 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_selection__ = __webpack_require__(72);\n\nvar Selection = __WEBPACK_IMPORTED_MODULE_0_d3_selection__[\"selection\"].prototype.constructor;\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  return new Selection(this._groups, this._parents);\n});\n\n/***/ }),\n/* 453 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__ = __webpack_require__(117);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3_selection__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tween__ = __webpack_require__(362);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__interpolate__ = __webpack_require__(386);\n\n\n\n\n\nfunction styleRemove(name, interpolate) {\n  var value00, value10, interpolate0;\n  return function () {\n    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"style\"])(this, name),\n        value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"style\"])(this, name));\n    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);\n  };\n}\n\nfunction styleRemoveEnd(name) {\n  return function () {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, interpolate, value1) {\n  var value00, interpolate0;\n  return function () {\n    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"style\"])(this, name);\n    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);\n  };\n}\n\nfunction styleFunction(name, interpolate, value) {\n  var value00, value10, interpolate0;\n  return function () {\n    var value0 = Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"style\"])(this, name),\n        value1 = value(this);\n    if (value1 == null) value1 = (this.style.removeProperty(name), Object(__WEBPACK_IMPORTED_MODULE_1_d3_selection__[\"style\"])(this, name));\n    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? __WEBPACK_IMPORTED_MODULE_0_d3_interpolate__[\"interpolateTransformCss\"] : __WEBPACK_IMPORTED_MODULE_3__interpolate__[\"a\" /* default */];\n  return value == null ? this.styleTween(name, styleRemove(name, i)).on(\"end.style.\" + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === \"function\" ? styleFunction(name, i, Object(__WEBPACK_IMPORTED_MODULE_2__tween__[\"b\" /* tweenValue */])(this, \"style.\" + name, value)) : styleConstant(name, i, value + \"\"), priority);\n});\n\n/***/ }),\n/* 454 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction styleTween(name, value, priority) {\n  function tween() {\n    var node = this,\n        i = value.apply(node, arguments);\n    return i && function (t) {\n      node.style.setProperty(name, i(t), priority);\n    };\n  }\n\n  tween._value = value;\n  return tween;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error();\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n});\n\n/***/ }),\n/* 455 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tween__ = __webpack_require__(362);\n\n\nfunction textConstant(value) {\n  return function () {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function () {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (value) {\n  return this.tween(\"text\", typeof value === \"function\" ? textFunction(Object(__WEBPACK_IMPORTED_MODULE_0__tween__[\"b\" /* tweenValue */])(this, \"text\", value)) : textConstant(value == null ? \"\" : value + \"\"));\n});\n\n/***/ }),\n/* 456 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index__ = __webpack_require__(169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__schedule__ = __webpack_require__(70);\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (function () {\n  var name = this._name,\n      id0 = this._id,\n      id1 = Object(__WEBPACK_IMPORTED_MODULE_0__index__[\"c\" /* newId */])();\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit = Object(__WEBPACK_IMPORTED_MODULE_1__schedule__[\"f\" /* get */])(node, id0);\n        Object(__WEBPACK_IMPORTED_MODULE_1__schedule__[\"e\" /* default */])(node, name, id1, i, group, {\n          time: inherit.time + inherit.delay + inherit.duration,\n          delay: 0,\n          duration: inherit.duration,\n          ease: inherit.ease\n        });\n      }\n    }\n  }\n\n  return new __WEBPACK_IMPORTED_MODULE_0__index__[\"a\" /* Transition */](groups, this._parents, name, id1);\n});\n\n/***/ }),\n/* 457 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transition_index__ = __webpack_require__(169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transition_schedule__ = __webpack_require__(70);\n\n\nvar root = [null];\n/* harmony default export */ __webpack_exports__[\"a\"] = (function (node, name) {\n  var schedules = node.__transition,\n      schedule,\n      i;\n\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > __WEBPACK_IMPORTED_MODULE_1__transition_schedule__[\"c\" /* SCHEDULED */] && schedule.name === name) {\n        return new __WEBPACK_IMPORTED_MODULE_0__transition_index__[\"a\" /* Transition */]([[node]], root, name, +i);\n      }\n    }\n  }\n\n  return null;\n});\n\n/***/ }),\n/* 458 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview venn shapes\n * @author leungwensen@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nvar PathUtil = Util.PathUtil;\n\nfunction getAttrs(cfg) {\n  var defaultCfg = Global.shape.venn;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addFillAttrs(pathAttrs, cfg);\n  return pathAttrs;\n}\n\nfunction getHollowAttrs(cfg) {\n  var defaultCfg = Global.shape.hollowVenn;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);\n  return pathAttrs;\n} // register venn geom\n\n\nvar Venn = Shape.registerFactory('venn', {\n  defaultShapeType: 'venn',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    var points = [];\n    Util.each(pointInfo.x, function (subX, index) {\n      var subY = pointInfo.y[index];\n      points.push({\n        x: subX,\n        y: subY\n      });\n    });\n    return points;\n  },\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    var lineWidth = cfg.lineWidth || 1;\n\n    if (type === 'hollow') {\n      return {\n        lineWidth: lineWidth + 1\n      };\n    }\n\n    var opacity = cfg.fillOpacity || cfg.opacity || 1;\n    return {\n      // lineWidth,\n      fillOpacity: opacity - 0.08\n    };\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    if (cfg && cfg.style) {\n      return cfg.style;\n    }\n\n    return this.getActiveCfg(type, cfg);\n  }\n});\nShape.registerShape('venn', 'venn', {\n  draw: function draw(cfg, container) {\n    var origin = cfg.origin._origin;\n    var path = origin.path;\n    var attrs = getAttrs(cfg);\n    var segments = PathUtil.parsePathString(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: segments\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n});\nShape.registerShape('venn', 'hollow', {\n  draw: function draw(cfg, container) {\n    var origin = cfg.origin._origin;\n    var path = origin.path;\n    var attrs = getHollowAttrs(cfg);\n    var segments = PathUtil.parsePathString(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: segments\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n});\nmodule.exports = Venn;\n\n/***/ }),\n/* 459 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @fileOverview Venn Diagram\n * @author leungwensen@gmail.com\n */\nvar GeomBase = __webpack_require__(20);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = __webpack_require__(357);\n\n__webpack_require__(460);\n\nvar Violin =\n/*#__PURE__*/\nfunction (_GeomBase) {\n  _inheritsLoose(Violin, _GeomBase);\n\n  var _proto = Violin.prototype;\n\n  /**\n   * get default configuration\n   * @protected\n   * @return {Object} configuration\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _GeomBase.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'violin';\n    cfg.shapeType = 'violin';\n    cfg.generatePoints = true; // super.draw(data, container, shapeFactory, index);\n\n    return cfg;\n  };\n\n  function Violin(cfg) {\n    var _this;\n\n    _this = _GeomBase.call(this, cfg) || this;\n    Util.assign(_assertThisInitialized(_assertThisInitialized(_this)), SizeMixin);\n    return _this;\n  }\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var self = this;\n\n    var cfg = _GeomBase.prototype.createShapePointsCfg.call(this, obj);\n\n    cfg.size = self.getNormalizedSize(obj);\n    var sizeField = self.get('_sizeField');\n    cfg._size = obj._origin[sizeField];\n    return cfg;\n  };\n\n  _proto.clearInner = function clearInner() {\n    _GeomBase.prototype.clearInner.call(this);\n\n    this.set('defaultSize', null);\n  };\n\n  _proto._initAttrs = function _initAttrs() {\n    var self = this;\n    var attrOptions = self.get('attrOptions');\n    var sizeField = attrOptions.size ? attrOptions.size.field : self.get('_sizeField') ? self.get('_sizeField') : 'size';\n    self.set('_sizeField', sizeField);\n    delete attrOptions.size;\n\n    _GeomBase.prototype._initAttrs.call(this);\n  };\n\n  return Violin;\n}(GeomBase);\n\nvar ViolinDodge =\n/*#__PURE__*/\nfunction (_Violin) {\n  _inheritsLoose(ViolinDodge, _Violin);\n\n  function ViolinDodge() {\n    return _Violin.apply(this, arguments) || this;\n  }\n\n  var _proto2 = ViolinDodge.prototype;\n\n  _proto2.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Violin.prototype.getDefaultCfg.call(this);\n\n    cfg.hasDefaultAdjust = true;\n    cfg.adjusts = [{\n      type: 'dodge'\n    }];\n    return cfg;\n  };\n\n  return ViolinDodge;\n}(Violin);\n\nViolin.Dodge = ViolinDodge;\nGeomBase.Violin = Violin;\nGeomBase.ViolinDodge = ViolinDodge;\nmodule.exports = Violin;\n\n/***/ }),\n/* 460 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview venn shapes\n * @author leungwensen@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(18);\n\nvar ShapeUtil = __webpack_require__(45);\n\nvar Global = __webpack_require__(7);\n\nvar PathUtil = __webpack_require__(22);\n\nfunction getAttrs(cfg) {\n  var defaultCfg = Global.shape.venn;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addFillAttrs(pathAttrs, cfg);\n\n  if (cfg.color) {\n    pathAttrs.stroke = pathAttrs.stroke || cfg.color;\n  }\n\n  return pathAttrs;\n}\n\nfunction getHollowAttrs(cfg) {\n  var defaultCfg = Global.shape.hollowVenn;\n  var pathAttrs = Util.mix({}, defaultCfg, cfg.style);\n  ShapeUtil.addStrokeAttrs(pathAttrs, cfg);\n  return pathAttrs;\n}\n\nfunction getViolinPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (point) {\n      var action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  var first = points[0];\n\n  if (first) {\n    path.push(['L', first.x, first.y]);\n    path.push(['z']);\n  }\n\n  return path;\n}\n\nfunction getSmoothViolinPath(points) {\n  var half = points.length / 2;\n  var leftPoints = [];\n  var rightPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    if (i < half) {\n      leftPoints.push(points[i]);\n    } else {\n      rightPoints.push(points[i]);\n    }\n  }\n\n  var leftPath = PathUtil.getSplinePath(leftPoints, false);\n  var rightPath = PathUtil.getSplinePath(rightPoints, false);\n  leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);\n  rightPath.shift();\n  var path = leftPath.concat(rightPath);\n  path.push(['L', leftPoints[0].x, leftPoints[0].y]);\n  path.push(['z']);\n  return path;\n}\n\nfunction normalizeSize(arr) {\n  var max = Math.max.apply(null, arr);\n  return arr.map(function (num) {\n    return num / max;\n  });\n} // register violin geom shape\n\n\nvar Violin = Shape.registerFactory('violin', {\n  defaultShapeType: 'violin',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    var radius = pointInfo.size / 2;\n    var points = [];\n    var sizeArr = normalizeSize(pointInfo._size);\n    Util.each(pointInfo.y, function (y, index) {\n      var offset = sizeArr[index] * radius;\n      var isMin = index === 0;\n      var isMax = index === pointInfo.y.length - 1;\n      points.push({\n        isMin: isMin,\n        isMax: isMax,\n        x: pointInfo.x - offset,\n        y: y\n      });\n      points.unshift({\n        isMin: isMin,\n        isMax: isMax,\n        x: pointInfo.x + offset,\n        y: y\n      });\n    });\n    return points;\n  },\n  getActiveCfg: function getActiveCfg(type, cfg) {\n    var lineWidth = cfg.lineWidth || 1;\n\n    if (type === 'hollow') {\n      return {\n        lineWidth: lineWidth + 1\n      };\n    }\n\n    var opacity = cfg.fillOpacity || cfg.opacity || 1;\n    return {\n      // lineWidth,\n      fillOpacity: opacity - 0.08\n    };\n  },\n  getSelectedCfg: function getSelectedCfg(type, cfg) {\n    if (cfg && cfg.style) {\n      return cfg.style;\n    }\n\n    return this.getActiveCfg(type, cfg);\n  }\n}); // normal violin, filled path\n\nShape.registerShape('violin', 'violin', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getViolinPath(cfg.points);\n    path = this.parsePath(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n}); // smooth spline violin, filled path\n\nShape.registerShape('violin', 'smooth', {\n  draw: function draw(cfg, container) {\n    var attrs = getAttrs(cfg);\n    var path = getSmoothViolinPath(cfg.points);\n    path = this.parsePath(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getAttrs(cfg));\n  }\n}); // hollow violin, stroked path\n\nShape.registerShape('violin', 'hollow', {\n  draw: function draw(cfg, container) {\n    var attrs = getHollowAttrs(cfg);\n    var path = getViolinPath(cfg.points);\n    path = this.parsePath(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getHollowAttrs(cfg));\n  }\n}); // hollow smooth spline violin, stroked path\n\nShape.registerShape('violin', 'smoothHollow', {\n  draw: function draw(cfg, container) {\n    var attrs = getHollowAttrs(cfg);\n    var path = getSmoothViolinPath(cfg.points);\n    path = this.parsePath(path);\n    var pathShape = container.addShape('path', {\n      attrs: Util.mix(attrs, {\n        path: path\n      })\n    });\n    return pathShape;\n  },\n  getMarkerCfg: function getMarkerCfg(cfg) {\n    return Util.mix({\n      symbol: 'circle',\n      radius: 4\n    }, getHollowAttrs(cfg));\n  }\n});\nmodule.exports = Violin;\n\n/***/ }),\n/* 461 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Facet 的入口\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Chart = __webpack_require__(147);\n\nvar Facets = {};\nFacets.Rect = __webpack_require__(387);\nFacets.List = __webpack_require__(388);\nFacets.Circle = __webpack_require__(462);\nFacets.Tree = __webpack_require__(463);\nFacets.Mirror = __webpack_require__(464);\nFacets.Matrix = __webpack_require__(465);\n\nChart.prototype.facet = function (type, cfg) {\n  var cls = Facets[Util.upperFirst(type)];\n\n  if (!cls) {\n    throw new Error('Not support such type of facets as: ' + type);\n  }\n\n  var preFacets = this.get('facets');\n\n  if (preFacets) {\n    preFacets.destroy();\n  }\n\n  cfg.chart = this;\n  var facets = new cls(cfg);\n  this.set('facets', facets);\n};\n\nmodule.exports = Facets;\n\n/***/ }),\n/* 462 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview circle facets\n * @author dxq613@gmail.com\n */\nvar Base = __webpack_require__(363);\n\nfunction getPoint(center, r, angle) {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle)\n  };\n}\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Circle, _Base);\n\n  function Circle() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Circle.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'circle';\n    return cfg;\n  };\n\n  _proto.getRegion = function getRegion(count, index) {\n    var r = 1 / 2; // 画布半径\n\n    var avgAngle = Math.PI * 2 / count;\n    var angle = -1 * Math.PI / 2 + avgAngle * index; // 当前分面所在的弧度\n\n    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));\n    var center = {\n      x: 0.5,\n      y: 0.5\n    }; // 画布圆心\n\n    var middle = getPoint(center, r - facetR, angle); // 分面的中心点\n\n    var startAngle = Math.PI * 5 / 4; // 右上角\n\n    var endAngle = Math.PI * 1 / 4; // 左下角\n\n    return {\n      start: getPoint(middle, facetR, startAngle),\n      end: getPoint(middle, facetR, endAngle)\n    };\n  };\n\n  _proto.generateFacets = function generateFacets(data) {\n    var self = this;\n    var fields = self.fields;\n    var field = fields[0];\n\n    if (!field) {\n      throw 'Please specify for the field for facet!';\n    }\n\n    var values = self.getFieldValues(field, data);\n    var count = values.length;\n    var rst = [];\n    values.forEach(function (value, index) {\n      var conditions = [{\n        field: field,\n        value: value,\n        values: values\n      }];\n      var filter = self.getFilter(conditions);\n      var subData = data.filter(filter);\n      var facet = {\n        type: self.type,\n        colValue: value,\n        colField: field,\n        colIndex: index,\n        cols: count,\n        rows: 1,\n        rowIndex: 0,\n        data: subData,\n        region: self.getRegion(count, index)\n      };\n      rst.push(facet);\n    });\n    return rst;\n  };\n\n  return Circle;\n}(Base);\n\nmodule.exports = Circle;\n\n/***/ }),\n/* 463 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview tree facets\n * @author dxq613@gmail.com\n */\nvar Base = __webpack_require__(363);\n\nvar Util = __webpack_require__(0);\n\nvar assign = Util.assign;\n\nvar Tree =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Tree, _Base);\n\n  function Tree() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Tree.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Base.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'tree';\n    cfg.line = {\n      lineWidth: 1,\n      stroke: '#ddd'\n    };\n    cfg.lineSmooth = false;\n    return cfg;\n  };\n\n  _proto.generateFacets = function generateFacets(data) {\n    var self = this;\n    var fields = self.fields;\n\n    if (!fields.length) {\n      throw 'Please specify for the fields for facet!';\n    }\n\n    var rst = [];\n    var root = self.getRootFacet(data); // if (self.showRoot) {\n\n    rst.push(root); // }\n\n    root.children = self.getChildFacets(data, 1, rst);\n    self.setRegion(rst);\n    return rst;\n  };\n\n  _proto.getRootFacet = function getRootFacet(data) {\n    var self = this;\n    var facet = {\n      type: self.type,\n      rows: self.getRows(),\n      rowIndex: 0,\n      colIndex: 0,\n      colValue: self.rootTitle,\n      data: data\n    };\n    return facet;\n  };\n\n  _proto.getRows = function getRows() {\n    return this.fields.length + 1;\n  }; // get child\n\n\n  _proto.getChildFacets = function getChildFacets(data, level, arr) {\n    var self = this;\n    var fields = self.fields;\n    var length = fields.length;\n\n    if (length < level) {\n      return;\n    }\n\n    var rst = [];\n    var field = fields[level - 1];\n    var values = self.getFieldValues(field, data);\n    values.forEach(function (value, index) {\n      var conditions = [{\n        field: field,\n        value: value,\n        values: values\n      }];\n      var filter = self.getFilter(conditions);\n      var subData = data.filter(filter);\n\n      if (subData.length) {\n        var facet = {\n          type: self.type,\n          colValue: value,\n          colField: field,\n          colIndex: index,\n          rows: self.getRows(),\n          rowIndex: level,\n          data: subData,\n          children: self.getChildFacets(subData, level + 1, arr)\n        };\n        rst.push(facet);\n        arr.push(facet);\n      }\n    });\n    return rst;\n  }; // 设置 region\n\n\n  _proto.setRegion = function setRegion(facets) {\n    var self = this;\n    self.forceColIndex(facets);\n    facets.forEach(function (facet) {\n      facet.region = self.getRegion(facet.rows, facet.cols, facet.colIndex, facet.rowIndex);\n    });\n  }; // set column index of facets\n\n\n  _proto.forceColIndex = function forceColIndex(facets) {\n    var self = this;\n    var leafs = [];\n    var index = 0;\n    facets.forEach(function (facet) {\n      if (self.isLeaf(facet)) {\n        leafs.push(facet);\n        facet.colIndex = index;\n        index++;\n      }\n    });\n    leafs.forEach(function (facet) {\n      facet.cols = leafs.length;\n    });\n    var maxLevel = self.fields.length;\n\n    for (var i = maxLevel - 1; i >= 0; i--) {\n      var levelFacets = self.getFacetsByLevel(facets, i); // var yIndex = maxLevel - i;\n\n      for (var j = 0; j < levelFacets.length; j++) {\n        var facet = levelFacets[j];\n\n        if (!self.isLeaf(facet)) {\n          facet.originColIndex = facet.colIndex;\n          facet.colIndex = self.getRegionIndex(facet.children);\n          facet.cols = leafs.length;\n        }\n      }\n    }\n  }; // get facet use level\n\n\n  _proto.getFacetsByLevel = function getFacetsByLevel(facets, level) {\n    var rst = [];\n    facets.forEach(function (facet) {\n      if (facet.rowIndex === level) {\n        rst.push(facet);\n      }\n    });\n    return rst;\n  }; // set facets region\n\n\n  _proto.getRegion = function getRegion(rows, cols, xIndex, yIndex) {\n    var xWidth = 1 / cols; // x轴方向的每个分面的偏移\n\n    var yWidth = 1 / rows; // y轴方向的每个分面的偏移\n\n    var start = {\n      x: xWidth * xIndex,\n      y: yWidth * yIndex\n    };\n    var end = {\n      x: start.x + xWidth,\n      y: start.y + yWidth * 2 / 3 // 预留1/3的空隙，方便添加连接线\n\n    };\n    return {\n      start: start,\n      end: end\n    };\n  }; // if the facet has children , make it's column index in the middle of it's children\n\n\n  _proto.getRegionIndex = function getRegionIndex(children) {\n    var first = children[0];\n    var last = children[children.length - 1];\n    return (last.colIndex - first.colIndex) / 2 + first.colIndex;\n  }; // is  a leaf without children\n\n\n  _proto.isLeaf = function isLeaf(facet) {\n    return !facet.children || !facet.children.length;\n  };\n\n  _proto.setXAxis = function setXAxis(xField, axes, facet) {\n    // 当是最后一行或者下面没有 view 时文本不显示\n    if (facet.rowIndex !== facet.rows - 1) {\n      axes[xField].label = null;\n      axes[xField].title = null;\n    }\n  }; // 设置 y 坐标轴的文本、title 是否显示\n\n\n  _proto.setYAxis = function setYAxis(yField, axes, facet) {\n    if (facet.originColIndex !== 0 && facet.colIndex !== 0) {\n      axes[yField].title = null;\n      axes[yField].label = null;\n    }\n  }; // 绘制完成后\n\n\n  _proto.onPaint = function onPaint() {\n    _Base.prototype.onPaint.call(this);\n\n    this.group.clear();\n\n    if (this.facets && this.line) {\n      this.drawLines(this.facets, this.group);\n    }\n  };\n\n  _proto.drawLines = function drawLines(facets, group) {\n    var self = this;\n    var lineGroup = group.addGroup();\n    facets.forEach(function (facet) {\n      if (!self.isLeaf(facet)) {\n        var children = facet.children;\n\n        self._addFacetLines(facet, children, lineGroup);\n      }\n    });\n  }; // add lines with it's children\n\n\n  _proto._addFacetLines = function _addFacetLines(facet, children, group) {\n    var self = this;\n    var view = facet.view;\n    var region = view.getViewRegion();\n    var start = {\n      x: region.start.x + (region.end.x - region.start.x) / 2,\n      y: region.start.y\n    };\n    children.forEach(function (subFacet) {\n      var subRegion = subFacet.view.getViewRegion();\n      var end = {\n        x: subRegion.start.x + (subRegion.end.x - subRegion.start.x) / 2,\n        y: subRegion.end.y\n      };\n      var middle1 = {\n        x: start.x,\n        y: start.y + (end.y - start.y) / 2\n      };\n      var middle2 = {\n        x: end.x,\n        y: middle1.y\n      };\n\n      self._drawLine([start, middle1, middle2, end], group);\n    });\n  };\n\n  _proto._getPath = function _getPath(points) {\n    var self = this;\n    var path = [];\n    var smooth = self.lineSmooth;\n\n    if (smooth) {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    } else {\n      points.forEach(function (point, index) {\n        if (index === 0) {\n          path.push(['M', point.x, point.y]);\n        } else {\n          path.push(['L', point.x, point.y]);\n        }\n      });\n    }\n\n    return path;\n  }; // draw line width points\n\n\n  _proto._drawLine = function _drawLine(points, group) {\n    var self = this;\n\n    var path = self._getPath(points);\n\n    var line = self.line;\n    group.addShape('path', {\n      attrs: assign({\n        path: path\n      }, line)\n    });\n  };\n\n  return Tree;\n}(Base);\n\nmodule.exports = Tree;\n\n/***/ }),\n/* 464 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview mirror facets\n * @author dxq613@gmail.com\n */\nvar List = __webpack_require__(388);\n\nvar Mirror =\n/*#__PURE__*/\nfunction (_List) {\n  _inheritsLoose(Mirror, _List);\n\n  function Mirror() {\n    return _List.apply(this, arguments) || this;\n  }\n\n  var _proto = Mirror.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _List.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'mirror';\n    this.transpose = false;\n    return cfg;\n  };\n\n  _proto.init = function init() {\n    var self = this;\n\n    if (self.transpose) {\n      self.cols = 2;\n      self.rows = 1;\n    } else {\n      self.cols = 1;\n      self.rows = 2;\n    }\n\n    _List.prototype.init.call(this);\n  };\n\n  _proto.beforeProcessView = function beforeProcessView(view, facet) {\n    if (this.transpose) {\n      if (facet.colIndex % 2 === 0) {\n        view.coord().transpose().scale(-1, 1);\n      } else {\n        view.coord().transpose();\n      }\n    } else {\n      if (facet.rowIndex % 2 !== 0) {\n        view.coord().scale(1, -1);\n      }\n    }\n  };\n\n  _proto.renderTitle = function renderTitle(view, facet) {\n    if (this.transpose) {\n      this.drawColTitle(view, facet);\n    } else {\n      this.drawRowTitle(view, facet);\n    }\n  };\n\n  _proto.setXAxis = function setXAxis(xField, axes, facet) {\n    // 当是最后一行或者下面没有 view 时文本不显示\n    if (facet.colIndex === 1 || facet.rowIndex === 1) {\n      axes[xField].label = null;\n      axes[xField].title = null;\n    }\n  };\n\n  _proto.setYAxis = function setYAxis()\n  /* yField, axes, facet */\n  {};\n\n  return Mirror;\n}(List);\n\nmodule.exports = Mirror;\n\n/***/ }),\n/* 465 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview Use matrices to compare different fields\n * @author dxq613@gmail.com\n */\nvar Rect = __webpack_require__(387);\n\nvar Matrix =\n/*#__PURE__*/\nfunction (_Rect) {\n  _inheritsLoose(Matrix, _Rect);\n\n  function Matrix() {\n    return _Rect.apply(this, arguments) || this;\n  }\n\n  var _proto = Matrix.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Rect.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'matrix';\n    cfg.showTitle = false;\n    return cfg;\n  };\n\n  _proto.generateFacets = function generateFacets(data) {\n    var self = this;\n    var fields = self.fields;\n    var rows = fields.length;\n    var cols = rows; // 矩阵中行列相等，等于指定的字段个数\n\n    var rst = [];\n\n    for (var i = 0; i < cols; i++) {\n      var colField = fields[i];\n\n      for (var j = 0; j < rows; j++) {\n        var rowField = fields[j];\n        var facet = {\n          type: self.type,\n          colValue: colField,\n          rowValue: rowField,\n          colField: colField,\n          rowField: rowField,\n          colIndex: i,\n          rowIndex: j,\n          cols: cols,\n          rows: rows,\n          data: data,\n          region: self.getRegion(rows, cols, i, j)\n        };\n        rst.push(facet);\n      }\n    }\n\n    return rst;\n  }; // 设置 x 坐标轴的文本、title 是否显示\n\n\n  _proto.setXAxis = function setXAxis(xField, axes, facet) {\n    if (facet.rowIndex !== facet.rows - 1) {\n      axes[xField].title = null;\n      axes[xField].label = null;\n    }\n  }; // 设置 y 坐标轴的文本、title 是否显示\n\n\n  _proto.setYAxis = function setYAxis(yField, axes, facet) {\n    if (facet.colIndex !== 0) {\n      axes[yField].title = null;\n      axes[yField].label = null;\n    }\n  };\n\n  return Matrix;\n}(Rect);\n\nmodule.exports = Matrix;\n\n/***/ }),\n/* 466 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Interaction\n * @author leungwensen@gmail.com\n */\nvar G2 = __webpack_require__(172);\n\nvar Chart = __webpack_require__(147);\n\nvar Util = __webpack_require__(0);\n\nvar Interactions = {\n  Base: __webpack_require__(171),\n  Brush: __webpack_require__(467),\n  Drag: __webpack_require__(468),\n  ScrollBar: __webpack_require__(470),\n  ShapeSelect: __webpack_require__(472),\n  Slider: __webpack_require__(473),\n  Zoom: __webpack_require__(475)\n};\nG2._Interactions = {};\n\nG2.registerInteraction = function (type, constructor) {\n  G2._Interactions[type] = constructor;\n};\n\nG2.getInteraction = function (type) {\n  return G2._Interactions[type];\n}; // binding on View\n\n\nChart.prototype.getInteractions = function () {\n  var me = this;\n\n  if (!me._interactions) {\n    me._interactions = {};\n  }\n\n  return me._interactions;\n};\n\nChart.prototype._setInteraction = function (type, interaction) {\n  var me = this;\n  var interactions = me.getInteractions();\n\n  if (interactions[type] && interactions[type] !== interaction) {\n    // only one interaction for a key\n    interactions[type].destroy();\n  }\n\n  interactions[type] = interaction;\n};\n\nChart.prototype.clearInteraction = function (type) {\n  var me = this;\n  var interactions = me.getInteractions();\n\n  if (type) {\n    if (interactions[type]) {\n      interactions[type]._reset();\n\n      interactions[type].destroy();\n    }\n\n    delete interactions[type];\n  } else {\n    Util.each(interactions, function (interaction, key) {\n      interaction._reset();\n\n      interaction.destroy();\n      delete interactions[key];\n    });\n  }\n};\n\nChart.prototype.interact = Chart.prototype.interaction = function (type, cfg) {\n  var me = this;\n  var Ctor = G2.getInteraction(type);\n  var interaction = new Ctor(cfg, me);\n\n  me._setInteraction(type, interaction);\n\n  return me;\n};\n\nG2.registerInteraction('brush', Interactions.Brush);\nG2.registerInteraction('Brush', Interactions.Brush);\nG2.registerInteraction('drag', Interactions.Drag);\nG2.registerInteraction('Drag', Interactions.Drag);\nG2.registerInteraction('zoom', Interactions.Zoom);\nG2.registerInteraction('Zoom', Interactions.Zoom);\nG2.registerInteraction('scroll-bar', Interactions.ScrollBar);\nG2.registerInteraction('ScrollBar', Interactions.ScrollBar);\nG2.registerInteraction('shape-select', Interactions.ShapeSelect);\nG2.registerInteraction('ShapeSelect', Interactions.ShapeSelect);\nG2.registerInteraction('slider', Interactions.Slider);\nG2.registerInteraction('Slider', Interactions.Slider);\nmodule.exports = Interactions;\n\n/***/ }),\n/* 467 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Util = __webpack_require__(0);\n\nvar Interaction = __webpack_require__(171); // const G2 = require('../core.js');\n\n\nvar BRUSH_TYPES = ['X', 'Y', 'XY', 'POLYGON'];\nvar DEFAULT_TYPE = 'XY';\n\nvar Brush =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(Brush, _Interaction);\n\n  var _proto = Brush.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      type: DEFAULT_TYPE,\n      startPoint: null,\n      brushing: false,\n      dragging: false,\n      brushShape: null,\n      container: null,\n      polygonPath: null,\n      style: {\n        fill: '#C5D4EB',\n        opacity: 0.3,\n        lineWidth: 1,\n        stroke: '#82A6DD'\n      },\n      draggable: false,\n      dragOffX: 0,\n      dragOffY: 0,\n      inPlot: true,\n      xField: null,\n      yField: null\n    });\n  };\n\n  function Brush(cfg, view) {\n    var _this;\n\n    _this = _Interaction.call(this, cfg, view) || this;\n\n    var me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    me.filter = !me.draggable;\n    me.type = me.type.toUpperCase();\n    me.chart = view;\n\n    if (BRUSH_TYPES.indexOf(me.type) === -1) {\n      me.type = DEFAULT_TYPE;\n    }\n\n    var canvas = me.canvas;\n\n    if (canvas) {\n      var plotRange;\n      canvas.get('children').map(function (child) {\n        if (child.get('type') === 'plotBack') {\n          plotRange = child.get('plotRange');\n          return false;\n        }\n\n        return child;\n      });\n      me.plot = {\n        start: plotRange.bl,\n        end: plotRange.tr\n      };\n    }\n\n    if (view) {\n      var coord = view.get('coord');\n      me.plot = {\n        start: coord.start,\n        end: coord.end\n      };\n\n      var xScales = view._getScales('x');\n\n      var yScales = view._getScales('y');\n\n      me.xScale = me.xField ? xScales[me.xField] : view.getXScale();\n      me.yScale = me.yField ? yScales[me.yField] : view.getYScales()[0];\n    }\n\n    return _this;\n  } // onBurshstart() { }\n  // onBrushmove() { }\n  // onBrushend() {}\n  // onDragstart() {}\n  // onDragmove() {}\n  // onDragend() {}\n\n\n  _proto.start = function start(ev) {\n    var me = this;\n    var canvas = me.canvas,\n        type = me.type,\n        brushShape = me.brushShape;\n    if (!type) return;\n    var startPoint = {\n      x: ev.offsetX,\n      y: ev.offsetY\n    };\n    if (!startPoint.x) return;\n    var isInPlot = me.plot && me.inPlot;\n    var canvasDOM = canvas.get('canvasDOM');\n    var pixelRatio = canvas.get('pixelRatio');\n    if (me.selection) me.selection = null;\n\n    if (me.draggable && brushShape && !brushShape.get('destroyed')) {\n      // allow drag the brushShape\n      if (brushShape.isHit(startPoint.x * pixelRatio, startPoint.y * pixelRatio)) {\n        canvasDOM.style.cursor = 'move';\n        me.selection = brushShape;\n        me.dragging = true;\n\n        if (type === 'X') {\n          me.dragoffX = startPoint.x - brushShape.attr('x');\n          me.dragoffY = 0;\n        } else if (type === 'Y') {\n          me.dragoffX = 0;\n          me.dragoffY = startPoint.y - brushShape.attr('y');\n        } else if (type === 'XY') {\n          me.dragoffX = startPoint.x - brushShape.attr('x');\n          me.dragoffY = startPoint.y - brushShape.attr('y');\n        } else if (type === 'POLYGON') {\n          var box = brushShape.getBBox();\n          me.dragoffX = startPoint.x - box.minX;\n          me.dragoffY = startPoint.y - box.minY;\n        }\n\n        if (isInPlot) {// me.selection.attr('clip', canvas.addShape('rect', {\n          //   attrs: {\n          //     x: this.plot.start.x,\n          //     y: this.plot.end.y,\n          //     width: this.plot.end.x - this.plot.start.x,\n          //     height: this.plot.start.y - this.plot.end.y,\n          //     fill: '#fff',\n          //     fillOpacity: 0\n          //   }\n          // }));\n        }\n\n        me.onDragstart && me.onDragstart(ev);\n      }\n\n      me.prePoint = startPoint;\n    }\n\n    if (!me.dragging) {\n      // brush start\n      me.onBrushstart && me.onBrushstart(startPoint);\n      var container = me.container;\n\n      if (isInPlot) {\n        var _me$plot = me.plot,\n            start = _me$plot.start,\n            end = _me$plot.end;\n        if (startPoint.x < start.x || startPoint.x > end.x || startPoint.y < end.y || startPoint.y > start.y) return;\n      }\n\n      canvasDOM.style.cursor = 'crosshair';\n      me.startPoint = startPoint;\n      me.brushShape = null;\n      me.brushing = true;\n\n      if (!container) {\n        container = canvas.addGroup({\n          zIndex: 5 // upper\n\n        });\n        container.initTransform();\n      } else {\n        container.clear();\n      }\n\n      me.container = container;\n      if (type === 'POLYGON') me.polygonPath = \"M \" + startPoint.x + \" \" + startPoint.y;\n    }\n  };\n\n  _proto.process = function process(ev) {\n    var me = this;\n    var brushing = me.brushing,\n        dragging = me.dragging,\n        type = me.type,\n        plot = me.plot,\n        startPoint = me.startPoint,\n        xScale = me.xScale,\n        yScale = me.yScale,\n        canvas = me.canvas;\n\n    if (!brushing && !dragging) {\n      return;\n    }\n\n    var currentPoint = {\n      x: ev.offsetX,\n      y: ev.offsetY\n    };\n    var canvasDOM = canvas.get('canvasDOM');\n\n    if (brushing) {\n      canvasDOM.style.cursor = 'crosshair';\n      var start = plot.start,\n          end = plot.end;\n      var polygonPath = me.polygonPath;\n      var brushShape = me.brushShape;\n      var container = me.container;\n\n      if (me.plot && me.inPlot) {\n        currentPoint = me._limitCoordScope(currentPoint);\n      }\n\n      var rectStartX;\n      var rectStartY;\n      var rectWidth;\n      var rectHeight;\n\n      if (type === 'Y') {\n        rectStartX = start.x;\n        rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n        rectWidth = Math.abs(start.x - end.x);\n        rectHeight = Math.abs(startPoint.y - currentPoint.y);\n      } else if (type === 'X') {\n        rectStartX = currentPoint.x >= startPoint.x ? startPoint.x : currentPoint.x;\n        rectStartY = end.y;\n        rectWidth = Math.abs(startPoint.x - currentPoint.x);\n        rectHeight = Math.abs(end.y - start.y);\n      } else if (type === 'XY') {\n        if (currentPoint.x >= startPoint.x) {\n          rectStartX = startPoint.x;\n          rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n        } else {\n          rectStartX = currentPoint.x;\n          rectStartY = currentPoint.y >= startPoint.y ? startPoint.y : currentPoint.y;\n        }\n\n        rectWidth = Math.abs(startPoint.x - currentPoint.x);\n        rectHeight = Math.abs(startPoint.y - currentPoint.y);\n      } else if (type === 'POLYGON') {\n        polygonPath += \"L \" + currentPoint.x + \" \" + currentPoint.y;\n        me.polygonPath = polygonPath;\n\n        if (!brushShape) {\n          brushShape = container.addShape('path', {\n            attrs: Util.mix(me.style, {\n              path: polygonPath\n            })\n          });\n        } else {\n          !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {\n            path: polygonPath\n          }));\n        }\n      }\n\n      if (type !== 'POLYGON') {\n        if (!brushShape) {\n          brushShape = container.addShape('rect', {\n            attrs: Util.mix(me.style, {\n              x: rectStartX,\n              y: rectStartY,\n              width: rectWidth,\n              height: rectHeight\n            })\n          });\n        } else {\n          !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {\n            x: rectStartX,\n            y: rectStartY,\n            width: rectWidth,\n            height: rectHeight\n          }));\n        }\n      }\n\n      me.brushShape = brushShape;\n    } else if (dragging) {\n      canvasDOM.style.cursor = 'move';\n      var selection = me.selection;\n\n      if (selection && !selection.get('destroyed')) {\n        if (type === 'POLYGON') {\n          var prePoint = me.prePoint;\n          me.selection.translate(currentPoint.x - prePoint.x, currentPoint.y - prePoint.y);\n        } else {\n          me.dragoffX && selection.attr('x', currentPoint.x - me.dragoffX);\n          me.dragoffY && selection.attr('y', currentPoint.y - me.dragoffY);\n        }\n      }\n    }\n\n    me.prePoint = currentPoint;\n    canvas.draw();\n\n    var _me$_getSelected = me._getSelected(),\n        data = _me$_getSelected.data,\n        shapes = _me$_getSelected.shapes,\n        xValues = _me$_getSelected.xValues,\n        yValues = _me$_getSelected.yValues;\n\n    var eventObj = {\n      data: data,\n      shapes: shapes,\n      x: currentPoint.x,\n      y: currentPoint.y\n    };\n\n    if (xScale) {\n      eventObj[xScale.field] = xValues;\n    }\n\n    if (yScale) {\n      eventObj[yScale.field] = yValues;\n    }\n\n    me.onDragmove && me.onDragmove(eventObj);\n    me.onBrushmove && me.onBrushmove(eventObj);\n  };\n\n  _proto.end = function end(ev) {\n    var me = this;\n    var data = me.data,\n        shapes = me.shapes,\n        xValues = me.xValues,\n        yValues = me.yValues,\n        canvas = me.canvas,\n        type = me.type,\n        startPoint = me.startPoint,\n        chart = me.chart,\n        container = me.container,\n        xScale = me.xScale,\n        yScale = me.yScale;\n    var offsetX = ev.offsetX,\n        offsetY = ev.offsetY;\n    var canvasDOM = canvas.get('canvasDOM');\n    canvasDOM.style.cursor = 'default';\n\n    if (Math.abs(startPoint.x - offsetX) <= 1 && Math.abs(startPoint.y - offsetY) <= 1) {\n      // 防止点击事件\n      me.brushing = false;\n      me.dragging = false;\n      return;\n    }\n\n    var eventObj = {\n      data: data,\n      shapes: shapes,\n      x: offsetX,\n      y: offsetY\n    };\n\n    if (xScale) {\n      eventObj[xScale.field] = xValues;\n    }\n\n    if (yScale) {\n      eventObj[yScale.field] = yValues;\n    }\n\n    if (me.dragging) {\n      me.dragging = false;\n      me.onDragend && me.onDragend(eventObj);\n    } else if (me.brushing) {\n      me.brushing = false;\n      var brushShape = me.brushShape;\n      var polygonPath = me.polygonPath;\n\n      if (type === 'POLYGON') {\n        polygonPath += 'z';\n        brushShape && !brushShape.get('destroyed') && brushShape.attr(Util.mix({}, brushShape._attrs, {\n          path: polygonPath\n        }));\n        me.polygonPath = polygonPath;\n        canvas.draw();\n      }\n\n      if (me.onBrushend) {\n        me.onBrushend(eventObj);\n      } else if (chart && me.filter) {\n        container.clear(); // clear the brush\n        // filter data\n\n        if (type === 'X') {\n          xScale && chart.filter(xScale.field, function (val) {\n            return xValues.indexOf(val) > -1;\n          });\n        } else if (type === 'Y') {\n          yScale && chart.filter(yScale.field, function (val) {\n            return yValues.indexOf(val) > -1;\n          });\n        } else {\n          xScale && chart.filter(xScale.field, function (val) {\n            return xValues.indexOf(val) > -1;\n          });\n          yScale && chart.filter(yScale.field, function (val) {\n            return yValues.indexOf(val) > -1;\n          });\n        }\n\n        chart.repaint();\n      }\n    }\n  };\n\n  _proto.reset = function reset() {\n    var me = this;\n    var chart = me.chart,\n        filter = me.filter,\n        brushShape = me.brushShape,\n        canvas = me.canvas;\n\n    if (chart && filter) {\n      chart.get('options').filters = {};\n      chart.repaint();\n    }\n\n    if (brushShape) {\n      brushShape.destroy();\n      canvas.draw();\n    }\n  };\n\n  _proto._limitCoordScope = function _limitCoordScope(point) {\n    var plot = this.plot;\n    var start = plot.start,\n        end = plot.end;\n\n    if (point.x < start.x) {\n      point.x = start.x;\n    }\n\n    if (point.x > end.x) {\n      point.x = end.x;\n    }\n\n    if (point.y < end.y) {\n      point.y = end.y;\n    }\n\n    if (point.y > start.y) {\n      point.y = start.y;\n    }\n\n    return point;\n  };\n\n  _proto._getSelected = function _getSelected() {\n    var me = this;\n    var chart = me.chart,\n        xScale = me.xScale,\n        yScale = me.yScale,\n        brushShape = me.brushShape,\n        canvas = me.canvas;\n    var pixelRatio = canvas.get('pixelRatio');\n    var selectedShapes = [];\n    var xValues = [];\n    var yValues = [];\n    var selectedData = [];\n\n    if (chart) {\n      var geoms = chart.get('geoms');\n      geoms.map(function (geom) {\n        var shapes = geom.getShapes();\n        shapes.map(function (shape) {\n          var shapeData = shape.get('origin');\n\n          if (!Array.isArray(shapeData)) {\n            // 线图、区域图等\n            shapeData = [shapeData];\n          }\n\n          shapeData.map(function (each) {\n            if (brushShape.isHit(each.x * pixelRatio, each.y * pixelRatio)) {\n              selectedShapes.push(shape);\n              var origin = each._origin;\n              selectedData.push(origin);\n              xScale && xValues.push(origin[xScale.field]);\n              yScale && yValues.push(origin[yScale.field]);\n            }\n\n            return each;\n          });\n          return shape;\n        });\n        return geom;\n      });\n    }\n\n    me.shapes = selectedShapes;\n    me.xValues = xValues;\n    me.yValues = yValues;\n    me.data = selectedData;\n    canvas.draw();\n    return {\n      data: selectedData,\n      xValues: xValues,\n      yValues: yValues,\n      shapes: selectedShapes\n    };\n  };\n\n  return Brush;\n}(Interaction); // G2.registerInteraction('brush', Brush);\n// G2.registerInteraction('Brush', Brush);\n\n\nmodule.exports = Brush;\n\n/***/ }),\n/* 468 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Util = __webpack_require__(0);\n\nvar Interaction = __webpack_require__(171);\n\nvar filterData = __webpack_require__(469);\n\nvar getColDef = __webpack_require__(377);\n\nvar getLimitRange = __webpack_require__(378);\n\nvar DAY_TIMESTAMPS = 86400000; // const G2 = require('../core.js');\n\nvar DRAGGING_TYPES = ['X', 'Y', 'XY'];\nvar DEFAULT_TYPE = 'X';\n\nvar Drag =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(Drag, _Interaction);\n\n  var _proto = Drag.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      type: DEFAULT_TYPE,\n      stepRatio: 0.05,\n      limitRange: {},\n      stepByField: {},\n      threshold: 20,\n      originScaleDefsByField: {},\n      previousPoint: null,\n      isDragging: false\n    });\n  };\n\n  _proto._disableTooltip = function _disableTooltip() {\n    var me = this;\n    var chart = me.chart;\n    var tooltipController = chart.get('tooltipController');\n\n    if (tooltipController) {\n      me._showTooltip = true;\n      chart.tooltip(false);\n    }\n  };\n\n  _proto._enableTooltip = function _enableTooltip(ev) {\n    var me = this;\n    var chart = me.chart;\n\n    if (me._showTooltip) {\n      chart.tooltip(true);\n      chart.showTooltip(ev);\n    }\n  };\n\n  function Drag(cfg, chart) {\n    var _this;\n\n    _this = _Interaction.call(this, cfg, chart) || this;\n\n    var me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    me.type = me.type.toUpperCase();\n    me.chart = chart;\n    me.coord = chart.get('coord');\n    var data = me.data = chart.get('data'); // pre process\n\n    filterData(chart);\n    var scales = chart.getYScales();\n    var xScale = chart.getXScale();\n    scales.push(xScale);\n    var scaleController = chart.get('scaleController');\n    scales.forEach(function (scale) {\n      var field = scale.field;\n      me.limitRange[field] = getLimitRange(data, scale);\n      var def = scaleController.defs[field] || {};\n      me.originScaleDefsByField[field] = Util.mix(def, {\n        nice: !!def.nice\n      });\n\n      if (scale.isLinear) {\n        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;\n      }\n    });\n\n    if (DRAGGING_TYPES.indexOf(me.type) === -1) {\n      me.type = DEFAULT_TYPE;\n    }\n\n    me._disableTooltip();\n\n    return _this;\n  } // onDragstart() { }\n  // onDrag() { }\n  // onDragend() { }\n\n\n  _proto._applyTranslate = function _applyTranslate(scale, offset, total) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var me = this;\n\n    if (scale.isLinear) {\n      me._translateLinearScale(scale, offset, total);\n    } else {\n      me._translateCatScale(scale, offset, total);\n    }\n  };\n\n  _proto._translateCatScale = function _translateCatScale(scale, offset, total) {\n    var me = this;\n    var chart = me.chart;\n    var type = scale.type,\n        field = scale.field,\n        values = scale.values,\n        ticks = scale.ticks;\n    var colDef = getColDef(chart, field);\n    var originValues = me.limitRange[field];\n    var ratio = offset / total;\n    var valueLength = values.length;\n    var deltaCount = Math.max(1, Math.abs(parseInt(ratio * valueLength)));\n    var firstIndex = originValues.indexOf(values[0]);\n    var lastIndex = originValues.indexOf(values[valueLength - 1]);\n\n    if (offset > 0 && firstIndex >= 0) {\n      // right\n      for (var i = 0; i < deltaCount && firstIndex > 0; i++) {\n        firstIndex -= 1;\n        lastIndex -= 1;\n      }\n\n      var newValues = originValues.slice(firstIndex, lastIndex + 1);\n      var newTicks = null;\n\n      if (type === 'timeCat') {\n        var tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;\n\n        for (var _i = ticks[0] - tickGap; _i >= newValues[0]; _i -= tickGap) {\n          ticks.unshift(_i);\n        }\n\n        newTicks = ticks;\n      }\n\n      chart.scale(field, Util.mix({}, colDef, {\n        values: newValues,\n        ticks: newTicks\n      }));\n    } else if (offset < 0 && lastIndex <= originValues.length - 1) {\n      // left\n      for (var _i2 = 0; _i2 < deltaCount && lastIndex < originValues.length - 1; _i2++) {\n        firstIndex += 1;\n        lastIndex += 1;\n      }\n\n      var _newValues = originValues.slice(firstIndex, lastIndex + 1);\n\n      var _newTicks = null;\n\n      if (type === 'timeCat') {\n        var _tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;\n\n        for (var _i3 = ticks[ticks.length - 1] + _tickGap; _i3 <= _newValues[_newValues.length - 1]; _i3 += _tickGap) {\n          ticks.push(_i3);\n        }\n\n        _newTicks = ticks;\n      }\n\n      chart.scale(field, Util.mix({}, colDef, {\n        values: _newValues,\n        ticks: _newTicks\n      }));\n    }\n  };\n\n  _proto._translateLinearScale = function _translateLinearScale(scale, offset, total) {\n    var me = this;\n    var chart = me.chart,\n        limitRange = me.limitRange; // linear / cat\n\n    var min = scale.min,\n        max = scale.max,\n        field = scale.field;\n    if (min === limitRange[field].min && max === limitRange[field].max) return;\n    var ratio = offset / total;\n    var range = max - min;\n    var colDef = getColDef(chart, field);\n    chart.scale(field, Util.mix({}, colDef, {\n      nice: false,\n      min: min + ratio * range,\n      max: max + ratio * range\n    }));\n  };\n\n  _proto.start = function start(ev) {\n    var me = this;\n    var canvas = me.canvas;\n    var canvasDOM = canvas.get('canvasDOM');\n    canvasDOM.style.cursor = 'pointer'; // const coord = chart.get('coord');\n\n    me.isDragging = true;\n    me.previousPoint = {\n      x: ev.x,\n      y: ev.y\n    };\n\n    me._disableTooltip();\n  };\n\n  _proto.process = function process(ev) {\n    var me = this;\n\n    if (me.isDragging) {\n      var chart = me.chart,\n          type = me.type,\n          canvas = me.canvas,\n          coord = me.coord,\n          threshold = me.threshold;\n      var canvasDOM = canvas.get('canvasDOM');\n      canvasDOM.style.cursor = 'move'; // const coord = chart.get('coord');\n\n      var previousPoint = me.previousPoint;\n      var currentPoint = ev;\n      var deltaX = currentPoint.x - previousPoint.x;\n      var deltaY = currentPoint.y - previousPoint.y;\n      var modified = false;\n\n      if (Math.abs(deltaX) > threshold && type.indexOf('X') > -1) {\n        modified = true;\n        var xScale = chart.getXScale();\n\n        me._applyTranslate(xScale, xScale.isLinear ? -deltaX : deltaX, coord.width);\n      }\n\n      if (Math.abs(deltaY) > threshold && type.indexOf('Y') > -1) {\n        modified = true;\n        var yScales = chart.getYScales();\n        yScales.forEach(function (yScale) {\n          me._applyTranslate(yScale, currentPoint.y - previousPoint.y, coord.height);\n        });\n      }\n\n      if (modified) {\n        me.previousPoint = currentPoint;\n        chart.repaint();\n      }\n    }\n  };\n\n  _proto.end = function end(ev) {\n    var me = this;\n    me.isDragging = false;\n    var canvas = me.canvas;\n    var canvasDOM = canvas.get('canvasDOM');\n    canvasDOM.style.cursor = 'default';\n\n    me._enableTooltip(ev);\n  };\n\n  _proto.reset = function reset() {\n    var me = this;\n    var view = me.view,\n        originScaleDefsByField = me.originScaleDefsByField;\n    var scales = view.getYScales();\n    var xScale = view.getXScale();\n    scales.push(xScale);\n    scales.forEach(function (scale) {\n      if (scale.isLinear) {\n        var field = scale.field;\n        view.scale(field, originScaleDefsByField[field]);\n      }\n    });\n    view.repaint();\n\n    me._disableTooltip();\n  };\n\n  return Drag;\n}(Interaction);\n\nmodule.exports = Drag;\n\n/***/ }),\n/* 469 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar TimeUtil = __webpack_require__(71);\n\nvar getColDefs = __webpack_require__(376);\n\nmodule.exports = function (chart) {\n  chart.on('beforeinitgeoms', function () {\n    chart.set('limitInPlot', true);\n    var data = chart.get('data');\n    var colDefs = getColDefs(chart);\n    if (!colDefs) return data;\n    var geoms = chart.get('geoms');\n    var isSpecialGeom = false;\n    Util.each(geoms, function (geom) {\n      if (['area', 'line', 'path'].indexOf(geom.get('type')) !== -1) {\n        isSpecialGeom = true;\n        return false;\n      }\n    });\n    var fields = [];\n    Util.each(colDefs, function (def, key) {\n      if (!isSpecialGeom && def && (def.values || def.min || def.max)) {\n        fields.push(key);\n      }\n    });\n\n    if (fields.length === 0) {\n      return data;\n    }\n\n    var geomData = [];\n    Util.each(data, function (obj) {\n      var flag = true;\n      Util.each(fields, function (field) {\n        var value = obj[field];\n\n        if (value) {\n          var colDef = colDefs[field];\n\n          if (colDef.type === 'timeCat') {\n            var values = colDef.values;\n\n            if (Util.isNumber(values[0])) {\n              value = TimeUtil.toTimeStamp(value);\n            }\n          }\n\n          if (colDef.values && colDef.values.indexOf(value) === -1 || colDef.min && value < colDef.min || colDef.max && value > colDef.max) {\n            flag = false;\n          }\n        }\n      });\n\n      if (flag) {\n        geomData.push(obj);\n      }\n    });\n    chart.set('filteredData', geomData);\n  });\n};\n\n/***/ }),\n/* 470 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Interaction = __webpack_require__(171);\n\nvar getFieldRange = __webpack_require__(471);\n\nvar getLimitRange = __webpack_require__(378);\n\nvar DEFAULT_TYPE = 'X';\n\nvar ScrollBar =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(ScrollBar, _Interaction);\n\n  var _proto = ScrollBar.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      startEvent: null,\n      processEvent: null,\n      endEvent: null,\n      resetEvent: null,\n      type: DEFAULT_TYPE,\n      xStyle: {\n        backgroundColor: 'rgba(202, 215, 239, .2)',\n        fillerColor: 'rgba(202, 215, 239, .75)',\n        size: 4,\n        lineCap: 'round',\n        offsetX: 0,\n        offsetY: -10\n      },\n      yStyle: {\n        backgroundColor: 'rgba(202, 215, 239, .2)',\n        fillerColor: 'rgba(202, 215, 239, .75)',\n        size: 4,\n        lineCap: 'round',\n        offsetX: 8,\n        offsetY: 0\n      }\n    });\n  };\n\n  _proto._renderScrollBars = function _renderScrollBars() {\n    var chart = this.chart;\n    var scrollBarCfg = chart.get('_scrollBarCfg');\n    if (!scrollBarCfg) return;\n    var data = chart.get('data');\n    var plotRange = chart.get('plotRange');\n    plotRange.width = Math.abs(plotRange.br.x - plotRange.bl.x);\n    plotRange.height = Math.abs(plotRange.tl.y - plotRange.bl.y);\n    var backPlot = chart.get('backPlot');\n    var canvas = chart.get('canvas');\n    var canvasHeight = canvas.get('height');\n    var limitRange = chart.get('_limitRange');\n    var type = scrollBarCfg.type;\n\n    if (type.indexOf('X') > -1) {\n      var _scrollBarCfg$xStyle = scrollBarCfg.xStyle,\n          offsetX = _scrollBarCfg$xStyle.offsetX,\n          offsetY = _scrollBarCfg$xStyle.offsetY,\n          lineCap = _scrollBarCfg$xStyle.lineCap,\n          backgroundColor = _scrollBarCfg$xStyle.backgroundColor,\n          fillerColor = _scrollBarCfg$xStyle.fillerColor,\n          size = _scrollBarCfg$xStyle.size;\n      var xScale = chart.getXScale();\n      var xLimitRange = limitRange[xScale.field];\n\n      if (!xLimitRange) {\n        xLimitRange = getLimitRange(data, xScale);\n        limitRange[xScale.field] = xLimitRange;\n      }\n\n      var currentRange = getFieldRange(xScale, xLimitRange, xScale.type);\n      var horizontalBar = chart.get('_horizontalBar');\n      var yPos = canvasHeight - size / 2 + offsetY;\n\n      if (horizontalBar) {\n        var progressLine = horizontalBar.get('children')[1];\n        progressLine.attr({\n          x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),\n          x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x)\n        });\n      } else {\n        horizontalBar = backPlot.addGroup({\n          className: 'horizontalBar'\n        });\n        horizontalBar.addShape('line', {\n          attrs: {\n            x1: plotRange.bl.x + offsetX,\n            y1: yPos,\n            x2: plotRange.br.x + offsetX,\n            y2: yPos,\n            lineWidth: size,\n            stroke: backgroundColor,\n            lineCap: lineCap\n          }\n        });\n        horizontalBar.addShape('line', {\n          attrs: {\n            x1: Math.max(plotRange.bl.x + plotRange.width * currentRange[0] + offsetX, plotRange.bl.x),\n            y1: yPos,\n            x2: Math.min(plotRange.bl.x + plotRange.width * currentRange[1] + offsetX, plotRange.br.x),\n            y2: yPos,\n            lineWidth: size,\n            stroke: fillerColor,\n            lineCap: lineCap\n          }\n        });\n        chart.set('_horizontalBar', horizontalBar);\n      }\n    }\n\n    if (type.indexOf('Y') > -1) {\n      var _scrollBarCfg$yStyle = scrollBarCfg.yStyle,\n          _offsetX = _scrollBarCfg$yStyle.offsetX,\n          _offsetY = _scrollBarCfg$yStyle.offsetY,\n          _lineCap = _scrollBarCfg$yStyle.lineCap,\n          _backgroundColor = _scrollBarCfg$yStyle.backgroundColor,\n          _fillerColor = _scrollBarCfg$yStyle.fillerColor,\n          _size = _scrollBarCfg$yStyle.size;\n      var yScale = chart.getYScales()[0];\n      var yLimitRange = limitRange[yScale.field];\n\n      if (!yLimitRange) {\n        yLimitRange = getLimitRange(data, yScale);\n        limitRange[yScale.field] = yLimitRange;\n      }\n\n      var _currentRange = getFieldRange(yScale, yLimitRange, yScale.type);\n\n      var verticalBar = chart.get('_verticalBar');\n      var xPos = _size / 2 + _offsetX;\n\n      if (verticalBar) {\n        var _progressLine = verticalBar.get('children')[1];\n\n        _progressLine.attr({\n          y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),\n          y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y)\n        });\n      } else {\n        verticalBar = backPlot.addGroup({\n          className: 'verticalBar'\n        });\n        verticalBar.addShape('line', {\n          attrs: {\n            x1: xPos,\n            y1: plotRange.tl.y + _offsetY,\n            x2: xPos,\n            y2: plotRange.bl.y + _offsetY,\n            lineWidth: _size,\n            stroke: _backgroundColor,\n            lineCap: _lineCap\n          }\n        });\n        verticalBar.addShape('line', {\n          attrs: {\n            x1: xPos,\n            y1: Math.max(plotRange.tl.y + plotRange.height * _currentRange[0] + _offsetY, plotRange.tl.y),\n            x2: xPos,\n            y2: Math.min(plotRange.tl.y + plotRange.height * _currentRange[1] + _offsetY, plotRange.bl.y),\n            lineWidth: _size,\n            stroke: _fillerColor,\n            lineCap: _lineCap\n          }\n        });\n        chart.set('_verticalBar', verticalBar);\n      }\n    }\n  };\n\n  function ScrollBar(cfg, chart) {\n    var _this;\n\n    _this = _Interaction.call(this, cfg, chart) || this;\n\n    var defaultCfg = _this.getDefaultCfg();\n\n    chart.set('_scrollBarCfg', Util.deepMix({}, defaultCfg, cfg));\n    chart.set('_limitRange', {});\n\n    if (!chart.get('_horizontalBar') && !chart.get('_verticalBar')) {\n      _this._renderScrollBars();\n    }\n\n    return _this;\n  }\n\n  _proto._clear = function _clear() {\n    var chart = this.chart;\n\n    if (chart) {\n      var hBar = chart.get('_horizontalBar');\n      var vBar = chart.get('_verticalBar');\n      hBar && hBar.remove(true);\n      vBar && vBar.remove(true);\n      chart.set('_horizontalBar', null);\n      chart.set('_verticalBar', null);\n    }\n  };\n\n  _proto._bindEvents = function _bindEvents() {\n    this._onAfterclearOrBeforechangedata = this._onAfterclearOrBeforechangedata.bind(this);\n    this._onAfterclearinner = this._onAfterclearinner.bind(this);\n    this._onAfterdrawgeoms = this._onAfterdrawgeoms.bind(this);\n    var chart = this.chart;\n    chart.on('afterclear', this._onAfterclearOrBeforechangedata);\n    chart.on('beforechangedata', this._onAfterclearOrBeforechangedata);\n    chart.on('afterclearinner', this._onAfterclearinner);\n    chart.on('afterdrawgeoms', this._onAfterdrawgeoms);\n  };\n\n  _proto._onAfterclearOrBeforechangedata = function _onAfterclearOrBeforechangedata() {\n    this.chart && this.chart.set('_limitRange', {});\n  };\n\n  _proto._onAfterclearinner = function _onAfterclearinner() {\n    this._clear();\n  };\n\n  _proto._onAfterdrawgeoms = function _onAfterdrawgeoms() {\n    this._renderScrollBars();\n  };\n\n  _proto._clearEvents = function _clearEvents() {\n    var chart = this.chart;\n\n    if (chart) {\n      chart.off('afterclear', this._onAfterclearOrBeforechangedata);\n      chart.off('beforechangedata', this._onAfterclearOrBeforechangedata);\n      chart.off('afterclearinner', this._onAfterclearinner);\n      chart.off('afterdrawgeoms', this._onAfterdrawgeoms);\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    this._clearEvents();\n\n    this._clear();\n\n    this.canvas.draw();\n  };\n\n  return ScrollBar;\n}(Interaction);\n\nmodule.exports = ScrollBar;\n\n/***/ }),\n/* 471 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (scale, limitRange, type) {\n  if (!scale) return [0, 1];\n  var minRatio = 0;\n  var maxRatio = 0;\n\n  if (type === 'linear') {\n    var min = limitRange.min,\n        max = limitRange.max;\n    var range = max - min;\n    minRatio = (scale.min - min) / range;\n    maxRatio = (scale.max - min) / range;\n  } else {\n    var originValues = limitRange;\n    var values = scale.values;\n    var firstIndex = originValues.indexOf(values[0]);\n    var lastIndex = originValues.indexOf(values[values.length - 1]);\n    minRatio = firstIndex / (originValues.length - 1);\n    maxRatio = lastIndex / (originValues.length - 1);\n  }\n\n  return [minRatio, maxRatio];\n};\n\n/***/ }),\n/* 472 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Interaction = __webpack_require__(171);\n\nfunction getOriginalAttrs(attrs, styles) {\n  var origin = {};\n\n  for (var style in styles) {\n    origin[style] = attrs[style];\n  }\n\n  return origin;\n}\n\nvar Select =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(Select, _Interaction);\n\n  function Select() {\n    return _Interaction.apply(this, arguments) || this;\n  }\n\n  var _proto = Select.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var defaultCfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, defaultCfg, {\n      startEvent: 'mouseup',\n      processEvent: null,\n      selectStyle: {\n        fillOpacity: 1\n      },\n      unSelectStyle: {\n        fillOpacity: 0.1\n      },\n      cancelable: true\n    });\n  };\n\n  _proto.start = function start(ev) {\n    var self = this;\n    var chart = self.view;\n    var selectedShape;\n    var unSelectedShapes = [];\n    chart.eachShape(function (obj, shape) {\n      if (shape.isPointInPath(ev.x, ev.y)) {\n        selectedShape = shape;\n      } else {\n        unSelectedShapes.push(shape);\n      }\n    });\n\n    if (!selectedShape) {\n      self.reset();\n      return;\n    }\n\n    if (selectedShape.get('_selected')) {\n      // 已经被选中\n      if (!self.cancelable) {\n        // 不允许取消选中则不处理\n        return;\n      }\n\n      self.reset(); // 允许取消选中\n    } else {\n      // 未被选中\n      var selectStyle = self.selectStyle,\n          unSelectStyle = self.unSelectStyle; // 获取选中效果对应的本来效果,保存下来\n\n      var originAttrs = getOriginalAttrs(selectedShape.attr(), selectedShape);\n      selectedShape.set('_originAttrs', originAttrs);\n      selectedShape.attr(selectStyle);\n      Util.each(unSelectedShapes, function (child) {\n        var originAttrs = child.get('_originAttrs'); // 先恢复到默认状态下\n\n        if (originAttrs) {\n          child.attr(originAttrs);\n        }\n\n        child.set('_selected', false); // 保存未选中效果对应的原始效果\n\n        if (unSelectStyle) {\n          originAttrs = getOriginalAttrs(child.attr(), unSelectStyle);\n          child.set('_originAttrs', originAttrs);\n          child.attr(unSelectStyle);\n        }\n      });\n      selectedShape.set('_selected', true);\n      self.selectedShape = selectedShape;\n      self.canvas.draw();\n    }\n  };\n\n  _proto.end = function end(ev) {\n    var selectedShape = this.selectedShape;\n\n    if (selectedShape && !selectedShape.get('destroyed') && selectedShape.get('origin')) {\n      ev.data = selectedShape.get('origin')._origin; // 绘制数据，包含原始数据啊\n\n      ev.shapeInfo = selectedShape.get('origin');\n      ev.shape = selectedShape;\n      ev.selected = !!selectedShape.get('_selected'); // 返回选中的状态\n    }\n  };\n\n  _proto.reset = function reset() {\n    var self = this;\n\n    if (!self.selectedShape) {\n      return;\n    }\n\n    var chart = self.view;\n    var geom = chart.get('geoms')[0];\n    var container = geom.get('container').get('children')[0];\n    var children = container.get('children');\n    Util.each(children, function (child) {\n      var originAttrs = child.get('_originAttrs');\n\n      if (originAttrs) {\n        child._attrs = originAttrs;\n        child.set('_originAttrs', null);\n      }\n\n      child.set('_selected', false);\n    });\n    self.canvas.draw();\n  };\n\n  return Select;\n}(Interaction);\n\nmodule.exports = Select;\n\n/***/ }),\n/* 473 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Range = __webpack_require__(474);\n\nvar Chart = __webpack_require__(147);\n\nvar Util = __webpack_require__(0);\n\nvar G = __webpack_require__(16);\n\nvar Global = __webpack_require__(7);\n\nvar Interaction = __webpack_require__(171);\n\nvar getColDef = __webpack_require__(377);\n\nvar getColDefs = __webpack_require__(376);\n\nvar Canvas = G.Canvas;\nvar DomUtil = Util.DomUtil,\n    isNumber = Util.isNumber;\n\nvar Slider =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(Slider, _Interaction);\n\n  var _proto = Slider.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      startEvent: null,\n      processEvent: null,\n      endEvent: null,\n      resetEvent: null,\n      height: 26,\n      width: 'auto',\n      // 默认自适应\n      padding: Global.plotCfg.padding,\n      container: null,\n      xAxis: null,\n      yAxis: null,\n      // 选中区域的样式\n      fillerStyle: {\n        fill: '#BDCCED',\n        fillOpacity: 0.3\n      },\n      // 滑动条背景样式\n      backgroundStyle: {\n        stroke: '#CCD6EC',\n        fill: '#CCD6EC',\n        fillOpacity: 0.3,\n        lineWidth: 1\n      },\n      range: [0, 100],\n      layout: 'horizontal',\n      // 文本颜色\n      textStyle: {\n        fill: '#545454'\n      },\n      // 滑块的样式\n      handleStyle: {\n        img: 'https://gw.alipayobjects.com/zos/rmsportal/QXtfhORGlDuRvLXFzpsQ.png',\n        width: 5\n      },\n      // 背景图表的配置，如果为 false 则表示不渲染\n      backgroundChart: {\n        type: ['area'],\n        // 图表的类型，可以是字符串也可是是数组\n        color: '#CCD6EC'\n      }\n    });\n  };\n\n  _proto._initContainer = function _initContainer() {\n    var me = this;\n    var container = me.container;\n\n    if (!container) {\n      throw new Error('Please specify the container for the Slider!');\n    }\n\n    if (Util.isString(container)) {\n      me.domContainer = document.getElementById(container);\n    } else {\n      me.domContainer = container;\n    }\n  };\n\n  _proto.forceFit = function forceFit() {\n    var me = this;\n\n    if (!me || me.destroyed) {\n      return;\n    }\n\n    var width = DomUtil.getWidth(me.domContainer);\n    var height = me.height;\n\n    if (width !== me.domWidth) {\n      var canvas = me.canvas;\n      canvas.changeSize(width, height); // 改变画布尺寸\n\n      me.bgChart && me.bgChart.changeWidth(width);\n      canvas.clear();\n\n      me._initWidth();\n\n      me._initSlider(); // 初始化滑动条\n\n\n      me._bindEvent();\n\n      canvas.draw();\n    }\n  };\n\n  _proto._initForceFitEvent = function _initForceFitEvent() {\n    var me = this;\n    var timer = setTimeout(Util.wrapBehavior(me, 'forceFit'), 200);\n    clearTimeout(me.resizeTimer);\n    me.resizeTimer = timer;\n  };\n\n  _proto._initStyle = function _initStyle() {\n    var me = this;\n    me.handleStyle = Util.mix({\n      width: me.height,\n      height: me.height\n    }, me.handleStyle);\n\n    if (me.width === 'auto') {\n      // 宽度自适应\n      window.addEventListener('resize', Util.wrapBehavior(me, '_initForceFitEvent'));\n    }\n  };\n\n  _proto._initWidth = function _initWidth() {\n    var me = this;\n    var width;\n\n    if (me.width === 'auto') {\n      width = DomUtil.getWidth(me.domContainer);\n    } else {\n      width = me.width;\n    }\n\n    me.domWidth = width;\n    var padding = Util.toAllPadding(me.padding);\n\n    if (me.layout === 'horizontal') {\n      me.plotWidth = width - padding[1] - padding[3];\n      me.plotPadding = padding[3];\n      me.plotHeight = me.height;\n    } else if (me.layout === 'vertical') {\n      me.plotWidth = me.width;\n      me.plotHeight = me.height - padding[0] - padding[2];\n      me.plotPadding = padding[0];\n    }\n  };\n\n  _proto._initCanvas = function _initCanvas() {\n    var me = this;\n    var width = me.domWidth;\n    var height = me.height;\n    var canvas = new Canvas({\n      width: width,\n      height: height,\n      containerDOM: me.domContainer,\n      capture: false\n    });\n    var node = canvas.get('el');\n    node.style.position = 'absolute';\n    node.style.top = 0;\n    node.style.left = 0;\n    node.style.zIndex = 3;\n    me.canvas = canvas;\n  };\n\n  _proto._initBackground = function _initBackground() {\n    var _Util$deepMix;\n\n    var me = this;\n    var chart = this.chart;\n    var geom = chart.getAllGeoms[0];\n    var data = me.data = me.data || chart.get('data');\n    var xScale = chart.getXScale();\n    var xAxis = me.xAxis || xScale.field;\n    var yAxis = me.yAxis || chart.getYScales()[0].field;\n    var scales = Util.deepMix((_Util$deepMix = {}, _Util$deepMix[\"\" + xAxis] = {\n      range: [0, 1]\n    }, _Util$deepMix), getColDefs(chart), me.scales); // 用户列定义\n\n    delete scales[xAxis].min;\n    delete scales[xAxis].max;\n\n    if (!data) {\n      // 没有数据，则不创建\n      throw new Error('Please specify the data!');\n    }\n\n    if (!xAxis) {\n      throw new Error('Please specify the xAxis!');\n    }\n\n    if (!yAxis) {\n      throw new Error('Please specify the yAxis!');\n    }\n\n    var backgroundChart = me.backgroundChart;\n    var type = backgroundChart.type || geom.get('type');\n    var color = backgroundChart.color || 'grey';\n\n    if (!Util.isArray(type)) {\n      type = [type];\n    }\n\n    var padding = Util.toAllPadding(me.padding);\n    var bgChart = new Chart({\n      container: me.container,\n      width: me.domWidth,\n      height: me.height,\n      padding: [0, padding[1], 0, padding[3]],\n      animate: false\n    });\n    bgChart.source(data);\n    bgChart.scale(scales);\n    bgChart.axis(false);\n    bgChart.tooltip(false);\n    bgChart.legend(false);\n    Util.each(type, function (eachType) {\n      bgChart[eachType]().position(xAxis + '*' + yAxis).color(color).opacity(1);\n    });\n    bgChart.render();\n    me.bgChart = bgChart;\n    me.scale = me.layout === 'horizontal' ? bgChart.getXScale() : bgChart.getYScales()[0];\n\n    if (me.layout === 'vertical') {\n      bgChart.destroy();\n    }\n  };\n\n  _proto._initRange = function _initRange() {\n    var me = this;\n    var startRadio = me.startRadio;\n    var endRadio = me.endRadio;\n    var start = me._startValue;\n    var end = me._endValue;\n    var scale = me.scale;\n    var min = 0;\n    var max = 1; // startRadio 优先级高于 start\n\n    if (isNumber(startRadio)) {\n      min = startRadio;\n    } else if (start) {\n      min = scale.scale(scale.translate(start));\n    } // endRadio 优先级高于 end\n\n\n    if (isNumber(endRadio)) {\n      max = endRadio;\n    } else if (end) {\n      max = scale.scale(scale.translate(end));\n    }\n\n    var minSpan = me.minSpan,\n        maxSpan = me.maxSpan;\n    var totalSpan = 0;\n\n    if (scale.type === 'time' || scale.type === 'timeCat') {\n      // 时间类型已排序\n      var values = scale.values;\n      var firstValue = values[0];\n      var lastValue = values[values.length - 1];\n      totalSpan = lastValue - firstValue;\n    } else if (scale.isLinear) {\n      totalSpan = scale.max - scale.min;\n    }\n\n    if (totalSpan && minSpan) {\n      me.minRange = minSpan / totalSpan * 100;\n    }\n\n    if (totalSpan && maxSpan) {\n      me.maxRange = maxSpan / totalSpan * 100;\n    }\n\n    var range = [min * 100, max * 100];\n    me.range = range;\n    return range;\n  };\n\n  _proto._getHandleValue = function _getHandleValue(type) {\n    var me = this;\n    var value;\n    var range = me.range;\n    var min = range[0] / 100;\n    var max = range[1] / 100;\n    var scale = me.scale;\n\n    if (type === 'min') {\n      value = me._startValue ? me._startValue : scale.invert(min);\n    } else {\n      value = me._endValue ? me._endValue : scale.invert(max);\n    }\n\n    return value;\n  };\n\n  _proto._initSlider = function _initSlider() {\n    var me = this;\n    var canvas = me.canvas;\n\n    var range = me._initRange();\n\n    var scale = me.scale;\n    var rangeElement = canvas.addGroup(Range, {\n      middleAttr: me.fillerStyle,\n      range: range,\n      minRange: me.minRange,\n      maxRange: me.maxRange,\n      layout: me.layout,\n      width: me.plotWidth,\n      height: me.plotHeight,\n      backgroundStyle: me.backgroundStyle,\n      textStyle: me.textStyle,\n      handleStyle: me.handleStyle,\n      minText: scale.getText(me._getHandleValue('min')),\n      maxText: scale.getText(me._getHandleValue('max'))\n    });\n\n    if (me.layout === 'horizontal') {\n      rangeElement.translate(me.plotPadding, 0);\n    } else if (me.layout === 'vertical') {\n      rangeElement.translate(0, me.plotPadding);\n    }\n\n    me.rangeElement = rangeElement;\n  };\n\n  _proto._updateElement = function _updateElement(minRatio, maxRatio) {\n    var me = this;\n    var chart = me.chart,\n        scale = me.scale,\n        rangeElement = me.rangeElement;\n    var field = scale.field;\n    var minTextElement = rangeElement.get('minTextElement');\n    var maxTextElement = rangeElement.get('maxTextElement');\n    var min = scale.invert(minRatio);\n    var max = scale.invert(maxRatio);\n    var minText = scale.getText(min);\n    var maxText = scale.getText(max);\n    minTextElement.attr('text', minText);\n    maxTextElement.attr('text', maxText);\n    me._startValue = minText;\n    me._endValue = maxText;\n\n    if (me.onChange) {\n      me.onChange({\n        startText: minText,\n        endText: maxText,\n        startValue: min,\n        endValue: max,\n        startRadio: minRatio,\n        endRadio: maxRatio\n      });\n    }\n\n    chart.scale(field, Util.mix({}, getColDef(chart, field), {\n      nice: false,\n      min: min,\n      max: max\n    }));\n    chart.repaint();\n  };\n\n  _proto._bindEvent = function _bindEvent() {\n    var me = this;\n    var rangeElement = me.rangeElement;\n    rangeElement.on('sliderchange', function (ev) {\n      var range = ev.range;\n      var minRatio = range[0] / 100;\n      var maxRatio = range[1] / 100;\n\n      me._updateElement(minRatio, maxRatio);\n    });\n  };\n\n  function Slider(cfg, chart) {\n    var _this;\n\n    _this = _Interaction.call(this, cfg, chart) || this;\n\n    var me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    me._initContainer();\n\n    me._initStyle();\n\n    me.render();\n    return _this;\n  }\n\n  _proto.clear = function clear() {\n    var me = this;\n    me.canvas.clear();\n    me.bgChart && me.bgChart.destroy();\n    me.bgChart = null;\n    me.scale = null;\n    me.canvas.draw();\n  };\n\n  _proto.repaint = function repaint() {\n    var me = this;\n    me.clear();\n    me.render();\n  };\n\n  _proto.render = function render() {\n    var me = this;\n\n    me._initWidth();\n\n    me._initCanvas();\n\n    me._initBackground();\n\n    me._initSlider();\n\n    me._bindEvent();\n\n    me.canvas.draw();\n  };\n\n  _proto.destroy = function destroy() {\n    var me = this;\n    clearTimeout(me.resizeTimer);\n    var rangeElement = me.rangeElement;\n    rangeElement.off('sliderchange');\n    me.bgChart && me.bgChart.destroy();\n    me.canvas.destroy();\n    var container = me.domContainer;\n\n    while (container.hasChildNodes()) {\n      container.removeChild(container.firstChild);\n    }\n\n    window.removeEventListener('resize', Util.getWrapBehavior(me, '_initForceFitEvent'));\n    me.destroyed = true;\n  };\n\n  return Slider;\n}(Interaction);\n\nmodule.exports = Slider;\n\n/***/ }),\n/* 474 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar G = __webpack_require__(16);\n\nvar Group = G.Group;\nvar DomUtil = Util.DomUtil;\nvar OFFSET = 5;\n\nvar Range =\n/*#__PURE__*/\nfunction (_Group) {\n  _inheritsLoose(Range, _Group);\n\n  function Range() {\n    return _Group.apply(this, arguments) || this;\n  }\n\n  var _proto = Range.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * 范围\n       * @type {Array}\n       */\n      range: null,\n\n      /**\n       * 中滑块属性\n       * @type {ATTRS}\n       */\n      middleAttr: null,\n\n      /**\n       * 背景\n       * @type {G-Element}\n       */\n      backgroundElement: null,\n\n      /**\n       * 下滑块\n       * @type {G-Element}\n       */\n      minHandleElement: null,\n\n      /**\n       * 上滑块\n       * @type {G-Element}\n       */\n      maxHandleElement: null,\n\n      /**\n       * 中块\n       * @type {G-Element}\n       */\n      middleHandleElement: null,\n\n      /**\n       * 当前的激活的元素\n       * @type {G-Element}\n       */\n      currentTarget: null,\n\n      /**\n       * 布局方式： horizontal，vertical\n       * @type {String}\n       */\n      layout: 'vertical',\n\n      /**\n       * 宽\n       * @type {Number}\n       */\n      width: null,\n\n      /**\n       * 高\n       * @type {Number}\n       */\n      height: null,\n\n      /**\n       * 当前的PageX\n       * @type {Number}\n       */\n      pageX: null,\n\n      /**\n       * 当前的PageY\n       * @type {Number}\n       */\n      pageY: null\n    };\n  };\n\n  _proto._initHandle = function _initHandle(type) {\n    var self = this;\n    var handle = self.addGroup();\n    var layout = self.get('layout');\n    var handleStyle = self.get('handleStyle');\n    var img = handleStyle.img;\n    var iconWidth = handleStyle.width;\n    var iconHeight = handleStyle.height;\n    var text;\n    var handleIcon;\n    var triggerCursor;\n\n    if (layout === 'horizontal') {\n      var _iconWidth = handleStyle.width;\n      triggerCursor = 'ew-resize';\n      handleIcon = handle.addShape('Image', {\n        attrs: {\n          x: -_iconWidth / 2,\n          y: 0,\n          width: _iconWidth,\n          height: iconHeight,\n          img: img,\n          cursor: triggerCursor\n        }\n      });\n      text = handle.addShape('Text', {\n        attrs: Util.mix({\n          x: type === 'min' ? -(_iconWidth / 2 + OFFSET) : _iconWidth / 2 + OFFSET,\n          y: iconHeight / 2,\n          textAlign: type === 'min' ? 'end' : 'start',\n          textBaseline: 'middle',\n          text: type === 'min' ? this.get('minText') : this.get('maxText'),\n          cursor: triggerCursor\n        }, this.get('textStyle'))\n      });\n    } else {\n      triggerCursor = 'ns-resize';\n      handleIcon = handle.addShape('Image', {\n        attrs: {\n          x: 0,\n          y: -iconHeight / 2,\n          width: iconWidth,\n          height: iconHeight,\n          img: img,\n          cursor: triggerCursor\n        }\n      });\n      text = handle.addShape('Text', {\n        attrs: Util.mix({\n          x: iconWidth / 2,\n          y: type === 'min' ? iconHeight / 2 + OFFSET : -(iconHeight / 2 + OFFSET),\n          textAlign: 'center',\n          textBaseline: 'middle',\n          text: type === 'min' ? this.get('minText') : this.get('maxText'),\n          cursor: triggerCursor\n        }, this.get('textStyle'))\n      });\n    }\n\n    this.set(type + 'TextElement', text);\n    this.set(type + 'IconElement', handleIcon);\n    return handle;\n  };\n\n  _proto._initSliderBackground = function _initSliderBackground() {\n    var backgroundElement = this.addGroup();\n    backgroundElement.initTransform();\n    backgroundElement.translate(0, 0);\n    backgroundElement.addShape('Rect', {\n      attrs: Util.mix({\n        x: 0,\n        y: 0,\n        width: this.get('width'),\n        height: this.get('height')\n      }, this.get('backgroundStyle'))\n    });\n    return backgroundElement;\n  };\n\n  _proto._beforeRenderUI = function _beforeRenderUI() {\n    var backgroundElement = this._initSliderBackground();\n\n    var minHandleElement = this._initHandle('min');\n\n    var maxHandleElement = this._initHandle('max');\n\n    var middleHandleElement = this.addShape('rect', {\n      attrs: this.get('middleAttr')\n    });\n    this.set('middleHandleElement', middleHandleElement);\n    this.set('minHandleElement', minHandleElement);\n    this.set('maxHandleElement', maxHandleElement);\n    this.set('backgroundElement', backgroundElement);\n    backgroundElement.set('zIndex', 0);\n    middleHandleElement.set('zIndex', 1);\n    minHandleElement.set('zIndex', 2);\n    maxHandleElement.set('zIndex', 2);\n    middleHandleElement.attr('cursor', 'move');\n    this.sort();\n  };\n\n  _proto._renderUI = function _renderUI() {\n    if (this.get('layout') === 'horizontal') {\n      this._renderHorizontal();\n    } else {\n      this._renderVertical();\n    }\n  };\n\n  _proto._transform = function _transform(layout) {\n    var range = this.get('range');\n    var minRatio = range[0] / 100;\n    var maxRatio = range[1] / 100;\n    var width = this.get('width');\n    var height = this.get('height');\n    var minHandleElement = this.get('minHandleElement');\n    var maxHandleElement = this.get('maxHandleElement');\n    var middleHandleElement = this.get('middleHandleElement');\n\n    if (minHandleElement.resetMatrix) {\n      minHandleElement.resetMatrix();\n      maxHandleElement.resetMatrix();\n    } else {\n      minHandleElement.initTransform();\n      maxHandleElement.initTransform();\n    }\n\n    if (layout === 'horizontal') {\n      middleHandleElement.attr({\n        x: width * minRatio,\n        y: 0,\n        width: (maxRatio - minRatio) * width,\n        height: height\n      });\n      minHandleElement.translate(minRatio * width, 0);\n      maxHandleElement.translate(maxRatio * width, 0);\n    } else {\n      middleHandleElement.attr({\n        x: 0,\n        y: height * (1 - maxRatio),\n        width: width,\n        height: (maxRatio - minRatio) * height\n      });\n      minHandleElement.translate(0, (1 - minRatio) * height);\n      maxHandleElement.translate(0, (1 - maxRatio) * height);\n    }\n  };\n\n  _proto._renderHorizontal = function _renderHorizontal() {\n    this._transform('horizontal');\n  };\n\n  _proto._renderVertical = function _renderVertical() {\n    this._transform('vertical');\n  };\n\n  _proto._bindUI = function _bindUI() {\n    this.on('mousedown', Util.wrapBehavior(this, '_onMouseDown'));\n  };\n\n  _proto._isElement = function _isElement(target, name) {\n    // 判断是否是该元素\n    var element = this.get(name);\n\n    if (target === element) {\n      return true;\n    }\n\n    if (element.isGroup) {\n      var elementChildren = element.get('children');\n      return elementChildren.indexOf(target) > -1;\n    }\n\n    return false;\n  };\n\n  _proto._getRange = function _getRange(diff, range) {\n    var rst = diff + range;\n    rst = rst > 100 ? 100 : rst;\n    rst = rst < 0 ? 0 : rst;\n    return rst;\n  };\n\n  _proto._limitRange = function _limitRange(diff, limit, range) {\n    range[0] = this._getRange(diff, range[0]);\n    range[1] = range[0] + limit;\n\n    if (range[1] > 100) {\n      range[1] = 100;\n      range[0] = range[1] - limit;\n    }\n  };\n\n  _proto._updateStatus = function _updateStatus(dim, ev) {\n    var totalLength = dim === 'x' ? this.get('width') : this.get('height');\n    dim = Util.upperFirst(dim);\n    var range = this.get('range');\n    var page = this.get('page' + dim);\n    var currentTarget = this.get('currentTarget');\n    var rangeStash = this.get('rangeStash');\n    var layout = this.get('layout');\n    var sign = layout === 'vertical' ? -1 : 1;\n    var currentPage = ev['page' + dim];\n    var diffPage = currentPage - page;\n    var diffRange = diffPage / totalLength * 100 * sign;\n    var diffStashRange;\n    var minRange = this.get('minRange');\n    var maxRange = this.get('maxRange');\n\n    if (range[1] <= range[0]) {\n      if (this._isElement(currentTarget, 'minHandleElement') || this._isElement(currentTarget, 'maxHandleElement')) {\n        range[0] = this._getRange(diffRange, range[0]);\n        range[1] = this._getRange(diffRange, range[0]);\n      }\n    } else {\n      if (this._isElement(currentTarget, 'minHandleElement')) {\n        range[0] = this._getRange(diffRange, range[0]);\n\n        if (minRange) {\n          // 设置了最小范围\n          if (range[1] - range[0] <= minRange) {\n            this._limitRange(diffRange, minRange, range);\n          }\n        }\n\n        if (maxRange) {\n          // 设置了最大范围\n          if (range[1] - range[0] >= maxRange) {\n            this._limitRange(diffRange, maxRange, range);\n          }\n        }\n      }\n\n      if (this._isElement(currentTarget, 'maxHandleElement')) {\n        range[1] = this._getRange(diffRange, range[1]);\n\n        if (minRange) {\n          // 设置了最小范围\n          if (range[1] - range[0] <= minRange) {\n            this._limitRange(diffRange, minRange, range);\n          }\n        }\n\n        if (maxRange) {\n          // 设置了最大范围\n          if (range[1] - range[0] >= maxRange) {\n            this._limitRange(diffRange, maxRange, range);\n          }\n        }\n      }\n    }\n\n    if (this._isElement(currentTarget, 'middleHandleElement')) {\n      diffStashRange = rangeStash[1] - rangeStash[0];\n\n      this._limitRange(diffRange, diffStashRange, range);\n    }\n\n    this.emit('sliderchange', {\n      range: range\n    });\n    this.set('page' + dim, currentPage);\n\n    this._renderUI();\n\n    this.get('canvas').draw(); // need delete\n\n    return;\n  };\n\n  _proto._onMouseDown = function _onMouseDown(ev) {\n    var currentTarget = ev.currentTarget;\n    var originEvent = ev.event;\n    var range = this.get('range');\n    originEvent.stopPropagation();\n    originEvent.preventDefault();\n    this.set('pageX', originEvent.pageX);\n    this.set('pageY', originEvent.pageY);\n    this.set('currentTarget', currentTarget);\n    this.set('rangeStash', [range[0], range[1]]);\n\n    this._bindCanvasEvents();\n  };\n\n  _proto._bindCanvasEvents = function _bindCanvasEvents() {\n    var containerDOM = this.get('canvas').get('containerDOM');\n    this.onMouseMoveListener = DomUtil.addEventListener(containerDOM, 'mousemove', Util.wrapBehavior(this, '_onCanvasMouseMove'));\n    this.onMouseUpListener = DomUtil.addEventListener(containerDOM, 'mouseup', Util.wrapBehavior(this, '_onCanvasMouseUp')); // @2018-06-06 by blue.lb 添加mouseleave事件监听，让用户在操作出滑块区域后有一个“正常”的效果，可以正常重新触发滑块的操作流程\n\n    this.onMouseLeaveListener = DomUtil.addEventListener(containerDOM, 'mouseleave', Util.wrapBehavior(this, '_onCanvasMouseUp'));\n  };\n\n  _proto._onCanvasMouseMove = function _onCanvasMouseMove(ev) {\n    var layout = this.get('layout');\n\n    if (layout === 'horizontal') {\n      this._updateStatus('x', ev);\n    } else {\n      this._updateStatus('y', ev);\n    }\n  };\n\n  _proto._onCanvasMouseUp = function _onCanvasMouseUp() {\n    this._removeDocumentEvents();\n  };\n\n  _proto._removeDocumentEvents = function _removeDocumentEvents() {\n    this.onMouseMoveListener.remove();\n    this.onMouseUpListener.remove();\n    this.onMouseLeaveListener.remove();\n  };\n\n  return Range;\n}(Group);\n\nmodule.exports = Range;\n\n/***/ }),\n/* 475 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Util = __webpack_require__(0);\n\nvar Interaction = __webpack_require__(171);\n\nvar getColDef = __webpack_require__(377);\n\nvar getLimitRange = __webpack_require__(378);\n\nvar ZOOMING_TYPES = ['X', 'Y', 'XY'];\nvar DEFAULT_TYPE = 'X';\n\nvar Zoom =\n/*#__PURE__*/\nfunction (_Interaction) {\n  _inheritsLoose(Zoom, _Interaction);\n\n  var _proto = Zoom.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Interaction.prototype.getDefaultCfg.call(this);\n\n    return Util.mix({}, cfg, {\n      processEvent: 'mousewheel',\n      type: DEFAULT_TYPE,\n      stepRatio: 0.05,\n      stepByField: {},\n      minScale: 1,\n      maxScale: 4,\n      catStep: 2,\n      limitRange: {},\n      originScaleDefsByField: {}\n    });\n  };\n\n  function Zoom(cfg, chart) {\n    var _this;\n\n    _this = _Interaction.call(this, cfg, chart) || this;\n\n    var me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    me.chart = chart;\n    me.type = me.type.toUpperCase();\n    var data = me.data = chart.get('data');\n    var scales = chart.getYScales();\n    var xScale = chart.getXScale();\n    scales.push(xScale);\n    var scaleController = chart.get('scaleController');\n    scales.forEach(function (scale) {\n      var field = scale.field;\n      var def = scaleController.defs[field] || {};\n      me.limitRange[field] = getLimitRange(data, scale);\n      me.originScaleDefsByField[field] = Util.mix(def, {\n        nice: !!def.nice\n      });\n\n      if (scale.isLinear) {\n        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;\n      } else {\n        me.stepByField[field] = me.catStep;\n      }\n    });\n\n    if (ZOOMING_TYPES.indexOf(me.type) === -1) {\n      me.type = DEFAULT_TYPE;\n    }\n\n    return _this;\n  } // onZoom() { }\n  // onZoomin() { }\n  // onZoomout() { }\n\n\n  _proto._applyScale = function _applyScale(scale, delta, minOffset, center) {\n    if (minOffset === void 0) {\n      minOffset = 0;\n    }\n\n    var me = this;\n    var chart = me.chart,\n        stepByField = me.stepByField;\n\n    if (scale.isLinear) {\n      var min = scale.min,\n          max = scale.max,\n          field = scale.field;\n      var maxOffset = 1 - minOffset;\n      var step = stepByField[field] * delta;\n      var newMin = min + step * minOffset;\n      var newMax = max - step * maxOffset;\n\n      if (newMax > newMin) {\n        chart.scale(field, {\n          nice: false,\n          min: newMin,\n          max: newMax\n        });\n      }\n    } else {\n      var _field = scale.field,\n          values = scale.values;\n      var _chart = me.chart;\n\n      var coord = _chart.get('coord');\n\n      var colDef = getColDef(_chart, _field);\n      var originValues = me.limitRange[_field];\n      var originValuesLen = originValues.length;\n      var maxScale = me.maxScale;\n      var minScale = me.minScale;\n      var minCount = originValuesLen / maxScale;\n      var maxCount = originValuesLen / minScale;\n      var valuesLength = values.length;\n      var offsetPoint = coord.invertPoint(center);\n      var percent = offsetPoint.x;\n      var deltaCount = valuesLength - delta * this.catStep;\n      var minDelta = parseInt(deltaCount * percent);\n      var maxDelta = deltaCount + minDelta;\n\n      if (delta > 0 && valuesLength >= minCount) {\n        // zoom out\n        var _min = minDelta;\n        var _max = maxDelta;\n\n        if (maxDelta > valuesLength) {\n          _max = valuesLength - 1;\n          _min = valuesLength - deltaCount;\n        }\n\n        var newValues = values.slice(_min, _max);\n\n        _chart.scale(_field, Util.mix({}, colDef, {\n          values: newValues\n        }));\n      } else if (delta < 0 && valuesLength <= maxCount) {\n        // zoom in\n        var firstIndex = originValues.indexOf(values[0]);\n        var lastIndex = originValues.indexOf(values[valuesLength - 1]);\n        var minIndex = Math.max(0, firstIndex - minDelta);\n        var maxIndex = Math.min(lastIndex + maxDelta, originValuesLen);\n\n        var _newValues = originValues.slice(minIndex, maxIndex);\n\n        _chart.scale(_field, Util.mix({}, colDef, {\n          values: _newValues\n        }));\n      }\n    }\n  };\n\n  _proto.process = function process(ev) {\n    var me = this;\n    var chart = me.chart,\n        type = me.type;\n    var coord = chart.get('coord');\n    var deltaY = ev.deltaY;\n    var offsetPoint = coord.invertPoint(ev);\n\n    if (deltaY) {\n      me.onZoom && me.onZoom(deltaY, offsetPoint, me);\n\n      if (deltaY > 0) {\n        me.onZoomin && me.onZoomin(deltaY, offsetPoint, me);\n      } else {\n        me.onZoomout && me.onZoomout(deltaY, offsetPoint, me);\n      }\n\n      var delta = deltaY / Math.abs(deltaY);\n\n      if (type.indexOf('X') > -1) {\n        me._applyScale(chart.getXScale(), delta, offsetPoint.x, ev);\n      }\n\n      if (type.indexOf('Y') > -1) {\n        var yScales = chart.getYScales();\n        yScales.forEach(function (yScale) {\n          me._applyScale(yScale, delta, offsetPoint.y, ev);\n        });\n      }\n    }\n\n    chart.repaint();\n  };\n\n  _proto.reset = function reset() {\n    var me = this;\n    var view = me.view,\n        originScaleDefsByField = me.originScaleDefsByField;\n    var scales = view.getYScales();\n    var xScale = view.getXScale();\n    scales.push(xScale);\n    scales.forEach(function (scale) {\n      if (scale.isLinear) {\n        var field = scale.field;\n        view.scale(field, originScaleDefsByField[field]);\n      }\n    });\n    view.repaint();\n  };\n\n  return Zoom;\n}(Interaction); // G2.registerInteraction('zoom', Zoom);\n// G2.registerInteraction('Zoom', Zoom);\n\n\nmodule.exports = Zoom;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=g2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFudHYvZzIvYnVpbGQvZzIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFudHYvZzIvYnVpbGQvZzIuanM/N2YxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJHMl8zXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkcyXzNcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM4OSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBUaGUgdXRpbCBtZXRob2QgYmFzZWQgb24gdGhlIGxvZGFzaC5cbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaFxuICovXG52YXIgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyk7XG5cbnZhciBHID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBVdGlsID0gVXRpbHMubWl4KHt9LCBVdGlscywge1xuICBhc3NpZ246IFV0aWxzLm1peCxcbiAgLy8gc2ltcGxlIG1peFxuICBtZXJnZTogVXRpbHMuZGVlcE1peCxcbiAgLy8gZGVlcCBtaXhcbiAgY2xvbmVEZWVwOiBVdGlscy5jbG9uZSxcbiAgaXNGaW5pdGU6IGlzRmluaXRlLFxuICBpc05hTjogaXNOYU4sXG4gIHNuYXBFcXVhbDogVXRpbHMuaXNOdW1iZXJFcXVhbCxcbiAgcmVtb3ZlOiBVdGlscy5wdWxsLFxuICBpbkFycmF5OiBVdGlscy5jb250YWlucyxcblxuICAvKipcbiAgICog5bCG55So5oi36L6T5YWl55qEIHBhZGRpbmcg6L2s5o2i5oiQIFt0b3AsIHJpZ2h0LCBib3R0b20sIHJpZ2h0XSDnmoTmqKHlvI9cbiAgICogQHBhcmFtICB7TnVtYmVyfEFycmF5fSBwYWRkaW5nIOi+k+WFpeeahHBhZGRpbmdcbiAgICogQHJldHVybiB7QXJyYXl9IOWbm+S4qnBhZGRpbmcg5YC8XG4gICAqL1xuICB0b0FsbFBhZGRpbmc6IGZ1bmN0aW9uIHRvQWxsUGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciByaWdodCA9IDA7XG4gICAgdmFyIGJvdHRvbSA9IDA7XG5cbiAgICBpZiAoVXRpbC5pc051bWJlcihwYWRkaW5nKSB8fCBVdGlsLmlzU3RyaW5nKHBhZGRpbmcpKSB7XG4gICAgICB0b3AgPSBsZWZ0ID0gcmlnaHQgPSBib3R0b20gPSBwYWRkaW5nO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc0FycmF5KHBhZGRpbmcpKSB7XG4gICAgICB0b3AgPSBwYWRkaW5nWzBdO1xuICAgICAgcmlnaHQgPSAhVXRpbC5pc05pbChwYWRkaW5nWzFdKSA/IHBhZGRpbmdbMV0gOiBwYWRkaW5nWzBdO1xuICAgICAgYm90dG9tID0gIVV0aWwuaXNOaWwocGFkZGluZ1syXSkgPyBwYWRkaW5nWzJdIDogcGFkZGluZ1swXTtcbiAgICAgIGxlZnQgPSAhVXRpbC5pc05pbChwYWRkaW5nWzNdKSA/IHBhZGRpbmdbM10gOiByaWdodDtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNPYmplY3QocGFkZGluZykpIHtcbiAgICAgIHRvcCA9IHBhZGRpbmcudG9wIHx8IDA7XG4gICAgICByaWdodCA9IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgICAgIGJvdHRvbSA9IHBhZGRpbmcuYm90dG9tIHx8IDA7XG4gICAgICBsZWZ0ID0gcGFkZGluZy5sZWZ0IHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdO1xuICB9LFxuICBnZXRDbGlwQnlSYW5nZTogZnVuY3Rpb24gZ2V0Q2xpcEJ5UmFuZ2UocGxvdFJhbmdlKSB7XG4gICAgdmFyIHRsID0gcGxvdFJhbmdlLnRsLFxuICAgICAgICBiciA9IHBsb3RSYW5nZS5icjtcbiAgICB2YXIgY2xpcCA9IG5ldyBHLlJlY3Qoe1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgeDogdGwueCxcbiAgICAgICAgeTogdGwueSxcbiAgICAgICAgd2lkdGg6IGJyLnggLSB0bC54LFxuICAgICAgICBoZWlnaHQ6IGJyLnkgLSB0bC55XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsaXA7XG4gIH1cbn0pO1xuVXRpbC5BcnJheSA9IHtcbiAgZ3JvdXBUb01hcDogVXRpbHMuZ3JvdXBUb01hcCxcbiAgZ3JvdXA6IFV0aWxzLmdyb3VwLFxuICBtZXJnZTogVXRpbHMubWVyZ2UsXG4gIHZhbHVlczogVXRpbHMudmFsdWVzT2ZLZXksXG4gIGdldFJhbmdlOiBVdGlscy5nZXRSYW5nZSxcbiAgZmlyc3RWYWx1ZTogVXRpbHMuZmlyc3RWYWx1ZSxcbiAgcmVtb3ZlOiBVdGlscy5wdWxsXG59O1xubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIENvbW1vblV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxudmFyIFV0aWwgPSB7fTtcbkNvbW1vblV0aWwubWVyZ2UoVXRpbCwgQ29tbW9uVXRpbCwge1xuICBtaXhpbjogZnVuY3Rpb24gbWl4aW4oYywgbWl4aW5zKSB7XG4gICAgdmFyIFBhcmFtID0gYy5DRkcgPyAnQ0ZHJyA6ICdBVFRSUyc7XG5cbiAgICBpZiAoYyAmJiBtaXhpbnMpIHtcbiAgICAgIGMuX21peGlucyA9IG1peGlucztcbiAgICAgIGNbUGFyYW1dID0gY1tQYXJhbV0gfHwge307XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgVXRpbC5lYWNoKG1peGlucywgZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICAgIFV0aWwuYXVnbWVudChjLCBtaXhpbik7XG4gICAgICAgIHZhciBhdHRycyA9IG1peGluW1BhcmFtXTtcblxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICBVdGlsLm1lcmdlKHRlbXAsIGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjW1BhcmFtXSA9IFV0aWwubWVyZ2UodGVtcCwgY1tQYXJhbV0pO1xuICAgIH1cbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgZWFjaCA9IGZ1bmN0aW9uIGVhY2goZWxlbWVudHMsIGZ1bmMpIHtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByc3QgPSB2b2lkIDA7XG5cbiAgaWYgKGlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2ldLCBpKTtcblxuICAgICAgaWYgKHJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGVsZW1lbnRzKSkge1xuICAgIGZvciAodmFyIGsgaW4gZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2tdLCBrKTtcblxuICAgICAgICBpZiAocnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhY2g7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIHV0aWwgbWV0aG9kIGJhc2VkIG9uIHRoZSBsb2Rhc2guXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjcpO1xuXG52YXIgVXRpbCA9IFV0aWxzLm1peCh7XG4gIGFzc2lnbjogVXRpbHMubWl4LFxuICBpc0Zpbml0ZTogaXNGaW5pdGUsXG4gIGlzTmFOOiBpc05hTixcbiAgR3JvdXA6IEcuR3JvdXAsXG4gIEV2ZW50OiBHLkV2ZW50XG59LCBVdGlscyk7XG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ0FycmF5Jyk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaXNGaW5pdGUsXG52YXIgaXNOaWwgPSBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAvKipcbiAgICogaXNOaWwobnVsbCkgPT4gdHJ1ZVxuICAgKiBpc05pbCgpID0+IHRydWVcbiAgICovXG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc05pbDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIGlzUG9pbnRJblBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OSk7XG5cbnZhciBFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG52YXIgSW5zaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cbnZhciBTaGFwZSA9IGZ1bmN0aW9uIFNoYXBlKGNmZykge1xuICBTaGFwZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY2ZnKTtcbn07XG5cblNoYXBlLkFUVFJTID0ge307XG5VdGlsLmV4dGVuZChTaGFwZSwgRWxlbWVudCk7XG52YXIgQVJSQVlfQVRUUlMgPSB7XG4gIG1hdHJpeDogJ21hdHJpeCcsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgbGluZURhc2g6ICdsaW5lRGFzaCdcbn07XG5cbmZ1bmN0aW9uIF9jbG9uZUFycmF5QXR0cihhcnIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKFV0aWwuaXNBcnJheShhcnJbaV0pKSB7XG4gICAgICByZXN1bHQucHVzaChbXS5jb25jYXQoYXJyW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXRpbC5hdWdtZW50KFNoYXBlLCBpc1BvaW50SW5QYXRoLCB7XG4gIGlzU2hhcGU6IHRydWUsXG4gIGRyYXdJbm5lcjogZnVuY3Rpb24gZHJhd0lubmVyKGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gICAgc2VsZi5jcmVhdGVQYXRoKGNvbnRleHQpO1xuICAgIHZhciBvcmlnaW5PcGFjaXR5ID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICAgIGlmIChzZWxmLmhhc0ZpbGwoKSkge1xuICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gYXR0cnMuZmlsbE9wYWNpdHk7XG5cbiAgICAgIGlmICghVXRpbC5pc05pbChmaWxsT3BhY2l0eSkgJiYgZmlsbE9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGZpbGxPcGFjaXR5O1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9yaWdpbk9wYWNpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5oYXNTdHJva2UoKSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHNlbGYuX2F0dHJzLmxpbmVXaWR0aDtcblxuICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhdHRycy5zdHJva2VPcGFjaXR5O1xuXG4gICAgICAgIGlmICghVXRpbC5pc05pbChzdHJva2VPcGFjaXR5KSAmJiBzdHJva2VPcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuYWZ0ZXJQYXRoKGNvbnRleHQpO1xuICB9LFxuICBhZnRlclBhdGg6IGZ1bmN0aW9uIGFmdGVyUGF0aCgpIHt9LFxuXG4gIC8qKlxuICAgKiDlh7vkuK3lm77lvaLml7bmmK/lkKbov5vooYzljIXlm7Tnm5LliKTmlq1cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgaXNIaXRCb3g6IGZ1bmN0aW9uIGlzSGl0Qm94KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDoioLngrnmmK/lkKbog73lpJ/ooqvlh7vkuK1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggeOWdkOagh1xuICAgKiBAcGFyYW0ge051bWJlcn0geSB55Z2Q5qCHXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IOaYr+WQpuWcqOWbvuW9ouS4rVxuICAgKi9cbiAgaXNIaXQ6IGZ1bmN0aW9uIGlzSGl0KHgsIHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHYgPSBbeCwgeSwgMV07XG4gICAgc2VsZi5pbnZlcnQodik7IC8vIGNhbnZhc1xuXG4gICAgaWYgKHNlbGYuaXNIaXRCb3goKSkge1xuICAgICAgdmFyIGJveCA9IHNlbGYuZ2V0QkJveCgpO1xuXG4gICAgICBpZiAoYm94ICYmICFJbnNpZGUuYm94KGJveC5taW5YLCBib3gubWF4WCwgYm94Lm1pblksIGJveC5tYXhZLCB2WzBdLCB2WzFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNsaXAgPSBzZWxmLl9hdHRycy5jbGlwO1xuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIGNsaXAuaW52ZXJ0KHYsIHNlbGYuZ2V0KCdjYW52YXMnKSk7XG5cbiAgICAgIGlmIChjbGlwLmlzUG9pbnRJblBhdGgodlswXSwgdlsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaXNQb2ludEluUGF0aCh2WzBdLCB2WzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGYuaXNQb2ludEluUGF0aCh2WzBdLCB2WzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6K6h566X5YyF5Zu055uSXG4gICAqIEByZXR1cm4ge09iamVjdH0g5YyF5Zu055uSXG4gICAqL1xuICBjYWxjdWxhdGVCb3g6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgLy8g6I635Y+W5ou+5Y+W5pe257q/55qE5a695bqm77yM6ZyA6KaB6ICD6JmR6ZmE5Yqg55qE57q/55qE5a695bqmXG4gIGdldEhpdExpbmVXaWR0aDogZnVuY3Rpb24gZ2V0SGl0TGluZVdpZHRoKCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzOyAvLyBpZiAoIWF0dHJzLnN0cm9rZSkge1xuICAgIC8vICAgcmV0dXJuIDA7XG4gICAgLy8gfVxuXG4gICAgdmFyIGxpbmVBcHBlbmRXaWR0aCA9IGF0dHJzLmxpbmVBcHBlbmRXaWR0aCB8fCAwO1xuICAgIHZhciBsaW5lV2lkdGggPSBhdHRycy5saW5lV2lkdGggfHwgMDtcbiAgICByZXR1cm4gbGluZVdpZHRoICsgbGluZUFwcGVuZFdpZHRoO1xuICB9LFxuICAvLyDmuIXpmaTlvZPliY3nmoTnn6npmLVcbiAgY2xlYXJUb3RhbE1hdHJpeDogZnVuY3Rpb24gY2xlYXJUb3RhbE1hdHJpeCgpIHtcbiAgICB0aGlzLl9jZmcudG90YWxNYXRyaXggPSBudWxsO1xuICAgIHRoaXMuX2NmZy5yZWdpb24gPSBudWxsO1xuICB9LFxuICBjbGVhckJCb3g6IGZ1bmN0aW9uIGNsZWFyQkJveCgpIHtcbiAgICB0aGlzLl9jZmcuYm94ID0gbnVsbDtcbiAgICB0aGlzLl9jZmcucmVnaW9uID0gbnVsbDtcbiAgfSxcbiAgZ2V0QkJveDogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICB2YXIgYm94ID0gdGhpcy5fY2ZnLmJveDsgLy8g5bu26L+f6K6h566XXG5cbiAgICBpZiAoIWJveCkge1xuICAgICAgYm94ID0gdGhpcy5jYWxjdWxhdGVCb3goKTtcblxuICAgICAgaWYgKGJveCkge1xuICAgICAgICBib3gueCA9IGJveC5taW5YO1xuICAgICAgICBib3gueSA9IGJveC5taW5ZO1xuICAgICAgICBib3gud2lkdGggPSBib3gubWF4WCAtIGJveC5taW5YO1xuICAgICAgICBib3guaGVpZ2h0ID0gYm94Lm1heFkgLSBib3gubWluWTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2ZnLmJveCA9IGJveDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xuICB9LFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbG9uZSA9IG51bGw7XG4gICAgdmFyIF9hdHRycyA9IHNlbGYuX2F0dHJzO1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIFV0aWwuZWFjaChfYXR0cnMsIGZ1bmN0aW9uIChpLCBrKSB7XG4gICAgICBpZiAoQVJSQVlfQVRUUlNba10gJiYgVXRpbC5pc0FycmF5KF9hdHRyc1trXSkpIHtcbiAgICAgICAgYXR0cnNba10gPSBfY2xvbmVBcnJheUF0dHIoX2F0dHJzW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzW2tdID0gX2F0dHJzW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNsb25lID0gbmV3IHNlbGYuY29uc3RydWN0b3Ioe1xuICAgICAgYXR0cnM6IGF0dHJzXG4gICAgfSk7IC8vIHpJbmRleOS5n+aYr+e7mOWbvuWxnuaAp++8jOS9huaYr+WcqGNmZ+S4re+8jOeJueauiuWkhOeQhlxuXG4gICAgY2xvbmUuX2NmZy56SW5kZXggPSBzZWxmLl9jZmcuekluZGV4O1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOWFqOWxgOWPmOmHj1xuICogQGF1dGhvciBkeHE2MTNcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgVGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MSk7XG5cbnZhciBHbG9iYWwgPSB7XG4gIHZlcnNpb246ICczLjQuMTAnLFxuICByZW5kZXJlcjogJ2NhbnZhcycsXG4gIC8vIHRyYWNrYWJsZTogZmFsc2UsXG4gIHRyYWNraW5nSW5mbzoge30sXG4gIGFuaW1hdGU6IHRydWUsXG4gIHdpZHRoUmF0aW86IHtcbiAgICAvLyDlrr3luqbmiYDljaDnmoTliIbnsbvnmoTmr5TkvotcbiAgICBjb2x1bW46IDEgLyAyLFxuICAgIC8vIOS4gOiIrOeahOafseeKtuWbvuWNoOavlCAxLzJcbiAgICByb3NlOiAwLjk5OTk5OTksXG4gICAgLy8g546r55Gw5Zu+5p+x54q25Y2g5q+UIDFcbiAgICBtdWx0aXBsZVBpZTogMSAvIDEuMyAvLyDlpJrlsYLnmoTppbzlm77jgIHnjq/lm75cblxuICB9LFxuICAvLyDmipjnur/lm77jgIHljLrln5/lm77jgIFwYXRoIOW9k+WPquacieS4gOS4quaVsOaNruaXtu+8jOaYr+WQpuaYvuekuuaIkOeCuVxuICBzaG93U2luZ2xlUG9pbnQ6IGZhbHNlLFxuICBjb25uZWN0TnVsbHM6IGZhbHNlLFxuICBzY2FsZXM6IHt9LFxuICByZWdpc3RlclRoZW1lOiBmdW5jdGlvbiByZWdpc3RlclRoZW1lKG5hbWUsIHRoZW1lKSB7XG4gICAgVGhlbWVbbmFtZV0gPSB0aGVtZTtcbiAgfSxcbiAgc2V0VGhlbWU6IGZ1bmN0aW9uIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgdmFyIG5ld1RoZW1lID0ge307XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdCh0aGVtZSkpIHtcbiAgICAgIG5ld1RoZW1lID0gdGhlbWU7XG4gICAgfSBlbHNlIGlmIChVdGlsLmluZGV4T2YoT2JqZWN0LmtleXMoVGhlbWUpLCB0aGVtZSkgIT09IC0xKSB7XG4gICAgICBuZXdUaGVtZSA9IFRoZW1lW3RoZW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3VGhlbWUgPSBUaGVtZS5kZWZhdWx0O1xuICAgIH1cblxuICAgIFV0aWwuZGVlcE1peChHbG9iYWwsIG5ld1RoZW1lKTtcbiAgfVxufTtcbkdsb2JhbC5zZXRUaGVtZSgnZGVmYXVsdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBHbG9iYWw7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfbWl4KGRpc3QsIG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaXN0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbn1cblxudmFyIG1peCA9IGZ1bmN0aW9uIG1peChkaXN0LCBzcmMxLCBzcmMyLCBzcmMzKSB7XG4gIGlmIChzcmMxKSBfbWl4KGRpc3QsIHNyYzEpO1xuICBpZiAoc3JjMikgX21peChkaXN0LCBzcmMyKTtcbiAgaWYgKHNyYzMpIF9taXgoZGlzdCwgc3JjMyk7XG4gIHJldHVybiBkaXN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaXg7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaVsOWtl1xuICogQHJldHVybiB7Qm9vbGVhbn0g5piv5ZCm5pWw5a2XXG4gKi9cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ051bWJlcicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICByZXR1cm4gaXNUeXBlKHN0ciwgJ1N0cmluZycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIOaYr+WQpuS4uuWHveaVsFxuICogQHBhcmFtICB7Kn0gZm4g5a+56LGhXG4gKiBAcmV0dXJuIHtCb29sZWFufSAg5piv5ZCm5Ye95pWwXG4gKi9cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdGdW5jdGlvbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNUeXBlID0gZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAvKipcbiAgICogaXNBcnJheUxpa2UoWzEsIDIsIDNdKSA9PiB0cnVlXG4gICAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pID0+IHRydWVcbiAgICogaXNBcnJheUxpa2UoJ2FiYycpID0+IHRydWVcbiAgICogaXNBcnJheUxpa2UoRnVuY3Rpb24pID0+IGZhbHNlXG4gICAqL1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIGlzRmluaXRlKHZhbHVlLmxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGT05UX0ZBTUlMWTogJ1wiLWFwcGxlLXN5c3RlbVwiLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLFwiSGVsdmV0aWNhIE5ldWVcIiwgSGVsdmV0aWNhLCBcIlBpbmdGYW5nIFNDXCIsIFwiSGlyYWdpbm8gU2FucyBHQlwiLCBcIk1pY3Jvc29mdCBZYUhlaVwiLFNpbVN1biwgXCJzYW5zLXNlcmlmXCInXG59O1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgSGVscGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTYpO1xuXG52YXIgQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5cbnZhciBLRVlXT1JEUyA9IFsnbWluJywgJ21heCcsICdtZWRpYW4nLCAnc3RhcnQnLCAnZW5kJ107XG5cbnZhciBHdWlkZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShHdWlkZSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gR3VpZGUoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEd1aWRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Db21wb25lbnQucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICB4U2NhbGVzOiBudWxsLFxuICAgICAgeVNjYWxlczogbnVsbCxcbiAgICAgIGVsOiBudWxsXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHt9O1xuICAvKipcbiAgICogY2xlYXIgY29udGFpbmVyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSBzZWxmLmdldCgnZWwnKTtcbiAgICBlbCAmJiBlbC5yZW1vdmUoKTtcbiAgfTtcbiAgLyoqXG4gICAqIHNob3cgb3IgaGlkZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSB0cnVlIG1lYW5zIHNob3csIGZhbHNlIG1lYW5zIGhpZGVcbiAgICovXG5cblxuICBfcHJvdG8uY2hhbmdlVmlzaWJsZSA9IGZ1bmN0aW9uIGNoYW5nZVZpc2libGUodmlzaWJsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnNldCgndmlzaWJsZScsIHZpc2libGUpO1xuICAgIHZhciBlbCA9IHNlbGYuZ2V0KCdlbCcpO1xuICAgIGlmICghZWwpIHJldHVybjtcblxuICAgIGlmIChlbC5zZXQpIHtcbiAgICAgIGVsLnNldCgndmlzaWJsZScsIHZpc2libGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgY2FudmFzIGNvb3JkaW5hdGUgdmFsdWVcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtDb29yZGluYXRlfSBjb29yZCAgdGhlIGluc3RhbmNlIG9mIENvb3JkaW5hdGUgY2xhc3NcbiAgICogQHBhcmFtICB7T2JqZWN0IHwgQXJyYXkgfCBGdW5jdGlvbn0gcG9zaXRpb24gdGhlIHZhbHVlIG5lZWQgdG8gY29udmVydFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybiB0aGUgcmVzdWx0XG4gICAqL1xuXG5cbiAgX3Byb3RvLnBhcnNlUG9pbnQgPSBmdW5jdGlvbiBwYXJzZVBvaW50KGNvb3JkLCBwb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgeFNjYWxlcyA9IHNlbGYuZ2V0KCd4U2NhbGVzJyk7XG4gICAgdmFyIHlTY2FsZXMgPSBzZWxmLmdldCgneVNjYWxlcycpO1xuXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24oeFNjYWxlcywgeVNjYWxlcyk7XG4gICAgfVxuXG4gICAgdmFyIHg7XG4gICAgdmFyIHk7IC8vIOWmguaenOaVsOaNruagvOW8j+aYryBbJzUwJScsICc1MCUnXSDnmoTmoLzlvI9cblxuICAgIGlmIChVdGlsLmlzQXJyYXkocG9zaXRpb24pICYmIFV0aWwuaXNTdHJpbmcocG9zaXRpb25bMF0pICYmIHBvc2l0aW9uWzBdLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVBlcmNlbnRQb2ludChjb29yZCwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChVdGlsLmlzQXJyYXkocG9zaXRpb24pKSB7XG4gICAgICAvLyBBcnJhee+8jHN1dXBvcnQgZm9yIG1peGluZyBvZiBrZXl3b3JkLCBwZXJjZW50IGFuZCB2YWx1ZVxuICAgICAgeCA9IHNlbGYuX2dldE5vcm1hbGl6ZWRWYWx1ZShwb3NpdGlvblswXSwgSGVscGVyLmdldEZpcnN0U2NhbGUoeFNjYWxlcykpO1xuICAgICAgeSA9IHNlbGYuX2dldE5vcm1hbGl6ZWRWYWx1ZShwb3NpdGlvblsxXSwgSGVscGVyLmdldEZpcnN0U2NhbGUoeVNjYWxlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBmaWVsZCBpbiBwb3NpdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBwb3NpdGlvbltmaWVsZF07XG5cbiAgICAgICAgaWYgKHhTY2FsZXNbZmllbGRdKSB7XG4gICAgICAgICAgeCA9IHNlbGYuX2dldE5vcm1hbGl6ZWRWYWx1ZSh2YWx1ZSwgeFNjYWxlc1tmaWVsZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlTY2FsZXNbZmllbGRdKSB7XG4gICAgICAgICAgeSA9IHNlbGYuX2dldE5vcm1hbGl6ZWRWYWx1ZSh2YWx1ZSwgeVNjYWxlc1tmaWVsZF0sICd5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIVV0aWwuaXNOaWwoeCkgJiYgIVV0aWwuaXNOaWwoeSkpIHtcbiAgICAgIHJldHVybiBjb29yZC5jb252ZXJ0KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogTm9ybWFsaXplZCB0aGUgdmFsdWVcbiAgICogQHBhcmFtICB7U3RyaW5nIHwgTnVtYmVyfSB2YWwgICBwYXJhbVxuICAgKiBAcGFyYW0gIHtTY2FsZX0gc2NhbGUgdGhlIGluc3RhbmNlIG9mIFNjYWxlXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgcmV0dXJuIHRoZSBub3JtYWxpemVkIHZhbHVlXG4gICAqL1xuXG5cbiAgX3Byb3RvLl9nZXROb3JtYWxpemVkVmFsdWUgPSBmdW5jdGlvbiBfZ2V0Tm9ybWFsaXplZFZhbHVlKHZhbCwgc2NhbGUpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKFV0aWwuaW5kZXhPZihLRVlXT1JEUywgdmFsKSAhPT0gLTEpIHtcbiAgICAgIC8vIGtleXdvcmRcbiAgICAgIHZhciBzY2FsZVZhbHVlO1xuXG4gICAgICBpZiAodmFsID09PSAnc3RhcnQnKSB7XG4gICAgICAgIC8vIHRoZSBzdGFydCBvZiBjb29yZGluYXRlXG4gICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsID09PSAnbWVkaWFuJykge1xuICAgICAgICBzY2FsZVZhbHVlID0gc2NhbGUuaXNDYXRlZ29yeSA/IChzY2FsZS52YWx1ZXMubGVuZ3RoIC0gMSkgLyAyIDogKHNjYWxlLm1pbiArIHNjYWxlLm1heCkgLyAyO1xuICAgICAgICByZXN1bHQgPSBzY2FsZS5zY2FsZShzY2FsZVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzY2FsZS5pc0NhdGVnb3J5KSB7XG4gICAgICAgICAgc2NhbGVWYWx1ZSA9IHZhbCA9PT0gJ21pbicgPyAwIDogc2NhbGUudmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGVWYWx1ZSA9IHNjYWxlW3ZhbF07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzY2FsZS5zY2FsZShzY2FsZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8g5pWw5YC8XG4gICAgICByZXN1bHQgPSBzY2FsZS5zY2FsZSh2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVBlcmNlbnRQb2ludCA9IGZ1bmN0aW9uIF9wYXJzZVBlcmNlbnRQb2ludChjb29yZCwgcG9zaXRpb24pIHtcbiAgICB2YXIgeFBlcmNlbnQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uWzBdKSAvIDEwMDtcbiAgICB2YXIgeVBlcmNlbnQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uWzFdKSAvIDEwMDtcbiAgICB2YXIgc3RhcnQgPSBjb29yZC5zdGFydCxcbiAgICAgICAgZW5kID0gY29vcmQuZW5kO1xuICAgIHZhciB0b3BMZWZ0ID0ge1xuICAgICAgeDogTWF0aC5taW4oc3RhcnQueCwgZW5kLngpLFxuICAgICAgeTogTWF0aC5taW4oc3RhcnQueSwgZW5kLnkpXG4gICAgfTtcbiAgICB2YXIgeCA9IGNvb3JkLndpZHRoICogeFBlcmNlbnQgKyB0b3BMZWZ0Lng7XG4gICAgdmFyIHkgPSBjb29yZC5oZWlnaHQgKiB5UGVyY2VudCArIHRvcExlZnQueTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBHdWlkZTtcbn0oQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHdWlkZTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEc7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1peCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBTY2FsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENmZygpIHtcbiAgICB0aGlzLnR5cGUgPSAnYmFzZSc7XG4gICAgLyoqXG4gICAgICog5qC85byP5YyW5Ye95pWwLOi+k+WHuuaWh+acrOaIluiAhXRpY2vml7bnmoTmoLzlvI/ljJblh73mlbBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG5cbiAgICB0aGlzLmZvcm1hdHRlciA9IG51bGw7XG4gICAgLyoqXG4gICAgICog6L6T5Ye655qE5YC85Z+fXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICAvKipcbiAgICAgKiDluqbph4/nmoTmoIforrBcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiDlj4LkuI7luqbph4/orqHnrpfnmoTlgLzvvIzlj6/pgInpoblcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNjYWxlKGNmZykge1xuICAgIHRoaXMuX2luaXREZWZhdWx0Q2ZnKCk7XG5cbiAgICBtaXgodGhpcywgY2ZnKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICAvKipcbiAgICog5bqm6YeP5Yid5aeL5YyWXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7fTtcbiAgLyoqXG4gICAqIOiOt+WPluivpeW6pumHj+eahHRpY2tzLOi/lOWbnueahOaYr+WkmuS4quWvueixoe+8jFxuICAgKiAgIC0gdGV4dDogdGljayDnmoTmlofmnKxcbiAgICogICAtIHZhbHVlOiDlr7nlupTnmoTluqbph4/ovazmjaLlkI7nmoTlgLxcbiAgICogPGNvZGU+XG4gICAqICAgW1xuICAgKiAgICAge3RleHQ6IDAsdmFsdWU6MH1cbiAgICogICAgIHt0ZXh0OiAxLHZhbHVlOjAuMn1cbiAgICogICAgIHt0ZXh0OiAyLHZhbHVlOjAuNH1cbiAgICogICAgIHt0ZXh0OiAzLHZhbHVlOjAuNn1cbiAgICogICAgIHt0ZXh0OiA0LHZhbHVlOjAuOH1cbiAgICogICAgIHt0ZXh0OiA1LHZhbHVlOjF9XG4gICAqICAgXVxuICAgKiA8L2NvZGU+XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCDovpPlh7p0aWNr55qE5Liq5pWw55qE6L+R5Ly85YC877yM6buY6K6k5pivIDEwXG4gICAqIEByZXR1cm4ge0FycmF5fSDov5Tlm54gdGlja3Mg5pWw57uEXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRpY2tzID0gZnVuY3Rpb24gZ2V0VGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrcyA9IHNlbGYudGlja3M7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgb2JqO1xuXG4gICAgICBpZiAoaXNPYmplY3QodGljaykpIHtcbiAgICAgICAgb2JqID0gdGljaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICB0ZXh0OiBzZWxmLmdldFRleHQodGljayksXG4gICAgICAgICAgdGlja1ZhbHVlOiB0aWNrLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLnNjYWxlKHRpY2spXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJzdC5wdXNoKG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcbiAgLyoqXG4gICAqIOiOt+WPluagvOW8j+WMluWQjueahOaWh+acrFxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZSDovpPlhaXnmoTmlbDmja5cbiAgICogQHBhcmFtICB7Kn0ga2V5IOWtl+auteeahCBrZXlcbiAgICogQHJldHVybiB7U3RyaW5nfSDmoLzlvI/ljJbnmoTmlofmnKxcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQodmFsdWUsIGtleSkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmZvcm1hdHRlcjtcbiAgICB2YWx1ZSA9IGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuXG4gICAgaWYgKGlzTmlsKHZhbHVlKSB8fCAhdmFsdWUudG9TdHJpbmcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH07XG4gIC8qKlxuICAgKiDovpPlh7rnmoTlgLzln5/mnIDlsI/lgLxcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IOi/lOWbnuacgOWwj+eahOWAvFxuICAgKi9cblxuXG4gIF9wcm90by5yYW5nZU1pbiA9IGZ1bmN0aW9uIHJhbmdlTWluKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlWzBdO1xuICB9O1xuICAvKipcbiAgICog6L6T5Ye655qE5YC85Z+f5pyA5aSn5YC8XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7TnVtYmVyfSDov5Tlm57mnIDlpKfnmoTlgLxcbiAgICovXG5cblxuICBfcHJvdG8ucmFuZ2VNYXggPSBmdW5jdGlvbiByYW5nZU1heCgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHJldHVybiByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcbiAgfTtcbiAgLyoqXG4gICAqIOW6pumHj+i9rOaNouWQjueahOe7k+aenO+8jOe/u+i9rOWbnui+k+WFpeWfn1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIOmcgOimgee/u+i9rOeahOaVsOWAvFxuICAgKiBAcmV0dXJuIHsqfSDluqbph4/nmoTovpPlhaXlgLxcbiAgICovXG5cblxuICBfcHJvdG8uaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICAvKipcbiAgICog5bCG5Lyg5YWl55qE5YC85LuO6Z2e5pWw5YC86L2s5o2i5oiQ5pWw5YC85qC85byP77yM5aaC5YiG57G75a2X56ym5Liy44CB5pe26Ze05a2X56ym5Liy562JXG4gICAqIEBwYXJhbSAgeyp9IHZhbHVlIOS8oOWFpeeahOWAvFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IOi9rOaNoueahOWAvFxuICAgKi9cblxuXG4gIF9wcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiDov5vooYzluqbph4/ovazmjaJcbiAgICogQHBhcmFtICB7Kn0gdmFsdWUg6L6T5YWl5YC8XG4gICAqIEByZXR1cm4ge051bWJlcn0g6L6T5Ye65YC877yM5Zyo6K6+5a6a55qE6L6T5Ye65YC85Z+f5LmL6Ze077yM6buY6K6kWzAsMV1cbiAgICovXG5cblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIOWFi+mahuS4gOS4quaWsOeahHNjYWxlLOaLpeaciei3n+W9k+WJjXNjYWxl55u45ZCM55qE6L6T5YWl5Z+f44CB6L6T5Ye65Z+f562JXG4gICAqIEByZXR1cm4ge1NjYWxlfSDlhYvpmobnmoTluqbph49cbiAgICovXG5cblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbnN0ciA9IHNlbGYuY29uc3RydWN0b3I7XG4gICAgdmFyIGNmZyA9IHt9O1xuICAgIGVhY2goc2VsZiwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGNmZ1trXSA9IHNlbGZba107XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBjb25zdHIoY2ZnKTtcbiAgfTtcbiAgLyoqXG4gICAqIOabtOaUueW6pumHj+eahOWxnuaAp+S/oeaBr1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGluZm8g5bGe5oCn5L+h5oGvXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHJldHVybiB7U2NhbGV9IOi/lOWbnuiHqui6q+eahOW8leeUqFxuICAgKi9cblxuXG4gIF9wcm90by5jaGFuZ2UgPSBmdW5jdGlvbiBjaGFuZ2UoaW5mbykge1xuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIG1peCh0aGlzLCBpbmZvKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gU2NhbGU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOW3peWOguexu++8jOeuoeeQhuWQhOenjeexu+Wei+eahCBzaGFwZVxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFBhdGhVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBHUGF0aCA9IFV0aWwuUGF0aFV0aWw7XG52YXIgU2hhcGUgPSB7fTtcbnZhciBTaGFwZUJhc2UgPSB7XG4gIF9jb29yZDogbnVsbCxcblxuICAvKipcbiAgICog57uY5Yi25Zu+5b2iXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcg6YWN572u6aG5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXIg5a655ZmoXG4gICAqIEByZXR1cm4ge09iamVjdH0gc2hhcGUg5Yib5bu655qEIHNoYXBlXG4gICAqL1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgaWYgKHRoaXMuZHJhd1NoYXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUoY2ZnLCBjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jliLblm77lvaLpnIDopoHnmoTngrksIOWPr+S7peS4jeWumuS5ie+8jOWImeS9v+eUqOm7mOiupOeahFxuICBnZXRQb2ludHMoY2ZnKSB7XG4gICAgaWYgKHRoaXMuZ2V0U2hhcGVQb2ludHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNoYXBlUG9pbnRzKGNmZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCovXG5cbiAgLyoqXG4gICAqIOiuvue9ruWdkOagh+ezu1xuICAgKiBAcGFyYW0ge0Nvb3JkfSBjb29yZCDlnZDmoIfns7tcbiAgICovXG4gIHNldENvb3JkOiBmdW5jdGlvbiBzZXRDb29yZChjb29yZCkge1xuICAgIHRoaXMuX2Nvb3JkID0gY29vcmQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIDDvvZ4xIHBhdGgg6L2sIOeUu+W4gyBwYXRoXG4gICAqIEBwYXJhbSAge3BhdGh9IHBhdGgg6Lev5b6EXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzbGluZVRvQXJjIOaYr+WQpui9rOaNouaIkOWchuW8p1xuICAgKiBAcmV0dXJuIHtwYXRofSBwYXRoIOi9rOaNouWIsOeUu+W4g+WdkOagh+eahHBhdGhcbiAgICovXG4gIHBhcnNlUGF0aDogZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIGlzbGluZVRvQXJjKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5fY29vcmQ7XG4gICAgcGF0aCA9IEdQYXRoLnBhcnNlUGF0aFN0cmluZyhwYXRoKTtcblxuICAgIGlmIChjb29yZC5pc1BvbGFyICYmIGlzbGluZVRvQXJjICE9PSBmYWxzZSkge1xuICAgICAgcGF0aCA9IFBhdGhVdGlsLmNvbnZlcnRQb2xhclBhdGgoY29vcmQsIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gUGF0aFV0aWwuY29udmVydE5vcm1hbFBhdGgoY29vcmQsIHBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiAw772eMSBwb2ludCDovawg55S75biDIHBvaW50XG4gICAqIEBwYXJhbSAge3BvaW50fSBwb2ludCDoioLngrlcbiAgICogQHJldHVybiB7cG9pbnR9IHBvaW50IOi9rOaNouWQjueahOeCuVxuICAgKi9cbiAgcGFyc2VQb2ludDogZnVuY3Rpb24gcGFyc2VQb2ludChwb2ludCkge1xuICAgIHZhciBjb29yZCA9IHRoaXMuX2Nvb3JkO1xuICAgIHJldHVybiBjb29yZC5jb252ZXJ0UG9pbnQocG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAw772eMSBwb2ludHMg6L2sIOeUu+W4gyBwb2ludHNcbiAgICogQHBhcmFtICB7cG9pbnRzfSBwb2ludHMg6IqC54K56ZuG5ZCIXG4gICAqIEByZXR1cm4ge3BvaW50c30gcG9pbnRzIOi9rOaNouWQjueahOWkmuS4quiKgueCuVxuICAgKi9cbiAgcGFyc2VQb2ludHM6IGZ1bmN0aW9uIHBhcnNlUG9pbnRzKHBvaW50cykge1xuICAgIHZhciBjb29yZCA9IHRoaXMuX2Nvb3JkO1xuICAgIHZhciByc3QgPSBbXTtcbiAgICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJzdC5wdXNoKGNvb3JkLmNvbnZlcnRQb2ludChwb2ludCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH1cbn07XG52YXIgU2hhcGVGYWN0b3J5QmFzZSA9IHtcbiAgZGVmYXVsdFNoYXBlVHlwZTogbnVsbCxcbiAgc2V0Q29vcmQ6IGZ1bmN0aW9uIHNldENvb3JkKGNvb3JkKSB7XG4gICAgdGhpcy5fY29vcmQgPSBjb29yZDtcbiAgfSxcbiAgZ2V0U2hhcGU6IGZ1bmN0aW9uIGdldFNoYXBlKHR5cGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gdHlwZVswXTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBzZWxmW3R5cGVdIHx8IHNlbGZbc2VsZi5kZWZhdWx0U2hhcGVUeXBlXTtcbiAgICBzaGFwZS5fY29vcmQgPSBzZWxmLl9jb29yZDtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH0sXG4gIGdldFNoYXBlUG9pbnRzOiBmdW5jdGlvbiBnZXRTaGFwZVBvaW50cyh0eXBlLCBjZmcpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLmdldFNoYXBlKHR5cGUpO1xuICAgIHZhciBmbiA9IHNoYXBlLmdldFBvaW50cyB8fCBzaGFwZS5nZXRTaGFwZVBvaW50cyB8fCB0aGlzLmdldERlZmF1bHRQb2ludHM7XG4gICAgdmFyIHBvaW50cyA9IGZuKGNmZyk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cygpXG4gIC8qIGNmZyAqL1xuICB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyh0eXBlLCBjZmcpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLmdldFNoYXBlKHR5cGUpO1xuXG4gICAgaWYgKCFzaGFwZS5nZXRNYXJrZXJDZmcpIHtcbiAgICAgIHZhciBkZWZhdWx0U2hhcGVUeXBlID0gdGhpcy5kZWZhdWx0U2hhcGVUeXBlO1xuICAgICAgc2hhcGUgPSB0aGlzLmdldFNoYXBlKGRlZmF1bHRTaGFwZVR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZS5nZXRNYXJrZXJDZmcoY2ZnKTtcbiAgfSxcbiAgZ2V0U2VsZWN0ZWRDZmc6IGZ1bmN0aW9uIGdldFNlbGVjdGVkQ2ZnKClcbiAgLyogdHlwZSwgY2ZnICovXG4gIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGRyYXdTaGFwZTogZnVuY3Rpb24gZHJhd1NoYXBlKHR5cGUsIGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5nZXRTaGFwZSh0eXBlKTtcbiAgICB2YXIgZ1NoYXBlID0gc2hhcGUuZHJhdyhjZmcsIGNvbnRhaW5lcik7XG5cbiAgICBpZiAoZ1NoYXBlKSB7XG4gICAgICBnU2hhcGUuc2V0U2lsZW50KCdvcmlnaW4nLCBjZmcub3JpZ2luKTtcbiAgICAgIGdTaGFwZS5faWQgPSBjZmcueUluZGV4ID8gY2ZnLl9pZCArIGNmZy55SW5kZXggOiBjZmcuX2lkO1xuICAgICAgZ1NoYXBlLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdTaGFwZTtcbiAgfVxufTsgLy8g5rOo5YaMIEdlb21ldHJ5IOiOt+WPluWbvuW9oueahOWFpeWPo1xuXG5TaGFwZS5yZWdpc3RlckZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeU5hbWUsIGNmZykge1xuICB2YXIgY2xhc3NOYW1lID0gVXRpbC51cHBlckZpcnN0KGZhY3RvcnlOYW1lKTtcbiAgdmFyIGdlb21PYmogPSBVdGlsLmFzc2lnbih7fSwgU2hhcGVGYWN0b3J5QmFzZSwgY2ZnKTtcbiAgU2hhcGVbY2xhc3NOYW1lXSA9IGdlb21PYmo7XG4gIGdlb21PYmoubmFtZSA9IGZhY3RvcnlOYW1lO1xuICByZXR1cm4gZ2VvbU9iajtcbn07IC8vIOazqOWGjOWbvuW9olxuXG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUgPSBmdW5jdGlvbiAoZmFjdG9yeU5hbWUsIHNoYXBlVHlwZSwgY2ZnKSB7XG4gIHZhciBjbGFzc05hbWUgPSBVdGlsLnVwcGVyRmlyc3QoZmFjdG9yeU5hbWUpO1xuICB2YXIgZmFjdG9yeSA9IFNoYXBlW2NsYXNzTmFtZV07XG4gIHZhciBzaGFwZU9iaiA9IFV0aWwuYXNzaWduKHt9LCBTaGFwZUJhc2UsIGNmZyk7XG4gIGZhY3Rvcnlbc2hhcGVUeXBlXSA9IHNoYXBlT2JqO1xuICByZXR1cm4gc2hhcGVPYmo7XG59OyAvLyDojrflvpdHZW9tIOWvueW6lOeahCBzaGFwZUZhY3RvcnlcblxuXG5TaGFwZS5nZXRTaGFwZUZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeU5hbWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmYWN0b3J5TmFtZSA9IGZhY3RvcnlOYW1lIHx8ICdwb2ludCc7XG4gIHZhciBjbGFzc05hbWUgPSBVdGlsLnVwcGVyRmlyc3QoZmFjdG9yeU5hbWUpO1xuICByZXR1cm4gc2VsZltjbGFzc05hbWVdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NyY19jb2xvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcmNfY29sb3JfX1tcImVcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX2NvbG9yX19bXCJnXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NyY19jb2xvcl9fW1wiZlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfbGFiX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMyk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfbGFiX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY19sYWJfX1tcImJcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc3JjX2N1YmVoZWxpeF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc3JjX2N1YmVoZWxpeF9fW1wiYVwiXTsgfSk7XG5cblxuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg5omA5pyJIEdlb21ldHJ5IOeahOWfuuexu1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBBdHRyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbnZhciBBZGp1c3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5Nyk7XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgTGFiZWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDUpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIFRvb2x0aXBNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzM3KTtcblxudmFyIEFjdGl2ZU1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzgpO1xuXG52YXIgU2VsZWN0TWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzOSk7XG5cbnZhciBwYXJzZUZpZWxkcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQwKTtcblxudmFyIEdST1VQX0FUVFJTID0gWydjb2xvcicsICdzaGFwZScsICdzaXplJ107XG52YXIgRklFTERfT1JJR0lOID0gJ19vcmlnaW4nOyAvLyDovazmjaLmiJDlr7nosaHnmoTmlbDnu4QgW3t0eXBlOiAnYWRqdXN0J31dXG5cbmZ1bmN0aW9uIHBhcnNlQWRqdXN0cyhhZGp1c3RzKSB7XG4gIC8vIOWmguaenOaYr+Wtl+espuS4suaIluiAheWvueixoei9rOaNouaIkOaVsOe7hFxuICBpZiAoVXRpbC5pc1N0cmluZyhhZGp1c3RzKSB8fCBVdGlsLmlzUGxhaW5PYmplY3QoYWRqdXN0cykpIHtcbiAgICBhZGp1c3RzID0gW2FkanVzdHNdO1xuICB9XG5cbiAgVXRpbC5lYWNoKGFkanVzdHMsIGZ1bmN0aW9uIChhZGp1c3QsIGluZGV4KSB7XG4gICAgaWYgKCFVdGlsLmlzT2JqZWN0KGFkanVzdCkpIHtcbiAgICAgIGFkanVzdHNbaW5kZXhdID0ge1xuICAgICAgICB0eXBlOiBhZGp1c3RcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFkanVzdHM7XG59XG4vKipcbiAqIOWHoOS9leagh+iusFxuICogQGNsYXNzIEdlb21cbiAqL1xuXG5cbnZhciBHZW9tQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoR2VvbUJhc2UsIF9CYXNlKTtcblxuICB2YXIgX3Byb3RvID0gR2VvbUJhc2UucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIOagh+iusCBfaWQg55So5LqO5Yy65YiG5omn6KGM5Yqo55S7XG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBfaWQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0eXBlOiAnYmFzZScsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Z2Q5qCH57O7XG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBjb29yZDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlsZ7mgKfmmKDlsITpm4ZcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGF0dHJzOiB7fSxcblxuICAgICAgLyoqXG4gICAgICAgKiDmiYDlsZ7nmoRWaWV3XG4gICAgICAgKiBAdHlwZSB7Vmlld31cbiAgICAgICAqL1xuICAgICAgdmlldzogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlh6DkvZXmoIforrDmmL7npLrnmoTmlbDmja5cbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgZGF0YTogW10sXG5cbiAgICAgIC8qKlxuICAgICAgICog55u45YWz55qE5bqm6YePXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzY2FsZXM6IHt9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOe7mOWbvuWuueWZqFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaWh+acrOWuueWZqFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgbGFiZWxDb250YWluZXI6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5b2i5a655ZmoXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzaGFwZUNvbnRhaW5lcjogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlh6DkvZXmoIforrDnmoTkuIDkupvphY3nva7pobnvvIznlKjkuo7lu7bov5/nlJ/miJDlm77ooahcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGF0dHJPcHRpb25zOiB7fSxcbiAgICAgIC8vIOagt+W8j+mFjee9rumhuVxuICAgICAgc3R5bGVPcHRpb25zOiBudWxsLFxuICAgICAgLy8g6YCJ5Lit5pe255qE6YWN572u6aG5XG4gICAgICBzZWxlY3RlZE9wdGlvbnM6IG51bGwsXG4gICAgICAvLyBhY3RpdmUg5pe255qE6YWN572u6aG5XG4gICAgICBhY3RpdmVkT3B0aW9uczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDmn5DkupvnsbvlrZjlnKjpu5jorqTnmoRhZGp1c3TvvIzkuI3og73mm7TmlLkgYWRqdXN0XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaGFzRGVmYXVsdEFkanVzdDogZmFsc2UsXG4gICAgICAvLyDmlbDmja7osIPmlbTnsbvlnotcbiAgICAgIGFkanVzdHM6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5L2/55So5b2i54q255qE57G75Z6LXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBzaGFwZVR5cGU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5piv5ZCm55Sf5oiQ5aSa5Liq54K55p2l57uY5Yi25Zu+5b2iXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgZ2VuZXJhdGVQb2ludHM6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaVsOaNruaYr+WQpui/m+ihjOaOkuW6j1xuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHNvcnRhYmxlOiBmYWxzZSxcbiAgICAgIGxhYmVsQ2ZnOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpuWFseS6qyB0b29sdGlwXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgc2hhcmVUb29sdGlwOiB0cnVlLFxuICAgICAgdG9vbHRpcENmZzogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDmmK/lkKbmiafooYzliqjnlLvvvIzpu5jorqTmiafooYxcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBhbmltYXRlOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWKqOeUu+mFjee9rlxuICAgICAgICogQHR5cGUge1t0eXBlXX1cbiAgICAgICAqL1xuICAgICAgYW5pbWF0ZUNmZzogbnVsbCxcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEdlb21CYXNlKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgX3RoaXMudmlld1RoZW1lID0gX3RoaXMuZ2V0KCd2aWV3VGhlbWUnKTtcbiAgICBVdGlsLmFzc2lnbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgVG9vbHRpcE1peGluLCBBY3RpdmVNaXhpbiwgU2VsZWN0TWl4aW4pO1xuXG4gICAgaWYgKF90aGlzLmdldCgnY29udGFpbmVyJykpIHtcbiAgICAgIF90aGlzLl9pbml0Q29udGFpbmVyKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2luaXRPcHRpb25zKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8g5Yid5aeL5YyW5pe25a+56YWN572u6aG555qE5qC85byP5YyWXG5cblxuICBfcHJvdG8uX2luaXRPcHRpb25zID0gZnVuY3Rpb24gX2luaXRPcHRpb25zKCkge1xuICAgIHZhciBhZGp1c3RzID0gdGhpcy5nZXQoJ2FkanVzdHMnKTtcblxuICAgIGlmIChhZGp1c3RzKSB7XG4gICAgICBhZGp1c3RzID0gcGFyc2VBZGp1c3RzKGFkanVzdHMpO1xuICAgICAgdGhpcy5zZXQoJ2FkanVzdHMnLCBhZGp1c3RzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jcmVhdGVTY2FsZSA9IGZ1bmN0aW9uIF9jcmVhdGVTY2FsZShmaWVsZCwgZGF0YSkge1xuICAgIHZhciBzY2FsZXMgPSB0aGlzLmdldCgnc2NhbGVzJyk7XG4gICAgdmFyIHNjYWxlID0gc2NhbGVzW2ZpZWxkXTtcblxuICAgIGlmICghc2NhbGUpIHtcbiAgICAgIHNjYWxlID0gdGhpcy5nZXQoJ3ZpZXcnKS5jcmVhdGVTY2FsZShmaWVsZCwgZGF0YSk7XG4gICAgICBzY2FsZXNbZmllbGRdID0gc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIF9wcm90by5fc2V0QXR0ck9wdGlvbnMgPSBmdW5jdGlvbiBfc2V0QXR0ck9wdGlvbnMoYXR0ck5hbWUsIGF0dHJDZmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdhdHRyT3B0aW9ucycpO1xuICAgIG9wdGlvbnNbYXR0ck5hbWVdID0gYXR0ckNmZztcbiAgfTtcblxuICBfcHJvdG8uX2NyZWF0ZUF0dHJPcHRpb24gPSBmdW5jdGlvbiBfY3JlYXRlQXR0ck9wdGlvbihhdHRyTmFtZSwgZmllbGQsIGNmZywgZGVmYXVsdFZhbHVlcykge1xuICAgIHZhciBhdHRyQ2ZnID0ge307XG4gICAgYXR0ckNmZy5maWVsZCA9IGZpZWxkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjZmcpKSB7XG4gICAgICAgIGF0dHJDZmcuY2FsbGJhY2sgPSBjZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyQ2ZnLnZhbHVlcyA9IGNmZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lICE9PSAnY29sb3InKSB7XG4gICAgICBhdHRyQ2ZnLnZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QXR0ck9wdGlvbnMoYXR0ck5hbWUsIGF0dHJDZmcpO1xuICB9O1xuICAvKipcbiAgICog5L2N572u5bGe5oCn5pig5bCEXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZCDlrZfmrrXlkI1cbiAgICogQHJldHVybiB7R2VvbX0gZ2VvbSDlvZPliY3lh6DkvZXmoIforrBcbiAgICovXG5cblxuICBfcHJvdG8ucG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbihmaWVsZCkge1xuICAgIHRoaXMuX3NldEF0dHJPcHRpb25zKCdwb3NpdGlvbicsIHtcbiAgICAgIGZpZWxkOiBmaWVsZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiDpopzoibLlsZ7mgKfmmKDlsIRcbiAgICogQGNoYWluYWJsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkIOWtl+auteWQjVxuICAgKiBAcGFyYW0gIHtBcnJheXxGdW5jdGlvbn0gdmFsdWVzIOminOiJsueahOaVsOe7hOaIluiAheWbnuiwg+WHveaVsFxuICAgKiBAcmV0dXJuIHtHZW9tfSBnZW9tIOW9k+WJjeWHoOS9leagh+iusFxuICAgKi9cblxuXG4gIF9wcm90by5jb2xvciA9IGZ1bmN0aW9uIGNvbG9yKGZpZWxkLCB2YWx1ZXMpIHtcbiAgICB2YXIgdmlld1RoZW1lID0gdGhpcy52aWV3VGhlbWUgfHwgR2xvYmFsO1xuXG4gICAgdGhpcy5fY3JlYXRlQXR0ck9wdGlvbignY29sb3InLCBmaWVsZCwgdmFsdWVzLCB2aWV3VGhlbWUuY29sb3JzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog5aSn5bCP5bGe5oCn5pig5bCEXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZCDlrZfmrrXlkI1cbiAgICogQHBhcmFtICB7QXJyYXl8RnVuY3Rpb259IHZhbHVlcyDlpKflsI/nmoTmlbDnu4TmiJbogIXlm57osIPlh73mlbBcbiAgICogQHJldHVybiB7R2VvbX0gZ2VvbSDlvZPliY3lh6DkvZXmoIforrBcbiAgICovXG5cblxuICBfcHJvdG8uc2l6ZSA9IGZ1bmN0aW9uIHNpemUoZmllbGQsIHZhbHVlcykge1xuICAgIHZhciB2aWV3VGhlbWUgPSB0aGlzLnZpZXdUaGVtZSB8fCBHbG9iYWw7XG5cbiAgICB0aGlzLl9jcmVhdGVBdHRyT3B0aW9uKCdzaXplJywgZmllbGQsIHZhbHVlcywgdmlld1RoZW1lLnNpemVzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog5b2i54q25bGe5oCn5pig5bCEXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZCDlrZfmrrXlkI1cbiAgICogQHBhcmFtICB7QXJyYXl8RnVuY3Rpb259IHZhbHVlcyDlpKflsI/nmoTmlbDnu4TmiJbogIXlm57osIPlh73mlbBcbiAgICogQHJldHVybiB7R2VvbX0gZ2VvbSDlvZPliY3lh6DkvZXmoIforrBcbiAgICovXG5cblxuICBfcHJvdG8uc2hhcGUgPSBmdW5jdGlvbiBzaGFwZShmaWVsZCwgdmFsdWVzKSB7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHRoaXMudmlld1RoZW1lIHx8IEdsb2JhbDtcbiAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIHNoYXBlcyA9IHZpZXdUaGVtZS5zaGFwZXNbdHlwZV0gfHwgW107XG5cbiAgICB0aGlzLl9jcmVhdGVBdHRyT3B0aW9uKCdzaGFwZScsIGZpZWxkLCB2YWx1ZXMsIHNoYXBlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIOmAj+aYjuW6puWxnuaAp+aYoOWwhFxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmllbGQg5a2X5q615ZCNXG4gICAqIEBwYXJhbSAge0FycmF5fEZ1bmN0aW9ufSB2YWx1ZXMg6YCP5piO5bqm55qE5pWw57uE5oiW6ICF5Zue6LCD5Ye95pWwXG4gICAqIEByZXR1cm4ge0dlb219IGdlb20g5b2T5YmN5Yeg5L2V5qCH6K6wXG4gICAqL1xuXG5cbiAgX3Byb3RvLm9wYWNpdHkgPSBmdW5jdGlvbiBvcGFjaXR5KGZpZWxkLCB2YWx1ZXMpIHtcbiAgICB2YXIgdmlld1RoZW1lID0gdGhpcy52aWV3VGhlbWUgfHwgR2xvYmFsO1xuXG4gICAgdGhpcy5fY3JlYXRlQXR0ck9wdGlvbignb3BhY2l0eScsIGZpZWxkLCB2YWx1ZXMsIHZpZXdUaGVtZS5vcGFjaXRpZXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnN0eWxlID0gZnVuY3Rpb24gc3R5bGUoZmllbGQsIGNmZykge1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSB0aGlzLmdldCgnc3R5bGVPcHRpb25zJyk7XG5cbiAgICBpZiAoIXN0eWxlT3B0aW9ucykge1xuICAgICAgc3R5bGVPcHRpb25zID0ge307XG4gICAgICB0aGlzLnNldCgnc3R5bGVPcHRpb25zJywgc3R5bGVPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgIGNmZyA9IGZpZWxkO1xuICAgICAgZmllbGQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBmaWVsZHM7XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGZpZWxkcyA9IHBhcnNlRmllbGRzKGZpZWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZU9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuICAgIHN0eWxlT3B0aW9ucy5zdHlsZSA9IGNmZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ubGFiZWwgPSBmdW5jdGlvbiBsYWJlbChmaWVsZCwgY2FsbGJhY2ssIGNmZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGFiZWxDZmcgPSBzZWxmLmdldCgnbGFiZWxDZmcnKTsgLy8gY29uc3Qgc2NhbGVzID0gVXRpbC5tYXAoc2VsZi5nZXQoJ2xhYmVsQ2ZnJykuZmllbGRzLCBmaWVsZCA9PiBzZWxmLl9jcmVhdGVTY2FsZShmaWVsZCkpO1xuXG4gICAgaWYgKCFsYWJlbENmZykge1xuICAgICAgbGFiZWxDZmcgPSB7fTtcbiAgICAgIHNlbGYuc2V0KCdsYWJlbENmZycsIGxhYmVsQ2ZnKTtcbiAgICB9XG5cbiAgICB2YXIgZmllbGRzO1xuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICBmaWVsZHMgPSBwYXJzZUZpZWxkcyhmaWVsZCk7XG4gICAgfVxuXG4gICAgbGFiZWxDZmcuZmllbGRzID0gZmllbGRzOyAvLyDlpoLmnpzlrZjlnKjlm57osIPlh73mlbBcblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICBpZiAoIWNmZykge1xuICAgICAgICBjZmcgPSB7fTtcbiAgICAgIH1cblxuICAgICAgbGFiZWxDZmcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNPYmplY3QoY2FsbGJhY2spKSB7XG4gICAgICAvLyDlpoLmnpzmsqHmnInorr7nva7lm57osIPlh73mlbBcbiAgICAgIGNmZyA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGxhYmVsQ2ZnLmdsb2JhbENmZyA9IGNmZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udG9vbHRpcCA9IGZ1bmN0aW9uIHRvb2x0aXAoZmllbGQsIGNmZykge1xuICAgIHZhciB0b29sdGlwQ2ZnID0gdGhpcy5nZXQoJ3Rvb2x0aXBDZmcnKTtcblxuICAgIGlmICghdG9vbHRpcENmZykge1xuICAgICAgdG9vbHRpcENmZyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChmaWVsZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGdlb20g5YWz6ZetIHRvb2x0aXBcbiAgICAgIHRoaXMuc2V0KCd0b29sdGlwQ2ZnJywgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdG9vbHRpcEZpZWxkcztcblxuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIHRvb2x0aXBGaWVsZHMgPSBwYXJzZUZpZWxkcyhmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHRvb2x0aXBDZmcuZmllbGRzID0gdG9vbHRpcEZpZWxkcztcbiAgICAgIHRvb2x0aXBDZmcuY2ZnID0gY2ZnO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCd0b29sdGlwQ2ZnJywgdG9vbHRpcENmZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGNmZykge1xuICAgIHRoaXMuc2V0KCdhbmltYXRlQ2ZnJywgY2ZnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIOaYr+WQpuWFgeiuuOS9v+eUqOm7mOiupOeahOWbvuW9oua/gOa0u+S6pOS6klxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBlbmFibGUg5piv5ZCm5YWB6K645r+A5rS75byA5YWzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcg5r+A5rS755qE6YWN572u6aG5XG4gICAqIEByZXR1cm4ge0dlb219ICAgIOi/lOWbniBnZW9tIOiHqui6q1xuICAgKi9cblxuXG4gIF9wcm90by5hY3RpdmUgPSBmdW5jdGlvbiBhY3RpdmUoZW5hYmxlLCBjZmcpIHtcbiAgICBpZiAoZW5hYmxlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5zZXQoJ2FsbG93QWN0aXZlJywgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc09iamVjdChlbmFibGUpKSB7XG4gICAgICB0aGlzLnNldCgnYWxsb3dBY3RpdmUnLCB0cnVlKTtcbiAgICAgIHRoaXMuc2V0KCdhY3RpdmVkT3B0aW9ucycsIGVuYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0KCdhbGxvd0FjdGl2ZScsIHRydWUpO1xuICAgICAgdGhpcy5zZXQoJ2FjdGl2ZWRPcHRpb25zJywgY2ZnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIOWvuSBnZW9tZXRyeSDov5vooYzmlbDmja7osIPmlbRcbiAgICogQGNoYWluYWJsZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl8bnVsbH0gYWRqdXN0cyDmlbDmja7osIPmlbTnmoTnsbvlnotcbiAgICogQHJldHVybiB7T2JqZWN0fSBnZW9tZXRyeSDlr7nosaFcbiAgICovXG5cblxuICBfcHJvdG8uYWRqdXN0ID0gZnVuY3Rpb24gYWRqdXN0KGFkanVzdHMpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KCdoYXNEZWZhdWx0QWRqdXN0JykpIHtcbiAgICAgIGlmIChhZGp1c3RzKSB7XG4gICAgICAgIGFkanVzdHMgPSBwYXJzZUFkanVzdHMoYWRqdXN0cyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhZGp1c3RzJywgYWRqdXN0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiDorr7nva7lm77lvaLnmoTpgInkuK3mqKHlvI9cbiAgICogQHBhcmFtICB7Qm9vbGVhbnxPYmplY3R9IGVuYWJsZSDluIPlsJTnsbvlnovnlKjkuo7mqKHlvI/lvIDlhbPvvIzlr7nosaHnsbvlnovnlKjkuo7phY3nva5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgICAg6YCJ5Lit6YWN572u6aG5XG4gICAqIEByZXR1cm4ge0dlb219ICAgICAgICAgIOi/lOWbniBnZW9tIOiHqui6q1xuICAgKi9cblxuXG4gIF9wcm90by5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoZW5hYmxlLCBjZmcpIHtcbiAgICBpZiAoZW5hYmxlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5zZXQoJ2FsbG93U2VsZWN0JywgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc09iamVjdChlbmFibGUpKSB7XG4gICAgICB0aGlzLnNldCgnYWxsb3dTZWxlY3QnLCB0cnVlKTtcbiAgICAgIHRoaXMuc2V0KCdzZWxlY3RlZE9wdGlvbnMnLCBlbmFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldCgnYWxsb3dTZWxlY3QnLCB0cnVlKTtcbiAgICAgIHRoaXMuc2V0KCdzZWxlY3RlZE9wdGlvbnMnLCBjZmcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5oYXNBZGp1c3QgPSBmdW5jdGlvbiBoYXNBZGp1c3QoYWRqdXN0VHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWRqdXN0cyA9IHNlbGYuZ2V0KCdhZGp1c3RzJyk7XG5cbiAgICBpZiAoIWFkanVzdFR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcnN0ID0gZmFsc2U7XG4gICAgVXRpbC5lYWNoKGFkanVzdHMsIGZ1bmN0aW9uIChhZGp1c3QpIHtcbiAgICAgIGlmIChhZGp1c3QudHlwZSA9PT0gYWRqdXN0VHlwZSkge1xuICAgICAgICByc3QgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uaGFzU3RhY2sgPSBmdW5jdGlvbiBoYXNTdGFjaygpIHtcbiAgICB2YXIgaXNTdGFja2VkID0gdGhpcy5nZXQoJ2lzU3RhY2tlZCcpO1xuXG4gICAgaWYgKFV0aWwuaXNOaWwoaXNTdGFja2VkKSkge1xuICAgICAgaXNTdGFja2VkID0gdGhpcy5oYXNBZGp1c3QoJ3N0YWNrJyk7XG4gICAgICB0aGlzLnNldCgnaXNTdGFja2VkJywgaXNTdGFja2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTdGFja2VkO1xuICB9O1xuXG4gIF9wcm90by5pc0luQ2lyY2xlID0gZnVuY3Rpb24gaXNJbkNpcmNsZSgpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLmdldCgnY29vcmQnKTtcbiAgICByZXR1cm4gY29vcmQgJiYgY29vcmQuaXNQb2xhcjtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRDb250YWluZXIgPSBmdW5jdGlvbiBfaW5pdENvbnRhaW5lcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gc2VsZi5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG5cbiAgICBpZiAoIXNoYXBlQ29udGFpbmVyKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgICAgdmFyIHZpZXcgPSBzZWxmLmdldCgndmlldycpO1xuICAgICAgdmFyIHZpZXdJZCA9IHZpZXcgJiYgdmlldy5nZXQoJ19pZCcpO1xuICAgICAgc2hhcGVDb250YWluZXIgPSBjb250YWluZXIuYWRkR3JvdXAoe1xuICAgICAgICB2aWV3SWQ6IHZpZXdJZCxcbiAgICAgICAgdmlzaWJsZTogc2VsZi5nZXQoJ3Zpc2libGUnKVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNldCgnc2hhcGVDb250YWluZXInLCBzaGFwZUNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgICBzZWxmLl9pbml0QXR0cnMoKTtcblxuICAgIGlmIChzZWxmLmdldCgndG9vbHRpcENmZycpICYmIHNlbGYuZ2V0KCd0b29sdGlwQ2ZnJykuZmllbGRzKSB7XG4gICAgICB2YXIgdG9vbHRpcEZpZWxkcyA9IHNlbGYuZ2V0KCd0b29sdGlwQ2ZnJykuZmllbGRzO1xuICAgICAgVXRpbC5lYWNoKHRvb2x0aXBGaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBzZWxmLl9jcmVhdGVTY2FsZShmaWVsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YUFycmF5ID0gc2VsZi5fcHJvY2Vzc0RhdGEoKTtcblxuICAgIGlmIChzZWxmLmdldCgnYWRqdXN0cycpKSB7XG4gICAgICBzZWxmLl9hZGp1c3QoZGF0YUFycmF5KTtcbiAgICB9XG5cbiAgICBzZWxmLnNldCgnZGF0YUFycmF5JywgZGF0YUFycmF5KTtcbiAgfTsgLy8gc3RlcCAxOiBpbml0IGF0dHJzXG5cblxuICBfcHJvdG8uX2luaXRBdHRycyA9IGZ1bmN0aW9uIF9pbml0QXR0cnMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuZ2V0KCdhdHRycycpO1xuICAgIHZhciBhdHRyT3B0aW9ucyA9IHNlbGYuZ2V0KCdhdHRyT3B0aW9ucycpO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLnZpZXdUaGVtZSB8fCBHbG9iYWw7XG4gICAgdmFyIGlzUGllID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIGF0dHJPcHRpb25zKSB7XG4gICAgICBpZiAoYXR0ck9wdGlvbnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGF0dHJPcHRpb25zW3R5cGVdO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gVXRpbC51cHBlckZpcnN0KHR5cGUpO1xuICAgICAgICB2YXIgZmllbGRzID0gcGFyc2VGaWVsZHMob3B0aW9uLmZpZWxkKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgICAgIG9wdGlvbi5jb29yZCA9IGNvb3JkOyAvLyDppbzlm77lnZDmoIfns7vkuIvvvIzloavlhYXkuIDnu7RcblxuICAgICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxICYmIGNvb3JkLnR5cGUgPT09ICd0aGV0YScpIHtcbiAgICAgICAgICAgIGZpZWxkcy51bnNoaWZ0KCcxJyk7XG4gICAgICAgICAgICBpc1BpZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuXG4gICAgICAgICAgdmFyIHNjYWxlID0gc2VsZi5fY3JlYXRlU2NhbGUoZmllbGQpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb2xvcicgJiYgVXRpbC5pc05pbChvcHRpb24udmFsdWVzKSkge1xuICAgICAgICAgICAgLy8g6K6+572uIGNvbG9yIOeahOm7mOiupOiJsuWAvFxuICAgICAgICAgICAgaWYgKHNjYWxlLnZhbHVlcy5sZW5ndGggPD0gOCkge1xuICAgICAgICAgICAgICBvcHRpb24udmFsdWVzID0gaXNQaWUgPyB2aWV3VGhlbWUuY29sb3JzX3BpZSA6IHZpZXdUaGVtZS5jb2xvcnM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxlLnZhbHVlcy5sZW5ndGggPD0gMTYpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlcyA9IGlzUGllID8gdmlld1RoZW1lLmNvbG9yc19waWVfMTYgOiB2aWV3VGhlbWUuY29sb3JzXzE2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlcyA9IHZpZXdUaGVtZS5jb2xvcnNfMjQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChVdGlsLmlzTmlsKG9wdGlvbi52YWx1ZXMpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi52YWx1ZXMgPSB2aWV3VGhlbWUuY29sb3JzOyAvLyDpmLLmraLkuLvpopjmsqHmnInlo7DmmI7or7jlpoIgY29sb3JzX3BpZSDnmoTlsZ7mgKdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2FsZXMucHVzaChzY2FsZSk7XG4gICAgICAgIH0gLy8g6aW85Zu+6ZyA6KaB5aGr5YWF5ruh5pW05Liq56m66Ze0XG5cblxuICAgICAgICBpZiAoY29vcmQudHlwZSA9PT0gJ3RoZXRhJyAmJiB0eXBlID09PSAncG9zaXRpb24nICYmIHNjYWxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHlTY2FsZSA9IHNjYWxlc1sxXTtcbiAgICAgICAgICB5U2NhbGUuY2hhbmdlKHtcbiAgICAgICAgICAgIG5pY2U6IGZhbHNlLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5U2NhbGUudmFsdWVzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9uLnNjYWxlcyA9IHNjYWxlcztcbiAgICAgICAgdmFyIGF0dHIgPSBuZXcgQXR0cltjbGFzc05hbWVdKG9wdGlvbik7XG4gICAgICAgIGF0dHJzW3R5cGVdID0gYXR0cjtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIHN0ZXAgMjog5aSE55CG5pWw5o2uXG5cblxuICBfcHJvdG8uX3Byb2Nlc3NEYXRhID0gZnVuY3Rpb24gX3Byb2Nlc3NEYXRhKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0KCdkYXRhJyk7XG4gICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuXG4gICAgdmFyIGdyb3VwZWRBcnJheSA9IHRoaXMuX2dyb3VwRGF0YShkYXRhKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3ViRGF0YSA9IGdyb3VwZWRBcnJheVtpXTtcblxuICAgICAgdmFyIHRlbXBEYXRhID0gc2VsZi5fc2F2ZU9yaWdpbihzdWJEYXRhKTtcblxuICAgICAgc2VsZi5fbnVtYmVyaWModGVtcERhdGEpO1xuXG4gICAgICBkYXRhQXJyYXkucHVzaCh0ZW1wRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFBcnJheTtcbiAgfTsgLy8gc3RlcCAyLjEg5pWw5o2u5YiG57uEXG5cblxuICBfcHJvdG8uX2dyb3VwRGF0YSA9IGZ1bmN0aW9uIF9ncm91cERhdGEoZGF0YSkge1xuICAgIHZhciBncm91cFNjYWxlcyA9IHRoaXMuX2dldEdyb3VwU2NhbGVzKCk7XG5cbiAgICB2YXIgZmllbGRzID0gZ3JvdXBTY2FsZXMubWFwKGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgcmV0dXJuIHNjYWxlLmZpZWxkO1xuICAgIH0pO1xuICAgIHJldHVybiBVdGlsLkFycmF5Lmdyb3VwKGRhdGEsIGZpZWxkcyk7XG4gIH07IC8vIHN0ZXAgMi4yIOaVsOaNruiwg+aVtOWJjeS/neWtmOWOn+Wni+aVsOaNrlxuXG5cbiAgX3Byb3RvLl9zYXZlT3JpZ2luID0gZnVuY3Rpb24gX3NhdmVPcmlnaW4oZGF0YSkge1xuICAgIHZhciByc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9yaWdpbiA9IGRhdGFbaV07XG4gICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgIGZvciAodmFyIGsgaW4gb3JpZ2luKSB7XG4gICAgICAgIG9ialtrXSA9IG9yaWdpbltrXTtcbiAgICAgIH0gLy8gY29uc3Qgb2JqID0gVXRpbC5taXgoe30sIG9yaWdpbik7XG5cblxuICAgICAgb2JqW0ZJRUxEX09SSUdJTl0gPSBvcmlnaW47XG4gICAgICByc3QucHVzaChvYmopO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07IC8vIHN0ZXAgMi4zIOWwhuWIhuexu+aVsOaNrue/u+ivkeaIkOaVsOaNriwg5LuF5a+55L2N572u55u45YWz55qE5bqm6YeP6L+b6KGM5pWw5a2X5YyW5aSE55CGXG5cblxuICBfcHJvdG8uX251bWJlcmljID0gZnVuY3Rpb24gX251bWJlcmljKGRhdGEpIHtcbiAgICB2YXIgcG9zaXRpb25BdHRyID0gdGhpcy5nZXRBdHRyKCdwb3NpdGlvbicpO1xuICAgIHZhciBzY2FsZXMgPSBwb3NpdGlvbkF0dHIuc2NhbGVzO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgb2JqID0gZGF0YVtqXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbigyLCBzY2FsZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlc1tpXTtcblxuICAgICAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSkge1xuICAgICAgICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgICAgICAgIG9ialtmaWVsZF0gPSBzY2FsZS50cmFuc2xhdGUob2JqW2ZpZWxkXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRHcm91cFNjYWxlcyA9IGZ1bmN0aW9uIF9nZXRHcm91cFNjYWxlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjYWxlcyA9IHNlbGYuZ2V0KCdncm91cFNjYWxlcycpO1xuXG4gICAgaWYgKCFzY2FsZXMpIHtcbiAgICAgIHNjYWxlcyA9IFtdO1xuICAgICAgdmFyIGF0dHJzID0gc2VsZi5nZXQoJ2F0dHJzJyk7XG4gICAgICBVdGlsLmVhY2goYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIGlmIChHUk9VUF9BVFRSUy5pbmRleE9mKGF0dHIudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIGF0dHJTY2FsZXMgPSBhdHRyLnNjYWxlcztcbiAgICAgICAgICBVdGlsLmVhY2goYXR0clNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSAmJiBVdGlsLmluZGV4T2Yoc2NhbGVzLCBzY2FsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNjYWxlcy5wdXNoKHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNldCgnZ3JvdXBTY2FsZXMnLCBzY2FsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZXM7XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVTdGFja1JhbmdlID0gZnVuY3Rpb24gX3VwZGF0ZVN0YWNrUmFuZ2UoZmllbGQsIHNjYWxlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgbWVyZ2VBcnJheSA9IFV0aWwuQXJyYXkubWVyZ2UoZGF0YUFycmF5KTtcbiAgICB2YXIgbWluID0gc2NhbGUubWluO1xuICAgIHZhciBtYXggPSBzY2FsZS5tYXg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lcmdlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBtZXJnZUFycmF5W2ldO1xuICAgICAgdmFyIHRtcE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIG9ialtmaWVsZF0pO1xuICAgICAgdmFyIHRtcE1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG9ialtmaWVsZF0pO1xuXG4gICAgICBpZiAodG1wTWluIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHRtcE1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRtcE1heCA+IG1heCkge1xuICAgICAgICBtYXggPSB0bXBNYXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbiA8IHNjYWxlLm1pbiB8fCBtYXggPiBzY2FsZS5tYXgpIHtcbiAgICAgIHNjYWxlLmNoYW5nZSh7XG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heFxuICAgICAgfSk7XG4gICAgfVxuICB9OyAvLyBzdGVwIDIuMiDosIPmlbTmlbDmja5cblxuXG4gIF9wcm90by5fYWRqdXN0ID0gZnVuY3Rpb24gX2FkanVzdChkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFkanVzdHMgPSBzZWxmLmdldCgnYWRqdXN0cycpO1xuICAgIHZhciB2aWV3VGhlbWUgPSB0aGlzLnZpZXdUaGVtZSB8fCBHbG9iYWw7XG4gICAgdmFyIHlTY2FsZSA9IHNlbGYuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIHhTY2FsZSA9IHNlbGYuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIHhGaWVsZCA9IHhTY2FsZS5maWVsZDtcbiAgICB2YXIgeUZpZWxkID0geVNjYWxlID8geVNjYWxlLmZpZWxkIDogbnVsbDtcbiAgICBVdGlsLmVhY2goYWRqdXN0cywgZnVuY3Rpb24gKGFkanVzdCkge1xuICAgICAgdmFyIGFkanVzdENmZyA9IFV0aWwubWl4KHtcbiAgICAgICAgeEZpZWxkOiB4RmllbGQsXG4gICAgICAgIHlGaWVsZDogeUZpZWxkXG4gICAgICB9LCBhZGp1c3QpO1xuICAgICAgdmFyIGFkanVzdFR5cGUgPSBVdGlsLnVwcGVyRmlyc3QoYWRqdXN0LnR5cGUpO1xuXG4gICAgICBpZiAoYWRqdXN0VHlwZSA9PT0gJ0RvZGdlJykge1xuICAgICAgICB2YXIgYWRqdXN0TmFtZXMgPSBbXTtcblxuICAgICAgICBpZiAoeFNjYWxlLmlzQ2F0ZWdvcnkgfHwgeFNjYWxlLmlzSWRlbnRpdHkpIHtcbiAgICAgICAgICBhZGp1c3ROYW1lcy5wdXNoKCd4Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXlTY2FsZSkge1xuICAgICAgICAgIGFkanVzdE5hbWVzLnB1c2goJ3knKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvZGdlIGlzIG5vdCBzdXBwb3J0IGxpbmVhciBhdHRyaWJ1dGUsIHBsZWFzZSB1c2UgY2F0ZWdvcnkgYXR0cmlidXRlIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRqdXN0Q2ZnLmFkanVzdE5hbWVzID0gYWRqdXN0TmFtZXM7XG4gICAgICAgIGFkanVzdENmZy5kb2RnZVJhdGlvID0gdmlld1RoZW1lLndpZHRoUmF0aW8uY29sdW1uO1xuICAgICAgICAvKiBpZiAoc2VsZi5pc0luQ2lyY2xlKCkpIHtcbiAgICAgICAgICBhZGp1c3RDZmcuZG9kZ2VSYXRpbyA9IDE7XG4gICAgICAgICAgYWRqdXN0Q2ZnLm1hcmdpblJhdGlvID0gMDtcbiAgICAgICAgfSovXG4gICAgICB9IGVsc2UgaWYgKGFkanVzdFR5cGUgPT09ICdTdGFjaycpIHtcbiAgICAgICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG5cbiAgICAgICAgaWYgKCF5U2NhbGUpIHtcbiAgICAgICAgICAvLyDkuIDnu7TnmoTmg4XlhrXkuIvojrflj5bpq5jluqblkozpu5jorqRzaXplXG4gICAgICAgICAgYWRqdXN0Q2ZnLmhlaWdodCA9IGNvb3JkLmdldEhlaWdodCgpO1xuICAgICAgICAgIHZhciBzaXplID0gc2VsZi5nZXREZWZhdWx0VmFsdWUoJ3NpemUnKSB8fCAzO1xuICAgICAgICAgIGFkanVzdENmZy5zaXplID0gc2l6ZTtcbiAgICAgICAgfSAvLyDkuI3ov5vooYwgdHJhbnNwb3NlIOaXtu+8jOeUqOaIt+WPiOayoeacieiuvue9rui/meS4quWPguaVsOaXtu+8jOm7mOiupOS7juS4iuWQkeS4i1xuXG5cbiAgICAgICAgaWYgKCFjb29yZC5pc1RyYW5zcG9zZWQgJiYgVXRpbC5pc05pbChhZGp1c3RDZmcucmV2ZXJzZU9yZGVyKSkge1xuICAgICAgICAgIGFkanVzdENmZy5yZXZlcnNlT3JkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGp1c3RFbGVtZW50ID0gbmV3IEFkanVzdFthZGp1c3RUeXBlXShhZGp1c3RDZmcpO1xuICAgICAgYWRqdXN0RWxlbWVudC5wcm9jZXNzQWRqdXN0KGRhdGFBcnJheSk7XG5cbiAgICAgIGlmIChhZGp1c3RUeXBlID09PSAnU3RhY2snICYmIHlTY2FsZSkge1xuICAgICAgICBzZWxmLl91cGRhdGVTdGFja1JhbmdlKHlGaWVsZCwgeVNjYWxlLCBkYXRhQXJyYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQGludGVybmFsIOiuvue9rmNvb3Jk77yM6YCa5bi45aSW6YOo5a655Zmo5Y+Y5YyW5pe277yMY29vcmQg5Lya5Y+R55Sf5Y+Y5YyWXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZCDlnZDmoIfns7tcbiAgICovXG5cblxuICBfcHJvdG8uc2V0Q29vcmQgPSBmdW5jdGlvbiBzZXRDb29yZChjb29yZCkge1xuICAgIHRoaXMuc2V0KCdjb29yZCcsIGNvb3JkKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldEF0dHIoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gdGhpcy5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgc2hhcGVDb250YWluZXIuc2V0TWF0cml4KGNvb3JkLm1hdHJpeCk7XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uLmNvb3JkID0gY29vcmQ7XG4gICAgfVxuICB9OyAvLyBzdGVwIDMg57uY5Yi2XG5cblxuICBfcHJvdG8ucGFpbnQgPSBmdW5jdGlvbiBwYWludCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGFBcnJheSA9IHNlbGYuZ2V0KCdkYXRhQXJyYXknKTtcbiAgICB2YXIgbWFwcGVkQXJyYXkgPSBbXTtcbiAgICB2YXIgc2hhcGVGYWN0b3J5ID0gc2VsZi5nZXRTaGFwZUZhY3RvcnkoKTtcbiAgICBzaGFwZUZhY3Rvcnkuc2V0Q29vcmQoc2VsZi5nZXQoJ2Nvb3JkJykpO1xuICAgIHNlbGYuc2V0KCdzaGFwZUZhY3RvcnknLCBzaGFwZUZhY3RvcnkpO1xuICAgIHZhciBzaGFwZUNvbnRhaW5lciA9IHNlbGYuZ2V0KCdzaGFwZUNvbnRhaW5lcicpO1xuXG4gICAgc2VsZi5fYmVmb3JlTWFwcGluZyhkYXRhQXJyYXkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkYXRhID0gZGF0YUFycmF5W2ldO1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIGRhdGEgPSBzZWxmLl9tYXBwaW5nKGRhdGEpO1xuICAgICAgbWFwcGVkQXJyYXkucHVzaChkYXRhKTtcbiAgICAgIHNlbGYuZHJhdyhkYXRhLCBzaGFwZUNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZ2V0KCdsYWJlbENmZycpKSB7XG4gICAgICBzZWxmLl9hZGRMYWJlbHMoVXRpbC51bmlvbi5hcHBseShudWxsLCBtYXBwZWRBcnJheSksIHNoYXBlQ29udGFpbmVyLmdldCgnY2hpbGRyZW4nKSk7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmdldCgnc29ydGFibGUnKSkge1xuICAgICAgc2VsZi5fc29ydChtYXBwZWRBcnJheSk7IC8vIOS+v+S6juaVsOaNrueahOafpeaJvu+8jOmcgOimgeWvueaVsOaNrui/m+ihjOaOkuW6j++8jOeUqOS6jiBnZW9tLmZpbmRQb2ludCgpXG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXQoJ2RhdGFBcnJheScsIG1hcHBlZEFycmF5KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zb3J0ID0gZnVuY3Rpb24gX3NvcnQobWFwcGVkQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHhTY2FsZSA9IHNlbGYuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIHhGaWVsZCA9IHhTY2FsZS5maWVsZDtcbiAgICBVdGlsLmVhY2gobWFwcGVkQXJyYXksIGZ1bmN0aW9uIChpdGVtQXJyKSB7XG4gICAgICBpdGVtQXJyLnNvcnQoZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgICAgcmV0dXJuIHhTY2FsZS50cmFuc2xhdGUob2JqMVtGSUVMRF9PUklHSU5dW3hGaWVsZF0pIC0geFNjYWxlLnRyYW5zbGF0ZShvYmoyW0ZJRUxEX09SSUdJTl1beEZpZWxkXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzZWxmLnNldCgnZGF0YUFycmF5JywgbWFwcGVkQXJyYXkpO1xuICB9OyAvLyBzdGVwIDMuMSBiZWZvcmUgbWFwcGluZ1xuXG5cbiAgX3Byb3RvLl9iZWZvcmVNYXBwaW5nID0gZnVuY3Rpb24gX2JlZm9yZU1hcHBpbmcoZGF0YUFycmF5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdzb3J0YWJsZScpKSB7XG4gICAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcbiAgICAgIHZhciBmaWVsZCA9IHhTY2FsZS5maWVsZDtcbiAgICAgIFV0aWwuZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGRhdGEuc29ydChmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZS50cmFuc2xhdGUodjFbZmllbGRdKSAtIHhTY2FsZS50cmFuc2xhdGUodjJbZmllbGRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ2dlbmVyYXRlUG9pbnRzJykpIHtcbiAgICAgIFV0aWwuZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuX2dlbmVyYXRlUG9pbnRzKGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBVdGlsLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0YSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG5leHREYXRhID0gZGF0YUFycmF5W2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG5leHREYXRhKSB7XG4gICAgICAgICAgZGF0YVswXS5uZXh0UG9pbnRzID0gbmV4dERhdGFbMF0ucG9pbnRzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIHN0ZXAgMy4yIGFkZCBsYWJlbHNcblxuXG4gIF9wcm90by5fYWRkTGFiZWxzID0gZnVuY3Rpb24gX2FkZExhYmVscyhwb2ludHMsIHNoYXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IHNlbGYuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYuZ2V0KCd2aWV3VGhlbWUnKSB8fCBHbG9iYWw7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIEMgPSBMYWJlbHMuZ2V0TGFiZWxzQ2xhc3MoY29vcmQudHlwZSwgdHlwZSk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgc2NhbGVzID0gVXRpbC5tYXAoc2VsZi5nZXQoJ2xhYmVsQ2ZnJykuZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVTY2FsZShmaWVsZCk7XG4gICAgfSk7XG4gICAgdmFyIGxhYmVsQ29udGFpbmVyID0gY29udGFpbmVyLmFkZEdyb3VwKEMsIHtcbiAgICAgIF9pZDogdGhpcy5nZXQoJ19pZCcpLFxuICAgICAgbGFiZWxDZmc6IFV0aWwubWl4KHtcbiAgICAgICAgc2NhbGVzOiBzY2FsZXNcbiAgICAgIH0sIHNlbGYuZ2V0KCdsYWJlbENmZycpKSxcbiAgICAgIGNvb3JkOiBjb29yZCxcbiAgICAgIGdlb206IHNlbGYsXG4gICAgICBnZW9tVHlwZTogdHlwZSxcbiAgICAgIHZpZXdUaGVtZTogdmlld1RoZW1lLFxuICAgICAgdmlzaWJsZTogc2VsZi5nZXQoJ3Zpc2libGUnKVxuICAgIH0pO1xuICAgIGxhYmVsQ29udGFpbmVyLnNob3dMYWJlbHMocG9pbnRzLCBzaGFwZXMpO1xuICAgIHNlbGYuc2V0KCdsYWJlbENvbnRhaW5lcicsIGxhYmVsQ29udGFpbmVyKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6I635Y+W5Zu+5b2i55qE5bel5Y6C57G7XG4gICAqIEByZXR1cm4ge09iamVjdH0g5bel5Y6C57G75a+56LGhXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFNoYXBlRmFjdG9yeSA9IGZ1bmN0aW9uIGdldFNoYXBlRmFjdG9yeSgpIHtcbiAgICB2YXIgc2hhcGVGYWN0b3J5ID0gdGhpcy5nZXQoJ3NoYXBlRmFjdG9yeScpO1xuXG4gICAgaWYgKCFzaGFwZUZhY3RvcnkpIHtcbiAgICAgIHZhciBzaGFwZVR5cGUgPSB0aGlzLmdldCgnc2hhcGVUeXBlJyk7XG4gICAgICBzaGFwZUZhY3RvcnkgPSBTaGFwZS5nZXRTaGFwZUZhY3Rvcnkoc2hhcGVUeXBlKTtcbiAgICAgIHRoaXMuc2V0KCdzaGFwZUZhY3RvcnknLCBzaGFwZUZhY3RvcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZUZhY3Rvcnk7XG4gIH07IC8vIHN0ZXAgMy4yIGdlbmVyYXRlIHBvaW50c1xuXG5cbiAgX3Byb3RvLl9nZW5lcmF0ZVBvaW50cyA9IGZ1bmN0aW9uIF9nZW5lcmF0ZVBvaW50cyhkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzaGFwZUZhY3RvcnkgPSBzZWxmLmdldFNoYXBlRmFjdG9yeSgpO1xuICAgIHZhciBzaGFwZUF0dHIgPSBzZWxmLmdldEF0dHIoJ3NoYXBlJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBkYXRhW2ldO1xuICAgICAgdmFyIGNmZyA9IHNlbGYuY3JlYXRlU2hhcGVQb2ludHNDZmcob2JqKTtcbiAgICAgIHZhciBzaGFwZSA9IHNoYXBlQXR0ciA/IHNlbGYuX2dldEF0dHJWYWx1ZXMoc2hhcGVBdHRyLCBvYmopIDogbnVsbDtcbiAgICAgIHZhciBwb2ludHMgPSBzaGFwZUZhY3RvcnkuZ2V0U2hhcGVQb2ludHMoc2hhcGUsIGNmZyk7XG4gICAgICBvYmoucG9pbnRzID0gcG9pbnRzO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIOiOt+WPluWbvuW9ouWvueW6lOeCueeahOmFjee9rumhuVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqIOaVsOaNruWvueixoVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNmZyDojrflj5blm77lvaLlr7nlupTngrnnmoTphY3nva7poblcbiAgICovXG5cblxuICBfcHJvdG8uY3JlYXRlU2hhcGVQb2ludHNDZmcgPSBmdW5jdGlvbiBjcmVhdGVTaGFwZVBvaW50c0NmZyhvYmopIHtcbiAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcblxuICAgIHZhciB4ID0gdGhpcy5fbm9ybWFsaXplVmFsdWVzKG9ialt4U2NhbGUuZmllbGRdLCB4U2NhbGUpO1xuXG4gICAgdmFyIHk7IC8vIOWtmOWcqOayoeaciSB5IOeahOaDheWGtVxuXG4gICAgaWYgKHlTY2FsZSkge1xuICAgICAgeSA9IHRoaXMuX25vcm1hbGl6ZVZhbHVlcyhvYmpbeVNjYWxlLmZpZWxkXSwgeVNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IG9iai55ID8gb2JqLnkgOiAwLjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgeTA6IHlTY2FsZSA/IHlTY2FsZS5zY2FsZSh0aGlzLmdldFlNaW5WYWx1ZSgpKSA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIOWmguaenHnovbTnmoTmnIDlsI/lgLzlsI/kuo4w5YiZ6L+U5ZueMO+8jOWQpuWImei/lOWbnuacgOWwj+WAvFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHnovbTkuIrnmoTmnIDlsI/lgLxcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0WU1pblZhbHVlID0gZnVuY3Rpb24gZ2V0WU1pblZhbHVlKCkge1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgIHZhciBtaW4gPSB5U2NhbGUubWluLFxuICAgICAgICBtYXggPSB5U2NhbGUubWF4O1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmIChtaW4gPj0gMCkge1xuICAgICAgdmFsdWUgPSBtaW47XG4gICAgfSBlbHNlIGlmIChtYXggPD0gMCkge1xuICAgICAgLy8g5b2T5YC85YWo5L2N5LqO6LSf5Yy66Ze05pe277yM6ZyA6KaB5L+d6K+BIHltaW4g5Zyo5Yy65Z+f5YaF77yM5LiN5Y+v5Li6IDBcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9OyAvLyDlsIbmlbDmja7lvZLkuIDljJZcblxuXG4gIF9wcm90by5fbm9ybWFsaXplVmFsdWVzID0gZnVuY3Rpb24gX25vcm1hbGl6ZVZhbHVlcyh2YWx1ZXMsIHNjYWxlKSB7XG4gICAgdmFyIHJzdCA9IFtdO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgcnN0LnB1c2goc2NhbGUuc2NhbGUodikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByc3QgPSBzY2FsZS5zY2FsZSh2YWx1ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07IC8vIHN0ZXAgMy4yIG1hcHBpbmdcblxuXG4gIF9wcm90by5fbWFwcGluZyA9IGZ1bmN0aW9uIF9tYXBwaW5nKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIG1hcHBlZERhdGEgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY29yZCA9IGRhdGFbaV07XG4gICAgICB2YXIgbmV3UmVjb3JkID0ge307XG4gICAgICBuZXdSZWNvcmRbRklFTERfT1JJR0lOXSA9IHJlY29yZFtGSUVMRF9PUklHSU5dO1xuICAgICAgbmV3UmVjb3JkLnBvaW50cyA9IHJlY29yZC5wb2ludHM7XG4gICAgICBuZXdSZWNvcmQubmV4dFBvaW50cyA9IHJlY29yZC5uZXh0UG9pbnRzO1xuXG4gICAgICBmb3IgKHZhciBrIGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNba107XG4gICAgICAgICAgdmFyIG5hbWVzID0gYXR0ci5uYW1lcztcblxuICAgICAgICAgIHZhciB2YWx1ZXMgPSBzZWxmLl9nZXRBdHRyVmFsdWVzKGF0dHIsIHJlY29yZCk7XG5cbiAgICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24g5LmL57G755qE55Sf5oiQ5aSa5Liq5a2X5q6155qE5bGe5oCnXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWVzW2pdO1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgICAgICAgICBuZXdSZWNvcmRbbmFtZV0gPSBVdGlsLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAxID8gdmFsWzBdIDogdmFsOyAvLyDlj6rmnInkuIDkuKrlgLzml7bov5Tlm57nrKzkuIDkuKrlsZ7mgKflgLxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3UmVjb3JkW25hbWVzWzBdXSA9IHZhbHVlcy5sZW5ndGggPT09IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcHBlZERhdGEucHVzaChuZXdSZWNvcmQpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwZWREYXRhO1xuICB9OyAvLyDojrflj5blsZ7mgKfmmKDlsITnmoTlgLxcblxuXG4gIF9wcm90by5fZ2V0QXR0clZhbHVlcyA9IGZ1bmN0aW9uIF9nZXRBdHRyVmFsdWVzKGF0dHIsIHJlY29yZCkge1xuICAgIHZhciBzY2FsZXMgPSBhdHRyLnNjYWxlcztcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjYWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNjYWxlID0gc2NhbGVzW2ldO1xuICAgICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG5cbiAgICAgIGlmIChzY2FsZS50eXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHNjYWxlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHJlY29yZFtmaWVsZF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBhdHRyLm1hcHBpbmcuYXBwbHkoYXR0ciwgcGFyYW1zKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIF9wcm90by5nZXRBdHRyVmFsdWUgPSBmdW5jdGlvbiBnZXRBdHRyVmFsdWUoYXR0ck5hbWUsIHJlY29yZCkge1xuICAgIHZhciBhdHRyID0gdGhpcy5nZXRBdHRyKGF0dHJOYW1lKTtcbiAgICB2YXIgcnN0ID0gbnVsbDtcblxuICAgIGlmIChhdHRyKSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5fZ2V0QXR0clZhbHVlcyhhdHRyLCByZWNvcmQpO1xuXG4gICAgICByc3QgPSB2YWx1ZXNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKGF0dHJOYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoYXR0ck5hbWUpO1xuICAgIHZhciBhdHRyID0gdGhpcy5nZXRBdHRyKGF0dHJOYW1lKTtcblxuICAgIGlmIChhdHRyKSB7XG4gICAgICB2YXIgc2NhbGUgPSBhdHRyLmdldFNjYWxlKGF0dHJOYW1lKTtcblxuICAgICAgaWYgKHNjYWxlLnR5cGUgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FsZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBzdGVwIDMuMyBkcmF3XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7QXJyYXl9IGRhdGEg57uY5Yi25Zu+5b2iXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXIg57uY5Zu+5a655ZmoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZUZhY3Rvcnkg57uY5Yi25Zu+5b2i55qE5bel5Y6C57G7XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCDmr4/kuKogc2hhcGUg55qE57Si5byV5YC8XG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGRhdGEsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICBzZWxmLmRyYXdQb2ludChvYmosIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCArIGkpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2FsbGJhY2tDZmcgPSBmdW5jdGlvbiBnZXRDYWxsYmFja0NmZyhmaWVsZHMsIGNmZywgb3JpZ2luKSB7XG4gICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgIHJldHVybiBjZmc7XG4gICAgfVxuXG4gICAgdmFyIHRtcENmZyA9IHt9O1xuICAgIHZhciBwYXJhbXMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIG9yaWdpbltmaWVsZF07XG4gICAgfSk7XG4gICAgVXRpbC5lYWNoKGNmZywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgdG1wQ2ZnW2tdID0gdi5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wQ2ZnW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG1wQ2ZnO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U2hhcGVJZCA9IGZ1bmN0aW9uIF9nZXRTaGFwZUlkKGRhdGFPYmopIHtcbiAgICB2YXIgaWQgPSB0aGlzLmdldCgnX2lkJyk7XG4gICAgdmFyIGtleUZpZWxkcyA9IHRoaXMuZ2V0KCdrZXlGaWVsZHMnKTtcblxuICAgIGlmIChrZXlGaWVsZHMgJiYga2V5RmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIFV0aWwuZWFjaChrZXlGaWVsZHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWQgKz0gJy0nICsgZGF0YU9ialtrZXldO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICAgIHZhciB4U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgICB2YXIgeEZpZWxkID0geFNjYWxlLmZpZWxkIHx8ICd4JztcbiAgICAgIHZhciB5RmllbGQgPSB5U2NhbGUuZmllbGQgfHwgJ3knO1xuICAgICAgdmFyIHlWYWwgPSBkYXRhT2JqW3lGaWVsZF07XG4gICAgICB2YXIgeFZhbDtcblxuICAgICAgaWYgKHhTY2FsZS5pc0lkZW50aXR5KSB7XG4gICAgICAgIHhWYWwgPSB4U2NhbGUudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4VmFsID0gZGF0YU9ialt4RmllbGRdO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2ludGVydmFsJyB8fCB0eXBlID09PSAnc2NoZW1hJykge1xuICAgICAgICBpZCArPSAnLScgKyB4VmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICBpZCArPSAnLScgKyB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWQgKz0gJy0nICsgeFZhbCArICctJyArIHlWYWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cFNjYWxlcyA9IHRoaXMuX2dldEdyb3VwU2NhbGVzKCk7XG5cbiAgICAgIGlmICghVXRpbC5pc0VtcHR5KGdyb3VwU2NhbGVzKSkge1xuICAgICAgICBVdGlsLmVhY2goZ3JvdXBTY2FsZXMsIGZ1bmN0aW9uIChncm91cFNjYWxlKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZ3JvdXBTY2FsZS5maWVsZDtcblxuICAgICAgICAgIGlmIChncm91cFNjYWxlLnR5cGUgIT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIGlkICs9ICctJyArIGRhdGFPYmpbZmllbGRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIF9wcm90by5nZXREcmF3Q2ZnID0gZnVuY3Rpb24gZ2V0RHJhd0NmZyhvYmopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNmZyA9IHtcbiAgICAgIG9yaWdpbjogb2JqLFxuICAgICAgeDogb2JqLngsXG4gICAgICB5OiBvYmoueSxcbiAgICAgIGNvbG9yOiBvYmouY29sb3IsXG4gICAgICBzaXplOiBvYmouc2l6ZSxcbiAgICAgIHNoYXBlOiBvYmouc2hhcGUsXG4gICAgICBpc0luQ2lyY2xlOiBzZWxmLmlzSW5DaXJjbGUoKSxcbiAgICAgIG9wYWNpdHk6IG9iai5vcGFjaXR5XG4gICAgfTtcbiAgICB2YXIgc3R5bGVPcHRpb25zID0gc2VsZi5nZXQoJ3N0eWxlT3B0aW9ucycpO1xuXG4gICAgaWYgKHN0eWxlT3B0aW9ucyAmJiBzdHlsZU9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIGNmZy5zdHlsZSA9IHNlbGYuZ2V0Q2FsbGJhY2tDZmcoc3R5bGVPcHRpb25zLmZpZWxkcywgc3R5bGVPcHRpb25zLnN0eWxlLCBvYmpbRklFTERfT1JJR0lOXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZ2V0KCdnZW5lcmF0ZVBvaW50cycpKSB7XG4gICAgICBjZmcucG9pbnRzID0gb2JqLnBvaW50cztcbiAgICAgIGNmZy5uZXh0UG9pbnRzID0gb2JqLm5leHRQb2ludHM7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZ2V0KCdhbmltYXRlJykpIHtcbiAgICAgIC8vIF9pZCDlrZfmrrXku4XnlKjkuo7liqjnlLtcbiAgICAgIGNmZy5faWQgPSBzZWxmLl9nZXRTaGFwZUlkKG9ialtGSUVMRF9PUklHSU5dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRTaGFwZUluZm8gPSBmdW5jdGlvbiBhcHBlbmRTaGFwZUluZm8oc2hhcGUsIGluZGV4KSB7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICBzaGFwZS5zZXRTaWxlbnQoJ2luZGV4JywgaW5kZXgpO1xuICAgICAgc2hhcGUuc2V0U2lsZW50KCdjb29yZCcsIHRoaXMuZ2V0KCdjb29yZCcpKTtcblxuICAgICAgaWYgKHRoaXMuZ2V0KCdhbmltYXRlJykgJiYgdGhpcy5nZXQoJ2FuaW1hdGVDZmcnKSkge1xuICAgICAgICBzaGFwZS5zZXRTaWxlbnQoJ2FuaW1hdGVDZmcnLCB0aGlzLmdldCgnYW5pbWF0ZUNmZycpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hcHBseVZpZXdUaGVtZVNoYXBlU3R5bGUgPSBmdW5jdGlvbiBfYXBwbHlWaWV3VGhlbWVTaGFwZVN0eWxlKGNmZywgc2hhcGUsIHNoYXBlRmFjdG9yeSkge1xuICAgIC8vIGFwcGx5aW5nIHZpZXcgdGhlbWVcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYudmlld1RoZW1lIHx8IEdsb2JhbDtcbiAgICB2YXIgc2hhcGVOYW1lID0gc2hhcGVGYWN0b3J5Lm5hbWU7XG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZSAmJiAoc2hhcGUuaW5kZXhPZignaG9sbG93JykgPiAtMSB8fCBzaGFwZS5pbmRleE9mKCdsaXF1aWQnKSA+IC0xKSkge1xuICAgICAgICBzaGFwZU5hbWUgPSBcImhvbGxvd1wiICsgVXRpbC51cHBlckZpcnN0KHNoYXBlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaGFwZUZhY3RvcnkuZGVmYXVsdFNoYXBlVHlwZS5pbmRleE9mKCdob2xsb3cnKSA+IC0xKSB7XG4gICAgICBzaGFwZU5hbWUgPSBcImhvbGxvd1wiICsgVXRpbC51cHBlckZpcnN0KHNoYXBlTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRTdHlsZSA9IHZpZXdUaGVtZS5zaGFwZVtzaGFwZU5hbWVdIHx8IHt9O1xuICAgIGNmZy5zdHlsZSA9IFV0aWwubWl4KHt9LCBkZWZhdWx0U3R5bGUsIGNmZy5zdHlsZSk7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXdQb2ludCA9IGZ1bmN0aW9uIGRyYXdQb2ludChvYmosIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2hhcGUgPSBvYmouc2hhcGU7XG4gICAgdmFyIGNmZyA9IHNlbGYuZ2V0RHJhd0NmZyhvYmopO1xuXG4gICAgc2VsZi5fYXBwbHlWaWV3VGhlbWVTaGFwZVN0eWxlKGNmZywgc2hhcGUsIHNoYXBlRmFjdG9yeSk7XG5cbiAgICB2YXIgZ2VvbVNoYXBlID0gc2hhcGVGYWN0b3J5LmRyYXdTaGFwZShzaGFwZSwgY2ZnLCBjb250YWluZXIpO1xuICAgIHNlbGYuYXBwZW5kU2hhcGVJbmZvKGdlb21TaGFwZSwgaW5kZXgpO1xuICB9O1xuICAvKipcbiAgICog6I635Y+W5bGe5oCnXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUg5bGe5oCn5ZCNXG4gICAqIEByZXR1cm4ge1NjYWxlfSDluqbph49cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0QXR0ciA9IGZ1bmN0aW9uIGdldEF0dHIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldCgnYXR0cnMnKVtuYW1lXTtcbiAgfTtcbiAgLyoqXG4gICAqIOiOt+WPliB4IOWvueW6lOeahOW6pumHj1xuICAgKiBAcmV0dXJuIHtTY2FsZX0geCDlr7nlupTnmoTluqbph49cbiAgICovXG5cblxuICBfcHJvdG8uZ2V0WFNjYWxlID0gZnVuY3Rpb24gZ2V0WFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHIoJ3Bvc2l0aW9uJykuc2NhbGVzWzBdO1xuICB9O1xuICAvKipcbiAgICog6I635Y+WIHkg5a+55bqU55qE5bqm6YePXG4gICAqIEByZXR1cm4ge1NjYWxlfSB5IOWvueW6lOeahOW6pumHj1xuICAgKi9cblxuXG4gIF9wcm90by5nZXRZU2NhbGUgPSBmdW5jdGlvbiBnZXRZU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cigncG9zaXRpb24nKS5zY2FsZXNbMV07XG4gIH07XG5cbiAgX3Byb3RvLmdldFNoYXBlcyA9IGZ1bmN0aW9uIGdldFNoYXBlcygpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gdGhpcy5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgdmFyIGNoaWxkcmVuID0gc2hhcGVDb250YWluZXIuZ2V0KCdjaGlsZHJlbicpO1xuICAgIFV0aWwuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuZ2V0KCdvcmlnaW4nKSkge1xuICAgICAgICAvLyDov4fmu6QgbGFiZWxcbiAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldEF0dHJzRm9yTGVnZW5kID0gZnVuY3Rpb24gZ2V0QXR0cnNGb3JMZWdlbmQoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIFV0aWwuZWFjaChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIGlmIChHUk9VUF9BVFRSUy5pbmRleE9mKGF0dHIudHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHJzdC5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZpZWxkc0ZvckxlZ2VuZCA9IGZ1bmN0aW9uIGdldEZpZWxkc0ZvckxlZ2VuZCgpIHtcbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgdmFyIGF0dHJPcHRpb25zID0gdGhpcy5nZXQoJ2F0dHJPcHRpb25zJyk7XG4gICAgVXRpbC5lYWNoKEdST1VQX0FUVFJTLCBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgIHZhciBhdHRyQ2ZnID0gYXR0ck9wdGlvbnNbYXR0ck5hbWVdO1xuXG4gICAgICBpZiAoYXR0ckNmZyAmJiBhdHRyQ2ZnLmZpZWxkICYmIFV0aWwuaXNTdHJpbmcoYXR0ckNmZy5maWVsZCkpIHtcbiAgICAgICAgZmllbGRzID0gZmllbGRzLmNvbmNhdChhdHRyQ2ZnLmZpZWxkLnNwbGl0KCcqJykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBVdGlsLnVuaXEoZmllbGRzKTtcbiAgfTtcblxuICBfcHJvdG8uY2hhbmdlVmlzaWJsZSA9IGZ1bmN0aW9uIGNoYW5nZVZpc2libGUodmlzaWJsZSwgc3RvcERyYXcpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLnNldCgndmlzaWJsZScsIHZpc2libGUpO1xuICAgIHZhciBzaGFwZUNvbnRhaW5lciA9IHRoaXMuZ2V0KCdzaGFwZUNvbnRhaW5lcicpO1xuXG4gICAgaWYgKHNoYXBlQ29udGFpbmVyKSB7XG4gICAgICBzaGFwZUNvbnRhaW5lci5zZXQoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICB9XG5cbiAgICB2YXIgbGFiZWxDb250YWluZXIgPSB0aGlzLmdldCgnbGFiZWxDb250YWluZXInKTtcblxuICAgIGlmIChsYWJlbENvbnRhaW5lcikge1xuICAgICAgbGFiZWxDb250YWluZXIuc2V0KCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFzdG9wRHJhdyAmJiBzaGFwZUNvbnRhaW5lcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHNoYXBlQ29udGFpbmVyLmdldCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMuZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnNldCgnYXR0ck9wdGlvbnMnLCB7fSk7XG4gICAgdGhpcy5jbGVhcklubmVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFySW5uZXIgPSBmdW5jdGlvbiBjbGVhcklubmVyKCkge1xuICAgIHRoaXMuY2xlYXJBY3RpdmVkU2hhcGVzKCk7XG4gICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gdGhpcy5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgc2hhcGVDb250YWluZXIgJiYgc2hhcGVDb250YWluZXIuY2xlYXIoKTsgLy8g55Sx5LqOIExhYmVscyDlr7nlupTnmoTmqKHlnZfpnIDopoHnlJ/miJBncm91cO+8jOaJgOS7pei/meS4quWcsOaWuemcgOimgeWIoOmZpFxuXG4gICAgdmFyIGxhYmVsQ29udGFpbmVyID0gdGhpcy5nZXQoJ2xhYmVsQ29udGFpbmVyJyk7XG4gICAgbGFiZWxDb250YWluZXIgJiYgbGFiZWxDb250YWluZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5zZXQoJ2F0dHJzJywge30pO1xuICAgIHRoaXMuc2V0KCdncm91cFNjYWxlcycsIG51bGwpOyAvLyBpZiAoIXRoaXMuZ2V0KCdoYXNEZWZhdWx0QWRqdXN0JykpIHtcbiAgICAvLyAgIHRoaXMuc2V0KCdhZGp1c3RzJywgbnVsbCk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5zZXQoJ2xhYmVsQ29udGFpbmVyJywgbnVsbCk7XG4gICAgdGhpcy5zZXQoJ3hEaXN0YW5jZScsIG51bGwpO1xuICAgIHRoaXMuc2V0KCdpc1N0YWNrZWQnLCBudWxsKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmNsZWFySW5uZXIoKTtcbiAgICB0aGlzLnNldCgnc2NhbGVzJywge30pO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gdGhpcy5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgc2hhcGVDb250YWluZXIgJiYgc2hhcGVDb250YWluZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5vZmZFdmVudHMoKTtcblxuICAgIF9CYXNlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmJpbmRFdmVudHMgPSBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmdldCgndmlldycpKSB7XG4gICAgICB0aGlzLl9iaW5kQWN0aXZlQWN0aW9uKCk7XG5cbiAgICAgIHRoaXMuX2JpbmRTZWxlY3RlZEFjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub2ZmRXZlbnRzID0gZnVuY3Rpb24gb2ZmRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmdldCgndmlldycpKSB7XG4gICAgICB0aGlzLl9vZmZBY3RpdmVBY3Rpb24oKTtcblxuICAgICAgdGhpcy5fb2ZmU2VsZWN0ZWRBY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEdlb21CYXNlO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9tQmFzZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQXhpczogX193ZWJwYWNrX3JlcXVpcmVfXygzMDYpLFxuICBDb21wb25lbnQ6IF9fd2VicGFja19yZXF1aXJlX18oNjYpLFxuICBHdWlkZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMTQpLFxuICBMYWJlbDogX193ZWJwYWNrX3JlcXVpcmVfXygzMjMpLFxuICBMZWdlbmQ6IF9fd2VicGFja19yZXF1aXJlX18oMzI0KSxcbiAgVG9vbHRpcDogX193ZWJwYWNrX3JlcXVpcmVfXygzMzApXG59O1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDorqHnrpdwYXRoIOS9v+eUqOeahOW3peWFt+aWueazlVxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNwbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzM0KTtcblxuZnVuY3Rpb24gcG9pbnRzMnBhdGgocG9pbnRzLCBpc0luQ2lyY2xlKSB7XG4gIGlmICghcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBwYXRoID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHBhdGgucHVzaChbJ00nLCBpdGVtLngsIGl0ZW0ueV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnB1c2goWydMJywgaXRlbS54LCBpdGVtLnldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNJbkNpcmNsZSkge1xuICAgIHBhdGgucHVzaChbJ1onXSk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gX2dldFBvaW50UmFkaXVzKGNvb3JkLCBwb2ludCkge1xuICB2YXIgY2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gIHZhciByID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50LnggLSBjZW50ZXIueCwgMikgKyBNYXRoLnBvdyhwb2ludC55IC0gY2VudGVyLnksIDIpKTtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRBcnIoYXJyLCBjb29yZCkge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRtcCA9IFthcnJbMF1dO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpID0gaSArIDIpIHtcbiAgICB2YXIgcG9pbnQgPSBjb29yZC5jb252ZXJ0UG9pbnQoe1xuICAgICAgeDogYXJyW2ldLFxuICAgICAgeTogYXJyW2kgKyAxXVxuICAgIH0pO1xuICAgIHRtcC5wdXNoKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG5cbiAgcmV0dXJuIHRtcDtcbn1cblxuZnVuY3Rpb24gX2NvbnZlcnRQb2xhclBhdGgocHJlLCBjdXIsIGNvb3JkKSB7XG4gIC8vIGNvbnN0IHJhZGl1cyA9IGNvb3JkLmdldFJhZGl1cygpO1xuICAvLyBjb25zdCBpbm5lciA9IGNvb3JkLmlubmVyUmFkaXVzIHx8IDA7XG4gIC8vIGxldCBpbm5lclJhZGl1cyA9IGlubmVyICogcmFkaXVzO1xuICB2YXIgdHJhbnNwb3NlZCA9IGNvb3JkLmlzVHJhbnNwb3NlZDtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBjb29yZC5zdGFydEFuZ2xlO1xuICB2YXIgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcbiAgdmFyIHByZVBvaW50ID0ge1xuICAgIHg6IHByZVsxXSxcbiAgICB5OiBwcmVbMl1cbiAgfTtcbiAgdmFyIGN1clBvaW50ID0ge1xuICAgIHg6IGN1clsxXSxcbiAgICB5OiBjdXJbMl1cbiAgfTtcbiAgdmFyIHJzdCA9IFtdOyAvLyBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XG5cbiAgdmFyIHhEaW0gPSB0cmFuc3Bvc2VkID8gJ3knIDogJ3gnO1xuICB2YXIgYW5nbGVSYW5nZSA9IE1hdGguYWJzKGN1clBvaW50W3hEaW1dIC0gcHJlUG9pbnRbeERpbV0pICogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIHZhciBkaXJlY3Rpb24gPSBjdXJQb2ludFt4RGltXSA+PSBwcmVQb2ludFt4RGltXSA/IDEgOiAwOyAvLyDlnIblvKfnmoTmlrnlkJFcblxuICB2YXIgZmxhZyA9IGFuZ2xlUmFuZ2UgPiBNYXRoLlBJID8gMSA6IDA7IC8vIOWkp+W8p+i/mOaYr+Wwj+W8p+agh+W/l+S9jVxuXG4gIHZhciBjb252ZXJ0UG9pbnQgPSBjb29yZC5jb252ZXJ0UG9pbnQoY3VyUG9pbnQpO1xuXG4gIHZhciByID0gX2dldFBvaW50UmFkaXVzKGNvb3JkLCBjb252ZXJ0UG9pbnQpO1xuXG4gIGlmIChyID49IDAuNSkge1xuICAgIC8vIOWwj+S6jjHlg4/ntKDnmoTlnIblnKjlm77lg4/kuIrml6Dms5Xor4bliKtcbiAgICBpZiAoYW5nbGVSYW5nZSA9PT0gTWF0aC5QSSAqIDIpIHtcbiAgICAgIHZhciBtaWRkbGVQb2ludCA9IHtcbiAgICAgICAgeDogKGN1clBvaW50LnggKyBwcmVQb2ludC54KSAvIDIsXG4gICAgICAgIHk6IChjdXJQb2ludC55ICsgcHJlUG9pbnQueSkgLyAyXG4gICAgICB9O1xuICAgICAgdmFyIG1pZGRsZUNvbnZlcnRQb2ludCA9IGNvb3JkLmNvbnZlcnRQb2ludChtaWRkbGVQb2ludCk7XG4gICAgICByc3QucHVzaChbJ0EnLCByLCByLCAwLCBmbGFnLCBkaXJlY3Rpb24sIG1pZGRsZUNvbnZlcnRQb2ludC54LCBtaWRkbGVDb252ZXJ0UG9pbnQueV0pO1xuICAgICAgcnN0LnB1c2goWydBJywgciwgciwgMCwgZmxhZywgZGlyZWN0aW9uLCBjb252ZXJ0UG9pbnQueCwgY29udmVydFBvaW50LnldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN0LnB1c2goWydBJywgciwgciwgMCwgZmxhZywgZGlyZWN0aW9uLCBjb252ZXJ0UG9pbnQueCwgY29udmVydFBvaW50LnldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0O1xufSAvLyDlvZPlrZjlnKjmlbTkvZPnmoTlnIbml7bvvIzljrvpmaTlnIbliY3pnaLlkozlkI7pnaLnmoTnur/vvIzpmLLmraLlh7rnjrDnm7Tnur/nqb/ov4fmlbTkuKrlnIbnmoTmg4XlvaJcblxuXG5mdW5jdGlvbiBmaWx0ZXJGdWxsQ2lybGVMaW5lKHBhdGgpIHtcbiAgVXRpbC5lYWNoKHBhdGgsIGZ1bmN0aW9uIChzdWJQYXRoLCBpbmRleCkge1xuICAgIHZhciBjdXIgPSBzdWJQYXRoO1xuXG4gICAgaWYgKGN1clswXS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgIHZhciBwcmUgPSBwYXRoW2luZGV4IC0gMV07XG4gICAgICB2YXIgbmV4dCA9IHBhdGhbaW5kZXggKyAxXTtcblxuICAgICAgaWYgKG5leHQgJiYgbmV4dFswXS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgaWYgKHByZSAmJiBwcmVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgcHJlWzBdID0gJ00nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZSAmJiBwcmVbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHRbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgbmV4dFswXSA9ICdNJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbnZhciBQYXRoVXRpbCA9IHtcbiAgLy8g57q/55qEcGF0aFxuICBnZXRMaW5lUGF0aDogZnVuY3Rpb24gZ2V0TGluZVBhdGgocG9pbnRzLCBpc0luQ2lyY2xlKSB7XG4gICAgcmV0dXJuIHBvaW50czJwYXRoKHBvaW50cywgaXNJbkNpcmNsZSk7XG4gIH0sXG4gIC8vIGdldCBzcGxpbmXvvJog6ZmQ5a6a5LqG6IyD5Zu055qE5bmz5ruR57q/XG4gIGdldFNwbGluZVBhdGg6IGZ1bmN0aW9uIGdldFNwbGluZVBhdGgocG9pbnRzLCBpc0luQ2lyY2xlLCBjb25zdGFpbnQpIHtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBmaXJzdCA9IHBvaW50c1swXTtcbiAgICB2YXIgcHJlUG9pbnQgPSBudWxsO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIFBhdGhVdGlsLmdldExpbmVQYXRoKHBvaW50cywgaXNJbkNpcmNsZSk7XG4gICAgfVxuXG4gICAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICBpZiAoIXByZVBvaW50IHx8ICEocHJlUG9pbnQueCA9PT0gcG9pbnQueCAmJiBwcmVQb2ludC55ID09PSBwb2ludC55KSkge1xuICAgICAgICBkYXRhLnB1c2gocG9pbnQueCk7XG4gICAgICAgIGRhdGEucHVzaChwb2ludC55KTtcbiAgICAgICAgcHJlUG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdGFpbnQgPSBjb25zdGFpbnQgfHwgWy8vIOiMg+WbtFxuICAgIFswLCAwXSwgWzEsIDFdXTtcbiAgICB2YXIgc3BsaW5lUGF0aCA9IFNwbGluZS5jYXRtdWxsUm9tMmJlemllcihkYXRhLCBpc0luQ2lyY2xlLCBjb25zdGFpbnQpO1xuICAgIHNwbGluZVBhdGgudW5zaGlmdChbJ00nLCBmaXJzdC54LCBmaXJzdC55XSk7XG4gICAgcmV0dXJuIHNwbGluZVBhdGg7XG4gIH0sXG4gIGdldFBvaW50UmFkaXVzOiBmdW5jdGlvbiBnZXRQb2ludFJhZGl1cyhjb29yZCwgcG9pbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gX2dldFBvaW50UmFkaXVzKGNvb3JkLCBwb2ludCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBnZXRQb2ludEFuZ2xlOiBmdW5jdGlvbiBnZXRQb2ludEFuZ2xlKGNvb3JkLCBwb2ludCkge1xuICAgIHZhciBjZW50ZXIgPSBjb29yZC5nZXRDZW50ZXIoKTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHBvaW50LnkgLSBjZW50ZXIueSwgcG9pbnQueCAtIGNlbnRlci54KTtcbiAgICByZXR1cm4gYW5nbGU7XG4gIH0sXG4gIGNvbnZlcnROb3JtYWxQYXRoOiBmdW5jdGlvbiBjb252ZXJ0Tm9ybWFsUGF0aChjb29yZCwgcGF0aCkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBVdGlsLmVhY2gocGF0aCwgZnVuY3Rpb24gKHN1YlBhdGgpIHtcbiAgICAgIHZhciBhY3Rpb24gPSBzdWJQYXRoWzBdO1xuXG4gICAgICBzd2l0Y2ggKGFjdGlvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgdG1wLnB1c2goY29udmVydEFycihzdWJQYXRoLCBjb29yZCkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRtcC5wdXNoKHN1YlBhdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0bXA7XG4gIH0sXG4gIGNvbnZlcnRQb2xhclBhdGg6IGZ1bmN0aW9uIGNvbnZlcnRQb2xhclBhdGgoY29vcmQsIHBhdGgpIHtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIHByZTtcbiAgICB2YXIgY3VyO1xuICAgIHZhciB0cmFuc3Bvc2VkO1xuICAgIHZhciBlcXVhbHM7XG4gICAgVXRpbC5lYWNoKHBhdGgsIGZ1bmN0aW9uIChzdWJQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIGFjdGlvbiA9IHN1YlBhdGhbMF07XG5cbiAgICAgIHN3aXRjaCAoYWN0aW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICB0bXAucHVzaChjb252ZXJ0QXJyKHN1YlBhdGgsIGNvb3JkKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgcHJlID0gcGF0aFtpbmRleCAtIDFdO1xuICAgICAgICAgIGN1ciA9IHN1YlBhdGg7XG4gICAgICAgICAgdHJhbnNwb3NlZCA9IGNvb3JkLmlzVHJhbnNwb3NlZDsgLy8g5piv5ZCm5Y2K5b6E55u45ZCM77yM6L2s5o2i5oiQ5ZyG5bynXG5cbiAgICAgICAgICBlcXVhbHMgPSB0cmFuc3Bvc2VkID8gcHJlW3ByZS5sZW5ndGggLSAyXSA9PT0gY3VyWzFdIDogcHJlW3ByZS5sZW5ndGggLSAxXSA9PT0gY3VyWzJdO1xuXG4gICAgICAgICAgaWYgKGVxdWFscykge1xuICAgICAgICAgICAgdG1wID0gdG1wLmNvbmNhdChfY29udmVydFBvbGFyUGF0aChwcmUsIGN1ciwgY29vcmQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8geSDkuI3nm7jnrYnvvIzmiYDku6Xnm7TmjqXovazmjaJcbiAgICAgICAgICAgIHRtcC5wdXNoKGNvbnZlcnRBcnIoc3ViUGF0aCwgY29vcmQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0bXAucHVzaChzdWJQYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWx0ZXJGdWxsQ2lybGVMaW5lKHRtcCk7IC8vIOi/h+a7pOWkmuS9meeahOebtOe6v1xuXG4gICAgcmV0dXJuIHRtcDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gUGF0aFV0aWw7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzTmlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzTmlsKHZhbHVlKSkgcmV0dXJuICcnO1xuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLyoqXG4gICAqIGlzT2JqZWN0KHt9KSA9PiB0cnVlXG4gICAqIGlzT2JqZWN0KFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgKiBpc09iamVjdChGdW5jdGlvbikgPT4gdHJ1ZVxuICAgKiBpc09iamVjdChudWxsKSA9PiBmYWxzZVxuICAgKi9cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYW52YXM6IF9fd2VicGFja19yZXF1aXJlX18oMTgxKSxcbiAgR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oMTAxKSxcbiAgU2hhcGU6IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gIEFyYzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpLFxuICBDaXJjbGU6IF9fd2VicGFja19yZXF1aXJlX18oMTA2KSxcbiAgRG9tOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyksXG4gIEVsbGlwc2U6IF9fd2VicGFja19yZXF1aXJlX18oMTA4KSxcbiAgRmFuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSksXG4gIEltYWdlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCksXG4gIExpbmU6IF9fd2VicGFja19yZXF1aXJlX18oMTExKSxcbiAgTWFya2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSxcbiAgUGF0aDogX193ZWJwYWNrX3JlcXVpcmVfXygxMTIpLFxuICBQb2x5Z29uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMyksXG4gIFBvbHlsaW5lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNCksXG4gIFJlY3Q6IF9fd2VicGFja19yZXF1aXJlX18oMTE1KSxcbiAgVGV4dDogX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpLFxuICBQYXRoU2VnbWVudDogX193ZWJwYWNrX3JlcXVpcmVfXygzOSksXG4gIFBhdGhVdGlsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSxcbiAgRXZlbnQ6IF9fd2VicGFja19yZXF1aXJlX18oMTAwKSxcbiAgLy8gdmVyc2lvbiwgZXRjLlxuICB2ZXJzaW9uOiAnMy4zLjUnXG59O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcblxudmFyIGlzVHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgLyoqXG4gICAqIGlzT2JqZWN0TGlrZShuZXcgRm9vKSA9PiBmYWxzZVxuICAgKiBpc09iamVjdExpa2UoWzEsIDIsIDNdKSA9PiBmYWxzZVxuICAgKiBpc09iamVjdExpa2UoeyB4OiAwLCB5OiAwIH0pID0+IHRydWVcbiAgICogaXNPYmplY3RMaWtlKE9iamVjdC5jcmVhdGUobnVsbCkpID0+IHRydWVcbiAgICovXG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCAhaXNUeXBlKHZhbHVlLCAnT2JqZWN0JykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvID0gdmFsdWU7XG5cbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgcmVnZXhUYWdzID0gL1tNTEhWUVRDU0FaXShbXk1MSFZRVENTQVpdKikvaWc7XG52YXIgcmVnZXhEb3QgPSAvW15cXHNcXCxdKy9pZztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVJhZGl1czogZnVuY3Rpb24gcGFyc2VSYWRpdXMocmFkaXVzKSB7XG4gICAgdmFyIHIxID0gMCxcbiAgICAgICAgcjIgPSAwLFxuICAgICAgICByMyA9IDAsXG4gICAgICAgIHI0ID0gMDtcblxuICAgIGlmIChVdGlsLmlzQXJyYXkocmFkaXVzKSkge1xuICAgICAgaWYgKHJhZGl1cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByYWRpdXNbMF07XG4gICAgICB9IGVsc2UgaWYgKHJhZGl1cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcjEgPSByMyA9IHJhZGl1c1swXTtcbiAgICAgICAgcjIgPSByNCA9IHJhZGl1c1sxXTtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByMSA9IHJhZGl1c1swXTtcbiAgICAgICAgcjIgPSByNCA9IHJhZGl1c1sxXTtcbiAgICAgICAgcjMgPSByYWRpdXNbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByMSA9IHJhZGl1c1swXTtcbiAgICAgICAgcjIgPSByYWRpdXNbMV07XG4gICAgICAgIHIzID0gcmFkaXVzWzJdO1xuICAgICAgICByNCA9IHJhZGl1c1szXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByYWRpdXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHIxOiByMSxcbiAgICAgIHIyOiByMixcbiAgICAgIHIzOiByMyxcbiAgICAgIHI0OiByNFxuICAgIH07XG4gIH0sXG4gIHBhcnNlUGF0aDogZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aCB8fCBbXTtcblxuICAgIGlmIChVdGlsLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICBwYXRoID0gcGF0aC5tYXRjaChyZWdleFRhZ3MpO1xuICAgICAgVXRpbC5lYWNoKHBhdGgsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBpdGVtID0gaXRlbS5tYXRjaChyZWdleERvdCk7XG5cbiAgICAgICAgaWYgKGl0ZW1bMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciB0YWcgPSBpdGVtWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgICBpdGVtLnNwbGljZSgxLCAwLCBpdGVtWzBdLnN1YnN0cigxKSk7XG4gICAgICAgICAgaXRlbVswXSA9IHRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWwuZWFjaChpdGVtLCBmdW5jdGlvbiAoc3ViLCBpKSB7XG4gICAgICAgICAgaWYgKCFpc05hTihzdWIpKSB7XG4gICAgICAgICAgICBpdGVtW2ldID0gK3N1YjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoW2luZGV4XSA9IGl0ZW07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gaHVlO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBnYW1tYTtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gbm9nYW1tYTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2NvbnN0YW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMSk7XG5cblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY29uc3RhbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5mdW5jdGlvbiBnYW1tYSh5KSB7XG4gIHJldHVybiAoeSA9ICt5KSA9PT0gMSA/IG5vZ2FtbWEgOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY29uc3RhbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5mdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19jb25zdGFudF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgdGhlIEF0dHJpYnV0ZSBiYXNlIGNsYXNzXG4gKi9cbnZhciBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbmZ1bmN0aW9uIHRvU2NhbGVTdHJpbmcoc2NhbGUsIHZhbHVlKSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2NhbGUuaW52ZXJ0KHNjYWxlLnNjYWxlKHZhbHVlKSk7XG59XG4vKipcbiAqIOaJgOacieinhuiniemAmumBk+WxnuaAp+eahOWfuuexu1xuICogQGNsYXNzIEF0dHJcbiAqL1xuXG5cbnZhciBBdHRyaWJ1dGVCYXNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXR0cmlidXRlQmFzZShjZmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIOWxnuaAp+eahOexu+Wei1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG5cblxuICAgIHRoaXMudHlwZSA9ICdiYXNlJztcbiAgICAvKipcbiAgICAgKiDlsZ7mgKfnmoTlkI3np7BcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiDlm57osIPlh73mlbBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG5cbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5aSH6YCJ55qE5YC85pWw57uEXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiDlsZ7mgKflhoXpg6jnmoTluqbph49cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cbiAgICB0aGlzLnNjYWxlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIOaYr+WQpumAmui/h+e6v+aAp+WPluWAvCwg5aaC5p6c5pyq5oyH5a6a77yM5YiZ5qC55o2u5pWw5YC855qE57G75Z6L5Yik5a6aXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICB0aGlzLmxpbmVhciA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5b2T55So5oi36K6+572u55qEIGNhbGxiYWNrIOi/lOWbniBudWxsIOaXtiwg5bqU6K+l6L+U5Zue6buY6K6kIGNhbGxiYWNrIOS4reeahOWAvFxuICAgICAqL1xuXG4gICAgdmFyIG1peGVkQ2FsbGJhY2sgPSBudWxsO1xuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrO1xuXG4gICAgaWYgKGNmZy5jYWxsYmFjaykge1xuICAgICAgdmFyIHVzZXJDYWxsYmFjayA9IGNmZy5jYWxsYmFjaztcblxuICAgICAgbWl4ZWRDYWxsYmFjayA9IGZ1bmN0aW9uIG1peGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IHVzZXJDYWxsYmFjay5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG5cbiAgICAgICAgaWYgKGlzTmlsKHJldCkpIHtcbiAgICAgICAgICByZXQgPSBkZWZhdWx0Q2FsbGJhY2suYXBwbHkoX3RoaXMsIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBtaXgodGhpcywgY2ZnKTtcblxuICAgIGlmIChtaXhlZENhbGxiYWNrKSB7XG4gICAgICBtaXgodGhpcywge1xuICAgICAgICBjYWxsYmFjazogbWl4ZWRDYWxsYmFja1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIOiOt+WPluWxnuaAp+WAvO+8jOWwhuWAvOaYoOWwhOWIsOinhuiniemAmumBk1xuXG5cbiAgdmFyIF9wcm90byA9IEF0dHJpYnV0ZUJhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5fZ2V0QXR0clZhbHVlID0gZnVuY3Rpb24gX2dldEF0dHJWYWx1ZShzY2FsZSwgdmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cbiAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSAmJiAhdGhpcy5saW5lYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IHNjYWxlLnRyYW5zbGF0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWVzW2luZGV4ICUgdmFsdWVzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSBzY2FsZS5zY2FsZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGluZWFyVmFsdWUocGVyY2VudCk7XG4gIH07XG4gIC8qKlxuICAgKiDlpoLmnpzov5vooYznur/mgKfmmKDlsITvvIzov5Tlm57lr7nlupTnmoTmmKDlsITlgLxcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBlcmNlbnQg55m+5YiG5q+UXG4gICAqIEByZXR1cm4geyp9ICDpopzoibLlgLzjgIHlvaLnirbjgIHlpKflsI/nrYlcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0TGluZWFyVmFsdWUgPSBmdW5jdGlvbiBnZXRMaW5lYXJWYWx1ZShwZXJjZW50KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBzdGVwcyA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgIHZhciBzdGVwID0gTWF0aC5mbG9vcihzdGVwcyAqIHBlcmNlbnQpO1xuICAgIHZhciBsZWZ0UGVyY2VudCA9IHN0ZXBzICogcGVyY2VudCAtIHN0ZXA7XG4gICAgdmFyIHN0YXJ0ID0gdmFsdWVzW3N0ZXBdO1xuICAgIHZhciBlbmQgPSBzdGVwID09PSBzdGVwcyA/IHN0YXJ0IDogdmFsdWVzW3N0ZXAgKyAxXTtcbiAgICB2YXIgcnN0VmFsdWUgPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiBsZWZ0UGVyY2VudDtcbiAgICByZXR1cm4gcnN0VmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiDpu5jorqTnmoTlm57osIPlh73mlbBcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSDlm57osIPlh73mlbDnmoTlgLxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcmV0dXJuIHtBcnJheX0g6L+U5Zue5pig5bCE5ZCO55qE5YC8XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2sodmFsdWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjYWxlID0gc2VsZi5zY2FsZXNbMF07XG4gICAgdmFyIHJzdFZhbHVlID0gbnVsbDtcblxuICAgIGlmIChzY2FsZS50eXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICByc3RWYWx1ZSA9IHNjYWxlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3RWYWx1ZSA9IHNlbGYuX2dldEF0dHJWYWx1ZShzY2FsZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiByc3RWYWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIOagueaNruW6pumHj+iOt+WPluWxnuaAp+WQjVxuICAgKiBAcmV0dXJuIHtBcnJheX0gZGltcyBvZiB0aGlzIEF0dHJpYnV0ZVxuICAgKi9cblxuXG4gIF9wcm90by5nZXROYW1lcyA9IGZ1bmN0aW9uIGdldE5hbWVzKCkge1xuICAgIHZhciBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICB2YXIgbmFtZXMgPSB0aGlzLm5hbWVzO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihzY2FsZXMubGVuZ3RoLCBuYW1lcy5sZW5ndGgpO1xuICAgIHZhciByc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJzdC5wdXNoKG5hbWVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5bqm6YeP6I635Y+W57u05bqm5ZCNXG4gICAqIEByZXR1cm4ge0FycmF5fSBkaW1zIG9mIHRoaXMgQXR0cmlidXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldEZpZWxkcyA9IGZ1bmN0aW9uIGdldEZpZWxkcygpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGVhY2goc2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIHJzdC5wdXNoKHNjYWxlLmZpZWxkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5ZCN56ew6I635Y+W5bqm6YePXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiBzY2FsZVxuICAgKiBAcmV0dXJuIHtTY2FsZX0gc2NhbGVcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZShuYW1lKSB7XG4gICAgdmFyIHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIHZhciBuYW1lcyA9IHRoaXMubmFtZXM7XG4gICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2NhbGVzW2luZGV4XTtcbiAgfTtcbiAgLyoqXG4gICAqIOaYoOWwhOaVsOaNrlxuICAgKiBAcGFyYW0geyp9IHBhcmFtMS4uLnBhcmFtbiDlpJrkuKrmlbDlgLxcbiAgICogQHJldHVybiB7QXJyYXl9IOaYoOWwhOeahOWAvOe7hOaIkOeahOaVsOe7hFxuICAgKi9cblxuXG4gIF9wcm90by5tYXBwaW5nID0gZnVuY3Rpb24gbWFwcGluZygpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFjaztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBwYXJhbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gcGFyYW1zO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBhcmFtc1tpXSA9IHRoaXMuX3RvT3JpZ2luUGFyYW0ocGFyYW1zW2ldLCBzY2FsZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07IC8vIOWOn+Wni+eahOWPguaVsFxuXG5cbiAgX3Byb3RvLl90b09yaWdpblBhcmFtID0gZnVuY3Rpb24gX3RvT3JpZ2luUGFyYW0ocGFyYW0sIHNjYWxlKSB7XG4gICAgdmFyIHJzdCA9IHBhcmFtO1xuXG4gICAgaWYgKCFzY2FsZS5pc0xpbmVhcikge1xuICAgICAgaWYgKGlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgIHJzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhbS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJzdC5wdXNoKHRvU2NhbGVTdHJpbmcoc2NhbGUsIHBhcmFtW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzdCA9IHRvU2NhbGVTdHJpbmcoc2NhbGUsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIHJldHVybiBBdHRyaWJ1dGVCYXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1peCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBBZGp1c3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gQWRqdXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIHRoaXMuYWRqdXN0TmFtZXMgPSBbJ3gnLCAneSddOyAvLyDosIPmlbTnmoTnu7TluqbvvIzpu5jorqQseCx56YO95YGa6LCD5pW0XG4gIH07XG5cbiAgZnVuY3Rpb24gQWRqdXN0KGNmZykge1xuICAgIHRoaXMuX2luaXREZWZhdWx0Q2ZnKCk7XG5cbiAgICBtaXgodGhpcywgY2ZnKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnByb2Nlc3NBZGp1c3QgPSBmdW5jdGlvbiBwcm9jZXNzQWRqdXN0KClcbiAgLyogZGF0YUFycmF5ICovXG4gIHt9O1xuXG4gIHJldHVybiBBZGp1c3Q7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRqdXN0O1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBHcmlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMpO1xuXG52YXIgTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLFxuICAgIEZPTlRfRkFNSUxZID0gX3JlcXVpcmUuRk9OVF9GQU1JTFk7XG5cbnZhciBBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEF4aXMsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEF4aXMoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEF4aXMucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIC8qKlxuICAgICAgICog55So5LqO5Yqo55S777yM5ZSv5LiA5qCH6K+G55qEIGlkXG4gICAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAgICovXG4gICAgICBfaWQ6IG51bGwsXG4gICAgICB6SW5kZXg6IDQsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Z2Q5qCH6L205LiK55qE5Z2Q5qCH54K5XG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHRpY2tzOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWdkOagh+i9tOe6v+eahOmFjee9ruS/oeaBr++8jOWmguaenOiuvue9ruaIkG51bGzvvIzliJnkuI3mmL7npLrovbTnur9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGxpbmU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Z2Q5qCH6L205Yi75bqm57q/55qE6YWN572uLOWmguaenOiuvue9ruaIkG51bGzvvIzliJnkuI3mmL7npLrliLvluqbnur9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHRpY2tMaW5lOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOasoeWIu+W6pue6v+S4quaVsOmFjee9rlxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgc3ViVGlja0NvdW50OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIOasoeWIu+W6pue6v+agt+W8j+mFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc3ViVGlja0xpbmU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog572R5qC857q/6YWN572u77yM5aaC5p6c5YC85Li6IG51bGzvvIzliJnkuI3mmL7npLpcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGdyaWQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Z2Q5qCH6L205paH5pys6YWN572uXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBsYWJlbDoge1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHRleHRTdHlsZToge30sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+acrOagt+W8j1xuICAgICAgICBhdXRvUm90YXRlOiB0cnVlLFxuICAgICAgICBhdXRvSGlkZTogZmFsc2UsXG4gICAgICAgIGZvcm1hdHRlcjogbnVsbCAvLyDlnZDmoIfovbTmlofmnKzmoLzlvI/ljJblm57osIPlh73mlbBcblxuICAgICAgfSxcbiAgICAgIGxhYmVsSXRlbXM6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWdkOagh+i9tOagh+mimOmFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgYXV0b1JvdGF0ZTogdHJ1ZSxcbiAgICAgICAgLy8g5paH5pys5piv5ZCm6Ieq5Yqo5peL6L2sXG4gICAgICAgIHRleHRTdHlsZToge30gLy8g5Z2Q5qCH6L205qCH6aKY5qC35byPXG5cbiAgICAgIH0sXG4gICAgICBhdXRvUGFpbnQ6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGl0bGUgPSBzZWxmLmdldCgndGl0bGUnKTtcbiAgICB2YXIgbGFiZWwgPSBzZWxmLmdldCgnbGFiZWwnKTtcbiAgICB2YXIgZ3JpZCA9IHNlbGYuZ2V0KCdncmlkJyk7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHNlbGYuc2V0KCd0aXRsZScsIFV0aWwuZGVlcE1peCh7XG4gICAgICAgIGF1dG9Sb3RhdGU6IHRydWUsXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICBmaWxsOiAnI2NjYycsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWSxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDogNDhcbiAgICAgIH0sIHRpdGxlKSk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBzZWxmLnNldCgnbGFiZWwnLCBVdGlsLmRlZXBNaXgoe1xuICAgICAgICBhdXRvUm90YXRlOiB0cnVlLFxuICAgICAgICBhdXRvSGlkZTogdHJ1ZSxcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgIGZpbGw6ICcjY2NjJyxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDogMTBcbiAgICAgIH0sIGxhYmVsKSk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQpIHtcbiAgICAgIHNlbGYuc2V0KCdncmlkJywgVXRpbC5kZWVwTWl4KHtcbiAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICAgIHN0cm9rZTogJyNDMEQwRTAnXG4gICAgICAgIH1cbiAgICAgIH0sIGdyaWQpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5iZWZvcmVSZW5kZXIoKTtcbiAgICB2YXIgbGFiZWxDZmcgPSBzZWxmLmdldCgnbGFiZWwnKTtcblxuICAgIGlmIChsYWJlbENmZykge1xuICAgICAgc2VsZi5yZW5kZXJMYWJlbHMoKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ2F1dG9QYWludCcpKSB7XG4gICAgICBzZWxmLnBhaW50KCk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsLmlzTmlsKHNlbGYuZ2V0KCd0aXRsZScpKSkge1xuICAgICAgc2VsZi5yZW5kZXJUaXRsZSgpO1xuICAgIH1cblxuICAgIHNlbGYuZ2V0KCdncm91cCcpLnNvcnQoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyTGFiZWxzID0gZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ3JvdXAgPSBzZWxmLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgbGFiZWxDZmcgPSBzZWxmLmdldCgnbGFiZWwnKTtcbiAgICB2YXIgbGFiZWxSZW5kZXJlciA9IG5ldyBMYWJlbCgpO1xuICAgIHNlbGYuc2V0KCdsYWJlbFJlbmRlcmVyJywgbGFiZWxSZW5kZXJlcik7XG4gICAgbGFiZWxSZW5kZXJlci5zZXQoJ2xhYmVsQ2ZnJywgbGFiZWxDZmcpO1xuICAgIHZhciBjZmdzMmNvcHkgPSBbJ2Zvcm1hdHRlcicsICdodG1sVGVtcGxhdGUnLCAnbGFiZWxMaW5lJywgJ3RleHRTdHlsZScsICd1c2VIdG1sJ107XG4gICAgVXRpbC5lYWNoKGNmZ3MyY29weSwgZnVuY3Rpb24gKGNmZykge1xuICAgICAgaWYgKGxhYmVsQ2ZnW2NmZ10pIHtcbiAgICAgICAgbGFiZWxSZW5kZXJlci5zZXQoY2ZnLCBsYWJlbENmZ1tjZmddKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsYWJlbFJlbmRlcmVyLnNldCgnY29vcmQnLCBzZWxmLmdldCgnY29vcmQnKSk7XG4gICAgbGFiZWxSZW5kZXJlci5zZXQoJ2dyb3VwJywgZ3JvdXAuYWRkR3JvdXAoKSk7XG4gICAgbGFiZWxSZW5kZXJlci5zZXQoJ2NhbnZhcycsIHNlbGYuZ2V0KCdjYW52YXMnKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVRpY2tzID0gZnVuY3Rpb24gX3BhcnNlVGlja3ModGlja3MpIHtcbiAgICB0aWNrcyA9IHRpY2tzIHx8IFtdO1xuICAgIHZhciB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0aWNrc1tpXTtcblxuICAgICAgaWYgKCFVdGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHRpY2tzW2ldID0gdGhpcy5wYXJzZVRpY2soaXRlbSwgaSwgdGlja3NMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0KCd0aWNrcycsIHRpY2tzKTtcbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGRUaWNrSXRlbSA9IGZ1bmN0aW9uIF9hZGRUaWNrSXRlbShpbmRleCwgcG9pbnQsIGxlbmd0aCwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgdGlja0l0ZW1zID0gdGhpcy5nZXQoJ3RpY2tJdGVtcycpO1xuICAgIHZhciBzdWJUaWNrSXRlbXMgPSB0aGlzLmdldCgnc3ViVGlja0l0ZW1zJyk7XG4gICAgdmFyIGVuZCA9IHRoaXMuZ2V0VGlja0VuZChwb2ludCwgbGVuZ3RoLCBpbmRleCk7XG4gICAgdmFyIGNmZyA9IHtcbiAgICAgIHgxOiBwb2ludC54LFxuICAgICAgeTE6IHBvaW50LnksXG4gICAgICB4MjogZW5kLngsXG4gICAgICB5MjogZW5kLnlcbiAgICB9O1xuXG4gICAgaWYgKCF0aWNrSXRlbXMpIHtcbiAgICAgIHRpY2tJdGVtcyA9IFtdO1xuICAgIH1cblxuICAgIGlmICghc3ViVGlja0l0ZW1zKSB7XG4gICAgICBzdWJUaWNrSXRlbXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N1YicpIHtcbiAgICAgIHN1YlRpY2tJdGVtcy5wdXNoKGNmZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tJdGVtcy5wdXNoKGNmZyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoJ3RpY2tJdGVtcycsIHRpY2tJdGVtcyk7XG4gICAgdGhpcy5zZXQoJ3N1YlRpY2tJdGVtcycsIHN1YlRpY2tJdGVtcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJMaW5lID0gZnVuY3Rpb24gX3JlbmRlckxpbmUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsaW5lQ2ZnID0gc2VsZi5nZXQoJ2xpbmUnKTtcbiAgICB2YXIgcGF0aDtcblxuICAgIGlmIChsaW5lQ2ZnKSB7XG4gICAgICBwYXRoID0gc2VsZi5nZXRMaW5lUGF0aCgpO1xuICAgICAgbGluZUNmZyA9IFV0aWwubWl4KHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSwgbGluZUNmZyk7XG4gICAgICB2YXIgZ3JvdXAgPSBzZWxmLmdldCgnZ3JvdXAnKTtcbiAgICAgIHZhciBsaW5lU2hhcGUgPSBncm91cC5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgICAgYXR0cnM6IGxpbmVDZmdcbiAgICAgIH0pO1xuICAgICAgbGluZVNoYXBlLm5hbWUgPSAnYXhpcy1saW5lJztcbiAgICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgbGluZVNoYXBlLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICAgICAgc2VsZi5zZXQoJ2xpbmVTaGFwZScsIGxpbmVTaGFwZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcHJvY2Vzc0NhdFRpY2tzID0gZnVuY3Rpb24gX3Byb2Nlc3NDYXRUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhYmVsQ2ZnID0gc2VsZi5nZXQoJ2xhYmVsJyk7XG4gICAgdmFyIHRpY2tMaW5lQ2ZnID0gc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG4gICAgdmFyIHRpY2tzID0gc2VsZi5nZXQoJ3RpY2tzJyk7XG4gICAgdGlja3MgPSBzZWxmLl9wYXJzZVRpY2tzKHRpY2tzKTtcblxuICAgIHZhciBuZXdfdGlja3MgPSBzZWxmLl9nZXROb3JtYWxpemVkVGlja3ModGlja3MpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdfdGlja3MubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciBwID0gc2VsZi5nZXRUaWNrUG9pbnQobmV3X3RpY2tzW2ldKTtcbiAgICAgIHZhciBwMCA9IHNlbGYuZ2V0VGlja1BvaW50KG5ld190aWNrc1tpICsgMV0pO1xuICAgICAgdmFyIHAxID0gc2VsZi5nZXRUaWNrUG9pbnQobmV3X3RpY2tzW2kgKyAyXSk7XG4gICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKGkgLyAzKTtcbiAgICAgIHZhciB0aWNrID0gdGlja3NbaW5kZXhdO1xuXG4gICAgICBpZiAodGlja0xpbmVDZmcpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgc2VsZi5fYWRkVGlja0l0ZW0oaW5kZXgsIHAwLCB0aWNrTGluZUNmZy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fYWRkVGlja0l0ZW0oaW5kZXgsIHAxLCB0aWNrTGluZUNmZy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFiZWxDZmcpIHtcbiAgICAgICAgc2VsZi5hZGRMYWJlbCh0aWNrLCBwLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fZ2V0Tm9ybWFsaXplZFRpY2tzID0gZnVuY3Rpb24gX2dldE5vcm1hbGl6ZWRUaWNrcyh0aWNrcykge1xuICAgIHZhciB0aWNrU2VnID0gMDtcblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aWNrU2VnID0gKHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWUpIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdmFyIHAgPSB0aWNrLnZhbHVlO1xuICAgICAgdmFyIHAwID0gdGljay52YWx1ZSAtIHRpY2tTZWc7XG4gICAgICB2YXIgcDEgPSB0aWNrLnZhbHVlICsgdGlja1NlZztcbiAgICAgIHBvaW50cy5wdXNoKHAsIHAwLCBwMSk7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlID0gVXRpbC5hcnJheVV0aWwuZ2V0UmFuZ2UocG9pbnRzKTtcbiAgICByZXR1cm4gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgdmFyIG5vcm0gPSAocCAtIHJhbmdlLm1pbikgLyAocmFuZ2UubWF4IC0gcmFuZ2UubWluKTtcbiAgICAgIHJldHVybiBub3JtO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKHRpY2ssIHBvaW50LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGFiZWxJdGVtcyA9IHNlbGYuZ2V0KCdsYWJlbEl0ZW1zJyk7XG4gICAgdmFyIGxhYmVsUmVuZGVyZXIgPSBzZWxmLmdldCgnbGFiZWxSZW5kZXJlcicpO1xuICAgIHZhciBsYWJlbCA9IFV0aWwuZGVlcE1peCh7fSwgc2VsZi5nZXQoJ2xhYmVsJykpO1xuICAgIHZhciByc3Q7XG5cbiAgICBpZiAobGFiZWxSZW5kZXJlcikge1xuICAgICAgdmFyIG9mZnNldCA9IHNlbGYuZ2V0KCdfbGFiZWxPZmZzZXQnKTtcblxuICAgICAgaWYgKCFVdGlsLmlzTmlsKHNlbGYuZ2V0KCdsYWJlbCcpLm9mZnNldCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5nZXQoJ2xhYmVsJykub2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgdmVjdG9yID0gc2VsZi5nZXRTaWRlVmVjdG9yKG9mZnNldCwgcG9pbnQsIGluZGV4KTtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICB4OiBwb2ludC54ICsgdmVjdG9yWzBdICsgbGFiZWwub2Zmc2V0WCxcbiAgICAgICAgeTogcG9pbnQueSArIHZlY3RvclsxXSArIGxhYmVsLm9mZnNldFlcbiAgICAgIH07XG4gICAgICBsYWJlbC50ZXh0ID0gdGljay50ZXh0O1xuICAgICAgbGFiZWwueCA9IHBvaW50Lng7XG4gICAgICBsYWJlbC55ID0gcG9pbnQueTtcbiAgICAgIGxhYmVsLnBvaW50ID0gcG9pbnQ7XG4gICAgICBsYWJlbC50ZXh0QWxpZ24gPSBzZWxmLmdldFRleHRBbmNob3IodmVjdG9yKTtcblxuICAgICAgaWYgKHBvaW50LnJvdGF0ZSkge1xuICAgICAgICBsYWJlbC5yb3RhdGUgPSBwb2ludC5yb3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsSXRlbXMucHVzaChsYWJlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uX3Byb2Nlc3NUaWNrcyA9IGZ1bmN0aW9uIF9wcm9jZXNzVGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYWJlbENmZyA9IHNlbGYuZ2V0KCdsYWJlbCcpO1xuICAgIHZhciBzdWJUaWNrQ291bnQgPSBzZWxmLmdldCgnc3ViVGlja0NvdW50Jyk7XG4gICAgdmFyIHRpY2tMaW5lQ2ZnID0gc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG4gICAgdmFyIHRpY2tzID0gc2VsZi5nZXQoJ3RpY2tzJyk7XG4gICAgdGlja3MgPSBzZWxmLl9wYXJzZVRpY2tzKHRpY2tzKTtcbiAgICBVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrLCBpbmRleCkge1xuICAgICAgdmFyIHRpY2tQb2ludCA9IHNlbGYuZ2V0VGlja1BvaW50KHRpY2sudmFsdWUsIGluZGV4KTtcblxuICAgICAgaWYgKHRpY2tMaW5lQ2ZnKSB7XG4gICAgICAgIHNlbGYuX2FkZFRpY2tJdGVtKGluZGV4LCB0aWNrUG9pbnQsIHRpY2tMaW5lQ2ZnLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYWJlbENmZykge1xuICAgICAgICBzZWxmLmFkZExhYmVsKHRpY2ssIHRpY2tQb2ludCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHN1YlRpY2tDb3VudCkge1xuICAgICAgLy8g5aaC5p6c5pyJ6K6+572u5qyh57qn5YiG54K577yM5re75Yqg5qyh57qndGlja1xuICAgICAgdmFyIHN1YlRpY2tMaW5lQ2ZnID0gc2VsZi5nZXQoJ3N1YlRpY2tMaW5lJyk7XG4gICAgICBVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSB0aWNrLnZhbHVlIC0gdGlja3NbaW5kZXggLSAxXS52YWx1ZTtcbiAgICAgICAgICBkaWZmID0gZGlmZiAvIChzZWxmLmdldCgnc3ViVGlja0NvdW50JykgKyAxKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN1YlRpY2tDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ViVGljayA9IHtcbiAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbmRleCA/IHRpY2tzW2luZGV4IC0gMV0udmFsdWUgKyBpICogZGlmZiA6IGkgKiBkaWZmXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRpY2tQb2ludCA9IHNlbGYuZ2V0VGlja1BvaW50KHN1YlRpY2sudmFsdWUpO1xuICAgICAgICAgICAgdmFyIHN1YlRpY2tMZW5ndGggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChzdWJUaWNrTGluZUNmZyAmJiBzdWJUaWNrTGluZUNmZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3ViVGlja0xlbmd0aCA9IHN1YlRpY2tMaW5lQ2ZnLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YlRpY2tMZW5ndGggPSBwYXJzZUludCh0aWNrTGluZUNmZy5sZW5ndGggKiAoMyAvIDUpLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2FkZFRpY2tJdGVtKGkgLSAxLCB0aWNrUG9pbnQsIHN1YlRpY2tMZW5ndGgsICdzdWInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2FkZFRpY2tMaW5lID0gZnVuY3Rpb24gX2FkZFRpY2tMaW5lKHRpY2tzLCBsaW5lQ2ZnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjZmcgPSBVdGlsLm1peCh7fSwgbGluZUNmZyk7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICBVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBwYXRoLnB1c2goWydNJywgaXRlbS54MSwgaXRlbS55MV0pO1xuICAgICAgcGF0aC5wdXNoKFsnTCcsIGl0ZW0ueDIsIGl0ZW0ueTJdKTtcbiAgICB9KTtcbiAgICBkZWxldGUgY2ZnLmxlbmd0aDtcbiAgICBjZmcucGF0aCA9IHBhdGg7XG4gICAgdmFyIGdyb3VwID0gc2VsZi5nZXQoJ2dyb3VwJyk7XG4gICAgdmFyIHRpY2tTaGFwZSA9IGdyb3VwLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IGNmZ1xuICAgIH0pO1xuICAgIHRpY2tTaGFwZS5uYW1lID0gJ2F4aXMtdGlja3MnO1xuICAgIHRpY2tTaGFwZS5faWQgPSBzZWxmLmdldCgnX2lkJykgKyAnLXRpY2tzJztcbiAgICB0aWNrU2hhcGUuc2V0KCdjb29yZCcsIHNlbGYuZ2V0KCdjb29yZCcpKTtcbiAgICBzZWxmLmdldCgnYXBwZW5kSW5mbycpICYmIHRpY2tTaGFwZS5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCBzZWxmLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlclRpY2tzID0gZnVuY3Rpb24gX3JlbmRlclRpY2tzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGlja0l0ZW1zID0gc2VsZi5nZXQoJ3RpY2tJdGVtcycpO1xuICAgIHZhciBzdWJUaWNrSXRlbXMgPSBzZWxmLmdldCgnc3ViVGlja0l0ZW1zJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNFbXB0eSh0aWNrSXRlbXMpKSB7XG4gICAgICB2YXIgdGlja0xpbmVDZmcgPSBzZWxmLmdldCgndGlja0xpbmUnKTtcblxuICAgICAgc2VsZi5fYWRkVGlja0xpbmUodGlja0l0ZW1zLCB0aWNrTGluZUNmZyk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsLmlzRW1wdHkoc3ViVGlja0l0ZW1zKSkge1xuICAgICAgdmFyIHN1YlRpY2tMaW5lQ2ZnID0gc2VsZi5nZXQoJ3N1YlRpY2tMaW5lJykgfHwgc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG5cbiAgICAgIHNlbGYuX2FkZFRpY2tMaW5lKHN1YlRpY2tJdGVtcywgc3ViVGlja0xpbmVDZmcpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckdyaWQgPSBmdW5jdGlvbiBfcmVuZGVyR3JpZCgpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0KCdncmlkJyk7XG5cbiAgICBpZiAoIWdyaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBncmlkLmNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgZ3JpZC5hcHBlbmRJbmZvID0gdGhpcy5nZXQoJ2FwcGVuZEluZm8nKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB0aGlzLnNldCgnZ3JpZEdyb3VwJywgZ3JvdXAuYWRkR3JvdXAoR3JpZCwgZ3JpZCkpO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyTGFiZWxzID0gZnVuY3Rpb24gX3JlbmRlckxhYmVscygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhYmVsUmVuZGVyZXIgPSBzZWxmLmdldCgnbGFiZWxSZW5kZXJlcicpO1xuICAgIHZhciBsYWJlbEl0ZW1zID0gc2VsZi5nZXQoJ2xhYmVsSXRlbXMnKTtcblxuICAgIGlmIChsYWJlbFJlbmRlcmVyKSB7XG4gICAgICBsYWJlbFJlbmRlcmVyLnNldCgnaXRlbXMnLCBsYWJlbEl0ZW1zKTtcblxuICAgICAgbGFiZWxSZW5kZXJlci5fZHJ5RHJhdygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFpbnQgPSBmdW5jdGlvbiBwYWludCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRpY2tMaW5lQ2ZnID0gc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG4gICAgdmFyIGFsaWduV2l0aExhYmVsID0gdHJ1ZTtcblxuICAgIGlmICh0aWNrTGluZUNmZyAmJiB0aWNrTGluZUNmZy5oYXNPd25Qcm9wZXJ0eSgnYWxpZ25XaXRoTGFiZWwnKSkge1xuICAgICAgYWxpZ25XaXRoTGFiZWwgPSB0aWNrTGluZUNmZy5hbGlnbldpdGhMYWJlbDtcbiAgICB9XG5cbiAgICBzZWxmLl9yZW5kZXJMaW5lKCk7XG5cbiAgICB2YXIgdHlwZSA9IHNlbGYuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGlzQ2F0ID0gdHlwZSA9PT0gJ2NhdCcgfHwgdHlwZSA9PT0gJ3RpbWVDYXQnO1xuXG4gICAgaWYgKGlzQ2F0ICYmIGFsaWduV2l0aExhYmVsID09PSBmYWxzZSkge1xuICAgICAgc2VsZi5fcHJvY2Vzc0NhdFRpY2tzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX3Byb2Nlc3NUaWNrcygpO1xuICAgIH1cblxuICAgIHNlbGYuX3JlbmRlclRpY2tzKCk7XG5cbiAgICBzZWxmLl9yZW5kZXJHcmlkKCk7XG5cbiAgICBzZWxmLl9yZW5kZXJMYWJlbHMoKTtcblxuICAgIHZhciBsYWJlbENmZyA9IHRoaXMuZ2V0KCdsYWJlbCcpO1xuXG4gICAgaWYgKGxhYmVsQ2ZnICYmIGxhYmVsQ2ZnLmF1dG9Sb3RhdGUpIHtcbiAgICAgIHNlbGYuYXV0b1JvdGF0ZUxhYmVscygpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbENmZyAmJiBsYWJlbENmZy5hdXRvSGlkZSkge1xuICAgICAgc2VsZi5hdXRvSGlkZUxhYmVscygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2VUaWNrID0gZnVuY3Rpb24gcGFyc2VUaWNrKHRpY2ssIGluZGV4LCBsZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdGljayxcbiAgICAgIHZhbHVlOiBpbmRleCAvIChsZW5ndGggLSAxKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFRleHRBbmNob3IgPSBmdW5jdGlvbiBnZXRUZXh0QW5jaG9yKHZlY3Rvcikge1xuICAgIHZhciByYXRpbyA9IE1hdGguYWJzKHZlY3RvclsxXSAvIHZlY3RvclswXSk7XG4gICAgdmFyIGFsaWduO1xuXG4gICAgaWYgKHJhdGlvID49IDEpIHtcbiAgICAgIC8vIOS4iumdouaIluiAheS4i+mdolxuICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZlY3RvclswXSA+IDApIHtcbiAgICAgICAgLy8g5Y+z5L6nXG4gICAgICAgIGFsaWduID0gJ3N0YXJ0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOW3puS+p1xuICAgICAgICBhbGlnbiA9ICdlbmQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TWF4TGFiZWxXaWR0aCA9IGZ1bmN0aW9uIGdldE1heExhYmVsV2lkdGgobGFiZWxSZW5kZXJlcikge1xuICAgIHZhciBsYWJlbHMgPSBsYWJlbFJlbmRlcmVyLmdldExhYmVscygpO1xuICAgIHZhciBtYXggPSAwO1xuICAgIFV0aWwuZWFjaChsYWJlbHMsIGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgdmFyIGJib3ggPSBsYWJlbC5nZXRCQm94KCk7XG4gICAgICB2YXIgd2lkdGggPSBiYm94LndpZHRoO1xuXG4gICAgICBpZiAobWF4IDwgd2lkdGgpIHtcbiAgICAgICAgbWF4ID0gd2lkdGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TWF4TGFiZWxIZWlnaHQgPSBmdW5jdGlvbiBnZXRNYXhMYWJlbEhlaWdodChsYWJlbFJlbmRlcmVyKSB7XG4gICAgdmFyIGxhYmVscyA9IGxhYmVsUmVuZGVyZXIuZ2V0TGFiZWxzKCk7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgVXRpbC5lYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICB2YXIgYmJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgICAgIHZhciBoZWlnaHQgPSBiYm94LmhlaWdodDtcblxuICAgICAgaWYgKG1heCA8IGhlaWdodCkge1xuICAgICAgICBtYXggPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLmRlc3Ryb3llZCkge1xuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgZ3JpZEdyb3VwID0gc2VsZi5nZXQoJ2dyaWRHcm91cCcpO1xuICAgICAgZ3JpZEdyb3VwICYmIGdyaWRHcm91cC5yZW1vdmUoKTtcbiAgICAgIHZhciBsYWJlbFJlbmRlcmVyID0gdGhpcy5nZXQoJ2xhYmVsUmVuZGVyZXInKTtcbiAgICAgIGxhYmVsUmVuZGVyZXIgJiYgbGFiZWxSZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICB2YXIgZ3JvdXAgPSBzZWxmLmdldCgnZ3JvdXAnKTtcbiAgICAgIGdyb3VwLmRlc3Ryb3koKTtcbiAgICAgIHNlbGYuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBncm91cCA9IHNlbGYuZ2V0KCdncm91cCcpO1xuXG4gICAgaWYgKCFncm91cC5nZXQoJ2Rlc3Ryb3llZCcpICYmIGdyb3VwLmdldCgnY2hpbGRyZW4nKS5sZW5ndGgpIHtcbiAgICAgIHZhciBncmlkR3JvdXAgPSBzZWxmLmdldCgnZ3JpZEdyb3VwJyk7XG4gICAgICBncmlkR3JvdXAgJiYgZ3JpZEdyb3VwLmNsZWFyKCk7XG4gICAgICB2YXIgbGFiZWxSZW5kZXJlciA9IHRoaXMuZ2V0KCdsYWJlbFJlbmRlcmVyJyk7XG4gICAgICBsYWJlbFJlbmRlcmVyICYmIGxhYmVsUmVuZGVyZXIuY2xlYXIoKTtcblxuICAgICAgdmFyIF9ncm91cCA9IHNlbGYuZ2V0KCdncm91cCcpO1xuXG4gICAgICBfZ3JvdXAuY2xlYXIoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiDml4vovazmlofmnKxcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cblxuXG4gIF9wcm90by5hdXRvUm90YXRlTGFiZWxzID0gZnVuY3Rpb24gYXV0b1JvdGF0ZUxhYmVscygpIHt9O1xuICAvKipcbiAgICog5paH5pys6Ieq5Yqo6Ziy6YGu572pXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICovXG5cblxuICBfcHJvdG8uYXV0b0hpZGVMYWJlbHMgPSBmdW5jdGlvbiBhdXRvSGlkZUxhYmVscygpIHt9O1xuICAvKipcbiAgICog5riy5p+T5qCH6aKYXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICovXG5cblxuICBfcHJvdG8ucmVuZGVyVGl0bGUgPSBmdW5jdGlvbiByZW5kZXJUaXRsZSgpIHt9O1xuICAvKipcbiAgICog6I635Y+W5Z2Q5qCH6L2057q/55qEIHBhdGhcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRMaW5lUGF0aCA9IGZ1bmN0aW9uIGdldExpbmVQYXRoKCkge307XG4gIC8qKlxuICAgKiDojrflj5YgdGljayDlnKjnlLvluIPkuIrnmoTkvY3nva5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRUaWNrUG9pbnQgPSBmdW5jdGlvbiBnZXRUaWNrUG9pbnQoKSB7fTtcbiAgLyoqXG4gICAqIOiOt+WPluagh+ekuuWdkOagh+eCueeahOe6v+eahOe7iOeCuVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRpY2tFbmQgPSBmdW5jdGlvbiBnZXRUaWNrRW5kKCkge307XG4gIC8qKlxuICAgKiDojrflj5bot53nprvlnZDmoIfovbTnmoTlkJHph49cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRTaWRlVmVjdG9yID0gZnVuY3Rpb24gZ2V0U2lkZVZlY3RvcigpIHt9O1xuXG4gIHJldHVybiBBeGlzO1xufShDb21wb25lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXM7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG52YXIgQ29tcG9uZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShDb21wb25lbnQsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21wb25lbnQucHJvdG90eXBlOyAvLyDphY3nva5cblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIOmhtuWxguagh+W/l+S9jVxuICAgICAgX2lkOiBudWxsLFxuICAgICAgLy8g55So5LqO5Yqo55S7XG4gICAgICAvLyDlrrnlmahcbiAgICAgIGNhbnZhczogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIC8vIGh0bWzvvIzlj6/pgIlcbiAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgLy8gRyBHcm91cO+8jOWPr+mAiVxuICAgICAgLy8g5Lqk5LqS5bGe5oCnXG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIC8vIHByb3BzXG4gICAgICBjb29yZDogbnVsbCxcbiAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgcGxvdFJhbmdlOiBudWxsLFxuICAgICAgLy8gQkJveFxuICAgICAgcG9zaXRpb246IFswLCAwXSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9O1xuICB9OyAvLyDln7rnoYDnlJ/lkb3lkajmnJ9cblxuXG4gIF9wcm90by5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge307XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7fTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTsgLy8g57uY5Zu+XG5cblxuICBfcHJvdG8uYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyKCkge307XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHt9OyAvLyDliJ3lp4vljJbjgIHnu5Hkuovku7blkoznu5jlm75cblxuXG4gIF9wcm90by5hZnRlclJlbmRlciA9IGZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge307XG5cbiAgX3Byb3RvLmJlZm9yZURyYXcgPSBmdW5jdGlvbiBiZWZvcmVEcmF3KCkge307XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KCkge307IC8vIOWNlee6r+abtOaWsOinhuWbvlxuXG5cbiAgX3Byb3RvLmFmdGVyRHJhdyA9IGZ1bmN0aW9uIGFmdGVyRHJhdygpIHt9OyAvLyB2aXNpYmlsaXR5XG5cblxuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7fTtcblxuICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7fTsgLy8gcHJvcHMgb3BlcmF0aW5nIHN5bnRhY3RpYyBzdWdhclxuXG5cbiAgX3Byb3RvLnNldE9mZnNldCA9IGZ1bmN0aW9uIHNldE9mZnNldCgpIHt9O1xuXG4gIF9wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFBvc2l0aW9uKCkge307XG5cbiAgX3Byb3RvLnNldFZpc2libGUgPSBmdW5jdGlvbiBzZXRWaXNpYmxlKCkge307XG5cbiAgX3Byb3RvLnNldFpJbmRleCA9IGZ1bmN0aW9uIHNldFpJbmRleCgpIHt9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudDtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIG1lYXN1cmVtZW50IG9mIGxpbmVhciBkYXRhIHNjYWxlIGZ1bmN0aW9uXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xuXG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIG51bWJlckF1dG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NCk7XG4vKipcbiAqIOe6v+aAp+W6pumHj1xuICogQGNsYXNzIFNjYWxlLkxpbmVhclxuICovXG5cblxudmFyIExpbmVhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGluZWFyLCBfQmFzZSk7XG5cbiAgZnVuY3Rpb24gTGluZWFyKCkge1xuICAgIHJldHVybiBfQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGluZWFyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9CYXNlLnByb3RvdHlwZS5faW5pdERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLnR5cGUgPSAnbGluZWFyJztcbiAgICBzZWxmLmlzTGluZWFyID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiDmmK/lkKbkuLrkuobnlKjmiLfkuaDmg6/vvIzkvJjljJZtaW4sbWF45ZKMdGlja3PvvIzlpoLmnpzov5vooYzkvJjljJbvvIzliJnkvJrmoLnmja7nlJ/miJDnmoR0aWNrc+iwg+aVtG1pbixtYXjvvIzlkKbliJnoiI3lvIMobWluLG1heCnojIPlm7TkuYvlpJbnmoR0aWNrc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICBzZWxmLm5pY2UgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBtaW4gdmFsdWUgb2YgdGhlIHNjYWxlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLm1pbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogbWluIHZhbHVlIGxpbWl0dGVkIG9mIHRoZSBzY2FsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi5taW5MaW1pdCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogbWF4IHZhbHVlIG9mIHRoZSBzY2FsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi5tYXggPSBudWxsO1xuICAgIC8qKlxuICAgICAqIG1heCB2YWx1ZSBsaW1pdHRlZCBvZiB0aGUgc2NhbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIHNlbGYubWF4TGltaXQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIOiHquWKqOeUn+aIkOagh+iusOaXtueahOS4quaVsFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi50aWNrQ291bnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIOWdkOagh+i9tOeCueS5i+mXtOeahOmXtOi3ne+8jOaMh+eahOaYr+ecn+WunuaVsOaNrueahOW3ruWAvFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi50aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIOWdkOagh+i9tOeCueS5i+mXtOeahOacgOWwj+mXtOi3ne+8jOaMh+eahOaYr+ecn+WunuaVsOaNrueahOW3ruWAvFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi5taW5UaWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIOeUqOS6juiuoeeul+WdkOagh+eCueaXtumAvOi/keeahOaVsOe7hFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cblxuICAgIHNlbGYuc25hcEFycmF5ID0gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghc2VsZi50aWNrcykge1xuICAgICAgc2VsZi5taW4gPSBzZWxmLnRyYW5zbGF0ZShzZWxmLm1pbik7XG4gICAgICBzZWxmLm1heCA9IHNlbGYudHJhbnNsYXRlKHNlbGYubWF4KTtcbiAgICAgIHNlbGYuaW5pdFRpY2tzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0aWNrcyA9IHNlbGYudGlja3M7XG4gICAgICB2YXIgZmlyc3RWYWx1ZSA9IHNlbGYudHJhbnNsYXRlKHRpY2tzWzBdKTtcbiAgICAgIHZhciBsYXN0VmFsdWUgPSBzZWxmLnRyYW5zbGF0ZSh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChpc05pbChzZWxmLm1pbikgfHwgc2VsZi5taW4gPiBmaXJzdFZhbHVlKSB7XG4gICAgICAgIHNlbGYubWluID0gZmlyc3RWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmlsKHNlbGYubWF4KSB8fCBzZWxmLm1heCA8IGxhc3RWYWx1ZSkge1xuICAgICAgICBzZWxmLm1heCA9IGxhc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiDorqHnrpflnZDmoIfngrlcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0g6K6h566X5a6M5oiQ55qE5Z2Q5qCH54K5XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbGN1bGF0ZVRpY2tzID0gZnVuY3Rpb24gY2FsY3VsYXRlVGlja3MoKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluLFxuICAgICAgICBtYXggPSB0aGlzLm1heCxcbiAgICAgICAgbWluTGltaXQgPSB0aGlzLm1pbkxpbWl0LFxuICAgICAgICBtYXhMaW1pdCA9IHRoaXMubWF4TGltaXQsXG4gICAgICAgIHRpY2tDb3VudCA9IHRoaXMudGlja0NvdW50LFxuICAgICAgICB0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcbiAgICAgICAgbWluVGlja0ludGVydmFsID0gdGhpcy5taW5UaWNrSW50ZXJ2YWwsXG4gICAgICAgIHNuYXBBcnJheSA9IHRoaXMuc25hcEFycmF5O1xuXG4gICAgaWYgKHRpY2tDb3VudCA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5lYXIgc2NhbGVcXCd0aWNrQ291bnQgc2hvdWxkIG5vdCBiZSAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG1heCA8IG1pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4OiBcIiArIG1heCArIFwiIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIG1pbjogXCIgKyBtaW4pO1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBudW1iZXJBdXRvKHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW5MaW1pdDogbWluTGltaXQsXG4gICAgICBtYXhMaW1pdDogbWF4TGltaXQsXG4gICAgICBtaW5Db3VudDogdGlja0NvdW50LFxuICAgICAgbWF4Q291bnQ6IHRpY2tDb3VudCxcbiAgICAgIGludGVydmFsOiB0aWNrSW50ZXJ2YWwsXG4gICAgICBtaW5UaWNrSW50ZXJ2YWw6IG1pblRpY2tJbnRlcnZhbCxcbiAgICAgIHNuYXBBcnJheTogc25hcEFycmF5XG4gICAgfSk7XG4gICAgcmV0dXJuIHRtcC50aWNrcztcbiAgfTsgLy8g5Yid5aeL5YyWdGlja3NcblxuXG4gIF9wcm90by5pbml0VGlja3MgPSBmdW5jdGlvbiBpbml0VGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxUaWNrcyA9IHNlbGYuY2FsY3VsYXRlVGlja3MoKTtcblxuICAgIGlmIChzZWxmLm5pY2UpIHtcbiAgICAgIC8vIOWmguaenOmcgOimgeS8mOWMluaYvuekuueahHRpY2tcbiAgICAgIHNlbGYudGlja3MgPSBjYWxUaWNrcztcbiAgICAgIHNlbGYubWluID0gY2FsVGlja3NbMF07XG4gICAgICBzZWxmLm1heCA9IGNhbFRpY2tzW2NhbFRpY2tzLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGlja3MgPSBbXTtcbiAgICAgIGVhY2goY2FsVGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgIGlmICh0aWNrID49IHNlbGYubWluICYmIHRpY2sgPD0gc2VsZi5tYXgpIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8g5aaC5p6cIHRpY2tzIOS4uuepuu+8jOebtOaOpei+k+WFpeacgOWwj+WAvOOAgeacgOWkp+WAvFxuXG4gICAgICBpZiAoIXRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcy5wdXNoKHNlbGYubWluKTtcbiAgICAgICAgdGlja3MucHVzaChzZWxmLm1heCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYudGlja3MgPSB0aWNrcztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2YWx1ZSkge1xuICAgIGlmIChpc05pbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBtaW4gPSB0aGlzLm1pbjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICByZXR1cm4gcmFuZ2VNaW4gKyBwZXJjZW50ICogKHJhbmdlTWF4IC0gcmFuZ2VNaW4pO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCh2YWx1ZSkge1xuICAgIHZhciBwZXJjZW50ID0gKHZhbHVlIC0gdGhpcy5yYW5nZU1pbigpKSAvICh0aGlzLnJhbmdlTWF4KCkgLSB0aGlzLnJhbmdlTWluKCkpO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBlcmNlbnQgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH07XG5cbiAgcmV0dXJuIExpbmVhcjtcbn0oQmFzZSk7XG5cbkJhc2UuTGluZWFyID0gTGluZWFyO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXI7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlKSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHZhbHVlKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIFBSRUNJU0lPTiA9IDAuMDAwMDE7IC8vIG51bWJlcnMgbGVzcyB0aGFuIHRoaXMgaXMgY29uc2lkZXJlZCBhcyAwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXJFcXVhbChhLCBiKSB7XG4gIHZhciBwcmVjaXNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFBSRUNJU0lPTjtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IHByZWNpc2lvbjtcbn07XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHZlYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLnZlYzI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdDogZnVuY3Rpb24gYXQocDEsIHAyLCB0KSB7XG4gICAgcmV0dXJuIChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgfSxcbiAgcG9pbnREaXN0YW5jZTogZnVuY3Rpb24gcG9pbnREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdO1xuXG4gICAgaWYgKHZlYzIuZXhhY3RFcXVhbHMoZCwgWzAsIDBdKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB2YXIgdSA9IFstZFsxXSwgZFswXV07XG4gICAgdmVjMi5ub3JtYWxpemUodSwgdSk7XG4gICAgdmFyIGEgPSBbeCAtIHgxLCB5IC0geTFdO1xuICAgIHJldHVybiBNYXRoLmFicyh2ZWMyLmRvdChhLCB1KSk7XG4gIH0sXG4gIGJveDogZnVuY3Rpb24gYm94KHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gbGluZVdpZHRoIC8gMjtcbiAgICB2YXIgbWluWCA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgdmFyIG1heFggPSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIHZhciBtaW5ZID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICB2YXIgbWF4WSA9IE1hdGgubWF4KHkxLCB5Mik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IG1pblggLSBoYWxmV2lkdGgsXG4gICAgICBtaW5ZOiBtaW5ZIC0gaGFsZldpZHRoLFxuICAgICAgbWF4WDogbWF4WCArIGhhbGZXaWR0aCxcbiAgICAgIG1heFk6IG1heFkgKyBoYWxmV2lkdGhcbiAgICB9O1xuICB9LFxuICBsZW46IGZ1bmN0aW9uIGxlbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIGNpcmNsZVBvaW50KGN4LCBjeSwgciwgYW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiByICsgY3gsXG4gICAgeTogTWF0aC5zaW4oYW5nbGUpICogciArIGN5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFuZ2xlTmVhclRvKGFuZ2xlLCBtaW4sIG1heCwgb3V0KSB7XG4gIHZhciB2MTtcbiAgdmFyIHYyO1xuXG4gIGlmIChvdXQpIHtcbiAgICBpZiAoYW5nbGUgPCBtaW4pIHtcbiAgICAgIHYxID0gbWluIC0gYW5nbGU7XG4gICAgICB2MiA9IE1hdGguUEkgKiAyIC0gbWF4ICsgYW5nbGU7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IG1heCkge1xuICAgICAgdjEgPSBNYXRoLlBJICogMiAtIGFuZ2xlICsgbWluO1xuICAgICAgdjIgPSBhbmdsZSAtIG1heDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdjEgPSBhbmdsZSAtIG1pbjtcbiAgICB2MiA9IG1heCAtIGFuZ2xlO1xuICB9XG5cbiAgcmV0dXJuIHYxID4gdjIgPyBtYXggOiBtaW47XG59XG5cbmZ1bmN0aW9uIG5lYXJBbmdsZShhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSkge1xuICB2YXIgcGx1cyA9IDA7XG5cbiAgaWYgKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA+PSBNYXRoLlBJICogMikge1xuICAgIHBsdXMgPSBNYXRoLlBJICogMjtcbiAgfVxuXG4gIHN0YXJ0QW5nbGUgPSBVdGlsLm1vZChzdGFydEFuZ2xlLCBNYXRoLlBJICogMik7XG4gIGVuZEFuZ2xlID0gVXRpbC5tb2QoZW5kQW5nbGUsIE1hdGguUEkgKiAyKSArIHBsdXM7XG4gIGFuZ2xlID0gVXRpbC5tb2QoYW5nbGUsIE1hdGguUEkgKiAyKTtcblxuICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgaWYgKHN0YXJ0QW5nbGUgPj0gZW5kQW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA+IGVuZEFuZ2xlICYmIGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmdsZU5lYXJUbyhhbmdsZSwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChhbmdsZSA8IHN0YXJ0QW5nbGUgfHwgYW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBhbmdsZU5lYXJUbyhhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUpIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA8IGFuZ2xlICYmIGFuZ2xlIDwgZW5kQW5nbGUpIHtcbiAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGVOZWFyVG8oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUgfHwgYW5nbGUgPCBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhbmdsZTtcbiAgfVxuXG4gIHJldHVybiBhbmdsZU5lYXJUbyhhbmdsZSwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhcmNQcm9qZWN0UG9pbnQoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCB4LCB5LCBvdXQpIHtcbiAgdmFyIHYgPSBbeCwgeV07XG4gIHZhciB2MCA9IFtjeCwgY3ldO1xuICB2YXIgdjEgPSBbMSwgMF07XG4gIHZhciBzdWJ2ID0gVXRpbC52ZWMyLnN1YnRyYWN0KFtdLCB2LCB2MCk7XG4gIHZhciBhbmdsZSA9IFV0aWwudmVjMi5hbmdsZVRvKHYxLCBzdWJ2KTtcbiAgYW5nbGUgPSBuZWFyQW5nbGUoYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UpO1xuICB2YXIgdnBvaW50ID0gW3IgKiBNYXRoLmNvcyhhbmdsZSkgKyBjeCwgciAqIE1hdGguc2luKGFuZ2xlKSArIGN5XTtcblxuICBpZiAob3V0KSB7XG4gICAgb3V0LnggPSB2cG9pbnRbMF07XG4gICAgb3V0LnkgPSB2cG9pbnRbMV07XG4gIH1cblxuICB2YXIgZCA9IFV0aWwudmVjMi5kaXN0YW5jZSh2cG9pbnQsIHYpO1xuICByZXR1cm4gZDtcbn1cblxuZnVuY3Rpb24gYXJjQm94KGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSkge1xuICB2YXIgYW5nbGVSaWdodCA9IDA7XG4gIHZhciBhbmdsZUJvdHRvbSA9IE1hdGguUEkgLyAyO1xuICB2YXIgYW5nbGVMZWZ0ID0gTWF0aC5QSTtcbiAgdmFyIGFuZ2xlVG9wID0gTWF0aC5QSSAqIDMgLyAyO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBhbmdsZSA9IG5lYXJBbmdsZShhbmdsZVJpZ2h0LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlKTtcblxuICBpZiAoYW5nbGUgPT09IGFuZ2xlUmlnaHQpIHtcbiAgICBwb2ludHMucHVzaChjaXJjbGVQb2ludChjeCwgY3ksIHIsIGFuZ2xlUmlnaHQpKTtcbiAgfVxuXG4gIGFuZ2xlID0gbmVhckFuZ2xlKGFuZ2xlQm90dG9tLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlKTtcblxuICBpZiAoYW5nbGUgPT09IGFuZ2xlQm90dG9tKSB7XG4gICAgcG9pbnRzLnB1c2goY2lyY2xlUG9pbnQoY3gsIGN5LCByLCBhbmdsZUJvdHRvbSkpO1xuICB9XG5cbiAgYW5nbGUgPSBuZWFyQW5nbGUoYW5nbGVMZWZ0LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlKTtcblxuICBpZiAoYW5nbGUgPT09IGFuZ2xlTGVmdCkge1xuICAgIHBvaW50cy5wdXNoKGNpcmNsZVBvaW50KGN4LCBjeSwgciwgYW5nbGVMZWZ0KSk7XG4gIH1cblxuICBhbmdsZSA9IG5lYXJBbmdsZShhbmdsZVRvcCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG5cbiAgaWYgKGFuZ2xlID09PSBhbmdsZVRvcCkge1xuICAgIHBvaW50cy5wdXNoKGNpcmNsZVBvaW50KGN4LCBjeSwgciwgYW5nbGVUb3ApKTtcbiAgfVxuXG4gIHBvaW50cy5wdXNoKGNpcmNsZVBvaW50KGN4LCBjeSwgciwgc3RhcnRBbmdsZSkpO1xuICBwb2ludHMucHVzaChjaXJjbGVQb2ludChjeCwgY3ksIHIsIGVuZEFuZ2xlKSk7XG4gIHZhciBtaW5YID0gSW5maW5pdHk7XG4gIHZhciBtYXhYID0gLUluZmluaXR5O1xuICB2YXIgbWluWSA9IEluZmluaXR5O1xuICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgaWYgKG1pblggPiBwb2ludC54KSB7XG4gICAgICBtaW5YID0gcG9pbnQueDtcbiAgICB9XG5cbiAgICBpZiAobWF4WCA8IHBvaW50LngpIHtcbiAgICAgIG1heFggPSBwb2ludC54O1xuICAgIH1cblxuICAgIGlmIChtaW5ZID4gcG9pbnQueSkge1xuICAgICAgbWluWSA9IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgaWYgKG1heFkgPCBwb2ludC55KSB7XG4gICAgICBtYXhZID0gcG9pbnQueTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1pblg6IG1pblgsXG4gICAgbWluWTogbWluWSxcbiAgICBtYXhYOiBtYXhYLFxuICAgIG1heFk6IG1heFlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5lYXJBbmdsZTogbmVhckFuZ2xlLFxuICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uIHByb2plY3RQb2ludChjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIHgsIHkpIHtcbiAgICB2YXIgcnN0ID0ge307XG4gICAgYXJjUHJvamVjdFBvaW50KGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgeCwgeSwgcnN0KTtcbiAgICByZXR1cm4gcnN0O1xuICB9LFxuICBwb2ludERpc3RhbmNlOiBhcmNQcm9qZWN0UG9pbnQsXG4gIGJveDogYXJjQm94XG59O1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBGb3JtYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIFBhdGhTZWdtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBQSSA9IE1hdGguUEk7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIERFRkFVTFRfTEVOR1RIID0gMTA7XG52YXIgREVGQVVMVF9BTkdMRSA9IFBJIC8gMztcblxuZnVuY3Rpb24gX2FkZEFycm93KGN0eCwgYXR0cnMsIHgxLCB5MSwgeDIsIHkyLCBpc1N0YXJ0KSB7XG4gIHZhciBsZWZ0WDtcbiAgdmFyIGxlZnRZO1xuICB2YXIgcmlnaHRYO1xuICB2YXIgcmlnaHRZO1xuICB2YXIgb2Zmc2V0WDtcbiAgdmFyIG9mZnNldFk7XG4gIHZhciBhbmdsZTtcblxuICBpZiAoIWF0dHJzLmZpbGwpIHtcbiAgICAvLyDpl63lkIjnmoTkuI3nu5jliLbnrq3lpLRcbiAgICB2YXIgYXJyb3dMZW5ndGggPSBhdHRycy5hcnJvd0xlbmd0aCB8fCBERUZBVUxUX0xFTkdUSDtcbiAgICB2YXIgYXJyb3dBbmdsZSA9IGF0dHJzLmFycm93QW5nbGUgPyBhdHRycy5hcnJvd0FuZ2xlICogUEkgLyAxODAgOiBERUZBVUxUX0FOR0xFOyAvLyDovazmjaLkuLrlvKdcbiAgICAvLyBDYWxjdWxhdGUgYW5nbGVcblxuICAgIGFuZ2xlID0gYXRhbjIoeTEgLSB5MiwgeDEgLSB4Mik7XG4gICAgLyogLy8gQWRqdXN0IGFuZ2xlIGNvcnJlY3RseVxuICAgIGFuZ2xlIC09IFBJOyovXG4gICAgLy8gQ2FsY3VsYXRlIG9mZnNldCB0byBwbGFjZSBhcnJvdyBhdCBlZGdlIG9mIHBhdGhcblxuICAgIG9mZnNldFggPSBNYXRoLmFicyhhdHRycy5saW5lV2lkdGggKiBjb3MoYW5nbGUpKSAvIDI7XG4gICAgb2Zmc2V0WSA9IE1hdGguYWJzKGF0dHJzLmxpbmVXaWR0aCAqIHNpbihhbmdsZSkpIC8gMjtcblxuICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICBvZmZzZXRYID0gLW9mZnNldFg7XG4gICAgICBvZmZzZXRZID0gLW9mZnNldFk7XG4gICAgfSAvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXMgZm9yIGxlZnQgaGFsZiBvZiBhcnJvd1xuXG5cbiAgICBsZWZ0WCA9IHgyICsgYXJyb3dMZW5ndGggKiBjb3MoYW5nbGUgKyBhcnJvd0FuZ2xlIC8gMik7XG4gICAgbGVmdFkgPSB5MiArIGFycm93TGVuZ3RoICogc2luKGFuZ2xlICsgYXJyb3dBbmdsZSAvIDIpOyAvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXMgZm9yIHJpZ2h0IGhhbGYgb2YgYXJyb3dcblxuICAgIHJpZ2h0WCA9IHgyICsgYXJyb3dMZW5ndGggKiBjb3MoYW5nbGUgLSBhcnJvd0FuZ2xlIC8gMik7XG4gICAgcmlnaHRZID0geTIgKyBhcnJvd0xlbmd0aCAqIHNpbihhbmdsZSAtIGFycm93QW5nbGUgLyAyKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7IC8vIERyYXcgbGVmdCBoYWxmIG9mIGFycm93XG5cbiAgICBjdHgubW92ZVRvKGxlZnRYIC0gb2Zmc2V0WCwgbGVmdFkgLSBvZmZzZXRZKTtcbiAgICBjdHgubGluZVRvKHgyIC0gb2Zmc2V0WCwgeTIgLSBvZmZzZXRZKTsgLy8gRHJhdyByaWdodCBoYWxmIG9mIGFycm93XG5cbiAgICBjdHgubGluZVRvKHJpZ2h0WCAtIG9mZnNldFgsIHJpZ2h0WSAtIG9mZnNldFkpOyAvLyBWaXN1YWxseSBjb25uZWN0IGFycm93IHRvIHBhdGhcblxuICAgIGN0eC5tb3ZlVG8oeDIgLSBvZmZzZXRYLCB5MiAtIG9mZnNldFkpO1xuICAgIGN0eC5saW5lVG8oeDIgKyBvZmZzZXRYLCB5MiArIG9mZnNldFkpOyAvLyBNb3ZlIGJhY2sgdG8gZW5kIG9mIHBhdGhcblxuICAgIGN0eC5tb3ZlVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoKGF0dHJzKSB7XG4gIHZhciBzZWdtZW50cyA9IFtdO1xuICB2YXIgcGF0aEFycmF5ID0gRm9ybWF0LnBhcnNlUGF0aChhdHRycy5wYXRoKTtcbiAgdmFyIHByZVNlZ21lbnQ7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhBcnJheSkgfHwgcGF0aEFycmF5Lmxlbmd0aCA9PT0gMCB8fCBwYXRoQXJyYXlbMF1bMF0gIT09ICdNJyAmJiBwYXRoQXJyYXlbMF1bMF0gIT09ICdtJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjb3VudCA9IHBhdGhBcnJheS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHBhdGhBcnJheVtpXTtcbiAgICBwcmVTZWdtZW50ID0gbmV3IFBhdGhTZWdtZW50KGl0ZW0sIHByZVNlZ21lbnQsIGkgPT09IGNvdW50IC0gMSk7XG4gICAgc2VnbWVudHMucHVzaChwcmVTZWdtZW50KTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gX2FkZEN1c3RvbWl6ZWRBcnJvdyhjdHgsIGF0dHJzLCB4MSwgeTEsIHgyLCB5MiwgaXNTdGFydCkge1xuICB2YXIgc2hhcGUgPSBpc1N0YXJ0ID8gYXR0cnMuc3RhcnRBcnJvdyA6IGF0dHJzLmVuZEFycm93O1xuICB2YXIgZCA9IHNoYXBlLmQ7XG4gIHZhciBkZWcgPSAwO1xuICB2YXIgeCA9IHgyIC0geDE7XG4gIHZhciB5ID0geTIgLSB5MTtcbiAgdmFyIHRhbiA9IE1hdGguYXRhbih4IC8geSk7XG5cbiAgaWYgKHkgPT09IDAgJiYgeCA8IDApIHtcbiAgICBkZWcgPSBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgZGVnID0gTWF0aC5QSSAvIDIgLSB0YW47XG4gIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA8IDApIHtcbiAgICBkZWcgPSAtTWF0aC5QSSAvIDIgLSB0YW47XG4gIH0gZWxzZSBpZiAoeCA+PSAwICYmIHkgPCAwKSB7XG4gICAgZGVnID0gLXRhbiAtIE1hdGguUEkgLyAyO1xuICB9IGVsc2UgaWYgKHggPD0gMCAmJiB5ID4gMCkge1xuICAgIGRlZyA9IE1hdGguUEkgLyAyIC0gdGFuO1xuICB9XG5cbiAgdmFyIHBhdGggPSBwYXJzZVBhdGgoc2hhcGUpO1xuXG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkKSB7XG4gICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgIHgyID0geDIgKyBNYXRoLnNpbihNYXRoLmFicyh0YW4pKSAqIGQ7XG4gICAgICB5MiA9IHkyICsgTWF0aC5jb3MoTWF0aC5hYnModGFuKSkgKiBkIC0gMC41ICogY3R4LmxpbmVXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSB4MiAtIE1hdGguc2luKE1hdGguYWJzKHRhbikpICogZDtcbiAgICAgIHkyID0geTIgLSBNYXRoLmNvcyhNYXRoLmFicyh0YW4pKSAqIGQgKyAwLjUgKiBjdHgubGluZVdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnRyYW5zbGF0ZSh4MiwgeTIpO1xuICBjdHgucm90YXRlKGRlZyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGF0aFtpXS5kcmF3KGN0eCk7XG4gIH1cblxuICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICBjdHguZmlsbCgpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkU3RhcnRBcnJvdzogZnVuY3Rpb24gYWRkU3RhcnRBcnJvdyhjdHgsIGF0dHJzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGlmICh0eXBlb2YgYXR0cnMuc3RhcnRBcnJvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIF9hZGRDdXN0b21pemVkQXJyb3coY3R4LCBhdHRycywgeDEsIHkxLCB4MiwgeTIsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYXR0cnMuc3RhcnRBcnJvdykge1xuICAgICAgX2FkZEFycm93KGN0eCwgYXR0cnMsIHgxLCB5MSwgeDIsIHkyLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGFkZEVuZEFycm93OiBmdW5jdGlvbiBhZGRFbmRBcnJvdyhjdHgsIGF0dHJzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGlmICh0eXBlb2YgYXR0cnMuZW5kQXJyb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICBfYWRkQ3VzdG9taXplZEFycm93KGN0eCwgYXR0cnMsIHgxLCB5MSwgeDIsIHkyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChhdHRycy5lbmRBcnJvdykge1xuICAgICAgX2FkZEFycm93KGN0eCwgYXR0cnMsIHgxLCB5MSwgeDIsIHkyLCBmYWxzZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEluc2lkZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXG52YXIgQ3ViaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblxudmFyIFF1YWRyYXRpYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxudmFyIEVsbGlwc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cbnZhciB2ZWMzID0gVXRpbC52ZWMzO1xudmFyIG1hdDMgPSBVdGlsLm1hdDM7XG52YXIgQVJSX0NNRCA9IFsnbScsICdsJywgJ2MnLCAnYScsICdxJywgJ2gnLCAndicsICd0JywgJ3MnLCAneiddO1xuXG5mdW5jdGlvbiB0b0Fic29sdXRlKHgsIHksIGN1clBvaW50KSB7XG4gIC8vIOiOt+WPlue7neWvueWdkOagh1xuICByZXR1cm4ge1xuICAgIHg6IGN1clBvaW50LnggKyB4LFxuICAgIHk6IGN1clBvaW50LnkgKyB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvU3ltbWV0cnkocG9pbnQsIGNlbnRlcikge1xuICAvLyDngrnlr7nnp7BcbiAgcmV0dXJuIHtcbiAgICB4OiBjZW50ZXIueCArIChjZW50ZXIueCAtIHBvaW50LngpLFxuICAgIHk6IGNlbnRlci55ICsgKGNlbnRlci55IC0gcG9pbnQueSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gdk1hZyh2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG59XG5cbmZ1bmN0aW9uIHZSYXRpbyh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufVxuXG5mdW5jdGlvbiB2QW5nbGUodSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG59XG5cbmZ1bmN0aW9uIGdldEFyY1BhcmFtcyhwb2ludDEsIHBvaW50MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZykge1xuICB2YXIgcHNpID0gVXRpbC5tb2QoVXRpbC50b1JhZGlhbihwc2lEZWcpLCBNYXRoLlBJICogMik7XG4gIHZhciB4MSA9IHBvaW50MS54O1xuICB2YXIgeTEgPSBwb2ludDEueTtcbiAgdmFyIHgyID0gcG9pbnQyLng7XG4gIHZhciB5MiA9IHBvaW50Mi55O1xuICB2YXIgeHAgPSBNYXRoLmNvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgdmFyIHlwID0gLTEgKiBNYXRoLnNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgdmFyIGxhbWJkYSA9IHhwICogeHAgLyAocnggKiByeCkgKyB5cCAqIHlwIC8gKHJ5ICogcnkpO1xuXG4gIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZGlmZiA9IHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApO1xuICB2YXIgZiA9IE1hdGguc3FydCgocnggKiByeCAqIChyeSAqIHJ5KSAtIGRpZmYpIC8gZGlmZik7XG5cbiAgaWYgKGZhID09PSBmcykge1xuICAgIGYgKj0gLTE7XG4gIH1cblxuICBpZiAoaXNOYU4oZikpIHtcbiAgICBmID0gMDtcbiAgfVxuXG4gIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICB2YXIgY3lwID0gZiAqIC1yeSAqIHhwIC8gcng7XG4gIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiBjeHAgLSBNYXRoLnNpbihwc2kpICogY3lwO1xuICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBNYXRoLnNpbihwc2kpICogY3hwICsgTWF0aC5jb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gTWF0aC5QSTtcbiAgfVxuXG4gIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgIGRUaGV0YSA9IDA7XG4gIH1cblxuICBpZiAoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xuICB9XG5cbiAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgKyAyICogTWF0aC5QSTtcbiAgfVxuXG4gIHJldHVybiBbcG9pbnQxLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmc107XG59XG5cbnZhciBQYXRoU2VnbWVudCA9IGZ1bmN0aW9uIFBhdGhTZWdtZW50KGl0ZW0sIHByZVNlZ21lbnQsIGlzTGFzdCkge1xuICB0aGlzLnByZVNlZ21lbnQgPSBwcmVTZWdtZW50O1xuICB0aGlzLmlzTGFzdCA9IGlzTGFzdDtcbiAgdGhpcy5pbml0KGl0ZW0sIHByZVNlZ21lbnQpO1xufTtcblxuVXRpbC5hdWdtZW50KFBhdGhTZWdtZW50LCB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoaXRlbSwgcHJlU2VnbWVudCkge1xuICAgIHZhciBjb21tYW5kID0gaXRlbVswXTtcbiAgICBwcmVTZWdtZW50ID0gcHJlU2VnbWVudCB8fCB7XG4gICAgICBlbmRQb2ludDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVsYXRpdmUgPSBBUlJfQ01ELmluZGV4T2YoY29tbWFuZCkgPj0gMDsgLy8gL1thLXpdLy50ZXN0KGNvbW1hbmQpO1xuXG4gICAgdmFyIGNtZCA9IHJlbGF0aXZlID8gY29tbWFuZC50b1VwcGVyQ2FzZSgpIDogY29tbWFuZDtcbiAgICB2YXIgcCA9IGl0ZW07XG4gICAgdmFyIHBvaW50MTtcbiAgICB2YXIgcG9pbnQyO1xuICAgIHZhciBwb2ludDM7XG4gICAgdmFyIHBvaW50O1xuICAgIHZhciBwcmVFbmRQb2ludCA9IHByZVNlZ21lbnQuZW5kUG9pbnQ7XG4gICAgdmFyIHAxID0gcFsxXTtcbiAgICB2YXIgcDIgPSBwWzJdO1xuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgcG9pbnQgPSB0b0Fic29sdXRlKHAxLCBwMiwgcHJlRW5kUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ID0ge1xuICAgICAgICAgICAgeDogcDEsXG4gICAgICAgICAgICB5OiBwMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbW1hbmQgPSAnTSc7XG4gICAgICAgIHRoaXMucGFyYW1zID0gW3ByZUVuZFBvaW50LCBwb2ludF07XG4gICAgICAgIHRoaXMuc3ViU3RhcnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIHBvaW50ID0gdG9BYnNvbHV0ZShwMSwgcDIsIHByZUVuZFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHAxLFxuICAgICAgICAgICAgeTogcDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kID0gJ0wnO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtwcmVFbmRQb2ludCwgcG9pbnRdO1xuICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50O1xuXG4gICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3BvaW50LnggLSBwcmVFbmRQb2ludC54LCBwb2ludC55IC0gcHJlRW5kUG9pbnQueV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdGFydFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gcG9pbnQueCwgcHJlRW5kUG9pbnQueSAtIHBvaW50LnldO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgcG9pbnQgPSB0b0Fic29sdXRlKHAxLCAwLCBwcmVFbmRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwMSxcbiAgICAgICAgICAgIHk6IHByZUVuZFBvaW50LnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kID0gJ0wnO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtwcmVFbmRQb2ludCwgcG9pbnRdO1xuICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50O1xuXG4gICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3BvaW50LnggLSBwcmVFbmRQb2ludC54LCBwb2ludC55IC0gcHJlRW5kUG9pbnQueV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdGFydFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gcG9pbnQueCwgcHJlRW5kUG9pbnQueSAtIHBvaW50LnldO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgcG9pbnQgPSB0b0Fic29sdXRlKDAsIHAxLCBwcmVFbmRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwcmVFbmRQb2ludC54LFxuICAgICAgICAgICAgeTogcDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21tYW5kID0gJ0wnO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtwcmVFbmRQb2ludCwgcG9pbnRdO1xuICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50O1xuXG4gICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3BvaW50LnggLSBwcmVFbmRQb2ludC54LCBwb2ludC55IC0gcHJlRW5kUG9pbnQueV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zdGFydFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gcG9pbnQueCwgcHJlRW5kUG9pbnQueSAtIHBvaW50LnldO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgcG9pbnQxID0gdG9BYnNvbHV0ZShwMSwgcDIsIHByZUVuZFBvaW50KTtcbiAgICAgICAgICBwb2ludDIgPSB0b0Fic29sdXRlKHBbM10sIHBbNF0sIHByZUVuZFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludDEgPSB7XG4gICAgICAgICAgICB4OiBwMSxcbiAgICAgICAgICAgIHk6IHAyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwb2ludDIgPSB7XG4gICAgICAgICAgICB4OiBwWzNdLFxuICAgICAgICAgICAgeTogcFs0XVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbW1hbmQgPSAnUSc7XG4gICAgICAgIHRoaXMucGFyYW1zID0gW3ByZUVuZFBvaW50LCBwb2ludDEsIHBvaW50Ml07XG4gICAgICAgIHRoaXMuc3ViU3RhcnQgPSBwcmVTZWdtZW50LnN1YlN0YXJ0O1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gcG9pbnQyO1xuXG4gICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3BvaW50Mi54IC0gcG9pbnQxLngsIHBvaW50Mi55IC0gcG9pbnQxLnldO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RhcnRUYW5nZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbcHJlRW5kUG9pbnQueCAtIHBvaW50MS54LCBwcmVFbmRQb2ludC55IC0gcG9pbnQxLnldO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgcG9pbnQyID0gdG9BYnNvbHV0ZShwMSwgcDIsIHByZUVuZFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludDIgPSB7XG4gICAgICAgICAgICB4OiBwMSxcbiAgICAgICAgICAgIHk6IHAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVTZWdtZW50LmNvbW1hbmQgPT09ICdRJykge1xuICAgICAgICAgIHBvaW50MSA9IHRvU3ltbWV0cnkocHJlU2VnbWVudC5wYXJhbXNbMV0sIHByZUVuZFBvaW50KTtcbiAgICAgICAgICB0aGlzLmNvbW1hbmQgPSAnUSc7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBbcHJlRW5kUG9pbnQsIHBvaW50MSwgcG9pbnQyXTtcbiAgICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgICB0aGlzLmVuZFBvaW50ID0gcG9pbnQyO1xuXG4gICAgICAgICAgdGhpcy5lbmRUYW5nZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwb2ludDIueCAtIHBvaW50MS54LCBwb2ludDIueSAtIHBvaW50MS55XTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5zdGFydFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3ByZUVuZFBvaW50LnggLSBwb2ludDEueCwgcHJlRW5kUG9pbnQueSAtIHBvaW50MS55XTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29tbWFuZCA9ICdUTCc7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBbcHJlRW5kUG9pbnQsIHBvaW50Ml07XG4gICAgICAgICAgdGhpcy5zdWJTdGFydCA9IHByZVNlZ21lbnQuc3ViU3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50MjtcblxuICAgICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbcG9pbnQyLnggLSBwcmVFbmRQb2ludC54LCBwb2ludDIueSAtIHByZUVuZFBvaW50LnldO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0VGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJlRW5kUG9pbnQueCAtIHBvaW50Mi54LCBwcmVFbmRQb2ludC55IC0gcG9pbnQyLnldO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIHBvaW50MSA9IHRvQWJzb2x1dGUocDEsIHAyLCBwcmVFbmRQb2ludCk7XG4gICAgICAgICAgcG9pbnQyID0gdG9BYnNvbHV0ZShwWzNdLCBwWzRdLCBwcmVFbmRQb2ludCk7XG4gICAgICAgICAgcG9pbnQzID0gdG9BYnNvbHV0ZShwWzVdLCBwWzZdLCBwcmVFbmRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQxID0ge1xuICAgICAgICAgICAgeDogcDEsXG4gICAgICAgICAgICB5OiBwMlxuICAgICAgICAgIH07XG4gICAgICAgICAgcG9pbnQyID0ge1xuICAgICAgICAgICAgeDogcFszXSxcbiAgICAgICAgICAgIHk6IHBbNF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHBvaW50MyA9IHtcbiAgICAgICAgICAgIHg6IHBbNV0sXG4gICAgICAgICAgICB5OiBwWzZdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tbWFuZCA9ICdDJztcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbcHJlRW5kUG9pbnQsIHBvaW50MSwgcG9pbnQyLCBwb2ludDNdO1xuICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50MztcblxuICAgICAgICB0aGlzLmVuZFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtwb2ludDMueCAtIHBvaW50Mi54LCBwb2ludDMueSAtIHBvaW50Mi55XTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN0YXJ0VGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3ByZUVuZFBvaW50LnggLSBwb2ludDEueCwgcHJlRW5kUG9pbnQueSAtIHBvaW50MS55XTtcbiAgICAgICAgfTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgIHBvaW50MiA9IHRvQWJzb2x1dGUocDEsIHAyLCBwcmVFbmRQb2ludCk7XG4gICAgICAgICAgcG9pbnQzID0gdG9BYnNvbHV0ZShwWzNdLCBwWzRdLCBwcmVFbmRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQyID0ge1xuICAgICAgICAgICAgeDogcDEsXG4gICAgICAgICAgICB5OiBwMlxuICAgICAgICAgIH07XG4gICAgICAgICAgcG9pbnQzID0ge1xuICAgICAgICAgICAgeDogcFszXSxcbiAgICAgICAgICAgIHk6IHBbNF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZVNlZ21lbnQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgcG9pbnQxID0gdG9TeW1tZXRyeShwcmVTZWdtZW50LnBhcmFtc1syXSwgcHJlRW5kUG9pbnQpO1xuICAgICAgICAgIHRoaXMuY29tbWFuZCA9ICdDJztcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IFtwcmVFbmRQb2ludCwgcG9pbnQxLCBwb2ludDIsIHBvaW50M107XG4gICAgICAgICAgdGhpcy5zdWJTdGFydCA9IHByZVNlZ21lbnQuc3ViU3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50MztcblxuICAgICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbcG9pbnQzLnggLSBwb2ludDIueCwgcG9pbnQzLnkgLSBwb2ludDIueV07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuc3RhcnRUYW5nZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gcG9pbnQxLngsIHByZUVuZFBvaW50LnkgLSBwb2ludDEueV07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbW1hbmQgPSAnU1EnO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gW3ByZUVuZFBvaW50LCBwb2ludDIsIHBvaW50M107XG4gICAgICAgICAgdGhpcy5zdWJTdGFydCA9IHByZVNlZ21lbnQuc3ViU3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmRQb2ludCA9IHBvaW50MztcblxuICAgICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbcG9pbnQzLnggLSBwb2ludDIueCwgcG9pbnQzLnkgLSBwb2ludDIueV07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuc3RhcnRUYW5nZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gcG9pbnQyLngsIHByZUVuZFBvaW50LnkgLSBwb2ludDIueV07XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByeCA9IHAxO1xuICAgICAgICAgIHZhciByeSA9IHAyO1xuICAgICAgICAgIHZhciBwc2kgPSBwWzNdO1xuICAgICAgICAgIHZhciBmYSA9IHBbNF07XG4gICAgICAgICAgdmFyIGZzID0gcFs1XTtcblxuICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgcG9pbnQgPSB0b0Fic29sdXRlKHBbNl0sIHBbN10sIHByZUVuZFBvaW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgICAgIHg6IHBbNl0sXG4gICAgICAgICAgICAgIHk6IHBbN11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21tYW5kID0gJ0EnO1xuICAgICAgICAgIHZhciBwYXJhbXMgPSBnZXRBcmNQYXJhbXMocHJlRW5kUG9pbnQsIHBvaW50LCBmYSwgZnMsIHJ4LCByeSwgcHNpKTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwcmVTZWdtZW50LnN1YlN0YXJ0O1xuICAgICAgICAgIHRoaXMuc3ViU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLmVuZFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBwYXJhbXNbNV0gJSAoTWF0aC5QSSAqIDIpO1xuXG4gICAgICAgICAgaWYgKFV0aWwuaXNOdW1iZXJFcXVhbChzdGFydEFuZ2xlLCBNYXRoLlBJICogMikpIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHBhcmFtc1s2XSAlIChNYXRoLlBJICogMik7XG5cbiAgICAgICAgICBpZiAoVXRpbC5pc051bWJlckVxdWFsKGVuZEFuZ2xlLCBNYXRoLlBJICogMikpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZCA9IDAuMDAxO1xuXG4gICAgICAgICAgdGhpcy5zdGFydFRhbmdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZnMgPT09IDApIHtcbiAgICAgICAgICAgICAgZCAqPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGR4ID0gcGFyYW1zWzNdICogTWF0aC5jb3Moc3RhcnRBbmdsZSAtIGQpICsgcGFyYW1zWzFdO1xuICAgICAgICAgICAgdmFyIGR5ID0gcGFyYW1zWzRdICogTWF0aC5zaW4oc3RhcnRBbmdsZSAtIGQpICsgcGFyYW1zWzJdO1xuICAgICAgICAgICAgcmV0dXJuIFtkeCAtIHN0YXJ0LngsIGR5IC0gc3RhcnQueV07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuZW5kVGFuZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHBhcmFtc1s2XTtcblxuICAgICAgICAgICAgaWYgKGVuZEFuZ2xlIC0gTWF0aC5QSSAqIDIgPCAwLjAwMDEpIHtcbiAgICAgICAgICAgICAgZW5kQW5nbGUgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZHggPSBwYXJhbXNbM10gKiBNYXRoLmNvcyhzdGFydEFuZ2xlICsgZW5kQW5nbGUgKyBkKSArIHBhcmFtc1sxXTtcbiAgICAgICAgICAgIHZhciBkeSA9IHBhcmFtc1s0XSAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSAtIGQpICsgcGFyYW1zWzJdO1xuICAgICAgICAgICAgcmV0dXJuIFtwcmVFbmRQb2ludC54IC0gZHgsIHByZUVuZFBvaW50LnkgLSBkeV07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5jb21tYW5kID0gJ1onO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gW3ByZUVuZFBvaW50LCBwcmVTZWdtZW50LnN1YlN0YXJ0XTtcbiAgICAgICAgICB0aGlzLnN1YlN0YXJ0ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgICB0aGlzLmVuZFBvaW50ID0gcHJlU2VnbWVudC5zdWJTdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNJbnNpZGU6IGZ1bmN0aW9uIGlzSW5zaWRlKHgsIHksIGxpbmVXaWR0aCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29tbWFuZCA9IHNlbGYuY29tbWFuZDtcbiAgICB2YXIgcGFyYW1zID0gc2VsZi5wYXJhbXM7XG4gICAgdmFyIGJveCA9IHNlbGYuYm94O1xuXG4gICAgaWYgKGJveCkge1xuICAgICAgaWYgKCFJbnNpZGUuYm94KGJveC5taW5YLCBib3gubWF4WCwgYm94Lm1pblksIGJveC5tYXhZLCB4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnVEwnOlxuICAgICAgY2FzZSAnTCc6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgcmV0dXJuIEluc2lkZS5saW5lKHBhcmFtc1swXS54LCBwYXJhbXNbMF0ueSwgcGFyYW1zWzFdLngsIHBhcmFtc1sxXS55LCBsaW5lV2lkdGgsIHgsIHkpO1xuXG4gICAgICBjYXNlICdTUSc6XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgcmV0dXJuIEluc2lkZS5xdWFkcmF0aWNsaW5lKHBhcmFtc1swXS54LCBwYXJhbXNbMF0ueSwgcGFyYW1zWzFdLngsIHBhcmFtc1sxXS55LCBwYXJhbXNbMl0ueCwgcGFyYW1zWzJdLnksIGxpbmVXaWR0aCwgeCwgeSk7XG5cbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIEluc2lkZS5jdWJpY2xpbmUocGFyYW1zWzBdLngsIHBhcmFtc1swXS55LCBwYXJhbXNbMV0ueCwgcGFyYW1zWzFdLnksIHBhcmFtc1syXS54LCBwYXJhbXNbMl0ueSwgcGFyYW1zWzNdLngsIHBhcmFtc1szXS55LCBsaW5lV2lkdGgsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgICAgdmFyIGN4ID0gcFsxXTtcbiAgICAgICAgICB2YXIgY3kgPSBwWzJdO1xuICAgICAgICAgIHZhciByeCA9IHBbM107XG4gICAgICAgICAgdmFyIHJ5ID0gcFs0XTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBwWzVdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBwWzZdO1xuICAgICAgICAgIHZhciBwc2kgPSBwWzddO1xuICAgICAgICAgIHZhciBmcyA9IHBbOF07XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgcCA9IFt4LCB5LCAxXTtcbiAgICAgICAgICB2YXIgbSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICBtYXQzLnRyYW5zbGF0ZShtLCBtLCBbLWN4LCAtY3ldKTtcbiAgICAgICAgICBtYXQzLnJvdGF0ZShtLCBtLCAtcHNpKTtcbiAgICAgICAgICBtYXQzLnNjYWxlKG0sIG0sIFsxIC8gc2NhbGVYLCAxIC8gc2NhbGVZXSk7XG4gICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQzKHAsIHAsIG0pO1xuICAgICAgICAgIHJldHVybiBJbnNpZGUuYXJjbGluZSgwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcywgbGluZVdpZHRoLCBwWzBdLCBwWzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0KSB7XG4gICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgIHZhciBwb2ludDE7XG4gICAgdmFyIHBvaW50MjtcbiAgICB2YXIgcG9pbnQzO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBhcmFtc1sxXS54LCBwYXJhbXNbMV0ueSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUTCc6XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgY29udGV4dC5saW5lVG8ocGFyYW1zWzFdLngsIHBhcmFtc1sxXS55KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1NRJzpcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICBwb2ludDEgPSBwYXJhbXNbMV07XG4gICAgICAgIHBvaW50MiA9IHBhcmFtc1syXTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50MS54LCBwb2ludDEueSwgcG9pbnQyLngsIHBvaW50Mi55KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICBwb2ludDEgPSBwYXJhbXNbMV07XG4gICAgICAgIHBvaW50MiA9IHBhcmFtc1syXTtcbiAgICAgICAgcG9pbnQzID0gcGFyYW1zWzNdO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8ocG9pbnQxLngsIHBvaW50MS55LCBwb2ludDIueCwgcG9pbnQyLnksIHBvaW50My54LCBwb2ludDMueSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICAgIHZhciBwMSA9IHBbMV07XG4gICAgICAgICAgdmFyIHAyID0gcFsyXTtcbiAgICAgICAgICB2YXIgY3ggPSBwMTtcbiAgICAgICAgICB2YXIgY3kgPSBwMjtcbiAgICAgICAgICB2YXIgcnggPSBwWzNdO1xuICAgICAgICAgIHZhciByeSA9IHBbNF07XG4gICAgICAgICAgdmFyIHRoZXRhID0gcFs1XTtcbiAgICAgICAgICB2YXIgZFRoZXRhID0gcFs2XTtcbiAgICAgICAgICB2YXIgcHNpID0gcFs3XTtcbiAgICAgICAgICB2YXIgZnMgPSBwWzhdO1xuICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgY29udGV4dC5yb3RhdGUocHNpKTtcbiAgICAgICAgICBjb250ZXh0LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICBjb250ZXh0LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgZ2V0QkJveDogZnVuY3Rpb24gZ2V0QkJveChsaW5lV2lkdGgpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gbGluZVdpZHRoIC8gMjtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgdmFyIHlEaW1zO1xuICAgIHZhciB4RGltcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbDtcblxuICAgIHN3aXRjaCAodGhpcy5jb21tYW5kKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnTSc6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1RMJzpcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICB0aGlzLmJveCA9IHtcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbihwYXJhbXNbMF0ueCwgcGFyYW1zWzFdLngpIC0gaGFsZldpZHRoLFxuICAgICAgICAgIG1heFg6IE1hdGgubWF4KHBhcmFtc1swXS54LCBwYXJhbXNbMV0ueCkgKyBoYWxmV2lkdGgsXG4gICAgICAgICAgbWluWTogTWF0aC5taW4ocGFyYW1zWzBdLnksIHBhcmFtc1sxXS55KSAtIGhhbGZXaWR0aCxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heChwYXJhbXNbMF0ueSwgcGFyYW1zWzFdLnkpICsgaGFsZldpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTUSc6XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgeERpbXMgPSBRdWFkcmF0aWMuZXh0cmVtYShwYXJhbXNbMF0ueCwgcGFyYW1zWzFdLngsIHBhcmFtc1syXS54KTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0geERpbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgeERpbXNbaV0gPSBRdWFkcmF0aWMuYXQocGFyYW1zWzBdLngsIHBhcmFtc1sxXS54LCBwYXJhbXNbMl0ueCwgeERpbXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgeERpbXMucHVzaChwYXJhbXNbMF0ueCwgcGFyYW1zWzJdLngpO1xuICAgICAgICB5RGltcyA9IFF1YWRyYXRpYy5leHRyZW1hKHBhcmFtc1swXS55LCBwYXJhbXNbMV0ueSwgcGFyYW1zWzJdLnkpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB5RGltcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB5RGltc1tpXSA9IFF1YWRyYXRpYy5hdChwYXJhbXNbMF0ueSwgcGFyYW1zWzFdLnksIHBhcmFtc1syXS55LCB5RGltcyk7XG4gICAgICAgIH1cblxuICAgICAgICB5RGltcy5wdXNoKHBhcmFtc1swXS55LCBwYXJhbXNbMl0ueSk7XG4gICAgICAgIHRoaXMuYm94ID0ge1xuICAgICAgICAgIG1pblg6IE1hdGgubWluLmFwcGx5KE1hdGgsIHhEaW1zKSAtIGhhbGZXaWR0aCxcbiAgICAgICAgICBtYXhYOiBNYXRoLm1heC5hcHBseShNYXRoLCB4RGltcykgKyBoYWxmV2lkdGgsXG4gICAgICAgICAgbWluWTogTWF0aC5taW4uYXBwbHkoTWF0aCwgeURpbXMpIC0gaGFsZldpZHRoLFxuICAgICAgICAgIG1heFk6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHlEaW1zKSArIGhhbGZXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIHhEaW1zID0gQ3ViaWMuZXh0cmVtYShwYXJhbXNbMF0ueCwgcGFyYW1zWzFdLngsIHBhcmFtc1syXS54LCBwYXJhbXNbM10ueCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHhEaW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHhEaW1zW2ldID0gQ3ViaWMuYXQocGFyYW1zWzBdLngsIHBhcmFtc1sxXS54LCBwYXJhbXNbMl0ueCwgcGFyYW1zWzNdLngsIHhEaW1zW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHlEaW1zID0gQ3ViaWMuZXh0cmVtYShwYXJhbXNbMF0ueSwgcGFyYW1zWzFdLnksIHBhcmFtc1syXS55LCBwYXJhbXNbM10ueSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHlEaW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHlEaW1zW2ldID0gQ3ViaWMuYXQocGFyYW1zWzBdLnksIHBhcmFtc1sxXS55LCBwYXJhbXNbMl0ueSwgcGFyYW1zWzNdLnksIHlEaW1zW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhEaW1zLnB1c2gocGFyYW1zWzBdLngsIHBhcmFtc1szXS54KTtcbiAgICAgICAgeURpbXMucHVzaChwYXJhbXNbMF0ueSwgcGFyYW1zWzNdLnkpO1xuICAgICAgICB0aGlzLmJveCA9IHtcbiAgICAgICAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4RGltcykgLSBoYWxmV2lkdGgsXG4gICAgICAgICAgbWF4WDogTWF0aC5tYXguYXBwbHkoTWF0aCwgeERpbXMpICsgaGFsZldpZHRoLFxuICAgICAgICAgIG1pblk6IE1hdGgubWluLmFwcGx5KE1hdGgsIHlEaW1zKSAtIGhhbGZXaWR0aCxcbiAgICAgICAgICBtYXhZOiBNYXRoLm1heC5hcHBseShNYXRoLCB5RGltcykgKyBoYWxmV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gdG9kbyDlvoXkvJjljJZcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgICB2YXIgY3ggPSBwWzFdO1xuICAgICAgICAgIHZhciBjeSA9IHBbMl07XG4gICAgICAgICAgdmFyIHJ4ID0gcFszXTtcbiAgICAgICAgICB2YXIgcnkgPSBwWzRdO1xuICAgICAgICAgIHZhciB0aGV0YSA9IHBbNV07XG4gICAgICAgICAgdmFyIGRUaGV0YSA9IHBbNl07XG4gICAgICAgICAgdmFyIHBzaSA9IHBbN107XG4gICAgICAgICAgdmFyIGZzID0gcFs4XTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGV0YTtcbiAgICAgICAgICB2YXIgZW5kID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgdmFyIHhEaW0gPSBFbGxpcHNlLnhFeHRyZW1hKHBzaSwgcngsIHJ5KTtcbiAgICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgIHZhciB4cyA9IFtzdGFydCwgZW5kXTtcblxuICAgICAgICAgIGZvciAoaSA9IC1NYXRoLlBJICogMjsgaSA8PSBNYXRoLlBJICogMjsgaSArPSBNYXRoLlBJKSB7XG4gICAgICAgICAgICB2YXIgeEFuZ2xlID0geERpbSArIGk7XG5cbiAgICAgICAgICAgIGlmIChmcyA9PT0gMSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB4QW5nbGUgJiYgeEFuZ2xlIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCh4QW5nbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZW5kIDwgeEFuZ2xlICYmIHhBbmdsZSA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCh4QW5nbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBFbGxpcHNlLnhBdChwc2ksIHJ4LCByeSwgY3gsIHhzW2ldKTtcblxuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgICAgIG1pblggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHlEaW0gPSBFbGxpcHNlLnlFeHRyZW1hKHBzaSwgcngsIHJ5KTtcbiAgICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgICAgIHZhciB5cyA9IFtzdGFydCwgZW5kXTtcblxuICAgICAgICAgIGZvciAoaSA9IC1NYXRoLlBJICogMjsgaSA8PSBNYXRoLlBJICogMjsgaSArPSBNYXRoLlBJKSB7XG4gICAgICAgICAgICB2YXIgeUFuZ2xlID0geURpbSArIGk7XG5cbiAgICAgICAgICAgIGlmIChmcyA9PT0gMSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPCB5QW5nbGUgJiYgeUFuZ2xlIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgeXMucHVzaCh5QW5nbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZW5kIDwgeUFuZ2xlICYmIHlBbmdsZSA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgeXMucHVzaCh5QW5nbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHkgPSBFbGxpcHNlLnlBdChwc2ksIHJ4LCByeSwgY3ksIHlzW2ldKTtcblxuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib3ggPSB7XG4gICAgICAgICAgICBtaW5YOiBtaW5YIC0gaGFsZldpZHRoLFxuICAgICAgICAgICAgbWF4WDogbWF4WCArIGhhbGZXaWR0aCxcbiAgICAgICAgICAgIG1pblk6IG1pblkgLSBoYWxmV2lkdGgsXG4gICAgICAgICAgICBtYXhZOiBtYXhZICsgaGFsZldpZHRoXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBhdGhTZWdtZW50O1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGEgKyBiICogdDtcbiAgfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhhcnIsIHZhbHVlKSB7XG4gIGlmICghaXNBcnJheUxpa2UoYXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSkgPiAtMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoZGF0YUFycmF5KSB7XG4gIHZhciByc3QgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJzdCA9IHJzdC5jb25jYXQoZGF0YUFycmF5W2ldKTtcbiAgfVxuXG4gIHJldHVybiByc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXQzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSxcbiAgdmVjMjogX193ZWJwYWNrX3JlcXVpcmVfXyg5NyksXG4gIHZlYzM6IF9fd2VicGFja19yZXF1aXJlX18oOTgpLFxuICB0cmFuc2Zvcm06IF9fd2VicGFja19yZXF1aXJlX18oOTkpXG59O1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgYmFzZSBjbGFzcyBvZiBDb29yZGluYXRlXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuXG5cbnZhciBNYXRyaXhVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgbWF0MyA9IE1hdHJpeFV0aWwubWF0MztcbnZhciB2ZWMzID0gTWF0cml4VXRpbC52ZWMzO1xuXG52YXIgQ29vcmQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoQ29vcmQsIFt7XG4gICAga2V5OiBcImdldERlZmF1bHRDZmdcIixcblxuICAgIC8qKlxuICAgICAqIOiOt+WPlum7mOiupOeahOmFjee9ruWxnuaAp1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgeCB5IGlzIHRyYW5zcG9zZWQuXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNUcmFuc3Bvc2VkOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1hdHJpeCBvZiBjb29yZGluYXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIG1hdHJpeDogWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENvb3JkKGNmZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb29yZCk7XG5cbiAgICB2YXIgZGVmYXVsdENmZyA9IHRoaXMuZ2V0RGVmYXVsdENmZygpO1xuICAgIG1peCh0aGlzLCBkZWZhdWx0Q2ZnLCBjZmcpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvb3JkLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogKHN0YXJ0LnggKyBlbmQueCkgLyAyLFxuICAgICAgICB5OiAoc3RhcnQueSArIGVuZC55KSAvIDJcbiAgICAgIH07XG4gICAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyhlbmQueCAtIHN0YXJ0LngpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmFicyhlbmQueSAtIHN0YXJ0LnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3dhcERpbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3dhcERpbShkaW0pIHtcbiAgICAgIHZhciBkaW1SYW5nZSA9IHRoaXNbZGltXTtcblxuICAgICAgaWYgKGRpbVJhbmdlKSB7XG4gICAgICAgIHZhciB0bXAgPSBkaW1SYW5nZS5zdGFydDtcbiAgICAgICAgZGltUmFuZ2Uuc3RhcnQgPSBkaW1SYW5nZS5lbmQ7XG4gICAgICAgIGRpbVJhbmdlLmVuZCA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNlbnRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydERpbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0RGltKHBlcmNlbnQsIGRpbSkge1xuICAgICAgdmFyIF90aGlzJGRpbSA9IHRoaXNbZGltXSxcbiAgICAgICAgICBzdGFydCA9IF90aGlzJGRpbS5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfdGhpcyRkaW0uZW5kO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgcGVyY2VudCAqIChlbmQgLSBzdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydERpbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnREaW0odmFsdWUsIGRpbSkge1xuICAgICAgdmFyIF90aGlzJGRpbTIgPSB0aGlzW2RpbV0sXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyRkaW0yLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF90aGlzJGRpbTIuZW5kO1xuICAgICAgcmV0dXJuICh2YWx1ZSAtIHN0YXJ0KSAvIChlbmQgLSBzdGFydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWwhuW9kuS4gOWMlueahOWdkOagh+eCueaVsOaNrui9rOaNouS4uueUu+W4g+WdkOagh1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg5b2S5LiA5YyW55qE5Z2Q5qCH54K5XG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICDov5Tlm57nlLvluIPlnZDmoIdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bCG55S75biD5Z2Q5qCH6L2s5o2i5Li65b2S5LiA5YyW55qE5Z2Q5qCH54K55pWw5o2uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDnlLvluIPlnZDmoIfngrnmlbDmja5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIOW9kuS4gOWMluWQjueahOaVsOaNrueCuVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bCG5Z2Q5qCH54K56L+b6KGM55+p6Zi15Y+Y5o2iXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB4ICAg5a+55bqUIHgg6L2055S75biD5Z2Q5qCHXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAg5a+55bqUIHkg6L2055S75biD5Z2Q5qCHXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0YWcg6buY6K6k5Li6IDDvvIzlj6/lj5blgLwgMCwgMVxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAg6L+U5Zue5Y+Y5o2i5ZCO55qE5LiJ6Zi25ZCR6YePIFt4LCB5LCB6XVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXgoeCwgeSkge1xuICAgICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciB2ZWN0b3IgPSBbeCwgeSwgdGFnXTtcbiAgICAgIHZlYzMudHJhbnNmb3JtTWF0Myh2ZWN0b3IsIHZlY3RvciwgbWF0cml4KTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWwhuWdkOagh+eCuei/m+ihjOefqemYtemAhuWPmOaNolxuICAgICAqIEBwYXJhbSAge051bWJlcn0geCAgIOWvueW6lCB4IOi9tOeUu+W4g+WdkOagh1xuICAgICAqIEBwYXJhbSAge051bWJlcn0geSAgIOWvueW6lCB5IOi9tOeUu+W4g+WdkOagh1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gdGFnIOm7mOiupOS4uiAw77yM5Y+v5Y+W5YC8IDAsIDFcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgIOi/lOWbnuefqemYtemAhuWPmOaNouWQjueahOS4iemYtuWQkemHjyBbeCwgeSwgel1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmVydE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnRNYXRyaXgoeCwgeSkge1xuICAgICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciBpbnZlcnNlZE1hdHJpeCA9IG1hdDMuaW52ZXJ0KFtdLCBtYXRyaXgpO1xuICAgICAgdmFyIHZlY3RvciA9IFt4LCB5LCB0YWddO1xuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQzKHZlY3RvciwgdmVjdG9yLCBpbnZlcnNlZE1hdHJpeCk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlsIblvZLkuIDljJbnmoTlnZDmoIfngrnmlbDmja7ovazmjaLkuLrnlLvluIPlnZDmoIfvvIzlubbmoLnmja7lnZDmoIfns7vlvZPliY3nn6npmLXov5vooYzlj5jmjaJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50IOW9kuS4gOWMlueahOWdkOagh+eCuVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAg6L+U5Zue6L+b6KGM55+p6Zi15Y+Y5o2i5ZCO55qE55S75biD5Z2Q5qCHXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjb252ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnQocG9pbnQpIHtcbiAgICAgIHZhciBfdGhpcyRjb252ZXJ0UG9pbnQgPSB0aGlzLmNvbnZlcnRQb2ludChwb2ludCksXG4gICAgICAgICAgeCA9IF90aGlzJGNvbnZlcnRQb2ludC54LFxuICAgICAgICAgIHkgPSBfdGhpcyRjb252ZXJ0UG9pbnQueTtcblxuICAgICAgdmFyIHZlY3RvciA9IHRoaXMuYXBwbHlNYXRyaXgoeCwgeSwgMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB2ZWN0b3JbMF0sXG4gICAgICAgIHk6IHZlY3RvclsxXVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bCG6L+b6KGM6L+H55+p6Zi15Y+Y5o2i55S75biD5Z2Q5qCH6L2s5o2i5Li65b2S5LiA5YyW5Z2Q5qCHXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDnlLvluIPlnZDmoIdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIOi/lOWbnuW9kuS4gOWMlueahOWdkOagh+eCuVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgICAgdmFyIHZlY3RvciA9IHRoaXMuaW52ZXJ0TWF0cml4KHBvaW50LngsIHBvaW50LnksIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuaW52ZXJ0UG9pbnQoe1xuICAgICAgICB4OiB2ZWN0b3JbMF0sXG4gICAgICAgIHk6IHZlY3RvclsxXVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWdkOagh+ezu+aXi+i9rOWPmOaNolxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcmFkaWFuIOaXi+i9rOW8p+W6plxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIOi/lOWbnuWdkOagh+ezu+WvueixoVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZShyYWRpYW4pIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICAgIG1hdDMudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbLWNlbnRlci54LCAtY2VudGVyLnldKTtcbiAgICAgIG1hdDMucm90YXRlKG1hdHJpeCwgbWF0cml4LCByYWRpYW4pO1xuICAgICAgbWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFtjZW50ZXIueCwgY2VudGVyLnldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlnZDmoIfns7vlj43lsITlj5jmjaJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpbSDlj43lsITnu7TluqZcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICDov5Tlm57lnZDmoIfns7vlr7nosaFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlZmxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmbGVjdChkaW0pIHtcbiAgICAgIHN3aXRjaCAoZGltKSB7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIHRoaXMuX3N3YXBEaW0oJ3gnKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHRoaXMuX3N3YXBEaW0oJ3knKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5fc3dhcERpbSgneScpO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlnZDmoIfns7vmr5Tkvovlj5jmjaJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHMxIHgg5pa55ZCR57yp5pS+5q+U5L6LXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBzMiB5IOaWueWQkee8qeaUvuavlOS+i1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAg6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZShzMSwgczIpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICAgIG1hdDMudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbLWNlbnRlci54LCAtY2VudGVyLnldKTtcbiAgICAgIG1hdDMuc2NhbGUobWF0cml4LCBtYXRyaXgsIFtzMSwgczJdKTtcbiAgICAgIG1hdDMudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbY2VudGVyLngsIGNlbnRlci55XSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICog5Z2Q5qCH57O75bmz56e75Y+Y5o2iXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB4IHgg5pa55ZCR5bmz56e75YOP57SgXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB5IHkg5pa55ZCR5bmz56e75YOP57SgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgIOi/lOWbnuWdkOagh+ezu+WvueixoVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgW3gsIHldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlsIblnZDmoIfns7sgeCB5IOS4pOS4qui9tOi/m+ihjOi9rOe9rlxuICAgICAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue5Z2Q5qCH57O75a+56LGhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgICAgdGhpcy5pc1RyYW5zcG9zZWQgPSAhdGhpcy5pc1RyYW5zcG9zZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29vcmQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29vcmQ7XG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHNoYXBlIOeahOi+heWKqeaWueazlVxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlVXRpbCA9IHtcbiAgc3BsaXRQb2ludHM6IGZ1bmN0aW9uIHNwbGl0UG9pbnRzKG9iaikge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICB2YXIgeCA9IG9iai54O1xuICAgIHZhciB5ID0gb2JqLnk7XG4gICAgeSA9IFV0aWwuaXNBcnJheSh5KSA/IHkgOiBbeV07XG4gICAgVXRpbC5lYWNoKHksIGZ1bmN0aW9uICh5SXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogVXRpbC5pc0FycmF5KHgpID8geFtpbmRleF0gOiB4LFxuICAgICAgICB5OiB5SXRlbVxuICAgICAgfTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICBhZGRGaWxsQXR0cnM6IGZ1bmN0aW9uIGFkZEZpbGxBdHRycyhhdHRycywgY2ZnKSB7XG4gICAgaWYgKGNmZy5jb2xvcikge1xuICAgICAgYXR0cnMuZmlsbCA9IGNmZy5jb2xvcjtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc051bWJlcihjZmcub3BhY2l0eSkpIHtcbiAgICAgIGF0dHJzLm9wYWNpdHkgPSBhdHRycy5maWxsT3BhY2l0eSA9IGNmZy5vcGFjaXR5O1xuICAgIH1cbiAgfSxcbiAgYWRkU3Ryb2tlQXR0cnM6IGZ1bmN0aW9uIGFkZFN0cm9rZUF0dHJzKGF0dHJzLCBjZmcpIHtcbiAgICBpZiAoY2ZnLmNvbG9yKSB7XG4gICAgICBhdHRycy5zdHJva2UgPSBjZmcuY29sb3I7XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNOdW1iZXIoY2ZnLm9wYWNpdHkpKSB7XG4gICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMuc3Ryb2tlT3BhY2l0eSA9IGNmZy5vcGFjaXR5O1xuICAgIH1cbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGVVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICBpZiAoKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJzdCA9IHZvaWQgMDtcblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcnN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChfdHlwZW9mKG9ialtpXSkgPT09ICdvYmplY3QnICYmIG9ialtpXSAhPSBudWxsKSB7XG4gICAgICAgIHJzdFtpXSA9IGNsb25lKG9ialtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByc3RbaV0gPSBvYmpbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJzdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGlmIChfdHlwZW9mKG9ialtrXSkgPT09ICdvYmplY3QnICYmIG9ialtrXSAhPSBudWxsKSB7XG4gICAgICAgIHJzdFtrXSA9IGNsb25lKG9ialtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByc3Rba10gPSBvYmpba107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUGxhaW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgTUFYX01JWF9MRVZFTCA9IDU7XG5cbmZ1bmN0aW9uIF9kZWVwTWl4KGRpc3QsIHNyYywgbGV2ZWwsIG1heExldmVsKSB7XG4gIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgbWF4TGV2ZWwgPSBtYXhMZXZlbCB8fCBNQVhfTUlYX0xFVkVMO1xuXG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHNyY1trZXldO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGRpc3Rba2V5XSkpIHtcbiAgICAgICAgICBkaXN0W2tleV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA8IG1heExldmVsKSB7XG4gICAgICAgICAgX2RlZXBNaXgoZGlzdFtrZXldLCB2YWx1ZSwgbGV2ZWwgKyAxLCBtYXhMZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZGlzdFtrZXldID0gW107XG4gICAgICAgIGRpc3Rba2V5XSA9IGRpc3Rba2V5XS5jb25jYXQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZGVlcE1peCA9IGZ1bmN0aW9uIGRlZXBNaXgoKSB7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gIH1cblxuICB2YXIgcnN0ID0gYXJnc1swXTtcblxuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgX2RlZXBNaXgocnN0LCBhcmdzW19pXSk7XG4gIH1cblxuICByZXR1cm4gcnN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwTWl4O1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgaXNPYmplY3RMaWtlID0gZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIC8qKlxuICAgKiBpc09iamVjdExpa2Uoe30pID0+IHRydWVcbiAgICogaXNPYmplY3RMaWtlKFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgKiBpc09iamVjdExpa2UoRnVuY3Rpb24pID0+IGZhbHNlXG4gICAqIGlzT2JqZWN0TGlrZShudWxsKSA9PiBmYWxzZVxuICAgKi9cbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBpc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAhb3RoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzU3RyaW5nKG90aGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgfHwgaXNBcnJheUxpa2Uob3RoZXIpKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJzdCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICByc3QgPSBpc0VxdWFsKHZhbHVlW2ldLCBvdGhlcltpXSk7XG5cbiAgICAgIGlmICghcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH1cblxuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBpc09iamVjdExpa2Uob3RoZXIpKSB7XG4gICAgdmFyIHZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuXG4gICAgaWYgKHZhbHVlS2V5cy5sZW5ndGggIT09IG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX3JzdCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdmFsdWVLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgX3JzdCA9IGlzRXF1YWwodmFsdWVbdmFsdWVLZXlzW19pXV0sIG90aGVyW3ZhbHVlS2V5c1tfaV1dKTtcblxuICAgICAgaWYgKCFfcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcnN0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKGEsIG1pbiwgbWF4KSB7XG4gIGlmIChhIDwgbWluKSB7XG4gICAgcmV0dXJuIG1pbjtcbiAgfSBlbHNlIGlmIChhID4gbWF4KSB7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIHJldHVybiBhO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWF0MyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgyKTtcblxubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gIHZhciB0cmFuc01hdCA9IG5ldyBBcnJheSg5KTtcbiAgbWF0My5mcm9tVHJhbnNsYXRpb24odHJhbnNNYXQsIHYpO1xuICByZXR1cm4gbWF0My5tdWx0aXBseShvdXQsIHRyYW5zTWF0LCBhKTtcbn07XG5cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gIHZhciByb3RhdGVNYXQgPSBuZXcgQXJyYXkoOSk7XG4gIG1hdDMuZnJvbVJvdGF0aW9uKHJvdGF0ZU1hdCwgcmFkKTtcbiAgcmV0dXJuIG1hdDMubXVsdGlwbHkob3V0LCByb3RhdGVNYXQsIGEpO1xufTtcblxubWF0My5zY2FsZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgdmFyIHNjYWxlTWF0ID0gbmV3IEFycmF5KDkpO1xuICBtYXQzLmZyb21TY2FsaW5nKHNjYWxlTWF0LCB2KTtcbiAgcmV0dXJuIG1hdDMubXVsdGlwbHkob3V0LCBzY2FsZU1hdCwgYSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDM7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0TWF0cml4QXJyYXlUeXBlID0gc2V0TWF0cml4QXJyYXlUeXBlO1xuZXhwb3J0cy50b1JhZGlhbiA9IHRvUmFkaWFuO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG4vKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcblxudmFyIEVQU0lMT04gPSBleHBvcnRzLkVQU0lMT04gPSAwLjAwMDAwMTtcbnZhciBBUlJBWV9UWVBFID0gZXhwb3J0cy5BUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbnZhciBSQU5ET00gPSBleHBvcnRzLlJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBleHBvcnRzLkFSUkFZX1RZUEUgPSBBUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuXG5mdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxuICogRXZlbnRFbWl0dGVyIHY1LjEuMCAtIGdpdC5pby9lZVxuICogVW5saWNlbnNlIC0gaHR0cDovL3VubGljZW5zZS5vcmcvXG4gKiBPbGl2ZXIgQ2FsZHdlbGwgLSBodHRwOi8vb2xpLm1lLnVrL1xuICogQHByZXNlcnZlXG4gKi9cbjtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIENsYXNzIGZvciBtYW5hZ2luZyBldmVudHMuXG4gICAqIENhbiBiZSBleHRlbmRlZCB0byBwcm92aWRlIGV2ZW50IGZ1bmN0aW9uYWxpdHkgaW4gb3RoZXIgY2xhc3Nlcy5cbiAgICpcbiAgICogQGNsYXNzIEV2ZW50RW1pdHRlciBNYW5hZ2VzIGV2ZW50IHJlZ2lzdGVyaW5nIGFuZCBlbWl0dGluZy5cbiAgICovXG5cbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge30gLy8gU2hvcnRjdXRzIHRvIGltcHJvdmUgc3BlZWQgYW5kIHNpemVcblxuXG4gIHZhciBwcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG4gIHZhciBvcmlnaW5hbEdsb2JhbFZhbHVlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXI7XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgaW4gaXRzIHN0b3JhZ2UgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGxvb2sgZm9yLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEFsaWFzIGEgbWV0aG9kIHdoaWxlIGtlZXBpbmcgdGhlIGNvbnRleHQgY29ycmVjdCwgdG8gYWxsb3cgZm9yIG92ZXJ3cml0aW5nIG9mIHRhcmdldCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGFsaWFzZWQgbWV0aG9kXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYWxpYXNDbG9zdXJlKCkge1xuICAgICAgcmV0dXJuIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICogV2lsbCBpbml0aWFsaXNlIHRoZSBldmVudCBvYmplY3QgYW5kIGxpc3RlbmVyIGFycmF5cyBpZiByZXF1aXJlZC5cbiAgICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxuICAgKiBFYWNoIHByb3BlcnR5IGluIHRoZSBvYmplY3QgcmVzcG9uc2UgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfE9iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhlIGV2ZW50LlxuICAgKi9cblxuXG4gIHByb3RvLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG5cbiAgICB2YXIgcmVzcG9uc2U7XG4gICAgdmFyIGtleTsgLy8gUmV0dXJuIGEgY29uY2F0ZW5hdGVkIGFycmF5IG9mIGFsbCBtYXRjaGluZyBldmVudHMgaWZcbiAgICAvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG5cbiAgICBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXNwb25zZSA9IHt9O1xuXG4gICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcbiAgICAgICAgICByZXNwb25zZVtrZXldID0gZXZlbnRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuICAvKipcbiAgICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlzdGVuZXJzIFJhdyBsaXN0ZW5lciBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAqL1xuXG5cbiAgcHJvdG8uZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGZsYXR0ZW5MaXN0ZW5lcnMobGlzdGVuZXJzKSB7XG4gICAgdmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0TGlzdGVuZXJzO1xuICB9O1xuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgcmVxdWVzdGVkIGxpc3RlbmVycyB2aWEgZ2V0TGlzdGVuZXJzIGJ1dCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHJlc3VsdHMgaW5zaWRlIGFuIG9iamVjdC4gVGhpcyBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSBidXQgb3RoZXJzIG1heSBmaW5kIGl0IHVzZWZ1bC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBpbiBhbiBvYmplY3QuXG4gICAqL1xuXG5cbiAgcHJvdG8uZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnNBc09iamVjdChldnQpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcbiAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICBpZiAobGlzdGVuZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICByZXNwb25zZVtldnRdID0gbGlzdGVuZXJzO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNWYWxpZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyB8fCBsaXN0ZW5lciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZExpc3RlbmVyKGxpc3RlbmVyLmxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAqIFRoZSBsaXN0ZW5lciB3aWxsIG5vdCBiZSBhZGRlZCBpZiBpdCBpcyBhIGR1cGxpY2F0ZS5cbiAgICogSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBjYWxsZWQuXG4gICAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAqL1xuXG5cbiAgcHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCFpc1ZhbGlkTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgICBsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQWxpYXMgb2YgYWRkTGlzdGVuZXJcbiAgICovXG5cblxuICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xuICAvKipcbiAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIGl0cyBmaXJzdCBleGVjdXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cbiAgcHJvdG8uYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkT25jZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIEFsaWFzIG9mIGFkZE9uY2VMaXN0ZW5lci5cbiAgICovXG5cblxuICBwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xuICAvKipcbiAgICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cbiAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cbiAgcHJvdG8uZGVmaW5lRXZlbnQgPSBmdW5jdGlvbiBkZWZpbmVFdmVudChldnQpIHtcbiAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAqL1xuXG5cbiAgcHJvdG8uZGVmaW5lRXZlbnRzID0gZnVuY3Rpb24gZGVmaW5lRXZlbnRzKGV2dHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZGVmaW5lRXZlbnQoZXZ0c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgKi9cblxuXG4gIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxuICAgKi9cblxuXG4gIHByb3RvLm9mZiA9IGFsaWFzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG4gICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC5cbiAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cbiAgcHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG4gICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcbiAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cbiAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgcmVtb3ZlZC5cbiAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cblxuICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnModHJ1ZSwgZXZ0LCBsaXN0ZW5lcnMpO1xuICB9O1xuICAvKipcbiAgICogRWRpdHMgbGlzdGVuZXJzIGluIGJ1bGsuIFRoZSBhZGRMaXN0ZW5lcnMgYW5kIHJlbW92ZUxpc3RlbmVycyBtZXRob2RzIGJvdGggdXNlIHRoaXMgdG8gZG8gdGhlaXIgam9iLiBZb3Ugc2hvdWxkIHJlYWxseSB1c2UgdGhvc2UgaW5zdGVhZCwgdGhpcyBpcyBhIGxpdHRsZSBsb3dlciBsZXZlbC5cbiAgICogVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgKHRydWUpIG9yIGFkZGVkIChmYWxzZSkuXG4gICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC9yZW1vdmVkLlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYW5pcHVsYXRlIHRoZSBsaXN0ZW5lcnMgb2YgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSBUcnVlIGlmIHlvdSB3YW50IHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGZhbHNlIGlmIHlvdSB3YW50IHRvIGFkZC5cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkL3JlbW92ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAqL1xuXG5cbiAgcHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xuICAgIHZhciBpO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XG4gICAgdmFyIG11bHRpcGxlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lcnMgOiB0aGlzLmFkZExpc3RlbmVyczsgLy8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdHMgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxuXG4gICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgZm9yIChpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpICYmICh2YWx1ZSA9IGV2dFtpXSkpIHtcbiAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFzcyBiYWNrIHRvIHRoZSBtdWx0aXBsZSBmdW5jdGlvblxuICAgICAgICAgICAgbXVsdGlwbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICAvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXG4gICAgICAvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxuICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgKiBUaGF0IG1lYW5zIGV2ZXJ5IGV2ZW50IHdpbGwgYmUgZW1wdGllZC5cbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWdleCB0byByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IFtldnRdIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci4gV2lsbCByZW1vdmUgZnJvbSBldmVyeSBldmVudCBpZiBub3QgcGFzc2VkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cblxuICBwcm90by5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGV2dCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGV2dDtcblxuICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcblxuICAgIHZhciBrZXk7IC8vIFJlbW92ZSBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgZXZ0XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gICAgICBkZWxldGUgZXZlbnRzW2V2dF07XG4gICAgfSBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSByZWdleC5cbiAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXG4gICAqXG4gICAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXG4gICAqL1xuXG5cbiAgcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCBvZiB5b3VyIGNob2ljZS5cbiAgICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAqIElmIHlvdSBwYXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBhcnJheSB0aGVuIHRob3NlIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBldmVyeSBsaXN0ZW5lciB1cG9uIGV4ZWN1dGlvbi5cbiAgICogQmVjYXVzZSBpdCB1c2VzIGBhcHBseWAsIHlvdXIgYXJyYXkgb2YgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGlmIHlvdSB3cm90ZSB0aGVtIG91dCBzZXBhcmF0ZWx5LlxuICAgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSBPcHRpb25hbCBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgKi9cblxuICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XG4gICAgdmFyIGxpc3RlbmVyc01hcCA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICB2YXIgbGlzdGVuZXJzO1xuICAgIHZhciBsaXN0ZW5lcjtcbiAgICB2YXIgaTtcbiAgICB2YXIga2V5O1xuICAgIHZhciByZXNwb25zZTtcblxuICAgIGZvciAoa2V5IGluIGxpc3RlbmVyc01hcCkge1xuICAgICAgaWYgKGxpc3RlbmVyc01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcFtrZXldLnNsaWNlKDApO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxuICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBlaXRoZXIgd2l0aCBhIGJhc2ljIGNhbGwgb3IgYW4gYXBwbHkgaWYgdGhlcmUgaXMgYW4gYXJncyBhcnJheVxuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzcG9uc2UgPSBsaXN0ZW5lci5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcblxuICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBBbGlhcyBvZiBlbWl0RXZlbnRcbiAgICovXG5cblxuICBwcm90by50cmlnZ2VyID0gYWxpYXMoJ2VtaXRFdmVudCcpO1xuICAvKipcbiAgICogU3VidGx5IGRpZmZlcmVudCBmcm9tIGVtaXRFdmVudCBpbiB0aGF0IGl0IHdpbGwgcGFzcyBpdHMgYXJndW1lbnRzIG9uIHRvIHRoZSBsaXN0ZW5lcnMsIGFzIG9wcG9zZWQgdG8gdGFraW5nIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIG9uLlxuICAgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cbiAgICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAqL1xuXG4gIHByb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmIGFcbiAgICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcbiAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICovXG5cblxuICBwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLl9vbmNlUmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXG4gICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cblxuICBwcm90by5fZ2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gX2dldE9uY2VSZXR1cm5WYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBldmVudHMgb2JqZWN0IGFuZCBjcmVhdGVzIG9uZSBpZiByZXF1aXJlZC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXZlbnRzIHN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cblxuICBwcm90by5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gX2dldEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IE5vbiBjb25mbGljdGluZyBFdmVudEVtaXR0ZXIgY2xhc3MuXG4gICAqL1xuXG5cbiAgRXZlbnRFbWl0dGVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gb3JpZ2luYWxHbG9iYWxWYWx1ZTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICB9OyAvLyBFeHBvc2UgdGhlIGNsYXNzIGVpdGhlciB2aWEgQU1ELCBDb21tb25KUyBvciB0aGUgZ2xvYmFsIG9iamVjdFxuXG5cbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiAgfVxufSkodGhpcyB8fCB7fSk7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxudmFyIFF1YWRyYXRpYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxudmFyIEN1YmljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cbnZhciBBcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxpbmU6IGZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgIHZhciBib3ggPSBMaW5lLmJveCh4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoKTtcblxuICAgIGlmICghdGhpcy5ib3goYm94Lm1pblgsIGJveC5tYXhYLCBib3gubWluWSwgYm94Lm1heFksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBMaW5lLnBvaW50RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIsIHgsIHkpO1xuXG4gICAgaWYgKGlzTmFOKGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQgPD0gbGluZVdpZHRoIC8gMjtcbiAgfSxcbiAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKHBvaW50cywgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChsIDwgMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgeDEgPSBwb2ludHNbaV1bMF07XG4gICAgICB2YXIgeTEgPSBwb2ludHNbaV1bMV07XG4gICAgICB2YXIgeDIgPSBwb2ludHNbaSArIDFdWzBdO1xuICAgICAgdmFyIHkyID0gcG9pbnRzW2kgKyAxXVsxXTtcblxuICAgICAgaWYgKHRoaXMubGluZSh4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGN1YmljbGluZTogZnVuY3Rpb24gY3ViaWNsaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgcmV0dXJuIEN1YmljLnBvaW50RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB4LCB5KSA8PSBsaW5lV2lkdGggLyAyO1xuICB9LFxuICBxdWFkcmF0aWNsaW5lOiBmdW5jdGlvbiBxdWFkcmF0aWNsaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgIHJldHVybiBRdWFkcmF0aWMucG9pbnREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSA8PSBsaW5lV2lkdGggLyAyO1xuICB9LFxuICBhcmNsaW5lOiBmdW5jdGlvbiBhcmNsaW5lKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgcmV0dXJuIEFyYy5wb2ludERpc3RhbmNlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgeCwgeSkgPD0gbGluZVdpZHRoIC8gMjtcbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24gcmVjdChyeCwgcnksIHdpZHRoLCBoZWlnaHQsIHgsIHkpIHtcbiAgICByZXR1cm4gcnggPD0geCAmJiB4IDw9IHJ4ICsgd2lkdGggJiYgcnkgPD0geSAmJiB5IDw9IHJ5ICsgaGVpZ2h0O1xuICB9LFxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShjeCwgY3ksIHIsIHgsIHkpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coeCAtIGN4LCAyKSArIE1hdGgucG93KHkgLSBjeSwgMikgPD0gTWF0aC5wb3cociwgMik7XG4gIH0sXG4gIGJveDogZnVuY3Rpb24gYm94KG1pblgsIG1heFgsIG1pblksIG1heFksIHgsIHkpIHtcbiAgICByZXR1cm4gbWluWCA8PSB4ICYmIHggPD0gbWF4WCAmJiBtaW5ZIDw9IHkgJiYgeSA8PSBtYXhZO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHZlYzIgPSBVdGlsLnZlYzI7XG5cbmZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMyArIDMgKiB0ICogcDIpICsgdCAqIHQgKiAodCAqIHAwICsgMyAqIG9uZXQgKiBwMSk7XG59XG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB4LCB5LCBvdXQpIHtcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuXG4gIHZhciBfdDtcblxuICB2YXIgdjE7XG4gIHZhciBkMTtcbiAgdmFyIGQyO1xuICB2YXIgdjI7XG4gIHZhciBwcmV2O1xuICB2YXIgbmV4dDtcbiAgdmFyIEVQU0lMT04gPSAwLjAwMDE7XG4gIHZhciB2MCA9IFt4LCB5XTtcblxuICBmb3IgKF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgdjEgPSBbY3ViaWNBdCh4MSwgeDIsIHgzLCB4NCwgX3QpLCBjdWJpY0F0KHkxLCB5MiwgeTMsIHk0LCBfdCldO1xuICAgIGQxID0gdmVjMi5zcXVhcmVkRGlzdGFuY2UodjAsIHYxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICBuZXh0ID0gdCArIGludGVydmFsO1xuICAgIHYxID0gW2N1YmljQXQoeDEsIHgyLCB4MywgeDQsIHByZXYpLCBjdWJpY0F0KHkxLCB5MiwgeTMsIHk0LCBwcmV2KV07XG4gICAgZDEgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZSh2MCwgdjEpO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2MiA9IFtjdWJpY0F0KHgxLCB4MiwgeDMsIHg0LCBuZXh0KSwgY3ViaWNBdCh5MSwgeTIsIHkzLCB5NCwgbmV4dCldO1xuICAgICAgZDIgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZSh2MCwgdjIpO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXQueCA9IGN1YmljQXQoeDEsIHgyLCB4MywgeDQsIHQpO1xuICAgIG91dC55ID0gY3ViaWNBdCh5MSwgeTIsIHkzLCB5NCwgdCk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGQpO1xufVxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMpIHtcbiAgdmFyIGEgPSAzICogcDAgLSA5ICogcDEgKyA5ICogcDIgLSAzICogcDM7XG4gIHZhciBiID0gNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgdmFyIGMgPSAzICogcDIgLSAzICogcDM7XG4gIHZhciBleHRyZW1hID0gW107XG4gIHZhciB0MTtcbiAgdmFyIHQyO1xuICB2YXIgZGlzY1NxcnQ7XG5cbiAgaWYgKFV0aWwuaXNOdW1iZXJFcXVhbChhLCAwKSkge1xuICAgIGlmICghVXRpbC5pc051bWJlckVxdWFsKGIsIDApKSB7XG4gICAgICB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hLnB1c2godDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKFV0aWwuaXNOdW1iZXJFcXVhbChkaXNjLCAwKSkge1xuICAgICAgZXh0cmVtYS5wdXNoKC1iIC8gKDIgKiBhKSk7XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgZGlzY1NxcnQgPSBNYXRoLnNxcnQoZGlzYyk7XG4gICAgICB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgZXh0cmVtYS5wdXNoKHQxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBleHRyZW1hLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHRyZW1hO1xufVxuXG5mdW5jdGlvbiBiYXNlMyh0LCBwMSwgcDIsIHAzLCBwNCkge1xuICB2YXIgdDEgPSAtMyAqIHAxICsgOSAqIHAyIC0gOSAqIHAzICsgMyAqIHA0O1xuICB2YXIgdDIgPSB0ICogdDEgKyA2ICogcDEgLSAxMiAqIHAyICsgNiAqIHAzO1xuICByZXR1cm4gdCAqIHQyIC0gMyAqIHAxICsgMyAqIHAyO1xufVxuXG5mdW5jdGlvbiBjdWJpY2xMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG4gIGlmIChVdGlsLmlzTmlsKHopKSB7XG4gICAgeiA9IDE7XG4gIH1cblxuICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgdmFyIHoyID0geiAvIDI7XG4gIHZhciBuID0gMTI7XG4gIHZhciBUdmFsdWVzID0gWy0wLjEyNTIsIDAuMTI1MiwgLTAuMzY3OCwgMC4zNjc4LCAtMC41ODczLCAwLjU4NzMsIC0wLjc2OTksIDAuNzY5OSwgLTAuOTA0MSwgMC45MDQxLCAtMC45ODE2LCAwLjk4MTZdO1xuICB2YXIgQ3ZhbHVlcyA9IFswLjI0OTEsIDAuMjQ5MSwgMC4yMzM1LCAwLjIzMzUsIDAuMjAzMiwgMC4yMDMyLCAwLjE2MDEsIDAuMTYwMSwgMC4xMDY5LCAwLjEwNjksIDAuMDQ3MiwgMC4wNDcyXTtcbiAgdmFyIHN1bSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY3QgPSB6MiAqIFR2YWx1ZXNbaV0gKyB6MjtcbiAgICB2YXIgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpO1xuICAgIHZhciB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCk7XG4gICAgdmFyIGNvbWIgPSB4YmFzZSAqIHhiYXNlICsgeWJhc2UgKiB5YmFzZTtcbiAgICBzdW0gKz0gQ3ZhbHVlc1tpXSAqIE1hdGguc3FydChjb21iKTtcbiAgfVxuXG4gIHJldHVybiB6MiAqIHN1bTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0OiBjdWJpY0F0LFxuICBkZXJpdmF0aXZlQXQ6IGN1YmljRGVyaXZhdGl2ZUF0LFxuICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uIHByb2plY3RQb2ludCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHgsIHkpIHtcbiAgICB2YXIgcnN0ID0ge307XG4gICAgY3ViaWNQcm9qZWN0UG9pbnQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB4LCB5LCByc3QpO1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIHBvaW50RGlzdGFuY2U6IGN1YmljUHJvamVjdFBvaW50LFxuICBleHRyZW1hOiBjdWJpY0V4dHJlbWEsXG4gIGxlbjogY3ViaWNsTGVuXG59O1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEZvcm1hdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgUGF0aFNlZ21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIE1hcmtlciA9IGZ1bmN0aW9uIE1hcmtlcihjZmcpIHtcbiAgTWFya2VyLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuTWFya2VyLlN5bWJvbHMgPSB7XG4gIC8vIOWchlxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZSh4LCB5LCByKSB7XG4gICAgcmV0dXJuIFtbJ00nLCB4LCB5XSwgWydtJywgLXIsIDBdLCBbJ2EnLCByLCByLCAwLCAxLCAwLCByICogMiwgMF0sIFsnYScsIHIsIHIsIDAsIDEsIDAsIC1yICogMiwgMF1dO1xuICB9LFxuICAvLyDmraPmlrnlvaJcbiAgc3F1YXJlOiBmdW5jdGlvbiBzcXVhcmUoeCwgeSwgcikge1xuICAgIHJldHVybiBbWydNJywgeCAtIHIsIHkgLSByXSwgWydMJywgeCArIHIsIHkgLSByXSwgWydMJywgeCArIHIsIHkgKyByXSwgWydMJywgeCAtIHIsIHkgKyByXSwgWydaJ11dO1xuICB9LFxuICAvLyDoj7HlvaJcbiAgZGlhbW9uZDogZnVuY3Rpb24gZGlhbW9uZCh4LCB5LCByKSB7XG4gICAgcmV0dXJuIFtbJ00nLCB4IC0gciwgeV0sIFsnTCcsIHgsIHkgLSByXSwgWydMJywgeCArIHIsIHldLCBbJ0wnLCB4LCB5ICsgcl0sIFsnWiddXTtcbiAgfSxcbiAgLy8g5LiJ6KeS5b2iXG4gIHRyaWFuZ2xlOiBmdW5jdGlvbiB0cmlhbmdsZSh4LCB5LCByKSB7XG4gICAgdmFyIGRpZmZZID0gciAqIE1hdGguc2luKDEgLyAzICogTWF0aC5QSSk7XG4gICAgcmV0dXJuIFtbJ00nLCB4IC0gciwgeSArIGRpZmZZXSwgWydMJywgeCwgeSAtIGRpZmZZXSwgWydMJywgeCArIHIsIHkgKyBkaWZmWV0sIFsneiddXTtcbiAgfSxcbiAgLy8g5YCS5LiJ6KeS5b2iXG4gICd0cmlhbmdsZS1kb3duJzogZnVuY3Rpb24gdHJpYW5nbGVEb3duKHgsIHksIHIpIHtcbiAgICB2YXIgZGlmZlkgPSByICogTWF0aC5zaW4oMSAvIDMgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gW1snTScsIHggLSByLCB5IC0gZGlmZlldLCBbJ0wnLCB4ICsgciwgeSAtIGRpZmZZXSwgWydMJywgeCwgeSArIGRpZmZZXSwgWydaJ11dO1xuICB9XG59O1xuTWFya2VyLkFUVFJTID0ge1xuICBwYXRoOiBudWxsLFxuICBsaW5lV2lkdGg6IDFcbn07XG5VdGlsLmV4dGVuZChNYXJrZXIsIFNoYXBlKTtcblV0aWwuYXVnbWVudChNYXJrZXIsIHtcbiAgdHlwZTogJ21hcmtlcicsXG4gIGNhbkZpbGw6IHRydWUsXG4gIGNhblN0cm9rZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgbGluZVdpZHRoOiAxXG4gICAgfTtcbiAgfSxcbiAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIGN4ID0gYXR0cnMueDtcbiAgICB2YXIgY3kgPSBhdHRycy55O1xuICAgIHZhciByID0gYXR0cnMucmFkaXVzO1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuICAgIHZhciBoYWxmV2lkdGggPSBsaW5lV2lkdGggLyAyICsgcjtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogY3ggLSBoYWxmV2lkdGgsXG4gICAgICBtaW5ZOiBjeSAtIGhhbGZXaWR0aCxcbiAgICAgIG1heFg6IGN4ICsgaGFsZldpZHRoLFxuICAgICAgbWF4WTogY3kgKyBoYWxmV2lkdGhcbiAgICB9O1xuICB9LFxuICBfZ2V0UGF0aDogZnVuY3Rpb24gX2dldFBhdGgoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgciA9IGF0dHJzLnJhZGl1cyB8fCBhdHRycy5yO1xuICAgIHZhciBzeW1ib2wgPSBhdHRycy5zeW1ib2wgfHwgJ2NpcmNsZSc7XG4gICAgdmFyIG1ldGhvZDtcblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oc3ltYm9sKSkge1xuICAgICAgbWV0aG9kID0gc3ltYm9sO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSBNYXJrZXIuU3ltYm9sc1tzeW1ib2xdO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRob2QoeCwgeSwgcik7XG4gIH0sXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX2NmZy5zZWdtZW50cztcblxuICAgIGlmIChzZWdtZW50cyAmJiAhdGhpcy5fY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50c1tpXS5kcmF3KGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBGb3JtYXQucGFyc2VQYXRoKHRoaXMuX2dldFBhdGgoKSk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB2YXIgcHJlU2VnbWVudDtcbiAgICBzZWdtZW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhdGgubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHBhdGhbX2ldO1xuICAgICAgcHJlU2VnbWVudCA9IG5ldyBQYXRoU2VnbWVudChpdGVtLCBwcmVTZWdtZW50LCBfaSA9PT0gcGF0aC5sZW5ndGggLSAxKTtcbiAgICAgIHNlZ21lbnRzLnB1c2gocHJlU2VnbWVudCk7XG4gICAgICBwcmVTZWdtZW50LmRyYXcoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2ZnLnNlZ21lbnRzID0gc2VnbWVudHM7XG4gICAgdGhpcy5fY2ZnLmhhc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gTWFya2VyO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbnZhciBTUEFDRVMgPSBcIlxcdFxcblxceDBCXFxmXFxyIFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XCI7XG52YXIgUEFUSF9DT01NQU5EID0gbmV3IFJlZ0V4cCgnKFthLXpdKVsnICsgU1BBQ0VTICsgJyxdKigoLT9cXFxcZCpcXFxcLj9cXFxcZCooPzplW1xcXFwtK10/XFxcXGQrKT9bJyArIFNQQUNFUyArICddKiw/WycgKyBTUEFDRVMgKyAnXSopKyknLCAnaWcnKTtcbnZhciBQQVRIX1ZBTFVFUyA9IG5ldyBSZWdFeHAoJygtP1xcXFxkKlxcXFwuP1xcXFxkKig/OmVbXFxcXC0rXT9cXFxcZCspPylbJyArIFNQQUNFUyArICddKiw/WycgKyBTUEFDRVMgKyAnXSonLCAnaWcnKTsgLy8gUGFyc2VzIGdpdmVuIHBhdGggc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBhdGggc2VnbWVudHNcblxudmFyIHBhcnNlUGF0aFN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gIGlmICghcGF0aFN0cmluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nID09PSB0eXBlb2YgW10pIHtcbiAgICByZXR1cm4gcGF0aFN0cmluZztcbiAgfVxuXG4gIHZhciBwYXJhbUNvdW50cyA9IHtcbiAgICBhOiA3LFxuICAgIGM6IDYsXG4gICAgbzogMixcbiAgICBoOiAxLFxuICAgIGw6IDIsXG4gICAgbTogMixcbiAgICByOiA0LFxuICAgIHE6IDQsXG4gICAgczogNCxcbiAgICB0OiAyLFxuICAgIHY6IDEsXG4gICAgdTogMyxcbiAgICB6OiAwXG4gIH07XG4gIHZhciBkYXRhID0gW107XG4gIFN0cmluZyhwYXRoU3RyaW5nKS5yZXBsYWNlKFBBVEhfQ09NTUFORCwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgdmFyIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgYy5yZXBsYWNlKFBBVEhfVkFMVUVTLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgYiAmJiBwYXJhbXMucHVzaCgrYik7XG4gICAgfSk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ20nICYmIHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICBuYW1lID0gJ2wnO1xuICAgICAgYiA9IGIgPT09ICdtJyA/ICdsJyA6ICdMJztcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ28nICYmIHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRhdGEucHVzaChbYiwgcGFyYW1zWzBdXSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdyJykge1xuICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG5cbiAgICAgICAgaWYgKCFwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59OyAvLyBodHRwOi8vc2NoZXBlcnMuY2MvZ2V0dGluZy10by10aGUtcG9pbnRcblxuXG52YXIgY2F0bXVsbFJvbTJiZXppZXIgPSBmdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihjcnAsIHopIHtcbiAgdmFyIGQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICB2YXIgcCA9IFt7XG4gICAgICB4OiArY3JwW2kgLSAyXSxcbiAgICAgIHk6ICtjcnBbaSAtIDFdXG4gICAgfSwge1xuICAgICAgeDogK2NycFtpXSxcbiAgICAgIHk6ICtjcnBbaSArIDFdXG4gICAgfSwge1xuICAgICAgeDogK2NycFtpICsgMl0sXG4gICAgICB5OiArY3JwW2kgKyAzXVxuICAgIH0sIHtcbiAgICAgIHg6ICtjcnBbaSArIDRdLFxuICAgICAgeTogK2NycFtpICsgNV1cbiAgICB9XTtcblxuICAgIGlmICh6KSB7XG4gICAgICBpZiAoIWkpIHtcbiAgICAgICAgcFswXSA9IHtcbiAgICAgICAgICB4OiArY3JwW2lMZW4gLSAyXSxcbiAgICAgICAgICB5OiArY3JwW2lMZW4gLSAxXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpTGVuIC0gNCA9PT0gaSkge1xuICAgICAgICBwWzNdID0ge1xuICAgICAgICAgIHg6ICtjcnBbMF0sXG4gICAgICAgICAgeTogK2NycFsxXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpTGVuIC0gMiA9PT0gaSkge1xuICAgICAgICBwWzJdID0ge1xuICAgICAgICAgIHg6ICtjcnBbMF0sXG4gICAgICAgICAgeTogK2NycFsxXVxuICAgICAgICB9O1xuICAgICAgICBwWzNdID0ge1xuICAgICAgICAgIHg6ICtjcnBbMl0sXG4gICAgICAgICAgeTogK2NycFszXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaUxlbiAtIDQgPT09IGkpIHtcbiAgICAgICAgcFszXSA9IHBbMl07XG4gICAgICB9IGVsc2UgaWYgKCFpKSB7XG4gICAgICAgIHBbMF0gPSB7XG4gICAgICAgICAgeDogK2NycFtpXSxcbiAgICAgICAgICB5OiArY3JwW2kgKyAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGQucHVzaChbJ0MnLCAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNiwgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsIChwWzFdLnggKyA2ICogcFsyXS54IC0gcFszXS54KSAvIDYsIChwWzFdLnkgKyA2ICogcFsyXS55IC0gcFszXS55KSAvIDYsIHBbMl0ueCwgcFsyXS55XSk7XG4gIH1cblxuICByZXR1cm4gZDtcbn07XG5cbnZhciBlbGxpcHNlUGF0aCA9IGZ1bmN0aW9uIGVsbGlwc2VQYXRoKHgsIHksIHJ4LCByeSwgYSkge1xuICB2YXIgcmVzID0gW107XG5cbiAgaWYgKGEgPT09IG51bGwgJiYgcnkgPT09IG51bGwpIHtcbiAgICByeSA9IHJ4O1xuICB9XG5cbiAgeCA9ICt4O1xuICB5ID0gK3k7XG4gIHJ4ID0gK3J4O1xuICByeSA9ICtyeTtcblxuICBpZiAoYSAhPT0gbnVsbCkge1xuICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciB4MSA9IHggKyByeCAqIE1hdGguY29zKC1yeSAqIHJhZCk7XG4gICAgdmFyIHgyID0geCArIHJ4ICogTWF0aC5jb3MoLWEgKiByYWQpO1xuICAgIHZhciB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCk7XG4gICAgdmFyIHkyID0geSArIHJ4ICogTWF0aC5zaW4oLWEgKiByYWQpO1xuICAgIHJlcyA9IFtbJ00nLCB4MSwgeTFdLCBbJ0EnLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gIH0gZWxzZSB7XG4gICAgcmVzID0gW1snTScsIHgsIHldLCBbJ20nLCAwLCAtcnldLCBbJ2EnLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sIFsnYScsIHJ4LCByeSwgMCwgMSwgMSwgMCwgLTIgKiByeV0sIFsneiddXTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgcGF0aFRvQWJzb2x1dGUgPSBmdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcbiAgcGF0aEFycmF5ID0gcGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG5cbiAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gW1snTScsIDAsIDBdXTtcbiAgfVxuXG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBteCA9IDA7XG4gIHZhciBteSA9IDA7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBwYTA7XG4gIHZhciBkb3RzO1xuXG4gIGlmIChwYXRoQXJyYXlbMF1bMF0gPT09ICdNJykge1xuICAgIHggPSArcGF0aEFycmF5WzBdWzFdO1xuICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgIG14ID0geDtcbiAgICBteSA9IHk7XG4gICAgc3RhcnQrKztcbiAgICByZXNbMF0gPSBbJ00nLCB4LCB5XTtcbiAgfVxuXG4gIHZhciBjcnogPSBwYXRoQXJyYXkubGVuZ3RoID09PSAzICYmIHBhdGhBcnJheVswXVswXSA9PT0gJ00nICYmIHBhdGhBcnJheVsxXVswXS50b1VwcGVyQ2FzZSgpID09PSAnUicgJiYgcGF0aEFycmF5WzJdWzBdLnRvVXBwZXJDYXNlKCkgPT09ICdaJztcblxuICBmb3IgKHZhciByLCBwYSwgaSA9IHN0YXJ0LCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgcmVzLnB1c2gociA9IFtdKTtcbiAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICBwYTAgPSBwYVswXTtcblxuICAgIGlmIChwYTAgIT09IHBhMC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICByWzBdID0gcGEwLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICByWzFdID0gcGFbMV07XG4gICAgICAgICAgclsyXSA9IHBhWzJdO1xuICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICByWzRdID0gcGFbNF07XG4gICAgICAgICAgcls1XSA9IHBhWzVdO1xuICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgIHJbN10gPSArcGFbN10gKyB5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgIGRvdHMgPSBbeCwgeV0uY29uY2F0KHBhLnNsaWNlKDEpKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAyLCBqaiA9IGRvdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgZG90c1tqXSA9ICtkb3RzW2pdICsgeDtcbiAgICAgICAgICAgIGRvdHNbKytqXSA9ICtkb3RzW2pdICsgeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdPJzpcbiAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgZG90cy5wdXNoKGRvdHNbMF0pO1xuICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgIHIgPSBbJ1UnXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICBteSA9ICtwYVsyXSArIHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZvciBsaW50XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDEsIF9qaiA9IHBhLmxlbmd0aDsgX2ogPCBfamo7IF9qKyspIHtcbiAgICAgICAgICAgIHJbX2pdID0gK3BhW19qXSArIChfaiAlIDIgPyB4IDogeSk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYTAgPT09ICdSJykge1xuICAgICAgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuICAgICAgcmVzLnBvcCgpO1xuICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgIHIgPSBbJ1InXS5jb25jYXQocGEuc2xpY2UoLTIpKTtcbiAgICB9IGVsc2UgaWYgKHBhMCA9PT0gJ08nKSB7XG4gICAgICByZXMucG9wKCk7XG4gICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgIGRvdHMucHVzaChkb3RzWzBdKTtcbiAgICAgIHJlcyA9IHJlcy5jb25jYXQoZG90cyk7XG4gICAgfSBlbHNlIGlmIChwYTAgPT09ICdVJykge1xuICAgICAgcmVzLnBvcCgpO1xuICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICByID0gWydVJ10uY29uY2F0KHJlc1tyZXMubGVuZ3RoIC0gMV0uc2xpY2UoLTIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gcGEubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICByW2tdID0gcGFba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGEwID0gcGEwLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAocGEwICE9PSAnTycpIHtcbiAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICB4ID0gK214O1xuICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgeCA9IHJbMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgeSA9IHJbMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZvciBsaW50XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBsMmMgPSBmdW5jdGlvbiBsMmMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbn07XG5cbnZhciBxMmMgPSBmdW5jdGlvbiBxMmMoeDEsIHkxLCBheCwgYXksIHgyLCB5Mikge1xuICB2YXIgXzEzID0gMSAvIDM7XG5cbiAgdmFyIF8yMyA9IDIgLyAzO1xuXG4gIHJldHVybiBbXzEzICogeDEgKyBfMjMgKiBheCwgXzEzICogeTEgKyBfMjMgKiBheSwgXzEzICogeDIgKyBfMjMgKiBheCwgXzEzICogeTIgKyBfMjMgKiBheSwgeDIsIHkyXTtcbn07XG5cbnZhciBhMmMgPSBmdW5jdGlvbiBhMmMoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcbiAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gIGlmIChyeCA9PT0gcnkpIHtcbiAgICByeCArPSAxO1xuICB9XG5cbiAgdmFyIF8xMjAgPSBNYXRoLlBJICogMTIwIC8gMTgwO1xuXG4gIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwICogKCthbmdsZSB8fCAwKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgeHk7XG4gIHZhciBmMTtcbiAgdmFyIGYyO1xuICB2YXIgY3g7XG4gIHZhciBjeTtcblxuICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHksIHJhZCkge1xuICAgIHZhciBYID0geCAqIE1hdGguY29zKHJhZCkgLSB5ICogTWF0aC5zaW4ocmFkKTtcbiAgICB2YXIgWSA9IHggKiBNYXRoLnNpbihyYWQpICsgeSAqIE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IFgsXG4gICAgICB5OiBZXG4gICAgfTtcbiAgfTtcblxuICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgeDEgPSB4eS54O1xuICAgIHkxID0geHkueTtcbiAgICB4eSA9IHJvdGF0ZSh4MiwgeTIsIC1yYWQpO1xuICAgIHgyID0geHkueDtcbiAgICB5MiA9IHh5Lnk7XG5cbiAgICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5Mikge1xuICAgICAgLy8g6Iul5byn55qE6LW35aeL54K55ZKM57uI54K56YeN5Y+g5YiZ6ZSZ5byA5LiA54K5XG4gICAgICB4MiArPSAxO1xuICAgICAgeTIgKz0gMTtcbiAgICB9IC8vIGNvbnN0IGNvcyA9IE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBhbmdsZSk7XG4gICAgLy8gY29uc3Qgc2luID0gTWF0aC5zaW4oTWF0aC5QSSAvIDE4MCAqIGFuZ2xlKTtcblxuXG4gICAgdmFyIHggPSAoeDEgLSB4MikgLyAyO1xuICAgIHZhciB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICB2YXIgaCA9IHggKiB4IC8gKHJ4ICogcngpICsgeSAqIHkgLyAocnkgKiByeSk7XG5cbiAgICBpZiAoaCA+IDEpIHtcbiAgICAgIGggPSBNYXRoLnNxcnQoaCk7XG4gICAgICByeCA9IGggKiByeDtcbiAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgIH1cblxuICAgIHZhciByeDIgPSByeCAqIHJ4O1xuICAgIHZhciByeTIgPSByeSAqIHJ5O1xuICAgIHZhciBrID0gKGxhcmdlX2FyY19mbGFnID09PSBzd2VlcF9mbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydChNYXRoLmFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKTtcbiAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDI7XG4gICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMjtcbiAgICBmMSA9IE1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuICAgIGYyID0gTWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG4gICAgZjEgPSB4MSA8IGN4ID8gTWF0aC5QSSAtIGYxIDogZjE7XG4gICAgZjIgPSB4MiA8IGN4ID8gTWF0aC5QSSAtIGYyIDogZjI7XG4gICAgZjEgPCAwICYmIChmMSA9IE1hdGguUEkgKiAyICsgZjEpO1xuICAgIGYyIDwgMCAmJiAoZjIgPSBNYXRoLlBJICogMiArIGYyKTtcblxuICAgIGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIHtcbiAgICAgIGYxID0gZjEgLSBNYXRoLlBJICogMjtcbiAgICB9XG5cbiAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgZjIgPSBmMiAtIE1hdGguUEkgKiAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICBmMiA9IHJlY3Vyc2l2ZVsxXTtcbiAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgfVxuXG4gIHZhciBkZiA9IGYyIC0gZjE7XG5cbiAgaWYgKE1hdGguYWJzKGRmKSA+IF8xMjApIHtcbiAgICB2YXIgZjJvbGQgPSBmMjtcbiAgICB2YXIgeDJvbGQgPSB4MjtcbiAgICB2YXIgeTJvbGQgPSB5MjtcbiAgICBmMiA9IGYxICsgXzEyMCAqIChzd2VlcF9mbGFnICYmIGYyID4gZjEgPyAxIDogLTEpO1xuICAgIHgyID0gY3ggKyByeCAqIE1hdGguY29zKGYyKTtcbiAgICB5MiA9IGN5ICsgcnkgKiBNYXRoLnNpbihmMik7XG4gICAgcmVzID0gYTJjKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKTtcbiAgfVxuXG4gIGRmID0gZjIgLSBmMTtcbiAgdmFyIGMxID0gTWF0aC5jb3MoZjEpO1xuICB2YXIgczEgPSBNYXRoLnNpbihmMSk7XG4gIHZhciBjMiA9IE1hdGguY29zKGYyKTtcbiAgdmFyIHMyID0gTWF0aC5zaW4oZjIpO1xuICB2YXIgdCA9IE1hdGgudGFuKGRmIC8gNCk7XG4gIHZhciBoeCA9IDQgLyAzICogcnggKiB0O1xuICB2YXIgaHkgPSA0IC8gMyAqIHJ5ICogdDtcbiAgdmFyIG0xID0gW3gxLCB5MV07XG4gIHZhciBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV07XG4gIHZhciBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl07XG4gIHZhciBtNCA9IFt4MiwgeTJdO1xuICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuXG4gIGlmIChyZWN1cnNpdmUpIHtcbiAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICB9XG5cbiAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdCgnLCcpO1xuICB2YXIgbmV3cmVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBuZXdyZXNbaV0gPSBpICUgMiA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgfVxuXG4gIHJldHVybiBuZXdyZXM7XG59O1xuXG52YXIgcGF0aFRvY3VydmUgPSBmdW5jdGlvbiBwYXRoVG9jdXJ2ZShwYXRoLCBwYXRoMikge1xuICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpO1xuICB2YXIgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMik7XG4gIHZhciBhdHRycyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgYng6IDAsXG4gICAgYnk6IDAsXG4gICAgWDogMCxcbiAgICBZOiAwLFxuICAgIHF4OiBudWxsLFxuICAgIHF5OiBudWxsXG4gIH07XG4gIHZhciBhdHRyczIgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGJ4OiAwLFxuICAgIGJ5OiAwLFxuICAgIFg6IDAsXG4gICAgWTogMCxcbiAgICBxeDogbnVsbCxcbiAgICBxeTogbnVsbFxuICB9O1xuICB2YXIgcGNvbXMxID0gW107IC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG5cbiAgdmFyIHBjb21zMiA9IFtdOyAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcDJcblxuICB2YXIgcGZpcnN0ID0gJyc7IC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuXG4gIHZhciBwY29tID0gJyc7IC8vIGhvbGRlciBmb3IgcHJldmlvdXMgcGF0aCBjb21tYW5kIG9mIG9yaWdpbmFsIHBhdGhcblxuICB2YXIgaWk7XG5cbiAgdmFyIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24gcHJvY2Vzc1BhdGgocGF0aCwgZCwgcGNvbSkge1xuICAgIHZhciBueCwgbnk7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHJldHVybiBbJ0MnLCBkLngsIGQueSwgZC54LCBkLnksIGQueCwgZC55XTtcbiAgICB9XG5cbiAgICAhKHBhdGhbMF0gaW4ge1xuICAgICAgVDogMSxcbiAgICAgIFE6IDFcbiAgICB9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcblxuICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChhMmMuYXBwbHkoMCwgW2QueCwgZC55XS5jb25jYXQocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICBpZiAocGNvbSA9PT0gJ0MnIHx8IHBjb20gPT09ICdTJykge1xuICAgICAgICAgIC8vIEluIFwiU1wiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgIG54ID0gZC54ICogMiAtIGQuYng7IC8vIEFuZCByZWZsZWN0IHRoZSBwcmV2aW91c1xuXG4gICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBbJ0MnLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICBpZiAocGNvbSA9PT0gJ1EnIHx8IHBjb20gPT09ICdUJykge1xuICAgICAgICAgIC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgLy8gQW5kIG1ha2UgYSByZWZsZWN0aW9uIHNpbWlsYXJcblxuICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQocTJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdLCBwYXRoWzNdLCBwYXRoWzRdKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgZC55KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsMmMoZC54LCBkLnksIGQueCwgcGF0aFsxXSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobDJjKGQueCwgZC55LCBkLlgsIGQuWSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgdmFyIGZpeEFyYyA9IGZ1bmN0aW9uIGZpeEFyYyhwcCwgaSkge1xuICAgIGlmIChwcFtpXS5sZW5ndGggPiA3KSB7XG4gICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgdmFyIHBpID0gcHBbaV07XG5cbiAgICAgIHdoaWxlIChwaS5sZW5ndGgpIHtcbiAgICAgICAgcGNvbXMxW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG5cbiAgICAgICAgcDIgJiYgKHBjb21zMltpXSA9ICdBJyk7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG5cbiAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgWydDJ10uY29uY2F0KHBpLnNwbGljZSgwLCA2KSkpO1xuICAgICAgfVxuXG4gICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaXhNID0gZnVuY3Rpb24gZml4TShwYXRoMSwgcGF0aDIsIGExLCBhMiwgaSkge1xuICAgIGlmIChwYXRoMSAmJiBwYXRoMiAmJiBwYXRoMVtpXVswXSA9PT0gJ00nICYmIHBhdGgyW2ldWzBdICE9PSAnTScpIHtcbiAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbJ00nLCBhMi54LCBhMi55XSk7XG4gICAgICBhMS5ieCA9IDA7XG4gICAgICBhMS5ieSA9IDA7XG4gICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICBhMS55ID0gcGF0aDFbaV1bMl07XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIGlpID0gTWF0aC5tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICBwW2ldICYmIChwZmlyc3QgPSBwW2ldWzBdKTsgLy8gc2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuXG4gICAgaWYgKHBmaXJzdCAhPT0gJ0MnKSB7XG4gICAgICAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgICAgaSAmJiAocGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICB9XG5cbiAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgIGlmIChwY29tczFbaV0gIT09ICdBJyAmJiBwZmlyc3QgPT09ICdDJykgcGNvbXMxW2ldID0gJ0MnOyAvLyBBIGlzIHRoZSBvbmx5IGNvbW1hbmRcbiAgICAvLyB3aGljaCBtYXkgcHJvZHVjZSBtdWx0aXBsZSBDOnNcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgIGZpeEFyYyhwLCBpKTsgLy8gZml4QXJjIGFkZHMgYWxzbyB0aGUgcmlnaHQgYW1vdW50IG9mIEE6cyB0byBwY29tczFcblxuICAgIGlmIChwMikge1xuICAgICAgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICBwMltpXSAmJiAocGZpcnN0ID0gcDJbaV1bMF0pO1xuXG4gICAgICBpZiAocGZpcnN0ICE9PSAnQycpIHtcbiAgICAgICAgcGNvbXMyW2ldID0gcGZpcnN0O1xuICAgICAgICBpICYmIChwY29tID0gcGNvbXMyW2kgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHAyW2ldID0gcHJvY2Vzc1BhdGgocDJbaV0sIGF0dHJzMiwgcGNvbSk7XG5cbiAgICAgIGlmIChwY29tczJbaV0gIT09ICdBJyAmJiBwZmlyc3QgPT09ICdDJykge1xuICAgICAgICBwY29tczJbaV0gPSAnQyc7XG4gICAgICB9XG5cbiAgICAgIGZpeEFyYyhwMiwgaSk7XG4gICAgfVxuXG4gICAgZml4TShwLCBwMiwgYXR0cnMsIGF0dHJzMiwgaSk7XG4gICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgdmFyIHNlZyA9IHBbaV07XG4gICAgdmFyIHNlZzIgPSBwMiAmJiBwMltpXTtcbiAgICB2YXIgc2VnbGVuID0gc2VnLmxlbmd0aDtcbiAgICB2YXIgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgIGF0dHJzLnggPSBzZWdbc2VnbGVuIC0gMl07XG4gICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICBhdHRycy5ieCA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgIGF0dHJzLmJ5ID0gcGFyc2VGbG9hdChzZWdbc2VnbGVuIC0gM10pIHx8IGF0dHJzLnk7XG4gICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHBhcnNlRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICBhdHRyczIuYnkgPSBwMiAmJiAocGFyc2VGbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgIGF0dHJzMi54ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMl07XG4gICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgfVxuXG4gIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xufTtcblxudmFyIHAycyA9IC8sPyhbYS16XSksPy9naTtcblxudmFyIHBhcnNlUGF0aEFycmF5ID0gZnVuY3Rpb24gcGFyc2VQYXRoQXJyYXkocGF0aCkge1xuICByZXR1cm4gcGF0aC5qb2luKCcsJykucmVwbGFjZShwMnMsICckMScpO1xufTtcblxudmFyIGJhc2UzID0gZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNDtcbiAgdmFyIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbn07XG5cbnZhciBiZXpsZW4gPSBmdW5jdGlvbiBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB6KSB7XG4gIGlmICh6ID09PSBudWxsKSB7XG4gICAgeiA9IDE7XG4gIH1cblxuICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgdmFyIHoyID0geiAvIDI7XG4gIHZhciBuID0gMTI7XG4gIHZhciBUdmFsdWVzID0gWy0wLjEyNTIsIDAuMTI1MiwgLTAuMzY3OCwgMC4zNjc4LCAtMC41ODczLCAwLjU4NzMsIC0wLjc2OTksIDAuNzY5OSwgLTAuOTA0MSwgMC45MDQxLCAtMC45ODE2LCAwLjk4MTZdO1xuICB2YXIgQ3ZhbHVlcyA9IFswLjI0OTEsIDAuMjQ5MSwgMC4yMzM1LCAwLjIzMzUsIDAuMjAzMiwgMC4yMDMyLCAwLjE2MDEsIDAuMTYwMSwgMC4xMDY5LCAwLjEwNjksIDAuMDQ3MiwgMC4wNDcyXTtcbiAgdmFyIHN1bSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY3QgPSB6MiAqIFR2YWx1ZXNbaV0gKyB6MjtcbiAgICB2YXIgeGJhc2UgPSBiYXNlMyhjdCwgeDEsIHgyLCB4MywgeDQpO1xuICAgIHZhciB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCk7XG4gICAgdmFyIGNvbWIgPSB4YmFzZSAqIHhiYXNlICsgeWJhc2UgKiB5YmFzZTtcbiAgICBzdW0gKz0gQ3ZhbHVlc1tpXSAqIE1hdGguc3FydChjb21iKTtcbiAgfVxuXG4gIHJldHVybiB6MiAqIHN1bTtcbn07XG5cbnZhciBjdXJ2ZURpbSA9IGZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgdHZhbHVlcyA9IFtdO1xuICB2YXIgYm91bmRzID0gW1tdLCBbXV07XG4gIHZhciBhO1xuICB2YXIgYjtcbiAgdmFyIGM7XG4gIHZhciB0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHQgPSAtYyAvIGI7XG5cbiAgICAgIGlmICh0ID4gMCAmJiB0IDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgdmFyIHNxcnRiMmFjID0gTWF0aC5zcXJ0KGIyYWMpO1xuXG4gICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuXG4gICAgaWYgKHQxID4gMCAmJiB0MSA8IDEpIHtcbiAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgfVxuXG4gICAgdmFyIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcblxuICAgIGlmICh0MiA+IDAgJiYgdDIgPCAxKSB7XG4gICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBqID0gdHZhbHVlcy5sZW5ndGg7XG4gIHZhciBqbGVuID0gajtcbiAgdmFyIG10O1xuXG4gIHdoaWxlIChqLS0pIHtcbiAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICBtdCA9IDEgLSB0O1xuICAgIGJvdW5kc1swXVtqXSA9IG10ICogbXQgKiBtdCAqIHgwICsgMyAqIG10ICogbXQgKiB0ICogeDEgKyAzICogbXQgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTAgKyAzICogbXQgKiBtdCAqIHQgKiB5MSArIDMgKiBtdCAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgfVxuXG4gIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG4gIHJldHVybiB7XG4gICAgbWluOiB7XG4gICAgICB4OiBNYXRoLm1pbi5hcHBseSgwLCBib3VuZHNbMF0pLFxuICAgICAgeTogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzFdKVxuICAgIH0sXG4gICAgbWF4OiB7XG4gICAgICB4OiBNYXRoLm1heC5hcHBseSgwLCBib3VuZHNbMF0pLFxuICAgICAgeTogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzFdKVxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBpbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gIGlmIChNYXRoLm1heCh4MSwgeDIpIDwgTWF0aC5taW4oeDMsIHg0KSB8fCBNYXRoLm1pbih4MSwgeDIpID4gTWF0aC5tYXgoeDMsIHg0KSB8fCBNYXRoLm1heCh5MSwgeTIpIDwgTWF0aC5taW4oeTMsIHk0KSB8fCBNYXRoLm1pbih5MSwgeTIpID4gTWF0aC5tYXgoeTMsIHk0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBueCA9ICh4MSAqIHkyIC0geTEgKiB4MikgKiAoeDMgLSB4NCkgLSAoeDEgLSB4MikgKiAoeDMgKiB5NCAtIHkzICogeDQpO1xuICB2YXIgbnkgPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzICogeTQgLSB5MyAqIHg0KTtcbiAgdmFyIGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuXG4gIGlmICghZGVub21pbmF0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHggPSBueCAvIGRlbm9taW5hdG9yO1xuICB2YXIgcHkgPSBueSAvIGRlbm9taW5hdG9yO1xuICB2YXIgcHgyID0gK3B4LnRvRml4ZWQoMik7XG4gIHZhciBweTIgPSArcHkudG9GaXhlZCgyKTtcblxuICBpZiAocHgyIDwgK01hdGgubWluKHgxLCB4MikudG9GaXhlZCgyKSB8fCBweDIgPiArTWF0aC5tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8IHB4MiA8ICtNYXRoLm1pbih4MywgeDQpLnRvRml4ZWQoMikgfHwgcHgyID4gK01hdGgubWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fCBweTIgPCArTWF0aC5taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8IHB5MiA+ICtNYXRoLm1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHwgcHkyIDwgK01hdGgubWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fCBweTIgPiArTWF0aC5tYXgoeTMsIHk0KS50b0ZpeGVkKDIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBweCxcbiAgICB5OiBweVxuICB9O1xufTtcblxudmFyIGlzUG9pbnRJbnNpZGVCQm94ID0gZnVuY3Rpb24gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkge1xuICByZXR1cm4geCA+PSBiYm94LnggJiYgeCA8PSBiYm94LnggKyBiYm94LndpZHRoICYmIHkgPj0gYmJveC55ICYmIHkgPD0gYmJveC55ICsgYmJveC5oZWlnaHQ7XG59O1xuXG52YXIgcmVjdFBhdGggPSBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gIGlmIChyKSB7XG4gICAgcmV0dXJuIFtbJ00nLCAreCArICtyLCB5XSwgWydsJywgdyAtIHIgKiAyLCAwXSwgWydhJywgciwgciwgMCwgMCwgMSwgciwgcl0sIFsnbCcsIDAsIGggLSByICogMl0sIFsnYScsIHIsIHIsIDAsIDAsIDEsIC1yLCByXSwgWydsJywgciAqIDIgLSB3LCAwXSwgWydhJywgciwgciwgMCwgMCwgMSwgLXIsIC1yXSwgWydsJywgMCwgciAqIDIgLSBoXSwgWydhJywgciwgciwgMCwgMCwgMSwgciwgLXJdLCBbJ3onXV07XG4gIH1cblxuICB2YXIgcmVzID0gW1snTScsIHgsIHldLCBbJ2wnLCB3LCAwXSwgWydsJywgMCwgaF0sIFsnbCcsIC13LCAwXSwgWyd6J11dO1xuICByZXMucGFyc2VQYXRoQXJyYXkgPSBwYXJzZVBhdGhBcnJheTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBib3ggPSBmdW5jdGlvbiBib3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHggPSB5ID0gd2lkdGggPSBoZWlnaHQgPSAwO1xuICB9XG5cbiAgaWYgKHkgPT09IG51bGwpIHtcbiAgICB5ID0geC55O1xuICAgIHdpZHRoID0geC53aWR0aDtcbiAgICBoZWlnaHQgPSB4LmhlaWdodDtcbiAgICB4ID0geC54O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIHc6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGg6IGhlaWdodCxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgIGN4OiB4ICsgd2lkdGggLyAyLFxuICAgIGN5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICByMTogTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgIHIyOiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIDIsXG4gICAgcjA6IE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIsXG4gICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgdmI6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKCcgJylcbiAgfTtcbn07XG5cbnZhciBpc0JCb3hJbnRlcnNlY3QgPSBmdW5jdGlvbiBpc0JCb3hJbnRlcnNlY3QoYmJveDEsIGJib3gyKSB7XG4gIGJib3gxID0gYm94KGJib3gxKTtcbiAgYmJveDIgPSBib3goYmJveDIpO1xuICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkpIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54MiwgYmJveDEueSkgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKSB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueDIsIGJib3gxLnkyKSB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueSkgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KSB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueCwgYmJveDIueTIpIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54MiwgYmJveDIueTIpIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnggfHwgYmJveDIueCA8IGJib3gxLngyICYmIGJib3gyLnggPiBiYm94MS54KSAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55IHx8IGJib3gyLnkgPCBiYm94MS55MiAmJiBiYm94Mi55ID4gYmJveDEueSk7XG59O1xuXG52YXIgYmV6aWVyQkJveCA9IGZ1bmN0aW9uIGJlemllckJCb3gocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnkpIHtcbiAgaWYgKCFVdGlsLmlzQXJyYXkocDF4KSkge1xuICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gIH1cblxuICB2YXIgYmJveCA9IGN1cnZlRGltLmFwcGx5KG51bGwsIHAxeCk7XG4gIHJldHVybiBib3goYmJveC5taW4ueCwgYmJveC5taW4ueSwgYmJveC5tYXgueCAtIGJib3gubWluLngsIGJib3gubWF4LnkgLSBiYm94Lm1pbi55KTtcbn07XG5cbnZhciBmaW5kRG90c0F0U2VnbWVudCA9IGZ1bmN0aW9uIGZpbmREb3RzQXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gIHZhciB0MSA9IDEgLSB0O1xuICB2YXIgdDEzID0gTWF0aC5wb3codDEsIDMpO1xuICB2YXIgdDEyID0gTWF0aC5wb3codDEsIDIpO1xuICB2YXIgdDIgPSB0ICogdDtcbiAgdmFyIHQzID0gdDIgKiB0O1xuICB2YXIgeCA9IHQxMyAqIHAxeCArIHQxMiAqIDMgKiB0ICogYzF4ICsgdDEgKiAzICogdCAqIHQgKiBjMnggKyB0MyAqIHAyeDtcbiAgdmFyIHkgPSB0MTMgKiBwMXkgKyB0MTIgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgdDMgKiBwMnk7XG4gIHZhciBteCA9IHAxeCArIDIgKiB0ICogKGMxeCAtIHAxeCkgKyB0MiAqIChjMnggLSAyICogYzF4ICsgcDF4KTtcbiAgdmFyIG15ID0gcDF5ICsgMiAqIHQgKiAoYzF5IC0gcDF5KSArIHQyICogKGMyeSAtIDIgKiBjMXkgKyBwMXkpO1xuICB2YXIgbnggPSBjMXggKyAyICogdCAqIChjMnggLSBjMXgpICsgdDIgKiAocDJ4IC0gMiAqIGMyeCArIGMxeCk7XG4gIHZhciBueSA9IGMxeSArIDIgKiB0ICogKGMyeSAtIGMxeSkgKyB0MiAqIChwMnkgLSAyICogYzJ5ICsgYzF5KTtcbiAgdmFyIGF4ID0gdDEgKiBwMXggKyB0ICogYzF4O1xuICB2YXIgYXkgPSB0MSAqIHAxeSArIHQgKiBjMXk7XG4gIHZhciBjeCA9IHQxICogYzJ4ICsgdCAqIHAyeDtcbiAgdmFyIGN5ID0gdDEgKiBjMnkgKyB0ICogcDJ5O1xuICB2YXIgYWxwaGEgPSA5MCAtIE1hdGguYXRhbjIobXggLSBueCwgbXkgLSBueSkgKiAxODAgLyBNYXRoLlBJOyAvLyAobXggPiBueCB8fCBteSA8IG55KSAmJiAoYWxwaGEgKz0gMTgwKTtcblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICBtOiB7XG4gICAgICB4OiBteCxcbiAgICAgIHk6IG15XG4gICAgfSxcbiAgICBuOiB7XG4gICAgICB4OiBueCxcbiAgICAgIHk6IG55XG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgeDogYXgsXG4gICAgICB5OiBheVxuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICB4OiBjeCxcbiAgICAgIHk6IGN5XG4gICAgfSxcbiAgICBhbHBoYTogYWxwaGFcbiAgfTtcbn07XG5cbnZhciBpbnRlckhlbHBlciA9IGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpO1xuICB2YXIgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuXG4gIGlmICghaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94MikpIHtcbiAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICB9XG5cbiAgdmFyIGwxID0gYmV6bGVuLmFwcGx5KDAsIGJlejEpO1xuICB2YXIgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6Mik7XG4gIHZhciBuMSA9IH5+KGwxIC8gOCk7XG4gIHZhciBuMiA9IH5+KGwyIC8gOCk7XG4gIHZhciBkb3RzMSA9IFtdO1xuICB2YXIgZG90czIgPSBbXTtcbiAgdmFyIHh5ID0ge307XG4gIHZhciByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMSArIDE7IGkrKykge1xuICAgIHZhciBkID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgZG90czEucHVzaCh7XG4gICAgICB4OiBkLngsXG4gICAgICB5OiBkLnksXG4gICAgICB0OiBpIC8gbjFcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMiArIDE7IF9pKyspIHtcbiAgICB2YXIgX2QgPSBmaW5kRG90c0F0U2VnbWVudC5hcHBseSgwLCBiZXoyLmNvbmNhdChfaSAvIG4yKSk7XG5cbiAgICBkb3RzMi5wdXNoKHtcbiAgICAgIHg6IF9kLngsXG4gICAgICB5OiBfZC55LFxuICAgICAgdDogX2kgLyBuMlxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjE7IF9pMisrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuMjsgaisrKSB7XG4gICAgICB2YXIgZGkgPSBkb3RzMVtfaTJdO1xuICAgICAgdmFyIGRpMSA9IGRvdHMxW19pMiArIDFdO1xuICAgICAgdmFyIGRqID0gZG90czJbal07XG4gICAgICB2YXIgZGoxID0gZG90czJbaiArIDFdO1xuICAgICAgdmFyIGNpID0gTWF0aC5hYnMoZGkxLnggLSBkaS54KSA8IDAuMDAxID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGNqID0gTWF0aC5hYnMoZGoxLnggLSBkai54KSA8IDAuMDAxID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcblxuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09PSBpcy55LnRvRml4ZWQoNCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHh5W2lzLngudG9GaXhlZCg0KV0gPSBpcy55LnRvRml4ZWQoNCk7XG4gICAgICAgIHZhciB0MSA9IGRpLnQgKyBNYXRoLmFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KTtcbiAgICAgICAgdmFyIHQyID0gZGoudCArIE1hdGguYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuXG4gICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEgJiYgdDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgcmVzKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgeDogaXMueCxcbiAgICAgICAgICAgICAgeTogaXMueSxcbiAgICAgICAgICAgICAgdDE6IHQxLFxuICAgICAgICAgICAgICB0MjogdDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgaW50ZXJQYXRoSGVscGVyID0gZnVuY3Rpb24gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwganVzdENvdW50KSB7XG4gIHBhdGgxID0gcGF0aFRvY3VydmUocGF0aDEpO1xuICBwYXRoMiA9IHBhdGhUb2N1cnZlKHBhdGgyKTtcbiAgdmFyIHgxO1xuICB2YXIgeTE7XG4gIHZhciB4MjtcbiAgdmFyIHkyO1xuICB2YXIgeDFtO1xuICB2YXIgeTFtO1xuICB2YXIgeDJtO1xuICB2YXIgeTJtO1xuICB2YXIgYmV6MTtcbiAgdmFyIGJlejI7XG4gIHZhciByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aDEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuXG4gICAgaWYgKHBpWzBdID09PSAnTScpIHtcbiAgICAgIHgxID0geDFtID0gcGlbMV07XG4gICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGlbMF0gPT09ICdDJykge1xuICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXoxID0gW3gxLCB5MSwgeDEsIHkxLCB4MW0sIHkxbSwgeDFtLCB5MW1dO1xuICAgICAgICB4MSA9IHgxbTtcbiAgICAgICAgeTEgPSB5MW07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHBhdGgyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIHBqID0gcGF0aDJbal07XG5cbiAgICAgICAgaWYgKHBqWzBdID09PSAnTScpIHtcbiAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgIHkyID0geTJtID0gcGpbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBqWzBdID09PSAnQycpIHtcbiAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgeTIgPSBiZXoyWzddO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXoyID0gW3gyLCB5MiwgeDIsIHkyLCB4Mm0sIHkybSwgeDJtLCB5Mm1dO1xuICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG5cbiAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICByZXMgKz0gaW50cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gaW50ci5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgIGludHJba10uc2VnbWVudDEgPSBpO1xuICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQyID0gajtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoxID0gYmV6MTtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoyID0gYmV6MjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxudmFyIHBhdGhJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBwYXRoSW50ZXJzZWN0aW9uKHBhdGgxLCBwYXRoMikge1xuICByZXR1cm4gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMik7XG59O1xuXG5mdW5jdGlvbiBkZWNhc3RlbGphdShwb2ludHMsIHQpIHtcbiAgdmFyIGxlZnQgPSBbXTtcbiAgdmFyIHJpZ2h0ID0gW107XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShwb2ludHMsIHQpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGVmdC5wdXNoKHBvaW50c1swXSk7XG4gICAgICByaWdodC5wdXNoKHBvaW50c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaWRkbGVQb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbGVmdC5wdXNoKHBvaW50c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICByaWdodC5wdXNoKHBvaW50c1tpICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWlkZGxlUG9pbnRzW2ldID0gWygxIC0gdCkgKiBwb2ludHNbaV1bMF0gKyB0ICogcG9pbnRzW2kgKyAxXVswXSwgKDEgLSB0KSAqIHBvaW50c1tpXVsxXSArIHQgKiBwb2ludHNbaSArIDFdWzFdXTtcbiAgICAgIH1cblxuICAgICAgcmVjdXJzZShtaWRkbGVQb2ludHMsIHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgcmVjdXJzZShwb2ludHMsIHQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodC5yZXZlcnNlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3BsaXRDdXJ2ZShzdGFydCwgZW5kLCBjb3VudCkge1xuICB2YXIgcG9pbnRzID0gW1tzdGFydFsxXSwgc3RhcnRbMl1dXTtcbiAgY291bnQgPSBjb3VudCB8fCAyO1xuICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICBpZiAoZW5kWzBdID09PSAnQScpIHtcbiAgICBwb2ludHMucHVzaChlbmRbNl0pO1xuICAgIHBvaW50cy5wdXNoKGVuZFs3XSk7XG4gIH0gZWxzZSBpZiAoZW5kWzBdID09PSAnQycpIHtcbiAgICBwb2ludHMucHVzaChbZW5kWzFdLCBlbmRbMl1dKTtcbiAgICBwb2ludHMucHVzaChbZW5kWzNdLCBlbmRbNF1dKTtcbiAgICBwb2ludHMucHVzaChbZW5kWzVdLCBlbmRbNl1dKTtcbiAgfSBlbHNlIGlmIChlbmRbMF0gPT09ICdTJyB8fCBlbmRbMF0gPT09ICdRJykge1xuICAgIHBvaW50cy5wdXNoKFtlbmRbMV0sIGVuZFsyXV0pO1xuICAgIHBvaW50cy5wdXNoKFtlbmRbM10sIGVuZFs0XV0pO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cy5wdXNoKFtlbmRbMV0sIGVuZFsyXV0pO1xuICB9XG5cbiAgdmFyIGxlZnRTZWdtZW50cyA9IHBvaW50cztcbiAgdmFyIHQgPSAxIC8gY291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAtIDE7IGkrKykge1xuICAgIHZhciBydCA9IHQgLyAoMSAtIHQgKiBpKTtcbiAgICB2YXIgc3BsaXQgPSBkZWNhc3RlbGphdShsZWZ0U2VnbWVudHMsIHJ0KTtcbiAgICBzZWdtZW50cy5wdXNoKHNwbGl0LmxlZnQpO1xuICAgIGxlZnRTZWdtZW50cyA9IHNwbGl0LnJpZ2h0O1xuICB9XG5cbiAgc2VnbWVudHMucHVzaChsZWZ0U2VnbWVudHMpO1xuICB2YXIgcmVzdWx0ID0gc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgdmFyIGNtZCA9IFtdO1xuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSA0KSB7XG4gICAgICBjbWQucHVzaCgnQycpO1xuICAgICAgY21kID0gY21kLmNvbmNhdChzZWdtZW50WzJdKTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPj0gMykge1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNtZC5wdXNoKCdRJyk7XG4gICAgICB9XG5cbiAgICAgIGNtZCA9IGNtZC5jb25jYXQoc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjbWQucHVzaCgnTCcpO1xuICAgIH1cblxuICAgIGNtZCA9IGNtZC5jb25jYXQoc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdKTtcbiAgICByZXR1cm4gY21kO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHNwbGl0U2VnbWVudCA9IGZ1bmN0aW9uIHNwbGl0U2VnbWVudChzdGFydCwgZW5kLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICByZXR1cm4gW1tdLmNvbmNhdChzdGFydCldO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gW107XG5cbiAgaWYgKGVuZFswXSA9PT0gJ0wnIHx8IGVuZFswXSA9PT0gJ0MnIHx8IGVuZFswXSA9PT0gJ1EnKSB7XG4gICAgc2VnbWVudHMgPSBzZWdtZW50cy5jb25jYXQoc3BsaXRDdXJ2ZShzdGFydCwgZW5kLCBjb3VudCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ZW1wID0gW10uY29uY2F0KHN0YXJ0KTtcblxuICAgIGlmICh0ZW1wWzBdID09PSAnTScpIHtcbiAgICAgIHRlbXBbMF0gPSAnTCc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQgLSAxOyBpKyspIHtcbiAgICAgIHNlZ21lbnRzLnB1c2godGVtcCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxudmFyIGZpbGxQYXRoID0gZnVuY3Rpb24gZmlsbFBhdGgoc291cmNlLCB0YXJnZXQpIHtcbiAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIHNvdXJjZUxlbiA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gIHZhciByYXRpbyA9IHNvdXJjZUxlbiAvIHRhcmdldExlbjtcbiAgdmFyIHNlZ21lbnRzVG9GaWxsID0gW107XG5cbiAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDEgJiYgc291cmNlWzBdWzBdID09PSAnTScpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldExlbiAtIHNvdXJjZUxlbjsgaSsrKSB7XG4gICAgICBzb3VyY2UucHVzaChzb3VyY2VbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0YXJnZXRMZW47IF9pMysrKSB7XG4gICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihyYXRpbyAqIF9pMyk7XG4gICAgc2VnbWVudHNUb0ZpbGxbaW5kZXhdID0gKHNlZ21lbnRzVG9GaWxsW2luZGV4XSB8fCAwKSArIDE7XG4gIH1cblxuICB2YXIgZmlsbGVkID0gc2VnbWVudHNUb0ZpbGwucmVkdWNlKGZ1bmN0aW9uIChmaWxsZWQsIGNvdW50LCBpKSB7XG4gICAgaWYgKGkgPT09IHNvdXJjZUxlbikge1xuICAgICAgcmV0dXJuIGZpbGxlZC5jb25jYXQoc291cmNlW3NvdXJjZUxlbl0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWQuY29uY2F0KHNwbGl0U2VnbWVudChzb3VyY2VbaV0sIHNvdXJjZVtpICsgMV0sIGNvdW50KSk7XG4gIH0sIFtdKTtcbiAgZmlsbGVkLnVuc2hpZnQoc291cmNlWzBdKTtcblxuICBpZiAodGFyZ2V0W3RhcmdldExlbl0gPT09ICdaJyB8fCB0YXJnZXRbdGFyZ2V0TGVuXSA9PT0gJ3onKSB7XG4gICAgZmlsbGVkLnB1c2goJ1onKTtcbiAgfVxuXG4gIHJldHVybiBmaWxsZWQ7XG59O1xuXG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIFV0aWwuZWFjaChvYmoxLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGlmIChpdGVtICE9PSBvYmoyW2ldKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZ2V0TWluRGlmZihkZWwsIGFkZCwgbW9kaWZ5KSB7XG4gIHZhciB0eXBlID0gbnVsbDtcbiAgdmFyIG1pbiA9IG1vZGlmeTtcblxuICBpZiAoYWRkIDwgbWluKSB7XG4gICAgbWluID0gYWRkO1xuICAgIHR5cGUgPSAnYWRkJztcbiAgfVxuXG4gIGlmIChkZWwgPCBtaW4pIHtcbiAgICBtaW4gPSBkZWw7XG4gICAgdHlwZSA9ICdkZWwnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIG1pbjogbWluXG4gIH07XG59XG4vKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2ZW5zaHRlaW5fZGlzdGFuY2VcbiAqIOiuoeeul+S4pOadoXBhdGjnmoTnvJbovpHot53nprtcbiAqL1xuXG5cbnZhciBsZXZlbnNodGVpbkRpc3RhbmNlID0gZnVuY3Rpb24gbGV2ZW5zaHRlaW5EaXN0YW5jZShzb3VyY2UsIHRhcmdldCkge1xuICB2YXIgc291cmNlTGVuID0gc291cmNlLmxlbmd0aDtcbiAgdmFyIHRhcmdldExlbiA9IHRhcmdldC5sZW5ndGg7XG4gIHZhciBzb3VyY2VTZWdtZW50LCB0YXJnZXRTZWdtZW50O1xuICB2YXIgdGVtcCA9IDA7XG5cbiAgaWYgKHNvdXJjZUxlbiA9PT0gMCB8fCB0YXJnZXRMZW4gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc291cmNlTGVuOyBpKyspIHtcbiAgICBkaXN0W2ldID0gW107XG4gICAgZGlzdFtpXVswXSA9IHtcbiAgICAgIG1pbjogaVxuICAgIH07XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8PSB0YXJnZXRMZW47IGorKykge1xuICAgIGRpc3RbMF1bal0gPSB7XG4gICAgICBtaW46IGpcbiAgICB9O1xuICB9XG5cbiAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDw9IHNvdXJjZUxlbjsgX2k0KyspIHtcbiAgICBzb3VyY2VTZWdtZW50ID0gc291cmNlW19pNCAtIDFdO1xuXG4gICAgZm9yICh2YXIgX2oyID0gMTsgX2oyIDw9IHRhcmdldExlbjsgX2oyKyspIHtcbiAgICAgIHRhcmdldFNlZ21lbnQgPSB0YXJnZXRbX2oyIC0gMV07XG5cbiAgICAgIGlmIChpc0VxdWFsKHNvdXJjZVNlZ21lbnQsIHRhcmdldFNlZ21lbnQpKSB7XG4gICAgICAgIHRlbXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWwgPSBkaXN0W19pNCAtIDFdW19qMl0ubWluICsgMTtcbiAgICAgIHZhciBhZGQgPSBkaXN0W19pNF1bX2oyIC0gMV0ubWluICsgMTtcbiAgICAgIHZhciBtb2RpZnkgPSBkaXN0W19pNCAtIDFdW19qMiAtIDFdLm1pbiArIHRlbXA7XG4gICAgICBkaXN0W19pNF1bX2oyXSA9IGdldE1pbkRpZmYoZGVsLCBhZGQsIG1vZGlmeSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3Q7XG59O1xuXG52YXIgZmlsbFBhdGhCeURpZmYgPSBmdW5jdGlvbiBmaWxsUGF0aEJ5RGlmZihzb3VyY2UsIHRhcmdldCkge1xuICB2YXIgZGlmZk1hdHJpeCA9IGxldmVuc2h0ZWluRGlzdGFuY2Uoc291cmNlLCB0YXJnZXQpO1xuICB2YXIgc291cmNlTGVuID0gc291cmNlLmxlbmd0aDtcbiAgdmFyIHRhcmdldExlbiA9IHRhcmdldC5sZW5ndGg7XG4gIHZhciBjaGFuZ2VzID0gW107XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBtaW5Qb3MgPSAxOyAvLyDlpoLmnpxzb3VyY2Xlkox0YXJnZXTkuI3mmK/lrozlhajkuI3nm7jnrYlcblxuICBpZiAoZGlmZk1hdHJpeFtzb3VyY2VMZW5dW3RhcmdldExlbl0gIT09IHNvdXJjZUxlbikge1xuICAgIC8vIOiOt+WPluS7jnNvdXJjZeWIsHRhcmdldOaJgOmcgOaUueWKqFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHNvdXJjZUxlbjsgaSsrKSB7XG4gICAgICB2YXIgbWluID0gZGlmZk1hdHJpeFtpXVtpXS5taW47XG4gICAgICBtaW5Qb3MgPSBpO1xuXG4gICAgICBmb3IgKHZhciBqID0gaW5kZXg7IGogPD0gdGFyZ2V0TGVuOyBqKyspIHtcbiAgICAgICAgaWYgKGRpZmZNYXRyaXhbaV1bal0ubWluIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gZGlmZk1hdHJpeFtpXVtqXS5taW47XG4gICAgICAgICAgbWluUG9zID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IG1pblBvcztcblxuICAgICAgaWYgKGRpZmZNYXRyaXhbaV1baW5kZXhdLnR5cGUpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICBpbmRleDogaSAtIDEsXG4gICAgICAgICAgdHlwZTogZGlmZk1hdHJpeFtpXVtpbmRleF0udHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIOWvuXNvdXJjZei/m+ihjOWinuWIoHBhdGhcblxuXG4gICAgZm9yICh2YXIgX2k1ID0gY2hhbmdlcy5sZW5ndGggLSAxOyBfaTUgPj0gMDsgX2k1LS0pIHtcbiAgICAgIGluZGV4ID0gY2hhbmdlc1tfaTVdLmluZGV4O1xuXG4gICAgICBpZiAoY2hhbmdlc1tfaTVdLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgIHNvdXJjZS5zcGxpY2UoaW5kZXgsIDAsIFtdLmNvbmNhdChzb3VyY2VbaW5kZXhdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2Uuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gc291cmNl5bC+6YOo6KGl6b2QXG5cblxuICBzb3VyY2VMZW4gPSBzb3VyY2UubGVuZ3RoO1xuICB2YXIgZGlmZiA9IHRhcmdldExlbiAtIHNvdXJjZUxlbjtcblxuICBpZiAoc291cmNlTGVuIDwgdGFyZ2V0TGVuKSB7XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGlmZjsgX2k2KyspIHtcbiAgICAgIGlmIChzb3VyY2Vbc291cmNlTGVuIC0gMV1bMF0gPT09ICd6JyB8fCBzb3VyY2Vbc291cmNlTGVuIC0gMV1bMF0gPT09ICdaJykge1xuICAgICAgICBzb3VyY2Uuc3BsaWNlKHNvdXJjZUxlbiAtIDIsIDAsIHNvdXJjZVtzb3VyY2VMZW4gLSAyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2UucHVzaChzb3VyY2Vbc291cmNlTGVuIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2VMZW4gKz0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufTsgLy8g5bCG5Lik5Liq54K55Z2H5YiG5oiQY291bnTkuKrngrlcblxuXG5mdW5jdGlvbiBfc3BsaXRQb2ludHMocG9pbnRzLCBmb3JtZXIsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSBbXS5jb25jYXQocG9pbnRzKTtcbiAgdmFyIGluZGV4O1xuICB2YXIgdCA9IDEgLyAoY291bnQgKyAxKTtcblxuICB2YXIgZm9ybWVyRW5kID0gX2dldFNlZ21lbnRQb2ludHMoZm9ybWVyKVswXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBjb3VudDsgaSsrKSB7XG4gICAgdCAqPSBpO1xuICAgIGluZGV4ID0gTWF0aC5mbG9vcihwb2ludHMubGVuZ3RoICogdCk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJlc3VsdC51bnNoaWZ0KFtmb3JtZXJFbmRbMF0gKiB0ICsgcG9pbnRzW2luZGV4XVswXSAqICgxIC0gdCksIGZvcm1lckVuZFsxXSAqIHQgKyBwb2ludHNbaW5kZXhdWzFdICogKDEgLSB0KV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc3BsaWNlKGluZGV4LCAwLCBbZm9ybWVyRW5kWzBdICogdCArIHBvaW50c1tpbmRleF1bMF0gKiAoMSAtIHQpLCBmb3JtZXJFbmRbMV0gKiB0ICsgcG9pbnRzW2luZGV4XVsxXSAqICgxIC0gdCldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLypcbiAqIOaKveWPlnBhdGhTZWdtZW505Lit55qE5YWz6ZSu54K5XG4gKiBNLEwsQSxRLEgsVuS4gOS4querr+eCuVxuICogUSwgU+aKveWPluS4gOS4querr+eCue+8jOS4gOS4quaOp+WItueCuVxuICogQ+aKveWPluS4gOS4querr+eCue+8jOS4pOS4quaOp+WItueCuVxuICovXG5cblxuZnVuY3Rpb24gX2dldFNlZ21lbnRQb2ludHMoc2VnbWVudCkge1xuICB2YXIgcG9pbnRzID0gW107XG5cbiAgc3dpdGNoIChzZWdtZW50WzBdKSB7XG4gICAgY2FzZSAnTSc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsyXV0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdMJzpcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzFdLCBzZWdtZW50WzJdXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0EnOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbNl0sIHNlZ21lbnRbN11dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUSc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFszXSwgc2VnbWVudFs0XV0pO1xuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnVCc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsyXV0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdDJzpcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzVdLCBzZWdtZW50WzZdXSk7XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsyXV0pO1xuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbM10sIHNlZ21lbnRbNF1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUyc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFszXSwgc2VnbWVudFs0XV0pO1xuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnSCc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsxXV0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdWJzpcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzFdLCBzZWdtZW50WzFdXSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuXG52YXIgZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgoZnJvbVBhdGgsIHRvUGF0aCkge1xuICBpZiAoZnJvbVBhdGgubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gZnJvbVBhdGg7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9QYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXRoW2ldWzBdICE9PSB0b1BhdGhbaV1bMF0pIHtcbiAgICAgIC8vIOiOt+WPlmZyb21QYXRo55qEcGF0aFNlZ21lbnTnmoTnq6/ngrnvvIzmoLnmja50b1BhdGjnmoTmjIfku6Tlr7nlhbbmlLnpgKBcbiAgICAgIHBvaW50cyA9IF9nZXRTZWdtZW50UG9pbnRzKGZyb21QYXRoW2ldKTtcblxuICAgICAgc3dpdGNoICh0b1BhdGhbaV1bMF0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgZnJvbVBhdGhbaV0gPSBbJ00nXS5jb25jYXQocG9pbnRzWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBmcm9tUGF0aFtpXSA9IFsnTCddLmNvbmNhdChwb2ludHNbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGZyb21QYXRoW2ldID0gW10uY29uY2F0KHRvUGF0aFtpXSk7XG4gICAgICAgICAgZnJvbVBhdGhbaV1bNl0gPSBwb2ludHNbMF1bMF07XG4gICAgICAgICAgZnJvbVBhdGhbaV1bN10gPSBwb2ludHNbMF1bMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgcG9pbnRzID0gX3NwbGl0UG9pbnRzKHBvaW50cywgZnJvbVBhdGhbaSAtIDFdLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21QYXRoW2ldID0gdG9QYXRoW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmcm9tUGF0aFtpXSA9IFsnUSddLmNvbmNhdChwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KGkpO1xuICAgICAgICAgIH0sIFtdKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgZnJvbVBhdGhbaV0gPSBbJ1QnXS5jb25jYXQocG9pbnRzWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBwb2ludHMgPSBfc3BsaXRQb2ludHMocG9pbnRzLCBmcm9tUGF0aFtpIC0gMV0sIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhdGhbaV0gPSB0b1BhdGhbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyb21QYXRoW2ldID0gWydDJ10uY29uY2F0KHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoaSk7XG4gICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBwb2ludHMgPSBfc3BsaXRQb2ludHMocG9pbnRzLCBmcm9tUGF0aFtpIC0gMV0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhdGhbaV0gPSB0b1BhdGhbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyb21QYXRoW2ldID0gWydTJ10uY29uY2F0KHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoaSk7XG4gICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb21QYXRoW2ldID0gdG9QYXRoW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcm9tUGF0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVBhdGhTdHJpbmc6IHBhcnNlUGF0aFN0cmluZyxcbiAgcGFyc2VQYXRoQXJyYXk6IHBhcnNlUGF0aEFycmF5LFxuICBwYXRoVG9jdXJ2ZTogcGF0aFRvY3VydmUsXG4gIHBhdGhUb0Fic29sdXRlOiBwYXRoVG9BYnNvbHV0ZSxcbiAgY2F0bXVsbFJvbVRvQmV6aWVyOiBjYXRtdWxsUm9tMmJlemllcixcbiAgcmVjdFBhdGg6IHJlY3RQYXRoLFxuICBmaWxsUGF0aDogZmlsbFBhdGgsXG4gIGZpbGxQYXRoQnlEaWZmOiBmaWxsUGF0aEJ5RGlmZixcbiAgZm9ybWF0UGF0aDogZm9ybWF0UGF0aCxcbiAgaW50ZXJzZWN0aW9uOiBwYXRoSW50ZXJzZWN0aW9uXG59O1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBub3c7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IFRpbWVyO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImNcIl0gPSB0aW1lcjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJkXCJdID0gdGltZXJGbHVzaDtcbnZhciBmcmFtZSA9IDAsXG4gICAgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG50aW1lb3V0ID0gMCxcbiAgICAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbmludGVydmFsID0gMCxcbiAgICAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG5wb2tlRGVsYXkgPSAxMDAwLFxuICAgIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG50YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24gKGYpIHtcbiAgc2V0VGltZW91dChmLCAxNyk7XG59O1xuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID0gdGhpcy5fdGltZSA9IHRoaXMuX25leHQgPSBudWxsO1xufVxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcblxuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7ZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcigpO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cblxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cblxuICB2YXIgdCA9IHRhc2tIZWFkLFxuICAgICAgZTtcblxuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKG51bGwsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG5cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuXG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLFxuICAgICAgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLFxuICAgICAgdDEgPSB0YXNrSGVhZCxcbiAgICAgIHQyLFxuICAgICAgdGltZSA9IEluZmluaXR5O1xuXG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuXG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3JnYl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fYXJyYXlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2RhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX251bWJlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19vYmplY3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3N0cmluZ19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fY29uc3RhbnRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIxKTtcblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsXG4gICAgICBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fY29uc3RhbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoYikgOiAodCA9PT0gXCJudW1iZXJcIiA/IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fbnVtYmVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10gOiB0ID09PSBcInN0cmluZ1wiID8gKGMgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX19bXCJhXCIgLyogY29sb3IgKi9dKShiKSkgPyAoYiA9IGMsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcmdiX19bXCJhXCIgLyogZGVmYXVsdCAqL10pIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19zdHJpbmdfX1tcImFcIiAvKiBkZWZhdWx0ICovXSA6IGIgaW5zdGFuY2VvZiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImFcIiAvKiBjb2xvciAqL10gPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3JnYl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dIDogYiBpbnN0YW5jZW9mIERhdGUgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2RhdGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSA6IEFycmF5LmlzQXJyYXkoYikgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2FycmF5X19bXCJhXCIgLyogZGVmYXVsdCAqL10gOiB0eXBlb2YgYi52YWx1ZU9mICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIudG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIiB8fCBpc05hTihiKSA/IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fb2JqZWN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10gOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX251bWJlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShhLCBiKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBDb2xvcjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGFya2VyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYnJpZ2h0ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImVcIl0gPSBjb2xvcjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJoXCJdID0gcmdiQ29udmVydDtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJnXCJdID0gcmdiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBSZ2I7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaHNsQ29udmVydCAqL1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImZcIl0gPSBoc2w7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWZpbmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXG5mdW5jdGlvbiBDb2xvcigpIHt9XG52YXIgZGFya2VyID0gMC43O1xudmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcbnZhciByZUkgPSBcIlxcXFxzKihbKy1dP1xcXFxkKylcXFxccypcIixcbiAgICByZU4gPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KVxcXFxzKlwiLFxuICAgIHJlUCA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pJVxcXFxzKlwiLFxuICAgIHJlSGV4MyA9IC9eIyhbMC05YS1mXXszfSkkLyxcbiAgICByZUhleDYgPSAvXiMoWzAtOWEtZl17Nn0pJC8sXG4gICAgcmVSZ2JJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlSSwgcmVJLCByZUldICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JcXFxcKFwiICsgW3JlUCwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVJLCByZUksIHJlSSwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlUCwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbFBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbFxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZUhzbGFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xhXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIik7XG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcbk9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShDb2xvciwgY29sb3IsIHtcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcbiAgfVxufSk7XG5mdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG07XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbmV3IFJnYihtID4+IDggJiAweGYgfCBtID4+IDQgJiAweDBmMCwgbSA+PiA0ICYgMHhmIHwgbSAmIDB4ZjAsIChtICYgMHhmKSA8PCA0IHwgbSAmIDB4ZiwgMSkgLy8gI2YwMFxuICApIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXG4gIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IG5ldyBSZ2IobVsxXSwgbVsyXSwgbVszXSwgMSkgLy8gcmdiKDI1NSwgMCwgMClcbiAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgOiAobSA9IHJlUmdiYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSAqIDI1NSAvIDEwMCwgbVsyXSAqIDI1NSAvIDEwMCwgbVszXSAqIDI1NSAvIDEwMCwgbVs0XSkgLy8gcmdiKDEwMCUsIDAlLCAwJSwgMSlcbiAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICA6IG5hbWVkLmhhc093blByb3BlcnR5KGZvcm1hdCkgPyByZ2JuKG5hbWVkW2Zvcm1hdF0pIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiKCk7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5mdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cbk9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShSZ2IsIHJnYiwgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGVmaW5lX19bXCJiXCIgLyogZXh0ZW5kICovXSkoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24gKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMCA8PSB0aGlzLnIgJiYgdGhpcy5yIDw9IDI1NSAmJiAwIDw9IHRoaXMuZyAmJiB0aGlzLmcgPD0gMjU1ICYmIDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUgJiYgMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDE7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIikgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCIgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCIgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSkgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO2Vsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO2Vsc2UgaWYgKHMgPD0gMCkgaCA9IE5hTjtcbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgYSk7XG59XG5cbmZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsKCk7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7ZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO2Vsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cblxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5PYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWZpbmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoSHNsLCBoc2wsIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fW1wiYlwiIC8qIGV4dGVuZCAqL10pKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbiAoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbiAoaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLCBoc2wycmdiKGgsIG0xLCBtMiksIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSkgJiYgMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEgJiYgMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDE7XG4gIH1cbn0pKTtcbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cblxuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MCA6IGggPCAxODAgPyBtMiA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwIDogbTEpICogMjU1O1xufVxuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBleHRlbmQ7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn0pO1xuZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciBrZXkgaW4gZGVmaW5pdGlvbikgcHJvdG90eXBlW2tleV0gPSBkZWZpbml0aW9uW2tleV07XG5cbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gYmFzaXM7XG5mdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSxcbiAgICAgIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjEgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MiArIHQzICogdjMpIC8gNjtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSAoZnVuY3Rpb24gKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/IHQgPSAwIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihhcnIsIGZ1bmMpIHtcbiAgaWYgKCFpc0FycmF5TGlrZShhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZWFjaChhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAoZnVuYyh2YWx1ZSwgaW5kZXgpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbHVlc09mS2V5KGRhdGEsIG5hbWUpIHtcbiAgdmFyIHJzdCA9IFtdO1xuICB2YXIgdG1wTWFwID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgdmFyIHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgaWYgKCFpc05pbCh2YWx1ZSkpIHtcbiAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICBlYWNoKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICghdG1wTWFwW3ZhbF0pIHtcbiAgICAgICAgICByc3QucHVzaCh2YWwpO1xuICAgICAgICAgIHRtcE1hcFt2YWxdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdDtcbn07XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICAgIEdyb3VwID0gX3JlcXVpcmUuR3JvdXA7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSxcbiAgICBMYWJlbCA9IF9yZXF1aXJlMi5MYWJlbDsgLy8gY29uc3QgdmlzdWFsQ2VudGVyID0gcmVxdWlyZSgnQGFudHYvY29tcG9uZW50L2xpYi9sYWJlbC91dGlscy92aXN1YWwtY2VudGVyJyk7XG5cblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIElHTk9SRV9BUlIgPSBbJ2xpbmUnLCAncG9pbnQnLCAncGF0aCddO1xudmFyIE9SSUdJTiA9ICdfb3JpZ2luJztcblxuZnVuY3Rpb24gYXZnKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgVXRpbC5lYWNoKGFyciwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgc3VtICs9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHN1bSAvIGFyci5sZW5ndGg7XG59IC8vIOiuoeeul+Wkmui+ueW9oumHjeW/gzogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQjT2ZfYV9wb2x5Z29uXG5cblxuZnVuY3Rpb24gZ2V0Q2VudHJvaWQoeHMsIHlzKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwO1xuICB2YXIgZm9ybWVyLFxuICAgICAgY3VycmVudCA9IHhzLmxlbmd0aCAtIDE7XG4gIHZhciBkaWZmLFxuICAgICAgayA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IHhzLmxlbmd0aCkge1xuICAgIGZvcm1lciA9IGN1cnJlbnQ7XG4gICAgY3VycmVudCA9IGk7XG4gICAgayArPSBkaWZmID0geHNbZm9ybWVyXSAqIHlzW2N1cnJlbnRdIC0geHNbY3VycmVudF0gKiB5c1tmb3JtZXJdO1xuICAgIHggKz0gKHhzW2Zvcm1lcl0gKyB4c1tjdXJyZW50XSkgKiBkaWZmO1xuICAgIHkgKz0gKHlzW2Zvcm1lcl0gKyB5c1tjdXJyZW50XSkgKiBkaWZmO1xuICB9XG5cbiAgayAqPSAzO1xuICByZXR1cm4gW3ggLyBrLCB5IC8ga107XG59XG5cbnZhciBHZW9tTGFiZWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3JvdXApIHtcbiAgX2luaGVyaXRzTG9vc2UoR2VvbUxhYmVscywgX0dyb3VwKTtcblxuICBmdW5jdGlvbiBHZW9tTGFiZWxzKCkge1xuICAgIHJldHVybiBfR3JvdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEdlb21MYWJlbHMucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IEdsb2JhbC5sYWJlbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDnlKjmiLfkvKDlhaXnmoTmlofmnKzphY3nva7kv6Hmga9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGxhYmVsQ2ZnOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaJgOWcqOeahOWdkOagh+ezu1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgY29vcmQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+6KGo55qE57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBnZW9tVHlwZTogbnVsbCxcbiAgICAgIHpJbmRleDogNlxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJVSSA9IGZ1bmN0aW9uIF9yZW5kZXJVSSgpIHtcbiAgICBfR3JvdXAucHJvdG90eXBlLl9yZW5kZXJVSS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5pbml0TGFiZWxzQ2ZnKCk7XG4gICAgdmFyIGxhYmVsc0dyb3VwID0gdGhpcy5hZGRHcm91cCgpO1xuICAgIHZhciBsaW5lR3JvdXAgPSB0aGlzLmFkZEdyb3VwKHtcbiAgICAgIGVsQ2xzOiAneC1saW5lLWdyb3VwJ1xuICAgIH0pO1xuICAgIHZhciBsYWJlbFJlbmRlcmVyID0gdGhpcy5nZXQoJ2xhYmVsUmVuZGVyZXInKTtcbiAgICB0aGlzLnNldCgnbGFiZWxzR3JvdXAnLCBsYWJlbHNHcm91cCk7XG4gICAgdGhpcy5zZXQoJ2xpbmVHcm91cCcsIGxpbmVHcm91cCk7XG4gICAgdGhpcy5nZXQoJ2xhYmVsUmVuZGVyZXInKS5zZXQoJ2dyb3VwJywgbGFiZWxzR3JvdXApO1xuICAgIGxhYmVsUmVuZGVyZXIuc2V0KCdncm91cCcsIGxhYmVsc0dyb3VwKTtcbiAgICBsYWJlbFJlbmRlcmVyLnNldCgnbGluZUdyb3VwJywgbGluZUdyb3VwKTtcbiAgfTsgLy8g5Yid5aeL5YyWbGFiZWxz55qE6YWN572u6aG5XG5cblxuICBfcHJvdG8uaW5pdExhYmVsc0NmZyA9IGZ1bmN0aW9uIGluaXRMYWJlbHNDZmcoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYWJlbFJlbmRlcmVyID0gbmV3IExhYmVsKCk7XG4gICAgdmFyIGxhYmVscyA9IHNlbGYuZ2V0RGVmYXVsdExhYmVsQ2ZnKCk7XG4gICAgdmFyIGxhYmVsQ2ZnID0gc2VsZi5nZXQoJ2xhYmVsQ2ZnJyk7IC8vIFV0aWwubWVyZ2UobGFiZWxzLCBsYWJlbENmZy5jZmcpO1xuXG4gICAgVXRpbC5kZWVwTWl4KGxhYmVscywgbGFiZWxDZmcuZ2xvYmFsQ2ZnIHx8IGxhYmVsQ2ZnLmNmZyk7XG4gICAgbGFiZWxSZW5kZXJlci5zZXQoJ2NvbmZpZycsIGZhbHNlKTtcblxuICAgIGlmIChsYWJlbHMubGFiZWxMaW5lKSB7XG4gICAgICBsYWJlbFJlbmRlcmVyLnNldCgnbGFiZWxMaW5lJywgbGFiZWxzLmxhYmVsTGluZSk7XG4gICAgfVxuXG4gICAgbGFiZWxSZW5kZXJlci5zZXQoJ2Nvb3JkJywgc2VsZi5nZXQoJ2Nvb3JkJykpO1xuICAgIHRoaXMuc2V0KCdsYWJlbFJlbmRlcmVyJywgbGFiZWxSZW5kZXJlcik7XG4gICAgc2VsZi5zZXQoJ2xhYmVsJywgbGFiZWxzKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6buY6K6k55qE5paH5pys5qC35byPXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGVmYXVsdCBsYWJlbCBjb25maWdcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0RGVmYXVsdExhYmVsQ2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdExhYmVsQ2ZnKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGFiZWxDZmcgPSBzZWxmLmdldCgnbGFiZWxDZmcnKS5jZmcgfHwgc2VsZi5nZXQoJ2xhYmVsQ2ZnJykuZ2xvYmFsQ2ZnO1xuICAgIHZhciBnZW9tVHlwZSA9IHNlbGYuZ2V0KCdnZW9tVHlwZScpO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLmdldCgndmlld1RoZW1lJykgfHwgR2xvYmFsO1xuXG4gICAgaWYgKGdlb21UeXBlID09PSAncG9seWdvbicgfHwgbGFiZWxDZmcgJiYgbGFiZWxDZmcub2Zmc2V0IDwgMCAmJiBVdGlsLmluZGV4T2YoSUdOT1JFX0FSUiwgZ2VvbVR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIFV0aWwuZGVlcE1peCh7fSwgc2VsZi5nZXQoJ2xhYmVsJyksIHZpZXdUaGVtZS5pbm5lckxhYmVscywgbGFiZWxDZmcpO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlsLmRlZXBNaXgoe30sIHNlbGYuZ2V0KCdsYWJlbCcpLCB2aWV3VGhlbWUubGFiZWwsIGxhYmVsQ2ZnKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6I635Y+WbGFiZWxzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBwb2ludHNcbiAgICogQHBhcmFtIHtBcnJheX0gc2hhcGVzIHNoYXBlc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gbGFiZWwgaXRlbXNcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0TGFiZWxzSXRlbXMgPSBmdW5jdGlvbiBnZXRMYWJlbHNJdGVtcyhwb2ludHMsIHNoYXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgZ2VvbSA9IHNlbGYuZ2V0KCdnZW9tJyk7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG5cbiAgICBzZWxmLl9nZXRMYWJlbENmZ3MocG9pbnRzLCBzaGFwZXMpO1xuXG4gICAgdmFyIGxhYmVsQ2ZnID0gc2VsZi5nZXQoJ2xhYmVsSXRlbUNmZ3MnKTsgLy8g6I635Y+WbGFiZWznm7jlhbPnmoR477yMeeeahOWAvO+8jOiOt+WPluWFt+S9k+eahHgseSzpmLLmraLlrZjlnKjmlbDnu4RcblxuICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHBvaW50W09SSUdJTl07XG4gICAgICB2YXIgbGFiZWwgPSBsYWJlbENmZ1tpXTtcblxuICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICBpdGVtcy5wdXNoKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghVXRpbC5pc0FycmF5KGxhYmVsLnRleHQpKSB7XG4gICAgICAgIGxhYmVsLnRleHQgPSBbbGFiZWwudGV4dF07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbCA9IGxhYmVsLmxlbmd0aDtcbiAgICAgIFV0aWwuZWFjaChsYWJlbC50ZXh0LCBmdW5jdGlvbiAoc3ViLCBzdWJJbmRleCkge1xuICAgICAgICBpZiAoVXRpbC5pc05pbChzdWIpIHx8IHN1YiA9PT0gJycpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKG51bGwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYmogPSBzZWxmLmdldExhYmVsUG9pbnQobGFiZWwsIHBvaW50LCBzdWJJbmRleCk7XG4gICAgICAgIG9iaiA9IFV0aWwubWl4KHt9LCBsYWJlbCwgb2JqKTtcblxuICAgICAgICBpZiAoIW9iai50ZXh0QWxpZ24pIHtcbiAgICAgICAgICBvYmoudGV4dEFsaWduID0gc2VsZi5nZXRMYWJlbEFsaWduKG9iaiwgc3ViSW5kZXgsIHRvdGFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW9tKSB7XG4gICAgICAgICAgb2JqLl9pZCA9IGdlb20uX2dldFNoYXBlSWQob3JpZ2luKSArICctZ2xhYmVsLScgKyBzdWJJbmRleCArICctJyArIG9iai50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLmNvb3JkID0gY29vcmQ7XG4gICAgICAgIGl0ZW1zLnB1c2gob2JqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVtcztcbiAgfTtcbiAgLyogLyEqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog5aaC5p6c5Y+R55Sf5Yay56qB5YiZ5Lya6LCD5pW05paH5pys55qE5L2N572uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIOaWh+acrOeahOmbhuWQiFxuICAgKiBAcGFyYW0ge0FycmF5fSBzaGFwZXMg5YWz6IGU5b2i54q2XG4gICAqIEByZXR1cm4ge0FycmF5fSBhZGp1c3RlZCBpdGVtc1xuICAgKiEvXG4gIGFkanVzdEl0ZW1zKGl0ZW1zLCBzaGFwZXMpIHtcbiAgICAvLyDlpJrovrnlvaJzaGFwZeeahGxhYmVs5L2N5LqO5YW25Y+v6KeG5Lit5b+DXG4gICAgaWYgKHRoaXMuZ2V0KCdnZW9tVHlwZScpID09PSAncG9seWdvbicpIHtcbiAgICAgIGxldCBpbmRleCxcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgcG9pbnRzO1xuICAgICAgVXRpbC5lYWNoKGl0ZW1zLCAoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgc2hhcGUgPSBzaGFwZXNbIGkgXTtcbiAgICAgICAgcGF0aCA9IHNoYXBlLmF0dHIoJ3BhdGgnKTtcbiAgICAgICAgcG9pbnRzID0gW1tdXTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBwYXRoLmZvckVhY2goKHNlZ21lbnQsIGkpID0+IHtcbiAgICAgICAgICBpZiAoc2VnbWVudFsgMCBdID09PSAneicgfHwgc2VnbWVudFsgMCBdID09PSAnWicgJiYgaSAhPT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbXSk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHBvaW50c1sgaW5kZXggXS5wdXNoKFsgc2VnbWVudFsgMSBdLCBzZWdtZW50WyAyIF0gXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2VudGVyID0gdmlzdWFsQ2VudGVyKHBvaW50cyk7XG4gICAgICAgIGl0ZW0ueCA9IGNlbnRlci54O1xuICAgICAgICBpdGVtLnkgPSBjZW50ZXIueTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgKi9cblxuXG4gIF9wcm90by5hZGp1c3RJdGVtcyA9IGZ1bmN0aW9uIGFkanVzdEl0ZW1zKGl0ZW1zKSB7XG4gICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0ub2Zmc2V0WCkge1xuICAgICAgICBpdGVtLnggKz0gaXRlbS5vZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbS5vZmZzZXRZKSB7XG4gICAgICAgIGl0ZW0ueSArPSBpdGVtLm9mZnNldFk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuICAvKipcbiAgICogZHJhd2luZyBsaW5lcyB0byBsYWJlbHNcbiAgICogQHBhcmFtICB7QXJyYXl9IGl0ZW1zIGxhYmVsc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGxhYmVsTGluZSBjb25maWd1cmF0aW9uIGZvciBsYWJlbCBsaW5lc1xuICAgKi9cblxuXG4gIF9wcm90by5kcmF3TGluZXMgPSBmdW5jdGlvbiBkcmF3TGluZXMoaXRlbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gMCkge1xuICAgICAgICBzZWxmLmxpbmVUb0xhYmVsKHBvaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTsgLy8g5a6a5LmJ6L+e5o6l57q/XG5cblxuICBfcHJvdG8ubGluZVRvTGFiZWwgPSBmdW5jdGlvbiBsaW5lVG9MYWJlbCgpIHt9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDojrflj5bmlofmnKznmoTkvY3nva7kv6Hmga9cbiAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxDZmcgbGFiZWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggaW5kZXhcbiAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludFxuICAgKi9cblxuXG4gIF9wcm90by5nZXRMYWJlbFBvaW50ID0gZnVuY3Rpb24gZ2V0TGFiZWxQb2ludChsYWJlbENmZywgcG9pbnQsIGluZGV4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB0b3RhbCA9IGxhYmVsQ2ZnLnRleHQubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGltVmFsdWUodmFsdWUsIGlkeCkge1xuICAgICAgaWYgKFV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhYmVsQ2ZnLnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8g5aaC5p6c5LuF5LiA5LiqbGFiZWws5aSa5LiqeSzlj5bmnIDlkI7kuIDkuKp5XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdOyAvLyB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGF2Zyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbaWR4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0ge1xuICAgICAgdGV4dDogbGFiZWxDZmcudGV4dFtpbmRleF1cbiAgICB9OyAvLyDlpJrovrnlvaLlnLrmma8s5aSa55So5LqO5Zyw5Zu+XG5cbiAgICBpZiAocG9pbnQgJiYgdGhpcy5nZXQoJ2dlb21UeXBlJykgPT09ICdwb2x5Z29uJykge1xuICAgICAgdmFyIGNlbnRyb2lkID0gZ2V0Q2VudHJvaWQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBsYWJlbC54ID0gY2VudHJvaWRbMF07XG4gICAgICBsYWJlbC55ID0gY2VudHJvaWRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsLnggPSBnZXREaW1WYWx1ZShwb2ludC54LCBpbmRleCk7XG4gICAgICBsYWJlbC55ID0gZ2V0RGltVmFsdWUocG9pbnQueSwgaW5kZXgpO1xuICAgIH0gLy8gZ2V0IG5lYXJlc3QgcG9pbnQgb2YgdGhlIHNoYXBlIGFzIHRoZSBsYWJlbCBsaW5lIHN0YXJ0IHBvaW50XG5cblxuICAgIGlmIChwb2ludCAmJiBwb2ludC5uZXh0UG9pbnRzICYmIChwb2ludC5zaGFwZSA9PT0gJ2Z1bm5lbCcgfHwgcG9pbnQuc2hhcGUgPT09ICdweXJhbWlkJykpIHtcbiAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgcG9pbnQubmV4dFBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAgPSBjb29yZC5jb252ZXJ0KHApO1xuXG4gICAgICAgIGlmIChwLnggPiBtYXhYKSB7XG4gICAgICAgICAgbWF4WCA9IHAueDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYWJlbC54ID0gKGxhYmVsLnggKyBtYXhYKSAvIDI7XG4gICAgfSAvLyBzaGFycCBlZGdlIG9mIHRoZSBweXJhbWlkXG5cblxuICAgIGlmIChwb2ludC5zaGFwZSA9PT0gJ3B5cmFtaWQnICYmICFwb2ludC5uZXh0UG9pbnRzICYmIHBvaW50LnBvaW50cykge1xuICAgICAgcG9pbnQucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcCA9IGNvb3JkLmNvbnZlcnQocCk7XG5cbiAgICAgICAgaWYgKFV0aWwuaXNBcnJheShwLngpICYmIHBvaW50LnguaW5kZXhPZihwLngpID09PSAtMSB8fCBVdGlsLmlzTnVtYmVyKHAueCkgJiYgcG9pbnQueCAhPT0gcC54KSB7XG4gICAgICAgICAgbGFiZWwueCA9IChsYWJlbC54ICsgcC54KSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsYWJlbENmZy5wb3NpdGlvbikge1xuICAgICAgc2VsZi5zZXRMYWJlbFBvc2l0aW9uKGxhYmVsLCBwb2ludCwgaW5kZXgsIGxhYmVsQ2ZnLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0UG9pbnQgPSBzZWxmLmdldExhYmVsT2Zmc2V0KGxhYmVsQ2ZnLCBpbmRleCwgdG90YWwpO1xuXG4gICAgaWYgKGxhYmVsQ2ZnLm9mZnNldFgpIHtcbiAgICAgIG9mZnNldFBvaW50LnggKz0gbGFiZWxDZmcub2Zmc2V0WDtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxDZmcub2Zmc2V0WSkge1xuICAgICAgb2Zmc2V0UG9pbnQueSArPSBsYWJlbENmZy5vZmZzZXRZO1xuICAgIH1cblxuICAgIHNlbGYudHJhbnNMYWJlbFBvaW50KGxhYmVsKTtcbiAgICBsYWJlbC5zdGFydCA9IHtcbiAgICAgIHg6IGxhYmVsLngsXG4gICAgICB5OiBsYWJlbC55XG4gICAgfTtcbiAgICBsYWJlbC54ICs9IG9mZnNldFBvaW50Lng7XG4gICAgbGFiZWwueSArPSBvZmZzZXRQb2ludC55O1xuICAgIGxhYmVsLmNvbG9yID0gcG9pbnQuY29sb3I7XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9O1xuXG4gIF9wcm90by5zZXRMYWJlbFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0TGFiZWxQb3NpdGlvbigpIHt9O1xuXG4gIF9wcm90by50cmFuc0xhYmVsUG9pbnQgPSBmdW5jdGlvbiB0cmFuc0xhYmVsUG9pbnQocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHRtcFBvaW50ID0gY29vcmQuYXBwbHlNYXRyaXgocG9pbnQueCwgcG9pbnQueSwgMSk7XG4gICAgcG9pbnQueCA9IHRtcFBvaW50WzBdO1xuICAgIHBvaW50LnkgPSB0bXBQb2ludFsxXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0T2Zmc2V0VmVjdG9yID0gZnVuY3Rpb24gZ2V0T2Zmc2V0VmVjdG9yKHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgICB2YXIgY29vcmQgPSBzZWxmLmdldCgnY29vcmQnKTtcbiAgICB2YXIgdmVjdG9yO1xuXG4gICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgLy8g5aaC5p6ceCx557+76L2s77yM5YiZ5YGP56e7eFxuICAgICAgdmVjdG9yID0gY29vcmQuYXBwbHlNYXRyaXgob2Zmc2V0LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g5ZCm5YiZ77yM5YGP6L2seVxuICAgICAgdmVjdG9yID0gY29vcmQuYXBwbHlNYXRyaXgoMCwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuICB9OyAvLyDojrflj5bpu5jorqTnmoTlgY/np7vph49cblxuXG4gIF9wcm90by5nZXREZWZhdWx0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RGVmYXVsdE9mZnNldChwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgY29vcmQgPSBzZWxmLmdldCgnY29vcmQnKTtcbiAgICB2YXIgdmVjdG9yID0gc2VsZi5nZXRPZmZzZXRWZWN0b3IocG9pbnQpO1xuXG4gICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgLy8g5aaC5p6ceCx557+76L2s77yM5YiZ5YGP56e7eFxuICAgICAgb2Zmc2V0ID0gdmVjdG9yWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDlkKbliJnvvIzlgY/ovax5XG4gICAgICBvZmZzZXQgPSB2ZWN0b3JbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTsgLy8g6I635Y+W5paH5pys55qE5YGP56e75L2N572u77yMeCx5XG5cblxuICBfcHJvdG8uZ2V0TGFiZWxPZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbE9mZnNldChwb2ludCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvZmZzZXQgPSBzZWxmLmdldERlZmF1bHRPZmZzZXQocG9pbnQpO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB0cmFuc3Bvc2VkID0gY29vcmQuaXNUcmFuc3Bvc2VkO1xuICAgIHZhciB5RmllbGQgPSB0cmFuc3Bvc2VkID8gJ3gnIDogJ3knO1xuICAgIHZhciBmYWN0b3IgPSB0cmFuc3Bvc2VkID8gMSA6IC0xOyAvLyB5IOaWueWQkeS4iui2iuWkp++8jOWDj+e0oOeahOWdkOagh+i2iuWwj++8jOaJgOS7pXRyYW5zcG9zZWTml7blsIbns7vmlbDlj5jmiJBcblxuICAgIHZhciBvZmZzZXRQb2ludCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIGlmIChpbmRleCA+IDAgfHwgdG90YWwgPT09IDEpIHtcbiAgICAgIC8vIOWIpOaWreaYr+WQpuWwj+S6jjBcbiAgICAgIG9mZnNldFBvaW50W3lGaWVsZF0gPSBvZmZzZXQgKiBmYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFBvaW50W3lGaWVsZF0gPSBvZmZzZXQgKiBmYWN0b3IgKiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldExhYmVsQWxpZ24gPSBmdW5jdGlvbiBnZXRMYWJlbEFsaWduKHBvaW50LCBpbmRleCwgdG90YWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFsaWduID0gJ2NlbnRlcic7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG5cbiAgICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2VsZi5nZXREZWZhdWx0T2Zmc2V0KHBvaW50KTsgLy8gdmFyIHZlY3RvciA9IGNvb3JkLmFwcGx5TWF0cml4KG9mZnNldCwwKTtcblxuICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodG90YWwgPiAxICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRMYWJlbFZhbHVlID0gZnVuY3Rpb24gX2dldExhYmVsVmFsdWUob3JpZ2luLCBzY2FsZXMpIHtcbiAgICBpZiAoIVV0aWwuaXNBcnJheShzY2FsZXMpKSB7XG4gICAgICBzY2FsZXMgPSBbc2NhbGVzXTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IFtdO1xuICAgIFV0aWwuZWFjaChzY2FsZXMsIGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgdmFyIHZhbHVlID0gb3JpZ2luW3NjYWxlLmZpZWxkXTtcblxuICAgICAgaWYgKFV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICBVdGlsLmVhY2godmFsdWUsIGZ1bmN0aW9uIChzdWJWYWwpIHtcbiAgICAgICAgICB0bXAucHVzaChzY2FsZS5nZXRUZXh0KHN1YlZhbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHNjYWxlLmdldFRleHQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbC5pc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHRleHQucHVzaChudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGV4dC5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTsgLy8g6I635Y+W5q+P5LiqbGFiZWznmoTphY3nva5cblxuXG4gIF9wcm90by5fZ2V0TGFiZWxDZmdzID0gZnVuY3Rpb24gX2dldExhYmVsQ2Zncyhwb2ludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhYmVsQ2ZnID0gdGhpcy5nZXQoJ2xhYmVsQ2ZnJyk7XG4gICAgdmFyIHNjYWxlcyA9IGxhYmVsQ2ZnLnNjYWxlcztcbiAgICB2YXIgZGVmYXVsdENmZyA9IHRoaXMuZ2V0KCdsYWJlbCcpO1xuICAgIHZhciBjZmdzID0gW107XG5cbiAgICBpZiAobGFiZWxDZmcuZ2xvYmFsQ2ZnICYmIGxhYmVsQ2ZnLmdsb2JhbENmZy50eXBlKSB7XG4gICAgICBzZWxmLnNldCgndHlwZScsIGxhYmVsQ2ZnLmdsb2JhbENmZy50eXBlKTtcbiAgICB9XG5cbiAgICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICAgIHZhciBjZmcgPSB7fTtcbiAgICAgIHZhciBvcmlnaW4gPSBwb2ludFtPUklHSU5dO1xuXG4gICAgICB2YXIgb3JpZ2luVGV4dCA9IHNlbGYuX2dldExhYmVsVmFsdWUob3JpZ2luLCBzY2FsZXMpO1xuXG4gICAgICBpZiAobGFiZWxDZmcuY2FsbGJhY2spIHtcbiAgICAgICAgLy8gY2FsbGJhY2vkuK3lupTkvb/nlKjljp/lp4vmlbDmja7vvIzogIzkuI3mmK/mlbDmja7lrZfnrKbkuLJcbiAgICAgICAgdmFyIG9yaWdpblZhbHVlcyA9IHNjYWxlcy5tYXAoZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbltzY2FsZS5maWVsZF07XG4gICAgICAgIH0pO1xuICAgICAgICBjZmcgPSBsYWJlbENmZy5jYWxsYmFjay5hcHBseShudWxsLCBvcmlnaW5WYWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNmZyAmJiBjZmcgIT09IDApIHtcbiAgICAgICAgY2Zncy5wdXNoKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsLmlzU3RyaW5nKGNmZykgfHwgVXRpbC5pc051bWJlcihjZmcpKSB7XG4gICAgICAgIGNmZyA9IHtcbiAgICAgICAgICB0ZXh0OiBjZmdcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmZy50ZXh0ID0gY2ZnLmNvbnRlbnQgfHwgb3JpZ2luVGV4dFswXTtcbiAgICAgICAgZGVsZXRlIGNmZy5jb250ZW50O1xuICAgICAgfVxuXG4gICAgICBjZmcgPSBVdGlsLm1peCh7fSwgZGVmYXVsdENmZywgbGFiZWxDZmcuZ2xvYmFsQ2ZnIHx8IHt9LCBjZmcpOyAvLyDlhbzlrrnml6fnmoTmupDmlbDmja7lhpnlnKhpdGVtLnBvaW505LitXG5cbiAgICAgIHBvaW50LnBvaW50ID0gb3JpZ2luO1xuXG4gICAgICBpZiAoY2ZnLmh0bWxUZW1wbGF0ZSkge1xuICAgICAgICBjZmcudXNlSHRtbCA9IHRydWU7XG4gICAgICAgIGNmZy50ZXh0ID0gY2ZnLmh0bWxUZW1wbGF0ZS5jYWxsKG51bGwsIGNmZy50ZXh0LCBwb2ludCwgaSk7XG4gICAgICAgIGRlbGV0ZSBjZmcuaHRtbFRlbXBsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLmZvcm1hdHRlcikge1xuICAgICAgICBjZmcudGV4dCA9IGNmZy5mb3JtYXR0ZXIuY2FsbChudWxsLCBjZmcudGV4dCwgcG9pbnQsIGkpO1xuICAgICAgICBkZWxldGUgY2ZnLmZvcm1hdHRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5sYWJlbCkge1xuICAgICAgICAvLyDlhbzlrrnmnInkupvnm7TmjqXlhpnlnKhsYWJlbENmZy5sYWJlbOeahOmFjee9rlxuICAgICAgICB2YXIgbGFiZWwgPSBjZmcubGFiZWw7XG4gICAgICAgIGRlbGV0ZSBjZmcubGFiZWw7XG4gICAgICAgIGNmZyA9IFV0aWwubWl4KGNmZywgbGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLnRleHRTdHlsZSkge1xuICAgICAgICAvLyDlhbzlrrnml6flhpnms5XvvIxnbG9iYWxDZmfnmoRvZmZzZXTkvJjlhYjnuqfpq5hcbiAgICAgICAgZGVsZXRlIGNmZy50ZXh0U3R5bGUub2Zmc2V0O1xuICAgICAgICB2YXIgdGV4dFN0eWxlID0gY2ZnLnRleHRTdHlsZTtcblxuICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHRleHRTdHlsZSkpIHtcbiAgICAgICAgICBjZmcudGV4dFN0eWxlID0gdGV4dFN0eWxlLmNhbGwobnVsbCwgY2ZnLnRleHQsIHBvaW50LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLmxhYmVsTGluZSkge1xuICAgICAgICBjZmcubGFiZWxMaW5lID0gVXRpbC5taXgoe30sIGRlZmF1bHRDZmcubGFiZWxMaW5lLCBjZmcubGFiZWxMaW5lKTtcbiAgICAgIH1cblxuICAgICAgY2ZnLnRleHRTdHlsZSA9IFV0aWwubWl4KHt9LCBkZWZhdWx0Q2ZnLnRleHRTdHlsZSwgY2ZnLnRleHRTdHlsZSk7XG4gICAgICBkZWxldGUgY2ZnLml0ZW1zO1xuICAgICAgY2Zncy5wdXNoKGNmZyk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXQoJ2xhYmVsSXRlbUNmZ3MnLCBjZmdzKTtcbiAgfTtcblxuICBfcHJvdG8uc2hvd0xhYmVscyA9IGZ1bmN0aW9uIHNob3dMYWJlbHMocG9pbnRzLCBzaGFwZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhYmVsUmVuZGVyZXIgPSBzZWxmLmdldCgnbGFiZWxSZW5kZXJlcicpO1xuICAgIHZhciBpdGVtcyA9IHNlbGYuZ2V0TGFiZWxzSXRlbXMocG9pbnRzLCBzaGFwZXMpO1xuICAgIHNoYXBlcyA9IFtdLmNvbmNhdChzaGFwZXMpO1xuICAgIHZhciB0eXBlID0gc2VsZi5nZXQoJ3R5cGUnKTtcbiAgICBpdGVtcyA9IHNlbGYuYWRqdXN0SXRlbXMoaXRlbXMsIHNoYXBlcyk7XG4gICAgc2VsZi5kcmF3TGluZXMoaXRlbXMpO1xuICAgIGxhYmVsUmVuZGVyZXIuc2V0KCdpdGVtcycsIGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHNoYXBlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGxhYmVsUmVuZGVyZXIuc2V0KCdzaGFwZXMnLCBzaGFwZXMpO1xuICAgICAgbGFiZWxSZW5kZXJlci5zZXQoJ3R5cGUnLCB0eXBlKTtcbiAgICAgIGxhYmVsUmVuZGVyZXIuc2V0KCdwb2ludHMnLCBwb2ludHMpO1xuICAgIH1cblxuICAgIGxhYmVsUmVuZGVyZXIuc2V0KCdjYW52YXMnLCB0aGlzLmdldCgnY2FudmFzJykpO1xuICAgIGxhYmVsUmVuZGVyZXIuZHJhdygpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmdldCgnbGFiZWxSZW5kZXJlcicpLmRlc3Ryb3koKTsgLy8g5riF55CG5paH5pysXG5cbiAgICBfR3JvdXAucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gR2VvbUxhYmVscztcbn0oR3JvdXApOyAvLyBVdGlsLmFzc2lnbihHZW9tTGFiZWxzLnByb3RvdHlwZSwgTGFiZWxzLkxhYmVsc2xhYmVsUmVuZGVyZXIpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gR2VvbUxhYmVscztcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ2hhcnTjgIFWaWV344CBR2VvbWV0cnkg55qE5Z+657G7XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xuXG5cbnZhciBFdmVudEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHNMb29zZShCYXNlLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3Byb3RvID0gQmFzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICBmdW5jdGlvbiBCYXNlKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGRlZmF1bHRDZmcgPSBzZWxmLmdldERlZmF1bHRDZmcoKTtcbiAgICBzZWxmLl9hdHRycyA9IGF0dHJzO1xuICAgIFV0aWwuZGVlcE1peChhdHRycywgZGVmYXVsdENmZywgY2ZnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2F0dHJzW25hbWVdID0gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSDmmK/lkKblj6/op4FcbiAgICog5pi+56S644CB6ZqQ6JePXG4gICAqL1xuXG5cbiAgX3Byb3RvLmNoYW5nZVZpc2libGUgPSBmdW5jdGlvbiBjaGFuZ2VWaXNpYmxlKClcbiAgLyogdmlzaWJsZSAqL1xuICB7fTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX2F0dHJzID0ge307XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBzZWxmLmRlc3Ryb3llZCA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGJhc2UgY2xhc3Mgb2YgY29udGludW91cyBsZWdlbmRcbiAqIEBhdXRob3Igc2ltYS56aGFuZ1xuICovXG5cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgTGVnZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTgpO1xuXG52YXIgU2xpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjcpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZO1xuXG52YXIgVFJJR0dFUl9XSURUSCA9IDg7XG52YXIgRXZlbnQgPSBVdGlsLkV2ZW50O1xudmFyIEdyb3VwID0gVXRpbC5Hcm91cDtcblxudmFyIENvbnRpbnVvdXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9MZWdlbmQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29udGludW91cywgX0xlZ2VuZCk7XG5cbiAgZnVuY3Rpb24gQ29udGludW91cygpIHtcbiAgICByZXR1cm4gX0xlZ2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29udGludW91cy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfTGVnZW5kLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgKiDnsbvlnotcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdjb250aW51b3VzLWxlZ2VuZCcsXG5cbiAgICAgIC8qKlxuICAgICAgICog5a2Q6aG5XG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIGl0ZW1zOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOW4g+WxgOaWueW8j1xuICAgICAgICogaG9yaXpvbnRhbCDmsLTlubNcbiAgICAgICAqIHZlcnRpY2FsIOWeguebtFxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWuveW6plxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2lkdGg6IDIwLFxuXG4gICAgICAvKipcbiAgICAgICAqIOmrmOW6plxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgaGVpZ2h0OiAxNTYsXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6k5paH5pys5Zu+5b2i5bGe5oCnXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIHRleHRTdHlsZToge1xuICAgICAgICBmaWxsOiAnIzMzMycsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIHN0cm9rZTogJyNmZmYnLFxuICAgICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICB9LFxuICAgICAgaG92ZXJUZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMC4yNSknXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOi/nue7reWbvuS+i+aYr+WQpuWPr+a7keWKqFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHNsaWRhYmxlOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4pOWktOa7keWdl+eahOagt+W8j1xuICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAqL1xuICAgICAgdHJpZ2dlckF0dHI6IHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICAvLyBzaGFkb3dPZmZzZXRYOiAtMixcbiAgICAgICAgLy8gc2hhZG93T2Zmc2V0WTogMixcbiAgICAgICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLDAsMCwwLjY1KScsXG4gICAgICAgIHJhZGl1czogMlxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzbGlkZXIg55qE6IyD5Zu0XG4gICAgICAgKiBAdHlwZSB7YXJyYXl9fVxuICAgICAgICovXG4gICAgICBfcmFuZ2U6IFswLCAxMDBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4remXtCBiYXIg6IOM5pmv54Gw6ImyXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIG1pZGRsZUJhY2tncm91bmRTdHlsZToge1xuICAgICAgICBmaWxsOiAnI0Q5RDlEOSdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog5paH5pys5LiO5Zu+5L6L6Ze06LedXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB0ZXh0T2Zmc2V0OiA0LFxuXG4gICAgICAvKipcbiAgICAgICAqIGxpbmUgc2VnbWVudCB0byBzZXBlcmF0ZSB0aGUgdW5zbGlkYWJsZSBzbGlkZXIgYmxvY2tzXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICovXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6ICcjZmZmJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgcG9pbnRlciB3aGlsZSBhY3RpdmF0ZSB0aGUgbGVnZW5kIGJ5IG1vdXNlIGhvdmVyaW5nIG9yIGNhbGxlZCBieSBvdXRzaWRlXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICovXG4gICAgICBwb2ludGVyU3R5bGU6IHtcbiAgICAgICAgLy8gY29sb3I6ICcjY2NjJyxcbiAgICAgICAgZmlsbDogJ3JnYigyMzAsIDIzMCwgMjMwKSdcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2NhbFN0YXJ0UG9pbnQgPSBmdW5jdGlvbiBfY2FsU3RhcnRQb2ludCgpIHtcbiAgICB2YXIgc3RhcnQgPSB7XG4gICAgICB4OiAxMCxcbiAgICAgIHk6IHRoaXMuZ2V0KCd0aXRsZUdhcCcpIC0gVFJJR0dFUl9XSURUSFxuICAgIH07XG4gICAgdmFyIHRpdGxlU2hhcGUgPSB0aGlzLmdldCgndGl0bGVTaGFwZScpO1xuXG4gICAgaWYgKHRpdGxlU2hhcGUpIHtcbiAgICAgIHZhciB0aXRsZUJveCA9IHRpdGxlU2hhcGUuZ2V0QkJveCgpO1xuICAgICAgc3RhcnQueSArPSB0aXRsZUJveC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9O1xuXG4gIF9wcm90by5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiBiZWZvcmVSZW5kZXIoKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNBcnJheShpdGVtcykgfHwgVXRpbC5pc0VtcHR5KGl0ZW1zKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9MZWdlbmQucHJvdG90eXBlLmJlZm9yZVJlbmRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zZXQoJ2ZpcnN0SXRlbScsIGl0ZW1zWzBdKTtcbiAgICB0aGlzLnNldCgnbGFzdEl0ZW0nLCBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSk7XG4gIH07XG5cbiAgX3Byb3RvLl9mb3JtYXRJdGVtVmFsdWUgPSBmdW5jdGlvbiBfZm9ybWF0SXRlbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZ2V0KCdmb3JtYXR0ZXInKSB8fCB0aGlzLmdldCgnaXRlbUZvcm1hdHRlcicpO1xuXG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgdmFsdWUgPSBmb3JtYXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgX0xlZ2VuZC5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ3NsaWRhYmxlJykpIHtcbiAgICAgIHRoaXMuX3JlbmRlclNsaWRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJVbnNsaWRhYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyU2xpZGVyID0gZnVuY3Rpb24gX3JlbmRlclNsaWRlcigpIHtcbiAgICB2YXIgbWluSGFuZGxlRWxlbWVudCA9IG5ldyBHcm91cCgpO1xuICAgIHZhciBtYXhIYW5kbGVFbGVtZW50ID0gbmV3IEdyb3VwKCk7XG4gICAgdmFyIGJhY2tncm91bmRFbGVtZW50ID0gbmV3IEdyb3VwKCk7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9jYWxTdGFydFBvaW50KCk7XG5cbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgc2xpZGVyID0gZ3JvdXAuYWRkR3JvdXAoU2xpZGVyLCB7XG4gICAgICBtaW5IYW5kbGVFbGVtZW50OiBtaW5IYW5kbGVFbGVtZW50LFxuICAgICAgbWF4SGFuZGxlRWxlbWVudDogbWF4SGFuZGxlRWxlbWVudCxcbiAgICAgIGJhY2tncm91bmRFbGVtZW50OiBiYWNrZ3JvdW5kRWxlbWVudCxcbiAgICAgIGxheW91dDogdGhpcy5nZXQoJ2xheW91dCcpLFxuICAgICAgcmFuZ2U6IHRoaXMuZ2V0KCdfcmFuZ2UnKSxcbiAgICAgIHdpZHRoOiB0aGlzLmdldCgnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogdGhpcy5nZXQoJ2hlaWdodCcpXG4gICAgfSk7XG4gICAgc2xpZGVyLnRyYW5zbGF0ZShzdGFydC54LCBzdGFydC55KTtcbiAgICB0aGlzLnNldCgnc2xpZGVyJywgc2xpZGVyKTtcblxuICAgIHZhciBzaGFwZSA9IHRoaXMuX3JlbmRlclNsaWRlclNoYXBlKCk7XG5cbiAgICBzaGFwZS5hdHRyKCdjbGlwJywgc2xpZGVyLmdldCgnbWlkZGxlSGFuZGxlRWxlbWVudCcpKTtcblxuICAgIHRoaXMuX3JlbmRlclRyaWdnZXIoKTtcbiAgfTsgLy8gdGhlIG1pZGRsZSBiYXJcblxuXG4gIF9wcm90by5fYWRkTWlkZGxlQmFyID0gZnVuY3Rpb24gX2FkZE1pZGRsZUJhcihwYXJlbnQsIG5hbWUsIGF0dHJzKSB7XG4gICAgLy8gYmFja2dyb3VuZCBvZiB0aGUgbWlkZGxlIGJhclxuICAgIHBhcmVudC5hZGRTaGFwZShuYW1lLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe30sIGF0dHJzLCB0aGlzLmdldCgnbWlkZGxlQmFja2dyb3VuZFN0eWxlJykpXG4gICAgfSk7IC8vIGZyb250Z3JvdW5kIG9mIHRoZSBtaWRkbGUgYmFyXG5cbiAgICByZXR1cm4gcGFyZW50LmFkZFNoYXBlKG5hbWUsIHtcbiAgICAgIGF0dHJzOiBhdHRyc1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyVHJpZ2dlciA9IGZ1bmN0aW9uIF9yZW5kZXJUcmlnZ2VyKCkge1xuICAgIHZhciBtaW4gPSB0aGlzLmdldCgnZmlyc3RJdGVtJyk7XG4gICAgdmFyIG1heCA9IHRoaXMuZ2V0KCdsYXN0SXRlbScpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIHRleHRTdHlsZSA9IHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgdHJpZ2dlckF0dHIgPSB0aGlzLmdldCgndHJpZ2dlckF0dHInKTtcbiAgICB2YXIgbWluQmxvY2tBdHRyID0gVXRpbC5taXgoe30sIHRyaWdnZXJBdHRyKTtcbiAgICB2YXIgbWF4QmxvY2tBdHRyID0gVXRpbC5taXgoe30sIHRyaWdnZXJBdHRyKTtcbiAgICB2YXIgbWluVGV4dEF0dHIgPSBVdGlsLm1peCh7XG4gICAgICB0ZXh0OiB0aGlzLl9mb3JtYXRJdGVtVmFsdWUobWluLnZhbHVlKSArICcnXG4gICAgfSwgdGV4dFN0eWxlKTtcbiAgICB2YXIgbWF4VGV4dEF0dHIgPSBVdGlsLm1peCh7XG4gICAgICB0ZXh0OiB0aGlzLl9mb3JtYXRJdGVtVmFsdWUobWF4LnZhbHVlKSArICcnXG4gICAgfSwgdGV4dFN0eWxlKTtcblxuICAgIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHRoaXMuX2FkZFZlcnRpY2FsVHJpZ2dlcignbWluJywgbWluQmxvY2tBdHRyLCBtaW5UZXh0QXR0cik7XG5cbiAgICAgIHRoaXMuX2FkZFZlcnRpY2FsVHJpZ2dlcignbWF4JywgbWF4QmxvY2tBdHRyLCBtYXhUZXh0QXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEhvcml6b250YWxUcmlnZ2VyKCdtaW4nLCBtaW5CbG9ja0F0dHIsIG1pblRleHRBdHRyKTtcblxuICAgICAgdGhpcy5fYWRkSG9yaXpvbnRhbFRyaWdnZXIoJ21heCcsIG1heEJsb2NrQXR0ciwgbWF4VGV4dEF0dHIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2FkZFZlcnRpY2FsVHJpZ2dlciA9IGZ1bmN0aW9uIF9hZGRWZXJ0aWNhbFRyaWdnZXIodHlwZSwgYmxvY2tBdHRyLCB0ZXh0QXR0cikge1xuICAgIHZhciBzbGlkZXIgPSB0aGlzLmdldCgnc2xpZGVyJyk7XG4gICAgdmFyIHRyaWdnZXIgPSBzbGlkZXIuZ2V0KHR5cGUgKyAnSGFuZGxlRWxlbWVudCcpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBidXR0b24gPSB0cmlnZ2VyLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogd2lkdGggLyAyIC0gVFJJR0dFUl9XSURUSCAtIDIsXG4gICAgICAgIHk6IHR5cGUgPT09ICdtaW4nID8gMCA6IC1UUklHR0VSX1dJRFRILFxuICAgICAgICB3aWR0aDogMiAqIFRSSUdHRVJfV0lEVEggKyAyLFxuICAgICAgICBoZWlnaHQ6IFRSSUdHRVJfV0lEVEhcbiAgICAgIH0sIGJsb2NrQXR0cilcbiAgICB9KTtcbiAgICB2YXIgdGV4dCA9IHRyaWdnZXIuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgodGV4dEF0dHIsIHtcbiAgICAgICAgeDogd2lkdGggKyB0aGlzLmdldCgndGV4dE9mZnNldCcpLFxuICAgICAgICB5OiB0eXBlID09PSAnbWF4JyA/IC00IDogNCxcbiAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIHRyaWdlckN1cnNvciA9IGxheW91dCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZSc7XG4gICAgYnV0dG9uLmF0dHIoJ2N1cnNvcicsIHRyaWdlckN1cnNvcik7XG4gICAgdGV4dC5hdHRyKCdjdXJzb3InLCB0cmlnZXJDdXJzb3IpO1xuICAgIHRoaXMuc2V0KHR5cGUgKyAnQnV0dG9uRWxlbWVudCcsIGJ1dHRvbik7XG4gICAgdGhpcy5zZXQodHlwZSArICdUZXh0RWxlbWVudCcsIHRleHQpO1xuICB9O1xuXG4gIF9wcm90by5fYWRkSG9yaXpvbnRhbFRyaWdnZXIgPSBmdW5jdGlvbiBfYWRkSG9yaXpvbnRhbFRyaWdnZXIodHlwZSwgYmxvY2tBdHRyLCB0ZXh0QXR0cikge1xuICAgIHZhciBzbGlkZXIgPSB0aGlzLmdldCgnc2xpZGVyJyk7XG4gICAgdmFyIHRyaWdnZXIgPSBzbGlkZXIuZ2V0KHR5cGUgKyAnSGFuZGxlRWxlbWVudCcpO1xuICAgIHZhciBidXR0b24gPSB0cmlnZ2VyLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogdHlwZSA9PT0gJ21pbicgPyAtVFJJR0dFUl9XSURUSCA6IDAsXG4gICAgICAgIHk6IC1UUklHR0VSX1dJRFRIIC0gdGhpcy5nZXQoJ2hlaWdodCcpIC8gMixcbiAgICAgICAgd2lkdGg6IFRSSUdHRVJfV0lEVEgsXG4gICAgICAgIGhlaWdodDogMiAqIFRSSUdHRVJfV0lEVEhcbiAgICAgIH0sIGJsb2NrQXR0cilcbiAgICB9KTtcbiAgICB2YXIgdGV4dCA9IHRyaWdnZXIuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgodGV4dEF0dHIsIHtcbiAgICAgICAgeDogdHlwZSA9PT0gJ21pbicgPyAtVFJJR0dFUl9XSURUSCAtIDQgOiBUUklHR0VSX1dJRFRIICsgNCxcbiAgICAgICAgeTogVFJJR0dFUl9XSURUSCAvIDIgKyB0aGlzLmdldCgndGV4dE9mZnNldCcpICsgMTAsXG4gICAgICAgIHRleHRBbGlnbjogdHlwZSA9PT0gJ21pbicgPyAnZW5kJyA6ICdzdGFydCcsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgdHJpZ2VyQ3Vyc29yID0gbGF5b3V0ID09PSAndmVydGljYWwnID8gJ25zLXJlc2l6ZScgOiAnZXctcmVzaXplJztcbiAgICBidXR0b24uYXR0cignY3Vyc29yJywgdHJpZ2VyQ3Vyc29yKTtcbiAgICB0ZXh0LmF0dHIoJ2N1cnNvcicsIHRyaWdlckN1cnNvcik7XG4gICAgdGhpcy5zZXQodHlwZSArICdCdXR0b25FbGVtZW50JywgYnV0dG9uKTtcbiAgICB0aGlzLnNldCh0eXBlICsgJ1RleHRFbGVtZW50JywgdGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5kRXZlbnRzID0gZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmdldCgnc2xpZGFibGUnKSkge1xuICAgICAgdmFyIHNsaWRlciA9IHRoaXMuZ2V0KCdzbGlkZXInKTtcbiAgICAgIHNsaWRlci5vbignc2xpZGVyY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciByYW5nZSA9IGV2LnJhbmdlO1xuXG4gICAgICAgIHZhciBmaXJzdEl0ZW1WYWx1ZSA9IF90aGlzLmdldCgnZmlyc3RJdGVtJykudmFsdWU7XG5cbiAgICAgICAgdmFyIGxhc3RJdGVtVmFsdWUgPSBfdGhpcy5nZXQoJ2xhc3RJdGVtJykudmFsdWU7XG5cbiAgICAgICAgdmFyIG1pblZhbHVlID0gZmlyc3RJdGVtVmFsdWUgKyByYW5nZVswXSAvIDEwMCAqIChsYXN0SXRlbVZhbHVlIC0gZmlyc3RJdGVtVmFsdWUpO1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSBmaXJzdEl0ZW1WYWx1ZSArIHJhbmdlWzFdIC8gMTAwICogKGxhc3RJdGVtVmFsdWUgLSBmaXJzdEl0ZW1WYWx1ZSk7XG5cbiAgICAgICAgX3RoaXMuX3VwZGF0ZUVsZW1lbnQobWluVmFsdWUsIG1heFZhbHVlKTtcblxuICAgICAgICB2YXIgaXRlbUZpbHRlcmVkID0gbmV3IEV2ZW50KCdpdGVtZmlsdGVyJywgZXYsIHRydWUsIHRydWUpO1xuICAgICAgICBpdGVtRmlsdGVyZWQucmFuZ2UgPSBbbWluVmFsdWUsIG1heFZhbHVlXTtcblxuICAgICAgICBfdGhpcy5lbWl0KCdpdGVtZmlsdGVyJywgaXRlbUZpbHRlcmVkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldCgnaG92ZXJhYmxlJykpIHtcbiAgICAgIHRoaXMuZ2V0KCdncm91cCcpLm9uKCdtb3VzZW1vdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uTW91c2VNb3ZlJykpO1xuICAgICAgdGhpcy5nZXQoJ2dyb3VwJykub24oJ21vdXNlbGVhdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uTW91c2VMZWF2ZScpKTtcbiAgICB9XG4gIH07IC8vIHVwZGF0ZSB0aGUgdGV4dCBvZiBtaW4gYW5kIG1heCB0cmlnZ2VyXG5cblxuICBfcHJvdG8uX3VwZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfdXBkYXRlRWxlbWVudChtaW4sIG1heCkge1xuICAgIHZhciBtaW5UZXh0RWxlbWVudCA9IHRoaXMuZ2V0KCdtaW5UZXh0RWxlbWVudCcpO1xuICAgIHZhciBtYXhUZXh0RWxlbWVudCA9IHRoaXMuZ2V0KCdtYXhUZXh0RWxlbWVudCcpO1xuXG4gICAgaWYgKG1heCA+IDEpIHtcbiAgICAgIC8vIOWvueS6juWkp+S6jiAxIOeahOWAvO+8jOm7mOiupOaYvuekuuS4uuaVtOaVsFxuICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICBtYXggPSBwYXJzZUludChtYXgsIDEwKTtcbiAgICB9XG5cbiAgICBtaW5UZXh0RWxlbWVudC5hdHRyKCd0ZXh0JywgdGhpcy5fZm9ybWF0SXRlbVZhbHVlKG1pbikgKyAnJyk7XG4gICAgbWF4VGV4dEVsZW1lbnQuYXR0cigndGV4dCcsIHRoaXMuX2Zvcm1hdEl0ZW1WYWx1ZShtYXgpICsgJycpO1xuICB9O1xuXG4gIF9wcm90by5fb25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gX29uTW91c2VMZWF2ZSgpIHtcbiAgICB2YXIgaG92ZXJQb2ludGVyID0gdGhpcy5nZXQoJ2dyb3VwJykuZmluZEJ5SWQoJ2hvdmVyUG9pbnRlcicpO1xuICAgIGhvdmVyUG9pbnRlciAmJiBob3ZlclBvaW50ZXIuZGVzdHJveSgpO1xuICAgIHZhciBob3ZlclRleHQgPSB0aGlzLmdldCgnZ3JvdXAnKS5maW5kQnlJZCgnaG92ZXJUZXh0Jyk7XG4gICAgaG92ZXJUZXh0ICYmIGhvdmVyVGV4dC5kZXN0cm95KCk7XG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgfTsgLy8gYWN0aXZhdGUgdGhlIGxlZ2VuZCB3aGlsZSBtb3VzZSBtb3ZpbmdcblxuXG4gIF9wcm90by5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiBfb25Nb3VzZU1vdmUoZXYpIHtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KCdpdGVtcycpO1xuICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJyk7XG4gICAgdmFyIGVsX2Jib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgYmJveCA9IHRoaXMuZ2V0KCdncm91cCcpLmdldEJCb3goKTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2xheW91dCcpID09PSAndmVydGljYWwnKSB7XG4gICAgICB2YXIgdmFsdWVQYWRkaW5nID0gNTtcblxuICAgICAgaWYgKHRoaXMuZ2V0KCd0eXBlJykgPT09ICdjb2xvci1sZWdlbmQnKSB7XG4gICAgICAgIHZhbHVlUGFkZGluZyA9IDMwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVPZmZzZXQgPSB0aGlzLmdldCgndGl0bGVHYXAnKTtcbiAgICAgIHZhciB0aXRsZVNoYXBlID0gdGhpcy5nZXQoJ3RpdGxlU2hhcGUnKTtcbiAgICAgIGlmICh0aXRsZVNoYXBlKSB0aXRsZU9mZnNldCArPSB0aXRsZVNoYXBlLmdldEJCb3goKS5tYXhZIC0gdGl0bGVTaGFwZS5nZXRCQm94KCkubWluWTtcbiAgICAgIHZhciBjdXJyZW50UGFnZSA9IGV2LmNsaWVudFkgfHwgZXYuZXZlbnQuY2xpZW50WTtcbiAgICAgIGN1cnJlbnRQYWdlID0gY3VycmVudFBhZ2UgLSBlbF9iYm94LnkgLSB0aGlzLmdldCgnZ3JvdXAnKS5hdHRyKCdtYXRyaXgnKVs3XSArIGJib3gueSAtIHZhbHVlUGFkZGluZyArIHRpdGxlT2Zmc2V0O1xuICAgICAgdmFsdWUgPSBpdGVtc1swXS52YWx1ZSArICgxIC0gY3VycmVudFBhZ2UgLyBoZWlnaHQpICogKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnZhbHVlIC0gaXRlbXNbMF0udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2N1cnJlbnRQYWdlID0gZXYuY2xpZW50WCB8fCBldi5ldmVudC5jbGllbnRYO1xuXG4gICAgICBfY3VycmVudFBhZ2UgPSBfY3VycmVudFBhZ2UgLSBlbF9iYm94LnggLSB0aGlzLmdldCgnZ3JvdXAnKS5hdHRyKCdtYXRyaXgnKVs2XTtcbiAgICAgIHZhbHVlID0gaXRlbXNbMF0udmFsdWUgKyBfY3VycmVudFBhZ2UgLyB3aWR0aCAqIChpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS52YWx1ZSAtIGl0ZW1zWzBdLnZhbHVlKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgdGhpcy5hY3RpdmF0ZSh2YWx1ZSk7XG4gICAgdGhpcy5lbWl0KCdtb3VzZWhvdmVyJywge1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH07IC8vIGFjdGl2YXRlZCBieSBtb3VzZSBtb3Zpbmcgb3IgYmVpbmcgY2FsbGVkXG5cblxuICBfcHJvdG8uYWN0aXZhdGUgPSBmdW5jdGlvbiBhY3RpdmF0ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJQb2ludGVyID0gdGhpcy5nZXQoJ2dyb3VwJykuZmluZEJ5SWQoJ2hvdmVyUG9pbnRlcicpO1xuICAgIHZhciBob3ZlclRleHQgPSB0aGlzLmdldCgnZ3JvdXAnKS5maW5kQnlJZCgnaG92ZXJUZXh0Jyk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG5cbiAgICBpZiAodmFsdWUgPCBpdGVtc1swXS52YWx1ZSB8fCB2YWx1ZSA+IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0KCdoZWlnaHQnKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgdGl0bGVTaGFwZSA9IHRoaXMuZ2V0KCd0aXRsZVNoYXBlJyk7XG4gICAgdmFyIHRpdGxlR2FwID0gdGhpcy5nZXQoJ3RpdGxlR2FwJyk7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIHZhciBwYWdlID0gKHZhbHVlIC0gaXRlbXNbMF0udmFsdWUpIC8gKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnZhbHVlIC0gaXRlbXNbMF0udmFsdWUpO1xuICAgIHZhciB0ZXh0U3R5bGU7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2xheW91dCcpID09PSAndmVydGljYWwnKSB7XG4gICAgICAvLyByZXZpc2UgdGhlIG9mZnNldFxuICAgICAgdmFyIHBhZGRpbmdZID0gMCxcbiAgICAgICAgICBwYWRkaW5nWCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmdldCgndHlwZScpID09PSAnY29sb3ItbGVnZW5kJykge1xuICAgICAgICBwYWRkaW5nWSA9IHRpdGxlR2FwO1xuICAgICAgICBpZiAodGl0bGVTaGFwZSkgcGFkZGluZ1kgKz0gdGl0bGVTaGFwZS5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXQoJ3NsaWRhYmxlJykpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCd0eXBlJykgPT09ICdjb2xvci1sZWdlbmQnKSB7XG4gICAgICAgICAgcGFkZGluZ1kgLT0gMTM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ1kgPSB0aXRsZUdhcCAtIDE1O1xuICAgICAgICAgIGlmICh0aXRsZVNoYXBlKSBwYWRkaW5nWSArPSB0aXRsZVNoYXBlLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYWRkaW5nWCArPSAxMDtcbiAgICAgIH1cblxuICAgICAgcGFnZSA9ICgxIC0gcGFnZSkgKiBoZWlnaHQ7XG4gICAgICBwb2ludHMgPSBbW3BhZGRpbmdYLCBwYWdlICsgcGFkZGluZ1ldLCBbcGFkZGluZ1ggLSAxMCwgcGFnZSArIHBhZGRpbmdZIC0gNV0sIFtwYWRkaW5nWCAtIDEwLCBwYWdlICsgcGFkZGluZ1kgKyA1XV07XG4gICAgICB0ZXh0U3R5bGUgPSBVdGlsLm1peCh7fSwge1xuICAgICAgICB4OiB3aWR0aCArIHRoaXMuZ2V0KCd0ZXh0T2Zmc2V0JykgLyAyICsgcGFkZGluZ1gsXG4gICAgICAgIHk6IHBhZ2UgKyBwYWRkaW5nWSxcbiAgICAgICAgdGV4dDogdGhpcy5fZm9ybWF0SXRlbVZhbHVlKHZhbHVlKSArICcnIC8vIOS7peWtl+espuS4suagvOW8j+WxleekulxuXG4gICAgICB9LCB0aGlzLmdldCgndGV4dFN0eWxlJyksIHtcbiAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wYWRkaW5nWSA9IDAsXG4gICAgICAgICAgX3BhZGRpbmdYID0gMDtcblxuICAgICAgaWYgKHRoaXMuZ2V0KCd0eXBlJykgPT09ICdjb2xvci1sZWdlbmQnKSB7XG4gICAgICAgIF9wYWRkaW5nWSA9IHRpdGxlR2FwO1xuICAgICAgICBpZiAodGl0bGVTaGFwZSkgX3BhZGRpbmdZICs9IHRpdGxlU2hhcGUuZ2V0QkJveCgpLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0KCdzbGlkYWJsZScpKSB7XG4gICAgICAgIGlmICh0aGlzLmdldCgndHlwZScpID09PSAnY29sb3ItbGVnZW5kJykge1xuICAgICAgICAgIC8vIGhvdmVyUG9pbnRlcuS4ieinkuW9oueahOmrmFxuICAgICAgICAgIF9wYWRkaW5nWSAtPSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9wYWRkaW5nWSA9IHRpdGxlR2FwO1xuICAgICAgICAgIGlmICghdGl0bGVTaGFwZSkgX3BhZGRpbmdZIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFkZGluZ1ggKz0gMTA7XG4gICAgICB9XG5cbiAgICAgIHBhZ2UgKj0gd2lkdGg7XG4gICAgICBwb2ludHMgPSBbW3BhZ2UgKyBfcGFkZGluZ1gsIF9wYWRkaW5nWV0sIFtwYWdlICsgX3BhZGRpbmdYIC0gNSwgX3BhZGRpbmdZIC0gMTBdLCBbcGFnZSArIF9wYWRkaW5nWCArIDUsIF9wYWRkaW5nWSAtIDEwXV07XG4gICAgICB0ZXh0U3R5bGUgPSBVdGlsLm1peCh7fSwge1xuICAgICAgICB4OiBwYWdlIC0gNSxcbiAgICAgICAgeTogaGVpZ2h0ICsgdGhpcy5nZXQoJ3RleHRPZmZzZXQnKSArIF9wYWRkaW5nWSxcbiAgICAgICAgdGV4dDogdGhpcy5fZm9ybWF0SXRlbVZhbHVlKHZhbHVlKSArICcnIC8vIOS7peWtl+espuS4suagvOW8j+WxleekulxuXG4gICAgICB9LCB0aGlzLmdldCgndGV4dFN0eWxlJykpO1xuICAgIH1cblxuICAgIHZhciBob3ZlclRleHRTdHlsZSA9IFV0aWwubWl4KHRleHRTdHlsZSwgdGhpcy5nZXQoJ2hvdmVyVGV4dFN0eWxlJykpO1xuXG4gICAgaWYgKCFob3ZlclRleHQpIHtcbiAgICAgIC8vIG1vdXNlIGVudGVyIHRoZSBsZWdlbmQsIGFkZCBob3ZlclRleHRcbiAgICAgIGhvdmVyVGV4dCA9IHRoaXMuZ2V0KCdncm91cCcpLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogaG92ZXJUZXh0U3R5bGVcbiAgICAgIH0pO1xuICAgICAgaG92ZXJUZXh0LnNldCgnaWQnLCAnaG92ZXJUZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1vdXNlIG1vdmUsIHVwZGF0ZSBob3ZlclRleHRcbiAgICAgIGhvdmVyVGV4dC5hdHRyKGhvdmVyVGV4dFN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIWhvdmVyUG9pbnRlcikge1xuICAgICAgLy8gbW91c2UgZW50ZXIgdGhlIGxlZ2VuZCwgYWRkIGhvdmVyUG9pbnRlclxuICAgICAgaG92ZXJQb2ludGVyID0gdGhpcy5nZXQoJ2dyb3VwJykuYWRkU2hhcGUoJ1BvbHlnb24nLCB7XG4gICAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgfSwgdGhpcy5nZXQoJ3BvaW50ZXJTdHlsZScpKVxuICAgICAgfSk7XG4gICAgICBob3ZlclBvaW50ZXIuc2V0KCdpZCcsICdob3ZlclBvaW50ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbW91c2UgbW92ZSwgdXBkYXRlIGhvdmVyUG9pbnRlclxuICAgICAgaG92ZXJQb2ludGVyLmF0dHIoVXRpbC5taXgoe1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSwgdGhpcy5nZXQoJ3BvaW50ZXJTdHlsZScpKSk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgdmFyIGhvdmVyUG9pbnRlciA9IHRoaXMuZ2V0KCdncm91cCcpLmZpbmRCeUlkKCdob3ZlclBvaW50ZXInKTtcbiAgICBob3ZlclBvaW50ZXIgJiYgaG92ZXJQb2ludGVyLmRlc3Ryb3koKTtcbiAgICB2YXIgaG92ZXJUZXh0ID0gdGhpcy5nZXQoJ2dyb3VwJykuZmluZEJ5SWQoJ2hvdmVyVGV4dCcpO1xuICAgIGhvdmVyVGV4dCAmJiBob3ZlclRleHQuZGVzdHJveSgpO1xuICAgIHRoaXMuZ2V0KCdjYW52YXMnKS5kcmF3KCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRpbnVvdXM7XG59KExlZ2VuZCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGludW91cztcblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUb29sdGlwLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUb29sdGlwKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb29sdGlwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Db21wb25lbnQucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIHRvb2x0aXAgY29udGFpbmVyXG4gICAgICAgKiBAdHlwZSB7RG9tIC8gU3RyaW5nfVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICog5Y+z5LiL6KeS5Z2Q5qCHXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB4OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIHkg5Y+z5LiL6KeS5Z2Q5qCHXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB5OiAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRvb2x0aXAg6K6w5b2V6aG5XG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIGl0ZW1zOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRvb2x0aXAg5qCH6aKYXG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHRpdGxlQ29udGVudDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDmmK/lkKblsZXnpLogdGl0bGVcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBzaG93VGl0bGU6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICog6KeG5Zu+6IyD5Zu0XG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBwbG90UmFuZ2U6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogeOi9tOS4iu+8jOenu+WKqOWIsOS9jee9rueahOWBj+enu+mHj1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgIC8vIFRPRE865pSv5oyBeHnkuKTkuKrmlrnlkJHkuIrnmoRvZmZzZXRcblxuICAgICAgLyoqXG4gICAgICAgKiDml7bpl7TmiLNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRpbWVTdGFtcDogMCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlsIYgdG9vbHRpcCDlsZXnpLrlnKjmjIflrprljLrln5/lhoVcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBpblBsb3Q6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICogdG9vbHRpcCDovoXliqnnur/phY3nva5cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGNyb3NzaGFpcnM6IG51bGxcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaXNDb250ZW50Q2hhbmdlID0gZnVuY3Rpb24gaXNDb250ZW50Q2hhbmdlKHRpdGxlLCBpdGVtcykge1xuICAgIHZhciB0aXRsZUNvbnRlbnQgPSB0aGlzLmdldCgndGl0bGVDb250ZW50Jyk7XG4gICAgdmFyIGxhc3RJdGVtcyA9IHRoaXMuZ2V0KCdpdGVtcycpO1xuICAgIHZhciBpc0NoYW5nZWQgPSAhKHRpdGxlID09PSB0aXRsZUNvbnRlbnQgJiYgbGFzdEl0ZW1zLmxlbmd0aCA9PT0gaXRlbXMubGVuZ3RoKTtcblxuICAgIGlmICghaXNDaGFuZ2VkKSB7XG4gICAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgcHJlSXRlbSA9IGxhc3RJdGVtc1tpbmRleF07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIVV0aWwuaXNPYmplY3QoaXRlbVtrZXldKSAmJiBpdGVtW2tleV0gIT09IHByZUl0ZW1ba2V5XSkge1xuICAgICAgICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNDaGFuZ2VkO1xuICB9O1xuXG4gIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCh0aXRsZSwgaXRlbXMpIHtcbiAgICB2YXIgdGltZVN0YW1wID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgdGhpcy5zZXQoJ2l0ZW1zJywgaXRlbXMpO1xuICAgIHRoaXMuc2V0KCd0aXRsZUNvbnRlbnQnLCB0aXRsZSk7XG4gICAgdGhpcy5zZXQoJ3RpbWVTdGFtcCcsIHRpbWVTdGFtcCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgdGhpcy5zZXQoJ3gnLCB4KTtcbiAgICB0aGlzLnNldCgneScsIHkpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7fTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHt9O1xuXG4gIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLnNldCgndmlzaWJsZScsIGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwO1xuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByb290OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gU2VsZWN0aW9uO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3RBbGxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDAzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZpbHRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZGF0YV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZW50ZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX2V4aXRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDA3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX21lcmdlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19vcmRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fc29ydF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fY2FsbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX25vZGVzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fbm9kZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3NpemVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19lbXB0eV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX2VhY2hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDE2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19hdHRyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fc3R5bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19wcm9wZXJ0eV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX2NsYXNzZWRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X190ZXh0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9faHRtbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX3JhaXNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fbG93ZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX19hcHBlbmRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDI0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI0X19pbnNlcnRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI1X19yZW1vdmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI2X19jbG9uZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX2RhdHVtX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOF9fb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzc0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI5X19kaXNwYXRjaF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjkpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJvb3QgPSBbbnVsbF07XG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHNlbGVjdEFsbDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3RBbGxfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZmlsdGVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2ZpbHRlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBkYXRhOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2RhdGFfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZW50ZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZW50ZXJfX1tcImJcIiAvKiBkZWZhdWx0ICovXSxcbiAgZXhpdDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19leGl0X19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIG1lcmdlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX21lcmdlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIG9yZGVyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX29yZGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHNvcnQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fc29ydF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBjYWxsOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX2NhbGxfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgbm9kZXM6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX25vZGVzX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIG5vZGU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX25vZGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgc2l6ZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fc2l6ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBlbXB0eTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fZW1wdHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZWFjaDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fZWFjaF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBhdHRyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19hdHRyX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHN0eWxlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19zdHlsZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBwcm9wZXJ0eTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fcHJvcGVydHlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgY2xhc3NlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fY2xhc3NlZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICB0ZXh0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X190ZXh0X19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIGh0bWw6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjBfX2h0bWxfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgcmFpc2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX3JhaXNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIGxvd2VyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIyX19sb3dlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBhcHBlbmQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjNfX2FwcGVuZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBpbnNlcnQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX2luc2VydF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICByZW1vdmU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjVfX3JlbW92ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBjbG9uZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yNl9fY2xvbmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZGF0dW06IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX2RhdHVtX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIG9uOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI4X19vbl9fW1wiYlwiIC8qIGRlZmF1bHQgKi9dLFxuICBkaXNwYXRjaDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOV9fZGlzcGF0Y2hfX1tcImFcIiAvKiBkZWZhdWx0ICovXVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSAoc2VsZWN0aW9uKTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBDUkVBVEVEICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNDSEVEVUxFRDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNUQVJUSU5HOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBTVEFSVEVEICovXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgUlVOTklORyAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFTkRJTkc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFTkRFRDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZ1wiXSA9IGluaXQ7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiaFwiXSA9IHNldDtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJmXCJdID0gZ2V0O1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19kaXNwYXRjaF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kM190aW1lcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzApO1xuXG5cbnZhciBlbXB0eU9uID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19kaXNwYXRjaF9fW1wiYVwiIC8qIGRpc3BhdGNoICovXSkoXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG52YXIgQ1JFQVRFRCA9IDA7XG52YXIgU0NIRURVTEVEID0gMTtcbnZhciBTVEFSVElORyA9IDI7XG52YXIgU1RBUlRFRCA9IDM7XG52YXIgUlVOTklORyA9IDQ7XG52YXIgRU5ESU5HID0gNTtcbnZhciBFTkRFRCA9IDY7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJlXCJdID0gKGZ1bmN0aW9uIChub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCxcbiAgICAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufSk7XG5mdW5jdGlvbiBpbml0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IENSRUFURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHNjaGVkdWxlZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzdGFydGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5mdW5jdGlvbiBnZXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkpIHRocm93IG5ldyBFcnJvcihcInRyYW5zaXRpb24gbm90IGZvdW5kXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShub2RlLCBpZCwgc2VsZikge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICB0d2VlbjsgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuXG4gIHNjaGVkdWxlc1tpZF0gPSBzZWxmO1xuICBzZWxmLnRpbWVyID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kM190aW1lcl9fW1widGltZXJcIl0pKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTsgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87IC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cblxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTsgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcblxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2QzX3RpbWVyX19bXCJ0aW1lb3V0XCJdKShzdGFydCk7IC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIC8vIERpc3BhdGNoIHRoZSBpbnRlcnJ1cHQgZXZlbnQuXG5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH0gLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLiBObyBpbnRlcnJ1cHQgZXZlbnQgaXMgZGlzcGF0Y2hlZFxuICAgICAgLy8gYmVjYXVzZSB0aGUgY2FuY2VsbGVkIHRyYW5zaXRpb25zIG5ldmVyIHN0YXJ0ZWQuIE5vdGUgdGhhdCB0aGlzIGFsc29cbiAgICAgIC8vIHJlbW92ZXMgdGhpcyB0cmFuc2l0aW9uIGZyb20gdGhlIHBlbmRpbmcgbGlzdCFcbiAgICAgIGVsc2UgaWYgKCtpIDwgaWQpIHtcbiAgICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgICAgfVxuICAgIH0gLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG5cblxuICAgIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfdGltZXJfX1tcInRpbWVvdXRcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDsgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuXG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobnVsbCwgdCk7XG4gICAgfSAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuXG5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG5cbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDmj5Dlj5blhazlhbHku6PnoIHliLB1dGls5pa55rOVXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBpc0RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvVGltZVN0YW1wOiBmdW5jdGlvbiB0b1RpbWVTdGFtcCh2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdUJykgPiAwKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUucmVwbGFjZSgvLS9pZywgJy8nKSkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcmNfY3JlYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwMSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmVhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NyY19jcmVhdGVfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fc3JjX2NyZWF0b3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYwKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyZWF0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY19jcmVhdG9yX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NyY19sb2NhbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzApO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9jYWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NyY19sb2NhbF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zcmNfbWF0Y2hlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWF0Y2hlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fc3JjX21hdGNoZXJfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fc3JjX21vdXNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtb3VzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fc3JjX21vdXNlX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3NyY19uYW1lc3BhY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcwKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVzcGFjZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fc3JjX25hbWVzcGFjZV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19zcmNfbmFtZXNwYWNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZXNwYWNlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fc3JjX25hbWVzcGFjZXNfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fc3JjX3BvaW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2MSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGllbnRQb2ludFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fc3JjX3BvaW50X19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3NyY19zZWxlY3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzc5KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlbGVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fc3JjX3NlbGVjdF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19zcmNfc2VsZWN0QWxsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZWxlY3RBbGxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3NyY19zZWxlY3RBbGxfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX3NyY19zZWxlY3Rpb25faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VsZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fc3JjX3NlbGVjdGlvbl9pbmRleF9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fc3JjX3NlbGVjdG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Mik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZWxlY3RvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX3NyY19zZWxlY3Rvcl9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fc3JjX3NlbGVjdG9yQWxsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZWxlY3RvckFsbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3NyY19zZWxlY3RvckFsbF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fc3JjX3NlbGVjdGlvbl9zdHlsZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic3R5bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19zcmNfc2VsZWN0aW9uX3N0eWxlX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19zcmNfdG91Y2hfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDMzKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvdWNoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fc3JjX3RvdWNoX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19zcmNfdG91Y2hlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG91Y2hlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3NyY190b3VjaGVzX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19zcmNfd2luZG93X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Myk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ3aW5kb3dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19zcmNfd2luZG93X19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19zcmNfc2VsZWN0aW9uX29uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3NCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJldmVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX3NyY19zZWxlY3Rpb25fb25fX1tcImNcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3VzdG9tRXZlbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19zcmNfc2VsZWN0aW9uX29uX19bXCJhXCJdOyB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUG9zaXRpb246IF9fd2VicGFja19yZXF1aXJlX18oMjkyKSxcbiAgQ29sb3I6IF9fd2VicGFja19yZXF1aXJlX18oMjkzKSxcbiAgU2hhcGU6IF9fd2VicGFja19yZXF1aXJlX18oMjk0KSxcbiAgU2l6ZTogX193ZWJwYWNrX3JlcXVpcmVfXygyOTUpLFxuICBPcGFjaXR5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NiksXG4gIENvbG9yVXRpbDogX193ZWJwYWNrX3JlcXVpcmVfXygxNDkpXG59O1xuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBTY2FsZSBlbnRyeSwgdXNlZCB0byByZWZlcmVuY2UgYWxsIHRoZSBzY2FsZXNcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgbG93ZXJGaXJzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG5CYXNlLkxpbmVhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuQmFzZS5JZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTc1KTtcbkJhc2UuQ2F0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG5CYXNlLlRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3Nik7XG5CYXNlLlRpbWVDYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCk7XG5CYXNlLkxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTc5KTtcbkJhc2UuUG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODApO1xuXG52YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrKSB7XG4gIGlmIChCYXNlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgdmFyIG1ldGhvZE5hbWUgPSBsb3dlckZpcnN0KGspO1xuXG4gICAgQmFzZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgIHJldHVybiBuZXcgQmFzZVtrXShjZmcpO1xuICAgIH07XG4gIH1cbn07XG5cbmZvciAodmFyIGsgaW4gQmFzZSkge1xuICBfbG9vcChrKTtcbn1cblxudmFyIENBVF9BUlIgPSBbJ2NhdCcsICd0aW1lQ2F0J107XG5cbkJhc2UuaXNDYXRlZ29yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBDQVRfQVJSLmluZGV4T2YodHlwZSkgPj0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIGxvd2VyRmlyc3QgPSBmdW5jdGlvbiBsb3dlckZpcnN0KHZhbHVlKSB7XG4gIHZhciBzdHIgPSB0b1N0cmluZyh2YWx1ZSk7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb3dlckZpcnN0O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDorqHnrpfmlrnms5VcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG4vLyDlpoLmnpzlsI/mlbDngrnlkI7pnaLotoXov4cgMTAg5L2N5rWu54K55pWw5pe26L+b6KGM5LiA5LiL5aSE55CGXG52YXIgREVDSU1BTF9MRU5HVEggPSAxMjsgLy8g6I635Y+W57O75pWwXG5cbmZ1bmN0aW9uIGdldEZhY3Rvcih2KSB7XG4gIHZhciBmYWN0b3IgPSAxO1xuXG4gIGlmICh2ID09PSBJbmZpbml0eSB8fCB2ID09PSAtSW5maW5pdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0IEluZmluaXR5IScpO1xuICB9XG5cbiAgaWYgKHYgPCAxKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIHdoaWxlICh2IDwgMSkge1xuICAgICAgZmFjdG9yID0gZmFjdG9yIC8gMTA7XG4gICAgICB2ID0gdiAqIDEwO1xuICAgICAgY291bnQrKztcbiAgICB9IC8vIOa1rueCueaVsOiuoeeul+WHuueOsOmXrumimFxuXG5cbiAgICBpZiAoZmFjdG9yLnRvU3RyaW5nKCkubGVuZ3RoID4gREVDSU1BTF9MRU5HVEgpIHtcbiAgICAgIGZhY3RvciA9IHBhcnNlRmxvYXQoZmFjdG9yLnRvRml4ZWQoY291bnQpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHYgPiAxMCkge1xuICAgICAgZmFjdG9yID0gZmFjdG9yICogMTA7XG4gICAgICB2ID0gdiAvIDEwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWN0b3I7XG59IC8vIOWPluWwj+S6juW9k+WJjeWAvOeahFxuXG5cbmZ1bmN0aW9uIGFycmF5Rmxvb3IodmFsdWVzLCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBwcmUgPSB2YWx1ZXNbMF07XG5cbiAgaWYgKHZhbHVlIDwgdmFsdWVzWzBdKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSB2YWx1ZXNbbGVuZ3RoIC0gMV0pIHtcbiAgICByZXR1cm4gdmFsdWVzW2xlbmd0aCAtIDFdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPCB2YWx1ZXNbaV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZSA9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBwcmU7XG59IC8vIOWkp+S6juW9k+WJjeWAvOeahOesrOS4gOS4qlxuXG5cbmZ1bmN0aW9uIGFycmF5Q2VpbGluZyh2YWx1ZXMsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IC8vIHZhciBwcmUgPSB2YWx1ZXNbMF07XG5cblxuICB2YXIgcnN0O1xuXG4gIGlmICh2YWx1ZSA+IHZhbHVlc1tsZW5ndGggLSAxXSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICBpZiAodmFsdWUgPCB2YWx1ZXNbMF0pIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPD0gdmFsdWVzW2ldKSB7XG4gICAgICByc3QgPSB2YWx1ZXNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0O1xufVxuXG52YXIgVXRpbCA9IHtcbiAgLy8g6I635Y+W6YC86L+R55qE5pWw5YC8XG4gIHNuYXBGYWN0b3JUbzogZnVuY3Rpb24gc25hcEZhY3RvclRvKHYsIGFyciwgc25hcFR5cGUpIHtcbiAgICAvLyDlgYforr4gdiA9IC01MTIsaXNGbG9vciA9IHRydWVcbiAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdmFyIGZhY3RvciA9IDE7IC8vIOiuoeeul+ezu+aVsFxuXG4gICAgaWYgKHYgIT09IDApIHtcbiAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICBmYWN0b3IgPSAtMTtcbiAgICAgIH1cblxuICAgICAgdiA9IHYgKiBmYWN0b3I7IC8vIHYgPSA1MTJcblxuICAgICAgdmFyIHRtcEZhY3RvciA9IGdldEZhY3Rvcih2KTtcbiAgICAgIGZhY3RvciA9IGZhY3RvciAqIHRtcEZhY3RvcjsgLy8gZmFjdG9yID0gLTEwMFxuXG4gICAgICB2ID0gdiAvIHRtcEZhY3RvcjsgLy8gdiA9IDUuMTJcbiAgICB9XG5cbiAgICBpZiAoc25hcFR5cGUgPT09ICdmbG9vcicpIHtcbiAgICAgIHYgPSBVdGlsLnNuYXBGbG9vcihhcnIsIHYpOyAvLyB2ID0gNVxuICAgIH0gZWxzZSBpZiAoc25hcFR5cGUgPT09ICdjZWlsJykge1xuICAgICAgdiA9IFV0aWwuc25hcENlaWxpbmcoYXJyLCB2KTsgLy8gdiA9IDZcbiAgICB9IGVsc2Uge1xuICAgICAgdiA9IFV0aWwuc25hcFRvKGFyciwgdik7IC8vIOWbm+iIjeS6lOWFpSA1XG4gICAgfVxuXG4gICAgdmFyIHJzdCA9IHYgKiBmYWN0b3I7IC8vIOWmguaenOWHuueOsOa1rueCueaVsOiuoeeul+mXrumimO+8jOmcgOimgeWkhOeQhuS4gOS4i1xuXG4gICAgaWYgKE1hdGguYWJzKGZhY3RvcikgPCAxICYmIHJzdC50b1N0cmluZygpLmxlbmd0aCA+IERFQ0lNQUxfTEVOR1RIKSB7XG4gICAgICB2YXIgZGVjaW1hbFZhbCA9IHBhcnNlSW50KDEgLyBmYWN0b3IpO1xuICAgICAgdmFyIHN5bWJvbCA9IGZhY3RvciA+IDAgPyAxIDogLTE7XG4gICAgICByc3QgPSB2IC8gZGVjaW1hbFZhbCAqIHN5bWJvbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9LFxuICAvLyDojrflj5bpgLzov5HnmoTlgI3mlbBcbiAgc25hcE11bHRpcGxlOiBmdW5jdGlvbiBzbmFwTXVsdGlwbGUodiwgYmFzZSwgc25hcFR5cGUpIHtcbiAgICB2YXIgZGl2O1xuXG4gICAgaWYgKHNuYXBUeXBlID09PSAnY2VpbCcpIHtcbiAgICAgIGRpdiA9IE1hdGguY2VpbCh2IC8gYmFzZSk7XG4gICAgfSBlbHNlIGlmIChzbmFwVHlwZSA9PT0gJ2Zsb29yJykge1xuICAgICAgZGl2ID0gTWF0aC5mbG9vcih2IC8gYmFzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdiA9IE1hdGgucm91bmQodiAvIGJhc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXYgKiBiYXNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bpgLzov5HnmoTlgLzvvIznlKjkuo7lr7npvZDmlbDmja5cbiAgICogQHBhcmFtICB7QXJyYXl9IHZhbHVlcyAgIOaVsOaNrumbhuWQiFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlICAg5pWw5YC8XG4gICAqIEByZXR1cm4ge051bWJlcn0g6YC86L+R55qE5YC8XG4gICAqL1xuICBzbmFwVG86IGZ1bmN0aW9uIHNuYXBUbyh2YWx1ZXMsIHZhbHVlKSB7XG4gICAgLy8g6L+Z6YeM5YGH5a6admFsdWVz5piv5Y2H5bqP5o6S5YiXXG4gICAgdmFyIGZsb29yVmFsID0gYXJyYXlGbG9vcih2YWx1ZXMsIHZhbHVlKTtcbiAgICB2YXIgY2VpbGluZ1ZhbCA9IGFycmF5Q2VpbGluZyh2YWx1ZXMsIHZhbHVlKTtcblxuICAgIGlmIChpc05hTihmbG9vclZhbCkgfHwgaXNOYU4oY2VpbGluZ1ZhbCkpIHtcbiAgICAgIGlmICh2YWx1ZXNbMF0gPj0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAobGFzdCA8PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModmFsdWUgLSBmbG9vclZhbCkgPCBNYXRoLmFicyhjZWlsaW5nVmFsIC0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmxvb3JWYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlaWxpbmdWYWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlumAvOi/keeahOacgOWwj+WAvO+8jOeUqOS6juWvuem9kOaVsOaNrlxuICAgKiBAcGFyYW0gIHtBcnJheX0gdmFsdWVzICAg5pWw5o2u6ZuG5ZCIXG4gICAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUgICDmlbDlgLxcbiAgICogQHJldHVybiB7TnVtYmVyfSDpgLzov5HnmoTmnIDlsI/lgLxcbiAgICovXG4gIHNuYXBGbG9vcjogZnVuY3Rpb24gc25hcEZsb29yKHZhbHVlcywgdmFsdWUpIHtcbiAgICAvLyDov5nph4zlgYflrpp2YWx1ZXPmmK/ljYfluo/mjpLliJdcbiAgICByZXR1cm4gYXJyYXlGbG9vcih2YWx1ZXMsIHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W6YC86L+R55qE5pyA5aSn5YC877yM55So5LqO5a+56b2Q5pWw5o2uXG4gICAqIEBwYXJhbSAge0FycmF5fSB2YWx1ZXMgICDmlbDmja7pm4blkIhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSAgIOaVsOWAvFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IOmAvOi/keeahOacgOWkp+WAvFxuICAgKi9cbiAgc25hcENlaWxpbmc6IGZ1bmN0aW9uIHNuYXBDZWlsaW5nKHZhbHVlcywgdmFsdWUpIHtcbiAgICAvLyDov5nph4zlgYflrpp2YWx1ZXPmmK/ljYfluo/mjpLliJdcbiAgICByZXR1cm4gYXJyYXlDZWlsaW5nKHZhbHVlcywgdmFsdWUpO1xuICB9LFxuICBmaXhlZEJhc2U6IGZ1bmN0aW9uIGZpeGVkQmFzZSh2LCBiYXNlKSB7XG4gICAgdmFyIHN0ciA9IGJhc2UudG9TdHJpbmcoKTtcbiAgICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodik7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHN0ci5zdWJzdHIoaW5kZXggKyAxKS5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoID4gMjApIHtcbiAgICAgIGxlbmd0aCA9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHYudG9GaXhlZChsZW5ndGgpKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBjYXRBdXRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBDYXRlZ29yeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2F0ZWdvcnksIF9CYXNlKTtcblxuICBmdW5jdGlvbiBDYXRlZ29yeSgpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhdGVnb3J5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9CYXNlLnByb3RvdHlwZS5faW5pdERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9ICdjYXQnO1xuICAgIC8qKlxuICAgICAqIOaYr+WQpuWIhuexu+W6pumHj1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuXG4gICAgdGhpcy5pc0NhdGVnb3J5ID0gdHJ1ZTtcbiAgICB0aGlzLmlzUm91bmRpbmcgPSB0cnVlOyAvLyDmmK/lkKbov5vooYzlj5bmlbTmk43kvZxcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZhbHVlcyA9IHNlbGYudmFsdWVzO1xuICAgIHZhciB0aWNrQ291bnQgPSBzZWxmLnRpY2tDb3VudDtcbiAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHYudG9TdHJpbmcoKTtcbiAgICB9KTtcblxuICAgIGlmICghc2VsZi50aWNrcykge1xuICAgICAgdmFyIHRpY2tzID0gdmFsdWVzO1xuXG4gICAgICBpZiAodGlja0NvdW50KSB7XG4gICAgICAgIHZhciB0ZW1wID0gY2F0QXV0byh7XG4gICAgICAgICAgbWF4Q291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgaXNSb3VuZGluZzogc2VsZi5pc1JvdW5kaW5nXG4gICAgICAgIH0pO1xuICAgICAgICB0aWNrcyA9IHRlbXAudGlja3M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGlja3MgPSB0aWNrcztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQodmFsdWUpIHtcbiAgICBpZiAodGhpcy52YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmIGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc1tNYXRoLnJvdW5kKHZhbHVlKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9CYXNlLnByb3RvdHlwZS5nZXRUZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudmFsdWVzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSAmJiBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIGluZGV4ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGluZGV4ID0gTmFOO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICB2YXIgcGVyY2VudDtcblxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdGhpcy52YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudHJhbnNsYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgcGVyY2VudCA9IHZhbHVlIC8gKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlTWluICsgcGVyY2VudCAqIChyYW5nZU1heCAtIHJhbmdlTWluKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQodmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAvLyDlpoLmnpzlt7Lnu4/mmK/lrZfnrKbkuLJcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgbWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciBtYXggPSB0aGlzLnJhbmdlTWF4KCk7IC8vIOW9kuS4gOWIsCDojIPlm7TlhoVcblxuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgdmFsdWUgPSBtaW47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICB2YWx1ZSA9IG1heDtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKHBlcmNlbnQgKiAodGhpcy52YWx1ZXMubGVuZ3RoIC0gMSkpICUgdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICB9O1xuXG4gIHJldHVybiBDYXRlZ29yeTtcbn0oQmFzZSk7XG5cbkJhc2UuQ2F0ID0gQ2F0ZWdvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5O1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDorqHnrpfliIbnsbvnmoTnmoTlnZDmoIfngrlcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBNQVhfQ09VTlQgPSA4O1xudmFyIFNVQl9DT1VOVCA9IDQ7IC8vIOaOp+WItuS4quaVsOS4jeiDvei/h+Wwj1xuXG5mdW5jdGlvbiBnZXRTaW1wbGVBcnJheShkYXRhKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZWFjaChkYXRhLCBmdW5jdGlvbiAoc3ViKSB7XG4gICAgYXJyID0gYXJyLmNvbmNhdChzdWIpO1xuICB9KTtcbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0R3JlYXRlc3RGYWN0b3IoY291bnQsIG51bWJlcikge1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBudW1iZXI7IGkgPiAwOyBpLS0pIHtcbiAgICBpZiAoY291bnQgJSBpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8g5aaC5p6c5piv57Sg5pWw77yM5rKh5pyJ5Y+v5Lul5pW06Zmk55qE5pWw5a2XXG5cblxuICBpZiAoaSA9PT0gMSkge1xuICAgIGZvciAoaSA9IG51bWJlcjsgaSA+IDA7IGktLSkge1xuICAgICAgaWYgKChjb3VudCAtIDEpICUgaSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5mbykge1xuICB2YXIgcnN0ID0ge307XG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgaXNSb3VuZGluZyA9IGluZm8uaXNSb3VuZGluZztcbiAgdmFyIGNhdGVnb3JpZXMgPSBnZXRTaW1wbGVBcnJheShpbmZvLmRhdGEpO1xuICB2YXIgbGVuZ3RoID0gY2F0ZWdvcmllcy5sZW5ndGg7XG4gIHZhciBtYXhDb3VudCA9IGluZm8ubWF4Q291bnQgfHwgTUFYX0NPVU5UO1xuICB2YXIgdGlja0NvdW50O1xuXG4gIGlmIChpc1JvdW5kaW5nKSB7XG4gICAgLy8g5Y+W5pW05pON5L2cXG4gICAgdGlja0NvdW50ID0gZ2V0R3JlYXRlc3RGYWN0b3IobGVuZ3RoIC0gMSwgbWF4Q291bnQgLSAxKSArIDE7IC8vIOWmguaenOiuoeeul+WHuuadpeWPquacieS4pOS4quWdkOagh+eCue+8jOWImeebtOaOpeS9v+eUqOS8oOWFpeeahCBtYXhDb3VudFxuXG4gICAgaWYgKHRpY2tDb3VudCA9PT0gMikge1xuICAgICAgdGlja0NvdW50ID0gbWF4Q291bnQ7XG4gICAgfSBlbHNlIGlmICh0aWNrQ291bnQgPCBtYXhDb3VudCAtIFNVQl9DT1VOVCkge1xuICAgICAgdGlja0NvdW50ID0gbWF4Q291bnQgLSBTVUJfQ09VTlQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpY2tDb3VudCA9IG1heENvdW50O1xuICB9XG5cbiAgaWYgKCFpc1JvdW5kaW5nICYmIGxlbmd0aCA8PSB0aWNrQ291bnQgKyB0aWNrQ291bnQgLyAyKSB7XG4gICAgdGlja3MgPSBbXS5jb25jYXQoY2F0ZWdvcmllcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0ZXAgPSBwYXJzZUludChsZW5ndGggLyAodGlja0NvdW50IC0gMSksIDEwKTtcbiAgICB2YXIgZ3JvdXBzID0gY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHJldHVybiBpICUgc3RlcCA9PT0gMCA/IGNhdGVnb3JpZXMuc2xpY2UoaSwgaSArIHN0ZXApIDogbnVsbDtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGdyb3VwTGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGdyb3VwTGVuICYmIChpc1JvdW5kaW5nID8gaSAqIHN0ZXAgPCBsZW5ndGggLSBzdGVwIDogaSA8IHRpY2tDb3VudCAtIDEpOyBpKyspIHtcbiAgICAgIHRpY2tzLnB1c2goZ3JvdXBzW2ldWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgIHRpY2tzLnVuc2hpZnQoY2F0ZWdvcmllc1swXSk7XG4gICAgICB2YXIgbGFzdCA9IGNhdGVnb3JpZXNbbGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0aWNrcy5pbmRleE9mKGxhc3QpID09PSAtMSkge1xuICAgICAgICB0aWNrcy5wdXNoKGxhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJzdC5jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcbiAgcnN0LnRpY2tzID0gdGlja3M7XG4gIHJldHVybiByc3Q7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKG1haW4pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogUGFyc2Ugb3IgZm9ybWF0IGRhdGVzXG4gICAqIEBjbGFzcyBmZWNoYVxuICAgKi9cblxuICB2YXIgZmVjaGEgPSB7fTtcbiAgdmFyIHRva2VuID0gL2R7MSw0fXxNezEsNH18WVkoPzpZWSk/fFN7MSwzfXxEb3xaWnwoW0hoTXNEbV0pXFwxP3xbYUFdfFwiW15cIl0qXCJ8J1teJ10qJy9nO1xuICB2YXIgdHdvRGlnaXRzID0gL1xcZFxcZD8vO1xuICB2YXIgdGhyZWVEaWdpdHMgPSAvXFxkezN9LztcbiAgdmFyIGZvdXJEaWdpdHMgPSAvXFxkezR9LztcbiAgdmFyIHdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcbiAgdmFyIGxpdGVyYWwgPSAvXFxbKFteXSo/KVxcXS9nbTtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIHNob3J0ZW4oYXJyLCBzTGVuKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbmV3QXJyLnB1c2goYXJyW2ldLnN1YnN0cigwLCBzTGVuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vbnRoVXBkYXRlKGFyck5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIHYsIGkxOG4pIHtcbiAgICAgIHZhciBpbmRleCA9IGkxOG5bYXJyTmFtZV0uaW5kZXhPZih2LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdi5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgZC5tb250aCA9IGluZGV4O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcbiAgICB2YWwgPSBTdHJpbmcodmFsKTtcbiAgICBsZW4gPSBsZW4gfHwgMjtcblxuICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB7XG4gICAgICB2YWwgPSAnMCcgKyB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHZhciBkYXlOYW1lcyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbiAgdmFyIG1vbnRoTmFtZXMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbiAgdmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNob3J0ZW4obW9udGhOYW1lcywgMyk7XG4gIHZhciBkYXlOYW1lc1Nob3J0ID0gc2hvcnRlbihkYXlOYW1lcywgMyk7XG4gIGZlY2hhLmkxOG4gPSB7XG4gICAgZGF5TmFtZXNTaG9ydDogZGF5TmFtZXNTaG9ydCxcbiAgICBkYXlOYW1lczogZGF5TmFtZXMsXG4gICAgbW9udGhOYW1lc1Nob3J0OiBtb250aE5hbWVzU2hvcnQsXG4gICAgbW9udGhOYW1lczogbW9udGhOYW1lcyxcbiAgICBhbVBtOiBbJ2FtJywgJ3BtJ10sXG4gICAgRG9GbjogZnVuY3Rpb24gRG9GbihEKSB7XG4gICAgICByZXR1cm4gRCArIFsndGgnLCAnc3QnLCAnbmQnLCAncmQnXVtEICUgMTAgPiAzID8gMCA6IChEIC0gRCAlIDEwICE9PSAxMCkgKiBEICUgMTBdO1xuICAgIH1cbiAgfTtcbiAgdmFyIGZvcm1hdEZsYWdzID0ge1xuICAgIEQ6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXREYXRlKCk7XG4gICAgfSxcbiAgICBERDogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXREYXRlKCkpO1xuICAgIH0sXG4gICAgRG86IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5Eb0ZuKGRhdGVPYmouZ2V0RGF0ZSgpKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXREYXkoKTtcbiAgICB9LFxuICAgIGRkOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldERheSgpKTtcbiAgICB9LFxuICAgIGRkZDogZnVuY3Rpb24gKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBpMThuLmRheU5hbWVzU2hvcnRbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBkZGRkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgcmV0dXJuIGkxOG4uZGF5TmFtZXNbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBNOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0TW9udGgoKSArIDE7XG4gICAgfSxcbiAgICBNTTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXRNb250aCgpICsgMSk7XG4gICAgfSxcbiAgICBNTU06IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzU2hvcnRbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIE1NTU06IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzW2RhdGVPYmouZ2V0TW9udGgoKV07XG4gICAgfSxcbiAgICBZWTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZU9iai5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMik7XG4gICAgfSxcbiAgICBZWVlZOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDQpO1xuICAgIH0sXG4gICAgaDogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9LFxuICAgIGhoOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMik7XG4gICAgfSxcbiAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKTtcbiAgICB9LFxuICAgIEhIOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldE1pbnV0ZXMoKTtcbiAgICB9LFxuICAgIG1tOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldE1pbnV0ZXMoKSk7XG4gICAgfSxcbiAgICBzOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0U2Vjb25kcygpO1xuICAgIH0sXG4gICAgc3M6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0U2Vjb25kcygpKTtcbiAgICB9LFxuICAgIFM6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpIC8gMTAwKTtcbiAgICB9LFxuICAgIFNTOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChNYXRoLnJvdW5kKGRhdGVPYmouZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMCksIDIpO1xuICAgIH0sXG4gICAgU1NTOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXRIb3VycygpIDwgMTIgPyBpMThuLmFtUG1bMF0gOiBpMThuLmFtUG1bMV07XG4gICAgfSxcbiAgICBBOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKSA8IDEyID8gaTE4bi5hbVBtWzBdLnRvVXBwZXJDYXNlKCkgOiBpMThuLmFtUG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIFpaOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgdmFyIG8gPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICByZXR1cm4gKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCk7XG4gICAgfVxuICB9O1xuICB2YXIgcGFyc2VGbGFncyA9IHtcbiAgICBEOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5kYXkgPSB2O1xuICAgIH1dLFxuICAgIERvOiBbbmV3IFJlZ0V4cCh0d29EaWdpdHMuc291cmNlICsgd29yZC5zb3VyY2UpLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5kYXkgPSBwYXJzZUludCh2LCAxMCk7XG4gICAgfV0sXG4gICAgTTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubW9udGggPSB2IC0gMTtcbiAgICB9XSxcbiAgICBZWTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIHZhciBkYSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgY2VudCA9ICsoJycgKyBkYS5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMCwgMik7XG4gICAgICBkLnllYXIgPSAnJyArICh2ID4gNjggPyBjZW50IC0gMSA6IGNlbnQpICsgdjtcbiAgICB9XSxcbiAgICBoOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5ob3VyID0gdjtcbiAgICB9XSxcbiAgICBtOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5taW51dGUgPSB2O1xuICAgIH1dLFxuICAgIHM6IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLnNlY29uZCA9IHY7XG4gICAgfV0sXG4gICAgWVlZWTogW2ZvdXJEaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLnllYXIgPSB2O1xuICAgIH1dLFxuICAgIFM6IFsvXFxkLywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubWlsbGlzZWNvbmQgPSB2ICogMTAwO1xuICAgIH1dLFxuICAgIFNTOiBbL1xcZHsyfS8sIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLm1pbGxpc2Vjb25kID0gdiAqIDEwO1xuICAgIH1dLFxuICAgIFNTUzogW3RocmVlRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5taWxsaXNlY29uZCA9IHY7XG4gICAgfV0sXG4gICAgZDogW3R3b0RpZ2l0cywgbm9vcF0sXG4gICAgZGRkOiBbd29yZCwgbm9vcF0sXG4gICAgTU1NOiBbd29yZCwgbW9udGhVcGRhdGUoJ21vbnRoTmFtZXNTaG9ydCcpXSxcbiAgICBNTU1NOiBbd29yZCwgbW9udGhVcGRhdGUoJ21vbnRoTmFtZXMnKV0sXG4gICAgYTogW3dvcmQsIGZ1bmN0aW9uIChkLCB2LCBpMThuKSB7XG4gICAgICB2YXIgdmFsID0gdi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAodmFsID09PSBpMThuLmFtUG1bMF0pIHtcbiAgICAgICAgZC5pc1BtID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzFdKSB7XG4gICAgICAgIGQuaXNQbSA9IHRydWU7XG4gICAgICB9XG4gICAgfV0sXG4gICAgWlo6IFsvKFtcXCtcXC1dXFxkXFxkOj9cXGRcXGR8WikvLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgaWYgKHYgPT09ICdaJykgdiA9ICcrMDA6MDAnO1xuICAgICAgdmFyIHBhcnRzID0gKHYgKyAnJykubWF0Y2goLyhbXFwrXFwtXXxcXGRcXGQpL2dpKSxcbiAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICBkLnRpbWV6b25lT2Zmc2V0ID0gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICAgIH1cbiAgICB9XVxuICB9O1xuICBwYXJzZUZsYWdzLmRkID0gcGFyc2VGbGFncy5kO1xuICBwYXJzZUZsYWdzLmRkZGQgPSBwYXJzZUZsYWdzLmRkZDtcbiAgcGFyc2VGbGFncy5ERCA9IHBhcnNlRmxhZ3MuRDtcbiAgcGFyc2VGbGFncy5tbSA9IHBhcnNlRmxhZ3MubTtcbiAgcGFyc2VGbGFncy5oaCA9IHBhcnNlRmxhZ3MuSCA9IHBhcnNlRmxhZ3MuSEggPSBwYXJzZUZsYWdzLmg7XG4gIHBhcnNlRmxhZ3MuTU0gPSBwYXJzZUZsYWdzLk07XG4gIHBhcnNlRmxhZ3Muc3MgPSBwYXJzZUZsYWdzLnM7XG4gIHBhcnNlRmxhZ3MuQSA9IHBhcnNlRmxhZ3MuYTsgLy8gU29tZSBjb21tb24gZm9ybWF0IHN0cmluZ3NcblxuICBmZWNoYS5tYXNrcyA9IHtcbiAgICBkZWZhdWx0OiAnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzJyxcbiAgICBzaG9ydERhdGU6ICdNL0QvWVknLFxuICAgIG1lZGl1bURhdGU6ICdNTU0gRCwgWVlZWScsXG4gICAgbG9uZ0RhdGU6ICdNTU1NIEQsIFlZWVknLFxuICAgIGZ1bGxEYXRlOiAnZGRkZCwgTU1NTSBELCBZWVlZJyxcbiAgICBzaG9ydFRpbWU6ICdISDptbScsXG4gICAgbWVkaXVtVGltZTogJ0hIOm1tOnNzJyxcbiAgICBsb25nVGltZTogJ0hIOm1tOnNzLlNTUydcbiAgfTtcbiAgLyoqKlxuICAgKiBGb3JtYXQgYSBkYXRlXG4gICAqIEBtZXRob2QgZm9ybWF0XG4gICAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ9IGRhdGVPYmpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hc2sgRm9ybWF0IG9mIHRoZSBkYXRlLCBpLmUuICdtbS1kZC15eScgb3IgJ3Nob3J0RGF0ZSdcbiAgICovXG5cbiAgZmVjaGEuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGVPYmosIG1hc2ssIGkxOG5TZXR0aW5ncykge1xuICAgIHZhciBpMThuID0gaTE4blNldHRpbmdzIHx8IGZlY2hhLmkxOG47XG5cbiAgICBpZiAodHlwZW9mIGRhdGVPYmogPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRlT2JqID0gbmV3IERhdGUoZGF0ZU9iaik7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlT2JqKSAhPT0gJ1tvYmplY3QgRGF0ZV0nIHx8IGlzTmFOKGRhdGVPYmouZ2V0VGltZSgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIERhdGUgaW4gZmVjaGEuZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgbWFzayA9IGZlY2hhLm1hc2tzW21hc2tdIHx8IG1hc2sgfHwgZmVjaGEubWFza3NbJ2RlZmF1bHQnXTtcbiAgICB2YXIgbGl0ZXJhbHMgPSBbXTsgLy8gTWFrZSBsaXRlcmFscyBpbmFjdGl2ZSBieSByZXBsYWNpbmcgdGhlbSB3aXRoID8/XG5cbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKGxpdGVyYWwsIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgIGxpdGVyYWxzLnB1c2goJDEpO1xuICAgICAgcmV0dXJuICc/Pyc7XG4gICAgfSk7IC8vIEFwcGx5IGZvcm1hdHRpbmcgcnVsZXNcblxuICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICQwIGluIGZvcm1hdEZsYWdzID8gZm9ybWF0RmxhZ3NbJDBdKGRhdGVPYmosIGkxOG4pIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSk7XG4gICAgfSk7IC8vIElubGluZSBsaXRlcmFsIHZhbHVlcyBiYWNrIGludG8gdGhlIGZvcm1hdHRlZCB2YWx1ZVxuXG4gICAgcmV0dXJuIG1hc2sucmVwbGFjZSgvXFw/XFw/L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaXRlcmFscy5zaGlmdCgpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUGFyc2UgYSBkYXRlIHN0cmluZyBpbnRvIGFuIG9iamVjdCwgY2hhbmdlcyAtIGludG8gL1xuICAgKiBAbWV0aG9kIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIERhdGUgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgRGF0ZSBwYXJzZSBmb3JtYXRcbiAgICogQHJldHVybnMge0RhdGV8Ym9vbGVhbn1cbiAgICovXG5cblxuICBmZWNoYS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRlU3RyLCBmb3JtYXQsIGkxOG5TZXR0aW5ncykge1xuICAgIHZhciBpMThuID0gaTE4blNldHRpbmdzIHx8IGZlY2hhLmkxOG47XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQgaW4gZmVjaGEucGFyc2UnKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmZWNoYS5tYXNrc1tmb3JtYXRdIHx8IGZvcm1hdDsgLy8gQXZvaWQgcmVndWxhciBleHByZXNzaW9uIGRlbmlhbCBvZiBzZXJ2aWNlLCBmYWlsIGVhcmx5IGZvciByZWFsbHkgbG9uZyBzdHJpbmdzXG4gICAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9SZWd1bGFyX2V4cHJlc3Npb25fRGVuaWFsX29mX1NlcnZpY2VfLV9SZURvU1xuXG4gICAgaWYgKGRhdGVTdHIubGVuZ3RoID4gMTAwMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB2YXIgZGF0ZUluZm8gPSB7fTtcbiAgICBmb3JtYXQucmVwbGFjZSh0b2tlbiwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICBpZiAocGFyc2VGbGFnc1skMF0pIHtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUZsYWdzWyQwXTtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0ZVN0ci5zZWFyY2goaW5mb1swXSk7XG5cbiAgICAgICAgaWYgKCF+aW5kZXgpIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZVN0ci5yZXBsYWNlKGluZm9bMF0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGluZm9bMV0oZGF0ZUluZm8sIHJlc3VsdCwgaTE4bik7XG4gICAgICAgICAgICBkYXRlU3RyID0gZGF0ZVN0ci5zdWJzdHIoaW5kZXggKyByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxhZ3NbJDBdID8gJycgOiAkMC5zbGljZSgxLCAkMC5sZW5ndGggLSAxKTtcbiAgICB9KTtcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAoZGF0ZUluZm8uaXNQbSA9PT0gdHJ1ZSAmJiBkYXRlSW5mby5ob3VyICE9IG51bGwgJiYgK2RhdGVJbmZvLmhvdXIgIT09IDEyKSB7XG4gICAgICBkYXRlSW5mby5ob3VyID0gK2RhdGVJbmZvLmhvdXIgKyAxMjtcbiAgICB9IGVsc2UgaWYgKGRhdGVJbmZvLmlzUG0gPT09IGZhbHNlICYmICtkYXRlSW5mby5ob3VyID09PSAxMikge1xuICAgICAgZGF0ZUluZm8uaG91ciA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRhdGU7XG5cbiAgICBpZiAoZGF0ZUluZm8udGltZXpvbmVPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgZGF0ZUluZm8ubWludXRlID0gKyhkYXRlSW5mby5taW51dGUgfHwgMCkgLSArZGF0ZUluZm8udGltZXpvbmVPZmZzZXQ7XG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZUluZm8ueWVhciB8fCB0b2RheS5nZXRGdWxsWWVhcigpLCBkYXRlSW5mby5tb250aCB8fCAwLCBkYXRlSW5mby5kYXkgfHwgMSwgZGF0ZUluZm8uaG91ciB8fCAwLCBkYXRlSW5mby5taW51dGUgfHwgMCwgZGF0ZUluZm8uc2Vjb25kIHx8IDAsIGRhdGVJbmZvLm1pbGxpc2Vjb25kIHx8IDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGVJbmZvLnllYXIgfHwgdG9kYXkuZ2V0RnVsbFllYXIoKSwgZGF0ZUluZm8ubW9udGggfHwgMCwgZGF0ZUluZm8uZGF5IHx8IDEsIGRhdGVJbmZvLmhvdXIgfHwgMCwgZGF0ZUluZm8ubWludXRlIHx8IDAsIGRhdGVJbmZvLnNlY29uZCB8fCAwLCBkYXRlSW5mby5taWxsaXNlY29uZCB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmVjaGE7XG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZlY2hhO1xuICAgIH0pLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2Uge1xuICAgIG1haW4uZmVjaGEgPSBmZWNoYTtcbiAgfVxufSkodGhpcyk7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzVHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdEYXRlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGF0ZTtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNGdW5jdGlvbjogX193ZWJwYWNrX3JlcXVpcmVfXygxMSksXG4gIGlzT2JqZWN0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxcbiAgaXNCb29sZWFuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKSxcbiAgaXNOaWw6IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gIGlzU3RyaW5nOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgaXNBcnJheTogX193ZWJwYWNrX3JlcXVpcmVfXyg0KSxcbiAgaXNOdW1iZXI6IF9fd2VicGFja19yZXF1aXJlX18oOSksXG4gIGlzRW1wdHk6IF9fd2VicGFja19yZXF1aXJlX18oODMpLFxuICAvLyBpc0JsYW5rXG4gIHVuaXF1ZUlkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KSxcbiAgY2xvbmU6IF9fd2VicGFja19yZXF1aXJlX18oNDYpLFxuICBkZWVwTWl4OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSxcbiAgYXNzaWduOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLFxuICAvLyBzaW1wbGVNaXhcbiAgbWVyZ2U6IF9fd2VicGFja19yZXF1aXJlX18oNDcpLFxuICAvLyBtaXhcbiAgdXBwZXJGaXJzdDogX193ZWJwYWNrX3JlcXVpcmVfXyg4NyksXG4gIC8vIHVjZmlyc3RcbiAgZWFjaDogX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgaXNFcXVhbDogX193ZWJwYWNrX3JlcXVpcmVfXyg0OSksXG4gIHRvQXJyYXk6IF9fd2VicGFja19yZXF1aXJlX18oMzQpLFxuICBleHRlbmQ6IF9fd2VicGFja19yZXF1aXJlX18oODgpLFxuICBhdWdtZW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KSxcbiAgcmVtb3ZlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKSxcbiAgaXNOdW1iZXJFcXVhbDogX193ZWJwYWNrX3JlcXVpcmVfXygzNSksXG4gIHRvUmFkaWFuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKSxcbiAgdG9EZWdyZWU6IF9fd2VicGFja19yZXF1aXJlX18oOTIpLFxuICBtb2Q6IF9fd2VicGFja19yZXF1aXJlX18oOTMpLFxuICBjbGFtcDogX193ZWJwYWNrX3JlcXVpcmVfXyg1MCksXG4gIGNyZWF0ZURvbTogX193ZWJwYWNrX3JlcXVpcmVfXyg5NCksXG4gIG1vZGlmeUNTUzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NSksXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZTogX193ZWJwYWNrX3JlcXVpcmVfXyg5NiksXG4gIGdldFJhdGlvOiBmdW5jdGlvbiBnZXRSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDI7XG4gIH0sXG4gIG1hdDM6IF9fd2VicGFja19yZXF1aXJlX18oNTEpLFxuICB2ZWMyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KSxcbiAgdmVjMzogX193ZWJwYWNrX3JlcXVpcmVfXyg5OCksXG4gIHRyYW5zZm9ybTogX193ZWJwYWNrX3JlcXVpcmVfXyg5OSlcbn07XG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiDmmK/lkKbmmK/luIPlsJTnsbvlnotcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUg5rWL6K+V55qE5YC8XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ0Jvb2xlYW4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgZ2V0VHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG52YXIgaXNQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAvKipcbiAgICogaXNFbXB0eShudWxsKSA9PiB0cnVlXG4gICAqIGlzRW1wdHkoKSA9PiB0cnVlXG4gICAqIGlzRW1wdHkodHJ1ZSkgPT4gdHJ1ZVxuICAgKiBpc0VtcHR5KDEpID0+IHRydWVcbiAgICogaXNFbXB0eShbMSwgMiwgM10pID0+IGZhbHNlXG4gICAqIGlzRW1wdHkoJ2FiYycpID0+IGZhbHNlXG4gICAqIGlzRW1wdHkoeyBhOiAxIH0pID0+IGZhbHNlXG4gICAqL1xuICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cblxuICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gIGlmICh0eXBlID09PSAnTWFwJyB8fCB0eXBlID09PSAnU2V0Jykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuXG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBnZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkucmVwbGFjZSgvXlxcW29iamVjdCAvLCAnJykucmVwbGFjZSgvXFxdJC8sICcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VHlwZTtcblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG52YXIgaXNQcm90b3R5cGUgPSBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yO1xuICB2YXIgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWFwID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICdnJztcblxuICAgIGlmICghbWFwW3ByZWZpeF0pIHtcbiAgICAgIG1hcFtwcmVmaXhdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwW3ByZWZpeF0gKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgbWFwW3ByZWZpeF07XG4gIH07XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciB1cHBlckZpcnN0ID0gZnVuY3Rpb24gdXBwZXJGaXJzdCh2YWx1ZSkge1xuICB2YXIgc3RyID0gdG9TdHJpbmcodmFsdWUpO1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXBwZXJGaXJzdDtcblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgbWl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChzdWJjbGFzcywgc3VwZXJjbGFzcywgb3ZlcnJpZGVzLCBzdGF0aWNPdmVycmlkZXMpIHtcbiAgLy8g5aaC5p6c5Y+q5o+Q5L6b54i257G75p6E6YCg5Ye95pWw77yM5YiZ6Ieq5Yqo55Sf5oiQ5a2Q57G75p6E6YCg5Ye95pWwXG4gIGlmICghaXNGdW5jdGlvbihzdXBlcmNsYXNzKSkge1xuICAgIG92ZXJyaWRlcyA9IHN1cGVyY2xhc3M7XG4gICAgc3VwZXJjbGFzcyA9IHN1YmNsYXNzO1xuXG4gICAgc3ViY2xhc3MgPSBmdW5jdGlvbiBzdWJjbGFzcygpIHt9O1xuICB9XG5cbiAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAocHJvdG8sIGMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90bywge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSA6IGZ1bmN0aW9uIChwcm90bywgYykge1xuICAgIGZ1bmN0aW9uIFRtcCgpIHt9XG5cbiAgICBUbXAucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIG8gPSBuZXcgVG1wKCk7XG4gICAgby5jb25zdHJ1Y3RvciA9IGM7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHZhciBzdXBlck9iaiA9IGNyZWF0ZShzdXBlcmNsYXNzLnByb3RvdHlwZSwgc3ViY2xhc3MpOyAvLyBuZXcgc3VwZXJjbGFzcygpLC8v5a6e5L6L5YyW54i257G75L2c5Li65a2Q57G755qEcHJvdG90eXBlXG5cbiAgc3ViY2xhc3MucHJvdG90eXBlID0gbWl4KHN1cGVyT2JqLCBzdWJjbGFzcy5wcm90b3R5cGUpOyAvLyDmjIflrprlrZDnsbvnmoRwcm90b3R5cGVcblxuICBzdWJjbGFzcy5zdXBlcmNsYXNzID0gY3JlYXRlKHN1cGVyY2xhc3MucHJvdG90eXBlLCBzdXBlcmNsYXNzKTtcbiAgbWl4KHN1cGVyT2JqLCBvdmVycmlkZXMpO1xuICBtaXgoc3ViY2xhc3MsIHN0YXRpY092ZXJyaWRlcyk7XG4gIHJldHVybiBzdWJjbGFzcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciB0b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgYXVnbWVudCA9IGZ1bmN0aW9uIGF1Z21lbnQoYykge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqID0gYXJnc1tpXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIG9iaiA9IG9iai5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgbWl4KGMucHJvdG90eXBlLCBvYmopO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF1Z21lbnQ7XG5cbi8qKiovIH0pLFxuLyogOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGFyclByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBzcGxpY2UgPSBhcnJQcm90b3R5cGUuc3BsaWNlO1xudmFyIGluZGV4T2YgPSBhcnJQcm90b3R5cGUuaW5kZXhPZjtcbnZhciBzbGljZSA9IGFyclByb3RvdHlwZS5zbGljZTtcblxudmFyIHB1bGwgPSBmdW5jdGlvbiBwdWxsKGFycikge1xuICB2YXIgdmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIHZhciBmcm9tSW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZi5jYWxsKGFyciwgdmFsdWUpKSA+IC0xKSB7XG4gICAgICBzcGxpY2UuY2FsbChhcnIsIGZyb21JbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHVsbDtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcblxudmFyIHRvUmFkaWFuID0gZnVuY3Rpb24gdG9SYWRpYW4oZGVncmVlKSB7XG4gIHJldHVybiBSQURJQU4gKiBkZWdyZWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUmFkaWFuO1xuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBERUdSRUUgPSAxODAgLyBNYXRoLlBJO1xuXG52YXIgdG9EZWdyZWUgPSBmdW5jdGlvbiB0b0RlZ3JlZShyYWRpYW4pIHtcbiAgcmV0dXJuIERFR1JFRSAqIHJhZGlhbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdG9EZWdyZWU7XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIG1vZCA9IGZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gIHJldHVybiAobiAlIG0gKyBtKSAlIG07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZDtcblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIOWIm+W7ukRPTSDoioLngrlcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyIERvbSDlrZfnrKbkuLJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgRE9NIOiKgueCuVxuICovXG52YXIgVEFCTEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xudmFyIFRBQkxFX1RSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbnZhciBGUkFHTUVOVF9SRUcgPSAvXlxccyo8KFxcdyt8ISlbXj5dKj4vO1xudmFyIENPTlRBSU5FUlMgPSB7XG4gIHRyOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxuICB0Ym9keTogVEFCTEUsXG4gIHRoZWFkOiBUQUJMRSxcbiAgdGZvb3Q6IFRBQkxFLFxuICB0ZDogVEFCTEVfVFIsXG4gIHRoOiBUQUJMRV9UUixcbiAgJyonOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVEb20oc3RyKSB7XG4gIHZhciBuYW1lID0gRlJBR01FTlRfUkVHLnRlc3Qoc3RyKSAmJiBSZWdFeHAuJDE7XG5cbiAgaWYgKCEobmFtZSBpbiBDT05UQUlORVJTKSkge1xuICAgIG5hbWUgPSAnKic7XG4gIH1cblxuICB2YXIgY29udGFpbmVyID0gQ09OVEFJTkVSU1tuYW1lXTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoLyheXFxzKil8KFxccyokKS9nLCAnJyk7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJyArIHN0cjtcbiAgdmFyIGRvbSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzWzBdO1xuICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgcmV0dXJuIGRvbTtcbn07XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2RpZnlDU1MoZG9tLCBjc3MpIHtcbiAgaWYgKGRvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBjc3MpIHtcbiAgICAgIGlmIChjc3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkb20uc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb207XG59O1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gIHZhciBtZXRob2QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDE2KTtcbiAgfTtcblxuICByZXR1cm4gbWV0aG9kKGZuKTtcbn07XG5cbi8qKiovIH0pLFxuLyogOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHZlYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4Myk7XG5cbnZhciBjbGFtcCA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXG52ZWMyLmFuZ2xlID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICB2YXIgdGhldGEgPSB2ZWMyLmRvdCh2MSwgdjIpIC8gKHZlYzIubGVuZ3RoKHYxKSAqIHZlYzIubGVuZ3RoKHYyKSk7XG4gIHJldHVybiBNYXRoLmFjb3MoY2xhbXAodGhldGEsIC0xLCAxKSk7XG59O1xuLyoqXG4gKiDlkJHph48gdjEg5YiwIOWQkemHjyB2MiDlpLnop5LnmoTmlrnlkJFcbiAqIEBwYXJhbSAge0FycmF5fSB2MSDlkJHph49cbiAqIEBwYXJhbSAge0FycmF5fSB2MiDlkJHph49cbiAqIEByZXR1cm4ge0Jvb2xlYW59ID49IDAg6aG65pe26ZKIIDwgMCDpgIbml7bpkohcbiAqL1xuXG5cbnZlYzIuZGlyZWN0aW9uID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlsxXSAtIHYyWzBdICogdjFbMV07XG59O1xuXG52ZWMyLmFuZ2xlVG8gPSBmdW5jdGlvbiAodjEsIHYyLCBkaXJlY3QpIHtcbiAgdmFyIGFuZ2xlID0gdmVjMi5hbmdsZSh2MSwgdjIpO1xuICB2YXIgYW5nbGVMYXJnZVRoYW5QSSA9IHZlYzIuZGlyZWN0aW9uKHYxLCB2MikgPj0gMDtcblxuICBpZiAoZGlyZWN0KSB7XG4gICAgaWYgKGFuZ2xlTGFyZ2VUaGFuUEkpIHtcbiAgICAgIHJldHVybiBNYXRoLlBJICogMiAtIGFuZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBhbmdsZTtcbiAgfVxuXG4gIGlmIChhbmdsZUxhcmdlVGhhblBJKSB7XG4gICAgcmV0dXJuIGFuZ2xlO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguUEkgKiAyIC0gYW5nbGU7XG59O1xuXG52ZWMyLnZlcnRpY2FsID0gZnVuY3Rpb24gKG91dCwgdiwgZmxhZykge1xuICBpZiAoZmxhZykge1xuICAgIG91dFswXSA9IHZbMV07XG4gICAgb3V0WzFdID0gLTEgKiB2WzBdO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IC0xICogdlsxXTtcbiAgICBvdXRbMV0gPSB2WzBdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMjtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdmVjMyA9IF9fd2VicGFja19yZXF1aXJlX18oMTg0KTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBtYXQzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtKG0sIHRzKSB7XG4gIG0gPSBjbG9uZShtKTtcbiAgZWFjaCh0cywgZnVuY3Rpb24gKHQpIHtcbiAgICBzd2l0Y2ggKHRbMF0pIHtcbiAgICAgIGNhc2UgJ3QnOlxuICAgICAgICBtYXQzLnRyYW5zbGF0ZShtLCBtLCBbdFsxXSwgdFsyXV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6XG4gICAgICAgIG1hdDMuc2NhbGUobSwgbSwgW3RbMV0sIHRbMl1dKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3InOlxuICAgICAgICBtYXQzLnJvdGF0ZShtLCBtLCB0WzFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBtYXQzLm11bHRpcGx5KG0sIG0sIHRbMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgRXZlbnQgPSBmdW5jdGlvbiBFdmVudCh0eXBlLCBldmVudCwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlOyAvLyDkuovku7bnsbvlnotcblxuICB0aGlzLnRhcmdldCA9IG51bGw7IC8vIOebruagh1xuXG4gIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7IC8vIOW9k+WJjeebruagh1xuXG4gIHRoaXMuYnViYmxlcyA9IGJ1YmJsZXM7IC8vIOWGkuazoVxuXG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7IC8vIOaYr+WQpuiDveWkn+mYu+atolxuXG4gIHRoaXMudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7IC8vIOaXtumXtOaIs1xuXG4gIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlOyAvLyDpmLvmraLpu5jorqRcblxuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlOyAvLyDpmLvmraLlhpLms6FcblxuICB0aGlzLnJlbW92ZWQgPSBmYWxzZTsgLy8g5piv5ZCm6KKr56e76ZmkXG5cbiAgdGhpcy5ldmVudCA9IGV2ZW50OyAvLyDop6blj5HnmoTljp/nlJ/kuovku7Zcbn07XG5cblV0aWwuYXVnbWVudChFdmVudCwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdGhpcy5jYW5jZWxhYmxlICYmIHRydWU7XG4gIH0sXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdGhpcy5yZW1vdmUgPSB0cnVlO1xuICB9LFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIFV0aWwuY2xvbmUodGhpcyk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tFdmVudCAodHlwZT0nICsgdGhpcy50eXBlICsgJyldJztcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG4vKioqLyB9KSxcbi8qIDEwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4OCk7XG5cbnZhciBTSEFQRV9NQVAgPSB7fTsgLy8g57yT5a2Y5Zu+5b2i57G75Z6LXG5cbnZhciBJTkRFWCA9ICdfSU5ERVgnO1xuXG5mdW5jdGlvbiBnZXRDb21wYXJlcihjb21wYXJlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZShsZWZ0LCByaWdodCk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gMCA/IGxlZnRbSU5ERVhdIC0gcmlnaHRbSU5ERVhdIDogcmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kKGNoaWxkcmVuLCB4LCB5KSB7XG4gIHZhciByc3Q7XG5cbiAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuX2NmZy52aXNpYmxlICYmIGNoaWxkLl9jZmcuY2FwdHVyZSkge1xuICAgICAgaWYgKGNoaWxkLmlzR3JvdXApIHtcbiAgICAgICAgcnN0ID0gY2hpbGQuZ2V0U2hhcGUoeCwgeSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzSGl0KHgsIHkpKSB7XG4gICAgICAgIHJzdCA9IGNoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyc3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByc3Q7XG59XG5cbnZhciBHcm91cCA9IGZ1bmN0aW9uIEdyb3VwKGNmZykge1xuICBHcm91cC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY2ZnKTtcbiAgdGhpcy5zZXQoJ2NoaWxkcmVuJywgW10pO1xuICB0aGlzLnNldCgndG9iZVJlbW92ZWQnLCBbXSk7XG5cbiAgdGhpcy5fYmVmb3JlUmVuZGVyVUkoKTtcblxuICB0aGlzLl9yZW5kZXJVSSgpO1xuXG4gIHRoaXMuX2JpbmRVSSgpO1xufTtcblxuZnVuY3Rpb24gaW5pdENsYXNzQ2ZncyhjKSB7XG4gIGlmIChjLl9jZmcgfHwgYyA9PT0gR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3VwZXJDb24gPSBjLnN1cGVyY2xhc3MuY29uc3RydWN0b3I7XG5cbiAgaWYgKHN1cGVyQ29uICYmICFzdXBlckNvbi5fY2ZnKSB7XG4gICAgaW5pdENsYXNzQ2ZncyhzdXBlckNvbik7XG4gIH1cblxuICBjLl9jZmcgPSB7fTtcbiAgVXRpbC5tZXJnZShjLl9jZmcsIHN1cGVyQ29uLl9jZmcpO1xuICBVdGlsLm1lcmdlKGMuX2NmZywgYy5DRkcpO1xufVxuXG5VdGlsLmV4dGVuZChHcm91cCwgRWxlbWVudCk7XG5VdGlsLmF1Z21lbnQoR3JvdXAsIHtcbiAgaXNHcm91cDogdHJ1ZSxcbiAgdHlwZTogJ2dyb3VwJyxcbiAgY2FuRmlsbDogdHJ1ZSxcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICBnZXREZWZhdWx0Q2ZnOiBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIGluaXRDbGFzc0NmZ3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgcmV0dXJuIFV0aWwubWVyZ2Uoe30sIHRoaXMuY29uc3RydWN0b3IuX2NmZyk7XG4gIH0sXG4gIF9iZWZvcmVSZW5kZXJVSTogZnVuY3Rpb24gX2JlZm9yZVJlbmRlclVJKCkge30sXG4gIF9yZW5kZXJVSTogZnVuY3Rpb24gX3JlbmRlclVJKCkge30sXG4gIF9iaW5kVUk6IGZ1bmN0aW9uIF9iaW5kVUkoKSB7fSxcbiAgYWRkU2hhcGU6IGZ1bmN0aW9uIGFkZFNoYXBlKHR5cGUsIGNmZykge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgY2ZnID0gY2ZnIHx8IHt9O1xuICAgIHZhciBzaGFwZVR5cGUgPSBTSEFQRV9NQVBbdHlwZV07XG5cbiAgICBpZiAoIXNoYXBlVHlwZSkge1xuICAgICAgc2hhcGVUeXBlID0gVXRpbC51cHBlckZpcnN0KHR5cGUpO1xuICAgICAgU0hBUEVfTUFQW3R5cGVdID0gc2hhcGVUeXBlO1xuICAgIH1cblxuICAgIGlmIChjZmcuYXR0cnMgJiYgY2FudmFzKSB7XG4gICAgICB2YXIgYXR0cnMgPSBjZmcuYXR0cnM7XG5cbiAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgLy8g5Li05pe26Kej5YazXG4gICAgICAgIHZhciB0b3BGb250RmFtaWx5ID0gY2FudmFzLmdldCgnZm9udEZhbWlseScpO1xuXG4gICAgICAgIGlmICh0b3BGb250RmFtaWx5KSB7XG4gICAgICAgICAgYXR0cnMuZm9udEZhbWlseSA9IGF0dHJzLmZvbnRGYW1pbHkgPyBhdHRycy5mb250RmFtaWx5IDogdG9wRm9udEZhbWlseTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNmZy5jYW52YXMgPSBjYW52YXM7XG4gICAgY2ZnLnR5cGUgPSB0eXBlO1xuICAgIHZhciByc3QgPSBuZXcgU2hhcGVbc2hhcGVUeXBlXShjZmcpO1xuICAgIHRoaXMuYWRkKHJzdCk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfSxcblxuICAvKiog5re75Yqg5Zu+57uEXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufE9iamVjdHx1bmRlZmluZWR9IHBhcmFtIOWbvue7hOexu1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNmZyDphY3nva7poblcbiAgICogQHJldHVybiB7T2JqZWN0fSByc3Qg5Zu+57uEXG4gICAqL1xuICBhZGRHcm91cDogZnVuY3Rpb24gYWRkR3JvdXAocGFyYW0sIGNmZykge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHJzdDtcbiAgICBjZmcgPSBVdGlsLm1lcmdlKHt9LCBjZmcpO1xuXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihwYXJhbSkpIHtcbiAgICAgIGlmIChjZmcpIHtcbiAgICAgICAgY2ZnLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgY2ZnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHJzdCA9IG5ldyBwYXJhbShjZmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnN0ID0gbmV3IHBhcmFtKHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkKHJzdCk7XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzT2JqZWN0KHBhcmFtKSkge1xuICAgICAgcGFyYW0uY2FudmFzID0gY2FudmFzO1xuICAgICAgcnN0ID0gbmV3IEdyb3VwKHBhcmFtKTtcbiAgICAgIHRoaXMuYWRkKHJzdCk7XG4gICAgfSBlbHNlIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByc3QgPSBuZXcgR3JvdXAoKTtcbiAgICAgIHRoaXMuYWRkKHJzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9LFxuXG4gIC8qKiDnu5jliLbog4zmma9cbiAgICogQHBhcmFtICB7QXJyYXl9IHBhZGRpbmcg5YaF6L656LedXG4gICAqIEBwYXJhbSAge0F0dHJzfSBhdHRycyDlm77lvaLlsZ7mgKdcbiAgICogQHBhcmFtICB7U2hhcGV9IGJhY2tTaGFwZSDog4zmma/lm77lvaJcbiAgICogQHJldHVybiB7T2JqZWN0fSDog4zmma/lsYLlr7nosaFcbiAgICovXG4gIHJlbmRlckJhY2s6IGZ1bmN0aW9uIHJlbmRlckJhY2socGFkZGluZywgYXR0cnMpIHtcbiAgICB2YXIgYmFja1NoYXBlID0gdGhpcy5nZXQoJ2JhY2tTaGFwZScpO1xuICAgIHZhciBpbm5lckJveCA9IHRoaXMuZ2V0QkJveCgpOyAvLyBjb25zdCBwYXJlbnQgPSB0aGlzLmdldCgncGFyZW50Jyk7IC8vIGdldFBhcmVudFxuXG4gICAgVXRpbC5tZXJnZShhdHRycywge1xuICAgICAgeDogaW5uZXJCb3gubWluWCAtIHBhZGRpbmdbM10sXG4gICAgICB5OiBpbm5lckJveC5taW5ZIC0gcGFkZGluZ1swXSxcbiAgICAgIHdpZHRoOiBpbm5lckJveC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdLFxuICAgICAgaGVpZ2h0OiBpbm5lckJveC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXVxuICAgIH0pO1xuXG4gICAgaWYgKGJhY2tTaGFwZSkge1xuICAgICAgYmFja1NoYXBlLmF0dHIoYXR0cnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrU2hhcGUgPSB0aGlzLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBhdHRyczogYXR0cnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdiYWNrU2hhcGUnLCBiYWNrU2hhcGUpO1xuICAgIHRoaXMuc29ydCgpO1xuICAgIHJldHVybiBiYWNrU2hhcGU7XG4gIH0sXG4gIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiByZW1vdmVDaGlsZChpdGVtLCBkZXN0cm95KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRoaXMuY29udGFpbihpdGVtKSkge1xuICAgICAgICBpdGVtLnJlbW92ZShkZXN0cm95KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKFV0aWwuaXNCb29sZWFuKGl0ZW0pKSB7XG4gICAgICAgICAgZGVzdHJveSA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbihpdGVtKSkge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVzdHJveSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIEdyb3VwLnN1cGVyY2xhc3MucmVtb3ZlLmNhbGwodGhpcywgZGVzdHJveSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWQkee7hOS4rea3u+WKoHNoYXBl5oiW6ICFZ3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1zIOWbvuW9ouaIluiAheWIhue7hFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGdyb3VwIOacrOWwilxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQoaXRlbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoaWxkcmVuID0gc2VsZi5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gaXRlbS5nZXQoJ3BhcmVudCcpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fc2V0Q2ZnUHJvcGVydHkoaXRlbSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuX2NmZy5jaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChpdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVtID0gaXRlbXM7XG4gICAgICB2YXIgcGFyZW50ID0gaXRlbS5nZXQoJ3BhcmVudCcpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpdGVtLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3NldENmZ1Byb3BlcnR5KGl0ZW0pO1xuXG4gICAgICBjaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBfc2V0Q2ZnUHJvcGVydHk6IGZ1bmN0aW9uIF9zZXRDZmdQcm9wZXJ0eShpdGVtKSB7XG4gICAgdmFyIGNmZyA9IHRoaXMuX2NmZztcbiAgICBpdGVtLnNldCgncGFyZW50JywgdGhpcyk7XG4gICAgaXRlbS5zZXQoJ2NhbnZhcycsIGNmZy5jYW52YXMpO1xuXG4gICAgaWYgKGNmZy50aW1lbGluZSkge1xuICAgICAgaXRlbS5zZXQoJ3RpbWVsaW5lJywgY2ZnLnRpbWVsaW5lKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uIGNvbnRhaW4oaXRlbSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHJldHVybiBjaGlsZHJlbi5pbmRleE9mKGl0ZW0pID4gLTE7XG4gIH0sXG4gIGdldENoaWxkQnlJbmRleDogZnVuY3Rpb24gZ2V0Q2hpbGRCeUluZGV4KGluZGV4KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuW2luZGV4XTtcbiAgfSxcbiAgZ2V0Rmlyc3Q6IGZ1bmN0aW9uIGdldEZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkQnlJbmRleCgwKTtcbiAgfSxcbiAgZ2V0TGFzdDogZnVuY3Rpb24gZ2V0TGFzdCgpIHtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5nZXQoJ2NoaWxkcmVuJykubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZEJ5SW5kZXgobGFzdEluZGV4KTtcbiAgfSxcbiAgZ2V0QkJveDogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgIHZhciBjaGlsZHJlbiA9IHNlbGYuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIFV0aWwuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5nZXQoJ3Zpc2libGUnKSkge1xuICAgICAgICAgIGlmIChjaGlsZC5pc0dyb3VwICYmIGNoaWxkLmdldCgnY2hpbGRyZW4nKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2JveCA9IGNoaWxkLmdldEJCb3goKTtcblxuICAgICAgICAgIGlmICghX2JveCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlZnRUb3AgPSBbX2JveC5taW5YLCBfYm94Lm1pblksIDFdO1xuICAgICAgICAgIHZhciBsZWZ0Qm90dG9tID0gW19ib3gubWluWCwgX2JveC5tYXhZLCAxXTtcbiAgICAgICAgICB2YXIgcmlnaHRUb3AgPSBbX2JveC5tYXhYLCBfYm94Lm1pblksIDFdO1xuICAgICAgICAgIHZhciByaWdodEJvdHRvbSA9IFtfYm94Lm1heFgsIF9ib3gubWF4WSwgMV07XG4gICAgICAgICAgY2hpbGQuYXBwbHkobGVmdFRvcCk7XG4gICAgICAgICAgY2hpbGQuYXBwbHkobGVmdEJvdHRvbSk7XG4gICAgICAgICAgY2hpbGQuYXBwbHkocmlnaHRUb3ApO1xuICAgICAgICAgIGNoaWxkLmFwcGx5KHJpZ2h0Qm90dG9tKTtcbiAgICAgICAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKGxlZnRUb3BbMF0sIGxlZnRCb3R0b21bMF0sIHJpZ2h0VG9wWzBdLCByaWdodEJvdHRvbVswXSk7XG4gICAgICAgICAgdmFyIGJveE1heFggPSBNYXRoLm1heChsZWZ0VG9wWzBdLCBsZWZ0Qm90dG9tWzBdLCByaWdodFRvcFswXSwgcmlnaHRCb3R0b21bMF0pO1xuICAgICAgICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4obGVmdFRvcFsxXSwgbGVmdEJvdHRvbVsxXSwgcmlnaHRUb3BbMV0sIHJpZ2h0Qm90dG9tWzFdKTtcbiAgICAgICAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KGxlZnRUb3BbMV0sIGxlZnRCb3R0b21bMV0sIHJpZ2h0VG9wWzFdLCByaWdodEJvdHRvbVsxXSk7XG5cbiAgICAgICAgICBpZiAoYm94TWluWCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSBib3hNaW5YO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3hNYXhYID4gbWF4WCkge1xuICAgICAgICAgICAgbWF4WCA9IGJveE1heFg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJveE1pblkgPCBtaW5ZKSB7XG4gICAgICAgICAgICBtaW5ZID0gYm94TWluWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYm94TWF4WSA+IG1heFkpIHtcbiAgICAgICAgICAgIG1heFkgPSBib3hNYXhZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblggPSAwO1xuICAgICAgbWF4WCA9IDA7XG4gICAgICBtaW5ZID0gMDtcbiAgICAgIG1heFkgPSAwO1xuICAgIH1cblxuICAgIHZhciBib3ggPSB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZXG4gICAgfTtcbiAgICBib3gueCA9IGJveC5taW5YO1xuICAgIGJveC55ID0gYm94Lm1pblk7XG4gICAgYm94LndpZHRoID0gYm94Lm1heFggLSBib3gubWluWDtcbiAgICBib3guaGVpZ2h0ID0gYm94Lm1heFkgLSBib3gubWluWTtcbiAgICByZXR1cm4gYm94O1xuICB9LFxuICBnZXRDb3VudDogZnVuY3Rpb24gZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjaGlsZHJlbicpLmxlbmd0aDtcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTsgLy8g56iz5a6a5o6S5bqPXG5cbiAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIGNoaWxkW0lOREVYXSA9IGluZGV4O1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICAgIGNoaWxkcmVuLnNvcnQoZ2V0Q29tcGFyZXIoZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICAgIHJldHVybiBvYmoxLmdldCgnekluZGV4JykgLSBvYmoyLmdldCgnekluZGV4Jyk7XG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmaW5kQnlJZDogZnVuY3Rpb24gZmluZEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5nZXQoJ2lkJykgPT09IGlkO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmoLnmja7mn6Xmib7lh73mlbDmn6Xmib7liIbnu4TmiJbogIXlm77lvaJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuIOWMuemFjeWHveaVsFxuICAgKiBAcmV0dXJuIHtDYW52YXMuQmFzZX0g5YiG57uE5oiW6ICF5Zu+5b2iXG4gICAqL1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGZuKSB7XG4gICAgaWYgKFV0aWwuaXNTdHJpbmcoZm4pKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kQnlJZChmbik7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIHJzdCA9IG51bGw7XG4gICAgVXRpbC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGZuKGl0ZW0pKSB7XG4gICAgICAgIHJzdCA9IGl0ZW07XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZmluZCkge1xuICAgICAgICByc3QgPSBpdGVtLmZpbmQoZm4pO1xuICAgICAgfVxuXG4gICAgICBpZiAocnN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gZmlsdGVyIG1hdGhvZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gYWxsIHRoZSBtYXRjaGluZyBzaGFwZXMgYW5kIGdyb3Vwc1xuICAgKi9cbiAgZmluZEFsbDogZnVuY3Rpb24gZmluZEFsbChmbikge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciByc3QgPSBbXTtcbiAgICB2YXIgY2hpbGRSc3QgPSBbXTtcbiAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoZm4oaXRlbSkpIHtcbiAgICAgICAgcnN0LnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLmZpbmRBbGxCeSkge1xuICAgICAgICBjaGlsZFJzdCA9IGl0ZW0uZmluZEFsbEJ5KGZuKTtcbiAgICAgICAgcnN0ID0gcnN0LmNvbmNhdChjaGlsZFJzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfSxcblxuICAvKipcbiAgICogQERlcHJlY2F0ZWRcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuIGZpbHRlciBtZXRob2RcbiAgICogQHJldHVybiB7T2JqZWN0fSBmb3VuZCBzaGFwZSBvciBncm91cFxuICAgKi9cbiAgZmluZEJ5OiBmdW5jdGlvbiBmaW5kQnkoZm4pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcbiAgICB2YXIgcnN0ID0gbnVsbDtcbiAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoZm4oaXRlbSkpIHtcbiAgICAgICAgcnN0ID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5maW5kQnkpIHtcbiAgICAgICAgcnN0ID0gaXRlbS5maW5kQnkoZm4pO1xuICAgICAgfVxuXG4gICAgICBpZiAocnN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBARGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gZmlsdGVyIG1hdGhvZFxuICAgKiBAcmV0dXJuIHtBcnJheX0gYWxsIHRoZSBtYXRjaGluZyBzaGFwZXMgYW5kIGdyb3Vwc1xuICAgKi9cbiAgZmluZEFsbEJ5OiBmdW5jdGlvbiBmaW5kQWxsQnkoZm4pIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldCgnY2hpbGRyZW4nKTtcbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIGNoaWxkUnN0ID0gW107XG4gICAgVXRpbC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGZuKGl0ZW0pKSB7XG4gICAgICAgIHJzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbS5maW5kQWxsQnkpIHtcbiAgICAgICAgY2hpbGRSc3QgPSBpdGVtLmZpbmRBbGxCeShmbik7XG4gICAgICAgIHJzdCA9IHJzdC5jb25jYXQoY2hpbGRSc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGdldFNoYXBlOiBmdW5jdGlvbiBnZXRTaGFwZSh4LCB5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjbGlwID0gc2VsZi5fYXR0cnMuY2xpcDtcbiAgICB2YXIgY2hpbGRyZW4gPSBzZWxmLl9jZmcuY2hpbGRyZW47XG4gICAgdmFyIHJzdDtcblxuICAgIGlmIChjbGlwKSB7XG4gICAgICB2YXIgdiA9IFt4LCB5LCAxXTtcbiAgICAgIGNsaXAuaW52ZXJ0KHYsIHNlbGYuZ2V0KCdjYW52YXMnKSk7IC8vIOW3sue7j+WcqOWklumdoui9rOaNolxuXG4gICAgICBpZiAoY2xpcC5pc1BvaW50SW5QYXRoKHZbMF0sIHZbMV0pKSB7XG4gICAgICAgIHJzdCA9IGZpbmQoY2hpbGRyZW4sIHgsIHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByc3QgPSBmaW5kKGNoaWxkcmVuLCB4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9LFxuICBjbGVhclRvdGFsTWF0cml4OiBmdW5jdGlvbiBjbGVhclRvdGFsTWF0cml4KCkge1xuICAgIHZhciBtID0gdGhpcy5nZXQoJ3RvdGFsTWF0cml4Jyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgdGhpcy5zZXRTaWxlbnQoJ3RvdGFsTWF0cml4JywgbnVsbCk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jZmcuY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLmNsZWFyVG90YWxNYXRyaXgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcihkZWxheVJlbW92ZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NmZy5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY2hpbGRyZW5baV0ucmVtb3ZlKHRydWUsIGRlbGF5UmVtb3ZlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jZmcuY2hpbGRyZW4gPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIEdyb3VwLnN1cGVyY2xhc3MuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9LFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGlsZHJlbiA9IHNlbGYuX2NmZy5jaGlsZHJlbjtcbiAgICB2YXIgY2xvbmUgPSBuZXcgR3JvdXAoKTtcbiAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2xvbmUuYWRkKGNoaWxkLmNsb25lKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBBdHRyaWJ1dGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NSk7XG5cbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4Nik7XG5cbnZhciBBbmltYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODcpO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gRWxlbWVudChjZmcpIHtcbiAgdGhpcy5fY2ZnID0ge1xuICAgIHpJbmRleDogMCxcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgZGVzdHJveWVkOiBmYWxzZVxuICB9OyAvLyDphY3nva7lrZjmlL7lnLBcblxuICBVdGlsLmFzc2lnbih0aGlzLl9jZmcsIHRoaXMuZ2V0RGVmYXVsdENmZygpLCBjZmcpOyAvLyBFbGVtZW50LkNGR+S4jeWQiOW5tu+8jOaPkOWNh+aAp+iDvSDlkIjlubbpu5jorqTphY3nva7vvIznlKjmiLfphY3nva4tPue7p+aJv+m7mOiupOmFjee9ri0+RWxlbWVudOm7mOiupOmFjee9rlxuXG4gIHRoaXMuaW5pdEF0dHJzKHRoaXMuX2NmZy5hdHRycyk7IC8vIOWIneWni+WMlue7mOWbvuWxnuaAp1xuXG4gIHRoaXMuX2NmZy5hdHRycyA9IHt9O1xuICB0aGlzLmluaXRUcmFuc2Zvcm0oKTsgLy8g5Yid5aeL5YyW5Y+Y5o2iXG5cbiAgdGhpcy5pbml0KCk7IC8vIOexu+Wei+WIneWni+WMllxufTtcblxuRWxlbWVudC5DRkcgPSB7XG4gIC8qKlxuICAgKiDllK/kuIDmoIfnpLpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGlkOiBudWxsLFxuXG4gIC8qKlxuICAgKiBa6L2055qE5bGC5Y+g5YWz57O777yMWuWAvOi2iuWkp+emu+eUqOaIt+i2iui/kVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgekluZGV4OiAwLFxuXG4gIC8qKlxuICAgKiBDYW52YXPlr7nosaFcbiAgICogQHR5cGU6IHtPYmplY3R9XG4gICAqL1xuICBjYW52YXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIOeItuWFg+e0oOaMh+mSiFxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcGFyZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiDnlKjmnaXorr7nva7lvZPliY3lr7nosaHmmK/lkKbog73ooqvmjZXmjYlcbiAgICogdHJ1ZSDog71cbiAgICogZmFsc2Ug5LiN6IO9XG4gICAqIOWvueixoem7mOiupOaYr+mDveWPr+S7peiiq+aNleaNieeahCwg5b2TY2FwdHVyZeS4umZhbHNl5pe277yMZ3JvdXAuZ2V0U2hhcGUoeCwgeSnmlrnms5Xml6Dms5Xojrflvpfor6XlhYPntKBcbiAgICog6YCa6L+H5bCG5LiN5b+F6KaB5o2V5o2J55qE5YWD57Sg55qE6K+l5bGe5oCn6K6+572u5oiQZmFsc2UsIOadpeaPkOmrmOaNleaNieaAp+iDvVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICoqL1xuICBjYXB0dXJlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiDnlLvluIPnmoTkuIrkuIvmlodcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGNvbnRleHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuaYvuekulxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHZpc2libGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIOaYr+WQpuiiq+mUgOavgVxuICAgKiBAdHlwZToge0Jvb2xlYW59XG4gICAqL1xuICBkZXN0cm95ZWQ6IGZhbHNlXG59O1xuVXRpbC5hdWdtZW50KEVsZW1lbnQsIEF0dHJpYnV0ZSwgVHJhbnNmb3JtLCBFdmVudEVtaXR0ZXIsIEFuaW1hdGUsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLnNldFNpbGVudCgnYW5pbWFibGUnLCB0cnVlKTtcbiAgICB0aGlzLnNldFNpbGVudCgnYW5pbWF0aW5nJywgZmFsc2UpOyAvLyDliJ3lp4vml7bkuI3lpITkuo7liqjnlLvnirbmgIFcbiAgfSxcbiAgZ2V0UGFyZW50OiBmdW5jdGlvbiBnZXRQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZy5wYXJlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlum7mOiupOeahOmFjee9ruS/oeaBr1xuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0g6buY6K6k55qE5bGe5oCnXG4gICAqL1xuICBnZXREZWZhdWx0Q2ZnOiBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3pJbmRleCcgJiYgdGhpcy5fYmVmb3JlU2V0WkluZGV4KSB7XG4gICAgICB0aGlzLl9iZWZvcmVTZXRaSW5kZXgodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnbG9hZGluZycgJiYgdGhpcy5fYmVmb3JlU2V0TG9hZGluZykge1xuICAgICAgdGhpcy5fYmVmb3JlU2V0TG9hZGluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2ZnW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGRlcHJlY2F0ZWRcbiAgc2V0U2lsZW50OiBmdW5jdGlvbiBzZXRTaWxlbnQobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9jZmdbbmFtZV0gPSB2YWx1ZTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9jZmdbbmFtZV07XG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5fY2ZnLnZpc2libGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuX2NmZy52aXNpYmxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGRlc3Ryb3ksIGRlbGF5UmVtb3ZlKSB7XG4gICAgdmFyIGNmZyA9IHRoaXMuX2NmZztcbiAgICB2YXIgcGFyZW50ID0gY2ZnLnBhcmVudDtcbiAgICB2YXIgZWwgPSBjZmcuZWw7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBVdGlsLnJlbW92ZShwYXJlbnQuZ2V0KCdjaGlsZHJlbicpLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChkZWxheVJlbW92ZSkge1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50Ll9jZmcudG9iZVJlbW92ZWQucHVzaChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVzdHJveSB8fCBkZXN0cm95ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBkZXN0cm95ZWQgPSB0aGlzLmdldCgnZGVzdHJveWVkJyk7XG5cbiAgICBpZiAoZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYXR0cnMgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnQoKTsgLy8g56e76Zmk5omA5pyJ55qE5LqL5Lu2XG5cbiAgICB0aGlzLl9jZmcgPSB7XG4gICAgICBkZXN0cm95ZWQ6IHRydWVcbiAgICB9O1xuICB9LFxuICB0b0Zyb250OiBmdW5jdGlvbiB0b0Zyb250KCkge1xuICAgIHZhciBjZmcgPSB0aGlzLl9jZmc7XG4gICAgdmFyIHBhcmVudCA9IGNmZy5wYXJlbnQ7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fY2ZnLmNoaWxkcmVuO1xuICAgIHZhciBlbCA9IGNmZy5lbDtcbiAgICB2YXIgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgIGNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgY2hpbGRyZW4ucHVzaCh0aGlzKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICBjZmcuZWwgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgdG9CYWNrOiBmdW5jdGlvbiB0b0JhY2soKSB7XG4gICAgdmFyIGNmZyA9IHRoaXMuX2NmZztcbiAgICB2YXIgcGFyZW50ID0gY2ZnLnBhcmVudDtcblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jZmcuY2hpbGRyZW47XG4gICAgdmFyIGVsID0gY2ZnLmVsO1xuICAgIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICBjaGlsZHJlbi51bnNoaWZ0KHRoaXMpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgX2JlZm9yZVNldFpJbmRleDogZnVuY3Rpb24gX2JlZm9yZVNldFpJbmRleCh6SW5kZXgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fY2ZnLnBhcmVudDtcbiAgICB0aGlzLl9jZmcuekluZGV4ID0gekluZGV4O1xuXG4gICAgaWYgKCFVdGlsLmlzTmlsKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudC5zb3J0KCk7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gdGhpcy5fY2ZnLmVsO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NmZy5jaGlsZHJlbjtcbiAgICAgIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcblxuICAgICAgaWYgKGluZGV4ID09PSBjaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudE5vZGUuY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB6SW5kZXg7XG4gIH0sXG4gIF9zZXRBdHRyczogZnVuY3Rpb24gX3NldEF0dHJzKGF0dHJzKSB7XG4gICAgdGhpcy5hdHRyKGF0dHJzKTtcbiAgICByZXR1cm4gYXR0cnM7XG4gIH0sXG4gIHNldFpJbmRleDogZnVuY3Rpb24gc2V0WkluZGV4KHpJbmRleCkge1xuICAgIHRoaXMuX2NmZy56SW5kZXggPSB6SW5kZXg7XG4gICAgcmV0dXJuIHRoaXMuX2JlZm9yZVNldFpJbmRleCh6SW5kZXgpO1xuICB9LFxuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIFV0aWwuY2xvbmUodGhpcyk7XG4gIH0sXG4gIGdldEJCb3g6IGZ1bmN0aW9uIGdldEJCb3goKSB7fVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cbi8qKiovIH0pLFxuLyogMTAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHZlYzIgPSBVdGlsLnZlYzI7XG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgb3V0KSB7XG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIGQxO1xuICB2YXIgdjE7XG4gIHZhciB2MjtcblxuICB2YXIgX3Q7XG5cbiAgdmFyIGQyO1xuICB2YXIgaTtcbiAgdmFyIEVQU0lMT04gPSAwLjAwMDE7XG4gIHZhciB2MCA9IFt4LCB5XTtcblxuICBmb3IgKF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgdjEgPSBbcXVhZHJhdGljQXQoeDEsIHgyLCB4MywgX3QpLCBxdWFkcmF0aWNBdCh5MSwgeTIsIHkzLCBfdCldO1xuICAgIGQxID0gdmVjMi5zcXVhcmVkRGlzdGFuY2UodjAsIHYxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICB2MSA9IFtxdWFkcmF0aWNBdCh4MSwgeDIsIHgzLCBwcmV2KSwgcXVhZHJhdGljQXQoeTEsIHkyLCB5MywgcHJldildO1xuICAgIGQxID0gdmVjMi5zcXVhcmVkRGlzdGFuY2UodjAsIHYxKTtcblxuICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGQgPSBkMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdjIgPSBbcXVhZHJhdGljQXQoeDEsIHgyLCB4MywgbmV4dCksIHF1YWRyYXRpY0F0KHkxLCB5MiwgeTMsIG5leHQpXTtcbiAgICAgIGQyID0gdmVjMi5zcXVhcmVkRGlzdGFuY2UodjAsIHYyKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3V0KSB7XG4gICAgb3V0LnggPSBxdWFkcmF0aWNBdCh4MSwgeDIsIHgzLCB0KTtcbiAgICBvdXQueSA9IHF1YWRyYXRpY0F0KHkxLCB5MiwgeTMsIHQpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChkKTtcbn1cblxuZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtYShwMCwgcDEsIHAyKSB7XG4gIHZhciBhID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoVXRpbC5pc051bWJlckVxdWFsKGEsIDApKSB7XG4gICAgcmV0dXJuIFswLjVdO1xuICB9XG5cbiAgdmFyIHJzdCA9IChwMCAtIHAxKSAvIGE7XG5cbiAgaWYgKHJzdCA8PSAxICYmIHJzdCA+PSAwKSB7XG4gICAgcmV0dXJuIFtyc3RdO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXQ6IHF1YWRyYXRpY0F0LFxuICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uIHByb2plY3RQb2ludCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgdmFyIHJzdCA9IHt9O1xuICAgIHF1YWRyYXRpY1Byb2plY3RQb2ludCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCByc3QpO1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIHBvaW50RGlzdGFuY2U6IHF1YWRyYXRpY1Byb2plY3RQb2ludCxcbiAgZXh0cmVtYTogcXVhZHJhdGljRXh0cmVtYVxufTtcblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHhBdDogZnVuY3Rpb24geEF0KHBzaSwgcngsIHJ5LCBjeCwgdCkge1xuICAgIHJldHVybiByeCAqIE1hdGguY29zKHBzaSkgKiBNYXRoLmNvcyh0KSAtIHJ5ICogTWF0aC5zaW4ocHNpKSAqIE1hdGguc2luKHQpICsgY3g7XG4gIH0sXG4gIHlBdDogZnVuY3Rpb24geUF0KHBzaSwgcngsIHJ5LCBjeSwgdCkge1xuICAgIHJldHVybiByeCAqIE1hdGguc2luKHBzaSkgKiBNYXRoLmNvcyh0KSArIHJ5ICogTWF0aC5jb3MocHNpKSAqIE1hdGguc2luKHQpICsgY3k7XG4gIH0sXG4gIHhFeHRyZW1hOiBmdW5jdGlvbiB4RXh0cmVtYShwc2ksIHJ4LCByeSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4oLXJ5IC8gcnggKiBNYXRoLnRhbihwc2kpKTtcbiAgfSxcbiAgeUV4dHJlbWE6IGZ1bmN0aW9uIHlFeHRyZW1hKHBzaSwgcngsIHJ5KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbihyeSAvIChyeCAqIE1hdGgudGFuKHBzaSkpKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgQXJjTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgQXJyb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxuZnVuY3Rpb24gX2dldEFyY1goeCwgcmFkaXVzLCBhbmdsZSkge1xuICByZXR1cm4geCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbn1cblxuZnVuY3Rpb24gX2dldEFyY1koeSwgcmFkaXVzLCBhbmdsZSkge1xuICByZXR1cm4geSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbn1cblxudmFyIEFyYyA9IGZ1bmN0aW9uIEFyYyhjZmcpIHtcbiAgQXJjLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuQXJjLkFUVFJTID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICByOiAwLFxuICBzdGFydEFuZ2xlOiAwLFxuICBlbmRBbmdsZTogMCxcbiAgY2xvY2t3aXNlOiBmYWxzZSxcbiAgbGluZVdpZHRoOiAxLFxuICBzdGFydEFycm93OiBmYWxzZSxcbiAgZW5kQXJyb3c6IGZhbHNlXG59O1xuVXRpbC5leHRlbmQoQXJjLCBTaGFwZSk7XG5VdGlsLmF1Z21lbnQoQXJjLCB7XG4gIGNhblN0cm9rZTogdHJ1ZSxcbiAgdHlwZTogJ2FyYycsXG4gIGdldERlZmF1bHRBdHRyczogZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHI6IDAsXG4gICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgZW5kQW5nbGU6IDAsXG4gICAgICBjbG9ja3dpc2U6IGZhbHNlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgc3RhcnRBcnJvdzogZmFsc2UsXG4gICAgICBlbmRBcnJvdzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjYWxjdWxhdGVCb3g6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgc3RhcnRBbmdsZSA9IGF0dHJzLnN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlID0gYXR0cnMuZW5kQW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZSA9IGF0dHJzLmNsb2Nrd2lzZTtcbiAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgICB2YXIgaGFsZldpZHRoID0gbGluZVdpZHRoIC8gMjtcbiAgICB2YXIgYm94ID0gQXJjTWF0aC5ib3goeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgYm94Lm1pblggLT0gaGFsZldpZHRoO1xuICAgIGJveC5taW5ZIC09IGhhbGZXaWR0aDtcbiAgICBib3gubWF4WCArPSBoYWxmV2lkdGg7XG4gICAgYm94Lm1heFkgKz0gaGFsZldpZHRoO1xuICAgIHJldHVybiBib3g7XG4gIH0sXG4gIGdldFN0YXJ0VGFuZ2VudDogZnVuY3Rpb24gZ2V0U3RhcnRUYW5nZW50KCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHZhciB4ID0gYXR0cnMueCxcbiAgICAgICAgeSA9IGF0dHJzLnksXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlLFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgY2xvY2t3aXNlID0gYXR0cnMuY2xvY2t3aXNlO1xuICAgIHZhciBkaWZmID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgIGRpZmYgKj0gLTE7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgdmFyIHgxID0gX2dldEFyY1goeCwgciwgc3RhcnRBbmdsZSArIGRpZmYpO1xuXG4gICAgdmFyIHkxID0gX2dldEFyY1koeSwgciwgc3RhcnRBbmdsZSArIGRpZmYpO1xuXG4gICAgdmFyIHgyID0gX2dldEFyY1goeCwgciwgc3RhcnRBbmdsZSk7XG5cbiAgICB2YXIgeTIgPSBfZ2V0QXJjWSh5LCByLCBzdGFydEFuZ2xlKTtcblxuICAgIHJlc3VsdC5wdXNoKFt4MSwgeTFdKTtcbiAgICByZXN1bHQucHVzaChbeDIsIHkyXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZ2V0RW5kVGFuZ2VudDogZnVuY3Rpb24gZ2V0RW5kVGFuZ2VudCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlLFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgY2xvY2t3aXNlID0gYXR0cnMuY2xvY2t3aXNlO1xuICAgIHZhciBkaWZmID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICBkaWZmICo9IC0xO1xuICAgIH1cblxuICAgIHZhciB4MSA9IF9nZXRBcmNYKHgsIHIsIGVuZEFuZ2xlICsgZGlmZik7XG5cbiAgICB2YXIgeTEgPSBfZ2V0QXJjWSh5LCByLCBlbmRBbmdsZSArIGRpZmYpO1xuXG4gICAgdmFyIHgyID0gX2dldEFyY1goeCwgciwgZW5kQW5nbGUpO1xuXG4gICAgdmFyIHkyID0gX2dldEFyY1koeSwgciwgZW5kQW5nbGUpO1xuXG4gICAgcmVzdWx0LnB1c2goW3gyLCB5Ml0pO1xuICAgIHJlc3VsdC5wdXNoKFt4MSwgeTFdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBjcmVhdGVQYXRoOiBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgc3RhcnRBbmdsZSA9IGF0dHJzLnN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlID0gYXR0cnMuZW5kQW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZSA9IGF0dHJzLmNsb2Nrd2lzZTtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBzZWxmLmdldCgnY29udGV4dCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gIH0sXG4gIGFmdGVyUGF0aDogZnVuY3Rpb24gYWZ0ZXJQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmdldCgnY29udGV4dCcpO1xuXG4gICAgaWYgKGF0dHJzLnN0YXJ0QXJyb3cpIHtcbiAgICAgIHZhciBzdGFydFBvaW50cyA9IHRoaXMuZ2V0U3RhcnRUYW5nZW50KCk7XG4gICAgICBBcnJvdy5hZGRTdGFydEFycm93KGNvbnRleHQsIGF0dHJzLCBzdGFydFBvaW50c1swXVswXSwgc3RhcnRQb2ludHNbMF1bMV0sIHN0YXJ0UG9pbnRzWzFdWzBdLCBzdGFydFBvaW50c1sxXVsxXSk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJzLmVuZEFycm93KSB7XG4gICAgICB2YXIgZW5kUG9pbnRzID0gdGhpcy5nZXRFbmRUYW5nZW50KCk7XG4gICAgICBBcnJvdy5hZGRFbmRBcnJvdyhjb250ZXh0LCBhdHRycywgZW5kUG9pbnRzWzBdWzBdLCBlbmRQb2ludHNbMF1bMV0sIGVuZFBvaW50c1sxXVswXSwgZW5kUG9pbnRzWzFdWzFdKTtcbiAgICB9XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBcmM7XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIENpcmNsZSA9IGZ1bmN0aW9uIENpcmNsZShjZmcpIHtcbiAgQ2lyY2xlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuQ2lyY2xlLkFUVFJTID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICByOiAwLFxuICBsaW5lV2lkdGg6IDFcbn07XG5VdGlsLmV4dGVuZChDaXJjbGUsIFNoYXBlKTtcblV0aWwuYXVnbWVudChDaXJjbGUsIHtcbiAgY2FuRmlsbDogdHJ1ZSxcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICB0eXBlOiAnY2lyY2xlJyxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVXaWR0aDogMVxuICAgIH07XG4gIH0sXG4gIGNhbGN1bGF0ZUJveDogZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHZhciBjeCA9IGF0dHJzLng7XG4gICAgdmFyIGN5ID0gYXR0cnMueTtcbiAgICB2YXIgciA9IGF0dHJzLnI7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0SGl0TGluZVdpZHRoKCk7XG4gICAgdmFyIGhhbGZXaWR0aCA9IGxpbmVXaWR0aCAvIDIgKyByO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBjeCAtIGhhbGZXaWR0aCxcbiAgICAgIG1pblk6IGN5IC0gaGFsZldpZHRoLFxuICAgICAgbWF4WDogY3ggKyBoYWxmV2lkdGgsXG4gICAgICBtYXhZOiBjeSArIGhhbGZXaWR0aFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHZhciBjeCA9IGF0dHJzLng7XG4gICAgdmFyIGN5ID0gYXR0cnMueTtcbiAgICB2YXIgciA9IGF0dHJzLnI7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgRG9tID0gZnVuY3Rpb24gRG9tKGNmZykge1xuICBEb20uc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNmZyk7XG59O1xuXG5VdGlsLmV4dGVuZChEb20sIFNoYXBlKTtcblV0aWwuYXVnbWVudChEb20sIHtcbiAgY2FuRmlsbDogdHJ1ZSxcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICB0eXBlOiAnZG9tJyxcbiAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuX2F0dHJzO1xuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG4gICAgdmFyIHdpZHRoID0gYXR0cnMud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcbiAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgICB2YXIgaGFsZldpZHRoID0gbGluZVdpZHRoIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogeCAtIGhhbGZXaWR0aCxcbiAgICAgIG1pblk6IHkgLSBoYWxmV2lkdGgsXG4gICAgICBtYXhYOiB4ICsgd2lkdGggKyBoYWxmV2lkdGgsXG4gICAgICBtYXhZOiB5ICsgaGVpZ2h0ICsgaGFsZldpZHRoXG4gICAgfTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IERvbTtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgRWxsaXBzZSA9IGZ1bmN0aW9uIEVsbGlwc2UoY2ZnKSB7XG4gIEVsbGlwc2Uuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNmZyk7XG59O1xuXG5FbGxpcHNlLkFUVFJTID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICByeDogMSxcbiAgcnk6IDEsXG4gIGxpbmVXaWR0aDogMVxufTtcblV0aWwuZXh0ZW5kKEVsbGlwc2UsIFNoYXBlKTtcblV0aWwuYXVnbWVudChFbGxpcHNlLCB7XG4gIGNhbkZpbGw6IHRydWUsXG4gIGNhblN0cm9rZTogdHJ1ZSxcbiAgdHlwZTogJ2VsbGlwc2UnLFxuICBnZXREZWZhdWx0QXR0cnM6IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVdpZHRoOiAxXG4gICAgfTtcbiAgfSxcbiAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIGN4ID0gYXR0cnMueDtcbiAgICB2YXIgY3kgPSBhdHRycy55O1xuICAgIHZhciByeCA9IGF0dHJzLnJ4O1xuICAgIHZhciByeSA9IGF0dHJzLnJ5O1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuICAgIHZhciBoYWxmWFdpZHRoID0gcnggKyBsaW5lV2lkdGggLyAyO1xuICAgIHZhciBoYWxmWVdpZHRoID0gcnkgKyBsaW5lV2lkdGggLyAyO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBjeCAtIGhhbGZYV2lkdGgsXG4gICAgICBtaW5ZOiBjeSAtIGhhbGZZV2lkdGgsXG4gICAgICBtYXhYOiBjeCArIGhhbGZYV2lkdGgsXG4gICAgICBtYXhZOiBjeSArIGhhbGZZV2lkdGhcbiAgICB9O1xuICB9LFxuICBjcmVhdGVQYXRoOiBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgY3ggPSBhdHRycy54O1xuICAgIHZhciBjeSA9IGF0dHJzLnk7XG4gICAgdmFyIHJ4ID0gYXR0cnMucng7XG4gICAgdmFyIHJ5ID0gYXR0cnMucnk7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5nZXQoJ2NvbnRleHQnKTtcbiAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcbiAgICB2YXIgbSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICBVdGlsLm1hdDMuc2NhbGUobSwgbSwgW3NjYWxlWCwgc2NhbGVZXSk7XG4gICAgVXRpbC5tYXQzLnRyYW5zbGF0ZShtLCBtLCBbY3gsIGN5XSk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzNdLCBtWzRdLCBtWzZdLCBtWzddKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCBNYXRoLlBJICogMik7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEVsbGlwc2U7XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEFyY01hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxudmFyIEZhbiA9IGZ1bmN0aW9uIEZhbihjZmcpIHtcbiAgRmFuLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuRmFuLkFUVFJTID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICByczogMCxcbiAgcmU6IDAsXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIGVuZEFuZ2xlOiAwLFxuICBjbG9ja3dpc2U6IGZhbHNlLFxuICBsaW5lV2lkdGg6IDFcbn07XG5VdGlsLmV4dGVuZChGYW4sIFNoYXBlKTtcblV0aWwuYXVnbWVudChGYW4sIHtcbiAgY2FuRmlsbDogdHJ1ZSxcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICB0eXBlOiAnZmFuJyxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb2Nrd2lzZTogZmFsc2UsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICByczogMCxcbiAgICAgIHJlOiAwXG4gICAgfTtcbiAgfSxcbiAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuX2F0dHJzO1xuICAgIHZhciBjeCA9IGF0dHJzLng7XG4gICAgdmFyIGN5ID0gYXR0cnMueTtcbiAgICB2YXIgcnMgPSBhdHRycy5ycztcbiAgICB2YXIgcmUgPSBhdHRycy5yZTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IGF0dHJzLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gYXR0cnMuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IGF0dHJzLmNsb2Nrd2lzZTtcbiAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgICB2YXIgYm94cyA9IEFyY01hdGguYm94KGN4LCBjeSwgcnMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIHZhciBib3hlID0gQXJjTWF0aC5ib3goY3gsIGN5LCByZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgdmFyIG1pblggPSBNYXRoLm1pbihib3hzLm1pblgsIGJveGUubWluWCk7XG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbihib3hzLm1pblksIGJveGUubWluWSk7XG4gICAgdmFyIG1heFggPSBNYXRoLm1heChib3hzLm1heFgsIGJveGUubWF4WCk7XG4gICAgdmFyIG1heFkgPSBNYXRoLm1heChib3hzLm1heFksIGJveGUubWF4WSk7XG4gICAgdmFyIGhhbGZXaWR0aCA9IGxpbmVXaWR0aCAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IG1pblggLSBoYWxmV2lkdGgsXG4gICAgICBtaW5ZOiBtaW5ZIC0gaGFsZldpZHRoLFxuICAgICAgbWF4WDogbWF4WCArIGhhbGZXaWR0aCxcbiAgICAgIG1heFk6IG1heFkgKyBoYWxmV2lkdGhcbiAgICB9O1xuICB9LFxuICBjcmVhdGVQYXRoOiBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgY3ggPSBhdHRycy54O1xuICAgIHZhciBjeSA9IGF0dHJzLnk7XG4gICAgdmFyIHJzID0gYXR0cnMucnM7XG4gICAgdmFyIHJlID0gYXR0cnMucmU7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBhdHRycy5jbG9ja3dpc2U7XG4gICAgdmFyIHNzcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKHN0YXJ0QW5nbGUpICogcnMgKyBjeCxcbiAgICAgIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpICogcnMgKyBjeVxuICAgIH07XG4gICAgdmFyIHNlcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmUgKyBjeCxcbiAgICAgIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmUgKyBjeVxuICAgIH07XG4gICAgdmFyIGVzcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKGVuZEFuZ2xlKSAqIHJzICsgY3gsXG4gICAgICB5OiBNYXRoLnNpbihlbmRBbmdsZSkgKiBycyArIGN5XG4gICAgfTtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBzZWxmLmdldCgnY29udGV4dCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc3NwLngsIHNzcC55KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzZXAueCwgc2VwLnkpO1xuICAgIGNvbnRleHQuYXJjKGN4LCBjeSwgcmUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIGNvbnRleHQubGluZVRvKGVzcC54LCBlc3AueSk7XG4gICAgY29udGV4dC5hcmMoY3gsIGN5LCBycywgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsICFjbG9ja3dpc2UpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBGYW47XG5cbi8qKiovIH0pLFxuLyogMTEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIENJbWFnZSA9IGZ1bmN0aW9uIENJbWFnZShjZmcpIHtcbiAgQ0ltYWdlLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuQ0ltYWdlLkFUVFJTID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBpbWc6IHVuZGVmaW5lZCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgc3g6IG51bGwsXG4gIHN5OiBudWxsLFxuICBzd2lkdGg6IG51bGwsXG4gIHNoZWlnaHQ6IG51bGxcbn07XG5VdGlsLmV4dGVuZChDSW1hZ2UsIFNoYXBlKTtcblV0aWwuYXVnbWVudChDSW1hZ2UsIHtcbiAgdHlwZTogJ2ltYWdlJyxcbiAgaXNIaXRCb3g6IGZ1bmN0aW9uIGlzSGl0Qm94KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG5cbiAgICBpZiAoIXRoaXMuX2NmZy5hdHRycyB8fCB0aGlzLl9jZmcuYXR0cnMuaW1nICE9PSBhdHRycy5pbWcpIHtcbiAgICAgIHRoaXMuX3NldEF0dHJJbWcoKTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IGF0dHJzLng7XG4gICAgdmFyIHkgPSBhdHRycy55O1xuICAgIHZhciB3aWR0aCA9IGF0dHJzLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBhdHRycy5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHgsXG4gICAgICBtaW5ZOiB5LFxuICAgICAgbWF4WDogeCArIHdpZHRoLFxuICAgICAgbWF4WTogeSArIGhlaWdodFxuICAgIH07XG4gIH0sXG4gIF9iZWZvcmVTZXRMb2FkaW5nOiBmdW5jdGlvbiBfYmVmb3JlU2V0TG9hZGluZyhsb2FkaW5nKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0KCdjYW52YXMnKTtcblxuICAgIGlmIChsb2FkaW5nID09PSBmYWxzZSAmJiB0aGlzLmdldCgndG9EcmF3JykgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2NmZy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICBjYW52YXMuZHJhdygpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9LFxuICBfc2V0QXR0ckltZzogZnVuY3Rpb24gX3NldEF0dHJJbWcoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuX2F0dHJzO1xuICAgIHZhciBpbWcgPSBhdHRycy5pbWc7XG5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyhpbWcpKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5nZXQoJ2Rlc3Ryb3llZCcpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNlbGYuYXR0cignaW1nU3JjJywgaW1nKTtcbiAgICAgICAgc2VsZi5hdHRyKCdpbWcnLCBpbWFnZSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHNlbGYuZ2V0KCdjYWxsYmFjaycpO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNldCgnbG9hZGluZycsIGZhbHNlKTtcbiAgICAgIH07XG5cbiAgICAgIGltYWdlLnNyYyA9IGltZztcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICBzZWxmLnNldCgnbG9hZGluZycsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoaW1nIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgIGlmICghYXR0cnMud2lkdGgpIHtcbiAgICAgICAgc2VsZi5hdHRyKCd3aWR0aCcsIGltZy53aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXR0cnMuaGVpZ2h0KSB7XG4gICAgICAgIHNlbGYuYXR0cignaGVpZ2h0JywgaW1nLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWc7XG4gICAgfSBlbHNlIGlmIChpbWcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBVdGlsLmlzU3RyaW5nKGltZy5ub2RlTmFtZSkgJiYgaW1nLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnKSB7XG4gICAgICBpZiAoIWF0dHJzLndpZHRoKSB7XG4gICAgICAgIHNlbGYuYXR0cignd2lkdGgnLCBOdW1iZXIoaW1nLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dHJzLmhlaWdodCkge1xuICAgICAgICBzZWxmLmF0dHIoJ2hlaWdodCcsIE51bWJlcihpbWcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nO1xuICAgIH0gZWxzZSBpZiAoaW1nIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICBpZiAoIWF0dHJzLndpZHRoKSB7XG4gICAgICAgIHNlbGYuYXR0cignd2lkdGgnLCBpbWcud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dHJzLmhlaWdodCkge1xuICAgICAgICBzZWxmLmF0dHIoJ2hlaWdodCcsIGltZy5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGRyYXdJbm5lcjogZnVuY3Rpb24gZHJhd0lubmVyKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5fY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fc2V0QXR0ckltZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldCgnbG9hZGluZycpKSB7XG4gICAgICB0aGlzLnNldCgndG9EcmF3JywgdHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0ltYWdlKGNvbnRleHQpO1xuXG4gICAgdGhpcy5fY2ZnLmhhc1VwZGF0ZSA9IGZhbHNlO1xuICB9LFxuICBfZHJhd0ltYWdlOiBmdW5jdGlvbiBfZHJhd0ltYWdlKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgeCA9IGF0dHJzLng7XG4gICAgdmFyIHkgPSBhdHRycy55O1xuICAgIHZhciBpbWFnZSA9IGF0dHJzLmltZztcbiAgICB2YXIgd2lkdGggPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuICAgIHZhciBzeCA9IGF0dHJzLnN4O1xuICAgIHZhciBzeSA9IGF0dHJzLnN5O1xuICAgIHZhciBzd2lkdGggPSBhdHRycy5zd2lkdGg7XG4gICAgdmFyIHNoZWlnaHQgPSBhdHRycy5zaGVpZ2h0O1xuICAgIHRoaXMuc2V0KCd0b0RyYXcnLCBmYWxzZSk7XG4gICAgdmFyIGltZyA9IGltYWdlO1xuXG4gICAgaWYgKGltZyBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gaW1hZ2U7XG4gICAgfVxuXG4gICAgaWYgKGltZyBpbnN0YW5jZW9mIEltYWdlIHx8IGltZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIFV0aWwuaXNTdHJpbmcoaW1nLm5vZGVOYW1lKSAmJiBpbWcubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgIGlmIChVdGlsLmlzTmlsKHN4KSB8fCBVdGlsLmlzTmlsKHN5KSB8fCBVdGlsLmlzTmlsKHN3aWR0aCkgfHwgVXRpbC5pc05pbChzaGVpZ2h0KSkge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghVXRpbC5pc05pbChzeCkgJiYgIVV0aWwuaXNOaWwoc3kpICYmICFVdGlsLmlzTmlsKHN3aWR0aCkgJiYgIVV0aWwuaXNOaWwoc2hlaWdodCkpIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBDSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogMTExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEFycm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBMaW5lTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXG52YXIgTGluZSA9IGZ1bmN0aW9uIExpbmUoY2ZnKSB7XG4gIExpbmUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNmZyk7XG59O1xuXG5MaW5lLkFUVFJTID0ge1xuICB4MTogMCxcbiAgeTE6IDAsXG4gIHgyOiAwLFxuICB5MjogMCxcbiAgbGluZVdpZHRoOiAxLFxuICBzdGFydEFycm93OiBmYWxzZSxcbiAgZW5kQXJyb3c6IGZhbHNlXG59O1xuVXRpbC5leHRlbmQoTGluZSwgU2hhcGUpO1xuVXRpbC5hdWdtZW50KExpbmUsIHtcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICB0eXBlOiAnbGluZScsXG4gIGdldERlZmF1bHRBdHRyczogZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzdGFydEFycm93OiBmYWxzZSxcbiAgICAgIGVuZEFycm93OiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNhbGN1bGF0ZUJveDogZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHZhciB4MSA9IGF0dHJzLngxLFxuICAgICAgICB5MSA9IGF0dHJzLnkxLFxuICAgICAgICB4MiA9IGF0dHJzLngyLFxuICAgICAgICB5MiA9IGF0dHJzLnkyO1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuICAgIHJldHVybiBMaW5lTWF0aC5ib3goeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCk7XG4gIH0sXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHZhciB4MSA9IGF0dHJzLngxLFxuICAgICAgICB5MSA9IGF0dHJzLnkxLFxuICAgICAgICB4MiA9IGF0dHJzLngyLFxuICAgICAgICB5MiA9IGF0dHJzLnkyO1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHNlbGYuZ2V0KCdjb250ZXh0Jyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gIH0sXG4gIGFmdGVyUGF0aDogZnVuY3Rpb24gYWZ0ZXJQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgeDEgPSBhdHRycy54MSxcbiAgICAgICAgeTEgPSBhdHRycy55MSxcbiAgICAgICAgeDIgPSBhdHRycy54MixcbiAgICAgICAgeTIgPSBhdHRycy55MjtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmdldCgnY29udGV4dCcpO1xuXG4gICAgaWYgKGF0dHJzLnN0YXJ0QXJyb3cpIHtcbiAgICAgIEFycm93LmFkZFN0YXJ0QXJyb3coY29udGV4dCwgYXR0cnMsIHgyLCB5MiwgeDEsIHkxKTtcbiAgICB9XG5cbiAgICBpZiAoYXR0cnMuZW5kQXJyb3cpIHtcbiAgICAgIEFycm93LmFkZEVuZEFycm93KGNvbnRleHQsIGF0dHJzLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICB9LFxuICBnZXRQb2ludDogZnVuY3Rpb24gZ2V0UG9pbnQodCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBMaW5lTWF0aC5hdChhdHRycy54MSwgYXR0cnMueDIsIHQpLFxuICAgICAgeTogTGluZU1hdGguYXQoYXR0cnMueTEsIGF0dHJzLnkyLCB0KVxuICAgIH07XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKioqLyB9KSxcbi8qIDExMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBQYXRoU2VnbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgRm9ybWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBBcnJvdyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgUGF0aFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblxudmFyIEN1YmljTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG52YXIgUGF0aCA9IGZ1bmN0aW9uIFBhdGgoY2ZnKSB7XG4gIFBhdGguc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNmZyk7XG59O1xuXG5QYXRoLkFUVFJTID0ge1xuICBwYXRoOiBudWxsLFxuICBsaW5lV2lkdGg6IDEsXG4gIHN0YXJ0QXJyb3c6IGZhbHNlLFxuICBlbmRBcnJvdzogZmFsc2Vcbn07XG5VdGlsLmV4dGVuZChQYXRoLCBTaGFwZSk7XG5VdGlsLmF1Z21lbnQoUGF0aCwge1xuICBjYW5GaWxsOiB0cnVlLFxuICBjYW5TdHJva2U6IHRydWUsXG4gIHR5cGU6ICdwYXRoJyxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIHN0YXJ0QXJyb3c6IGZhbHNlLFxuICAgICAgZW5kQXJyb3c6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgX2FmdGVyU2V0QXR0clBhdGg6IGZ1bmN0aW9uIF9hZnRlclNldEF0dHJQYXRoKHBhdGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoVXRpbC5pc05pbChwYXRoKSkge1xuICAgICAgc2VsZi5zZXRTaWxlbnQoJ3NlZ21lbnRzJywgbnVsbCk7XG4gICAgICBzZWxmLnNldFNpbGVudCgnYm94JywgdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aEFycmF5ID0gRm9ybWF0LnBhcnNlUGF0aChwYXRoKTtcbiAgICB2YXIgcHJlU2VnbWVudDtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICAgIGlmICghVXRpbC5pc0FycmF5KHBhdGhBcnJheSkgfHwgcGF0aEFycmF5Lmxlbmd0aCA9PT0gMCB8fCBwYXRoQXJyYXlbMF1bMF0gIT09ICdNJyAmJiBwYXRoQXJyYXlbMF1bMF0gIT09ICdtJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IHBhdGhBcnJheS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBwYXRoQXJyYXlbaV07XG4gICAgICBwcmVTZWdtZW50ID0gbmV3IFBhdGhTZWdtZW50KGl0ZW0sIHByZVNlZ21lbnQsIGkgPT09IGNvdW50IC0gMSk7XG4gICAgICBzZWdtZW50cy5wdXNoKHByZVNlZ21lbnQpO1xuICAgIH1cblxuICAgIHNlbGYuc2V0U2lsZW50KCdzZWdtZW50cycsIHNlZ21lbnRzKTtcbiAgICBzZWxmLnNldFNpbGVudCgndENhY2hlJywgbnVsbCk7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ2JveCcsIG51bGwpO1xuICB9LFxuICBjYWxjdWxhdGVCb3g6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gc2VsZi5nZXQoJ3NlZ21lbnRzJyk7XG5cbiAgICBpZiAoIXNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgVXRpbC5lYWNoKHNlZ21lbnRzLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgc2VnbWVudC5nZXRCQm94KGxpbmVXaWR0aCk7XG4gICAgICB2YXIgYm94ID0gc2VnbWVudC5ib3g7XG5cbiAgICAgIGlmIChib3gpIHtcbiAgICAgICAgaWYgKGJveC5taW5YIDwgbWluWCkge1xuICAgICAgICAgIG1pblggPSBib3gubWluWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3gubWF4WCA+IG1heFgpIHtcbiAgICAgICAgICBtYXhYID0gYm94Lm1heFg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm94Lm1pblkgPCBtaW5ZKSB7XG4gICAgICAgICAgbWluWSA9IGJveC5taW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJveC5tYXhZID4gbWF4WSkge1xuICAgICAgICAgIG1heFkgPSBib3gubWF4WTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1pblggPT09IEluZmluaXR5IHx8IG1pblkgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiAwLFxuICAgICAgICBtaW5ZOiAwLFxuICAgICAgICBtYXhYOiAwLFxuICAgICAgICBtYXhZOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZXG4gICAgfTtcbiAgfSxcbiAgX3NldFRjYWNoZTogZnVuY3Rpb24gX3NldFRjYWNoZSgpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICAgIHZhciB0ZW1wTGVuZ3RoID0gMDtcbiAgICB2YXIgdENhY2hlID0gW107XG4gICAgdmFyIHNlZ21lbnRUO1xuICAgIHZhciBzZWdtZW50TDtcbiAgICB2YXIgc2VnbWVudE47XG4gICAgdmFyIGw7XG4gICAgdmFyIGN1cnZlID0gdGhpcy5fY2ZnLmN1cnZlO1xuXG4gICAgaWYgKCFjdXJ2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChjdXJ2ZSwgZnVuY3Rpb24gKHNlZ21lbnQsIGkpIHtcbiAgICAgIHNlZ21lbnROID0gY3VydmVbaSArIDFdO1xuICAgICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgICBpZiAoc2VnbWVudE4pIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gQ3ViaWNNYXRoLmxlbihzZWdtZW50W2wgLSAyXSwgc2VnbWVudFtsIC0gMV0sIHNlZ21lbnROWzFdLCBzZWdtZW50TlsyXSwgc2VnbWVudE5bM10sIHNlZ21lbnROWzRdLCBzZWdtZW50Tls1XSwgc2VnbWVudE5bNl0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFV0aWwuZWFjaChjdXJ2ZSwgZnVuY3Rpb24gKHNlZ21lbnQsIGkpIHtcbiAgICAgIHNlZ21lbnROID0gY3VydmVbaSArIDFdO1xuICAgICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgICBpZiAoc2VnbWVudE4pIHtcbiAgICAgICAgc2VnbWVudFQgPSBbXTtcbiAgICAgICAgc2VnbWVudFRbMF0gPSB0ZW1wTGVuZ3RoIC8gdG90YWxMZW5ndGg7XG4gICAgICAgIHNlZ21lbnRMID0gQ3ViaWNNYXRoLmxlbihzZWdtZW50W2wgLSAyXSwgc2VnbWVudFtsIC0gMV0sIHNlZ21lbnROWzFdLCBzZWdtZW50TlsyXSwgc2VnbWVudE5bM10sIHNlZ21lbnROWzRdLCBzZWdtZW50Tls1XSwgc2VnbWVudE5bNl0pO1xuICAgICAgICB0ZW1wTGVuZ3RoICs9IHNlZ21lbnRMO1xuICAgICAgICBzZWdtZW50VFsxXSA9IHRlbXBMZW5ndGggLyB0b3RhbExlbmd0aDtcbiAgICAgICAgdENhY2hlLnB1c2goc2VnbWVudFQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2NmZy50Q2FjaGUgPSB0Q2FjaGU7XG4gIH0sXG4gIF9jYWxjdWxhdGVDdXJ2ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZUN1cnZlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcGF0aCA9IGF0dHJzLnBhdGg7XG4gICAgdGhpcy5fY2ZnLmN1cnZlID0gUGF0aFV0aWwucGF0aFRvY3VydmUocGF0aCk7XG4gIH0sXG4gIGdldFN0YXJ0VGFuZ2VudDogZnVuY3Rpb24gZ2V0U3RhcnRUYW5nZW50KCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuZ2V0KCdzZWdtZW50cycpO1xuICAgIHZhciBzdGFydFBvaW50LCBlbmRQb2ludCwgdGFuZ2VudCwgcmVzdWx0O1xuXG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSBzZWdtZW50c1swXS5lbmRQb2ludDtcbiAgICAgIGVuZFBvaW50ID0gc2VnbWVudHNbMV0uZW5kUG9pbnQ7XG4gICAgICB0YW5nZW50ID0gc2VnbWVudHNbMV0uc3RhcnRUYW5nZW50O1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24odGFuZ2VudCkpIHtcbiAgICAgICAgdmFyIHYgPSB0YW5nZW50KCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtzdGFydFBvaW50LnggLSB2WzBdLCBzdGFydFBvaW50LnkgLSB2WzFdXSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2VuZFBvaW50LngsIGVuZFBvaW50LnldKTtcbiAgICAgICAgcmVzdWx0LnB1c2goW3N0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZ2V0RW5kVGFuZ2VudDogZnVuY3Rpb24gZ2V0RW5kVGFuZ2VudCgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmdldCgnc2VnbWVudHMnKTtcbiAgICB2YXIgc2VnbWVudHNMZW4gPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgdmFyIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCB0YW5nZW50LCByZXN1bHQ7XG5cbiAgICBpZiAoc2VnbWVudHNMZW4gPiAxKSB7XG4gICAgICBzdGFydFBvaW50ID0gc2VnbWVudHNbc2VnbWVudHNMZW4gLSAyXS5lbmRQb2ludDtcbiAgICAgIGVuZFBvaW50ID0gc2VnbWVudHNbc2VnbWVudHNMZW4gLSAxXS5lbmRQb2ludDtcbiAgICAgIHRhbmdlbnQgPSBzZWdtZW50c1tzZWdtZW50c0xlbiAtIDFdLmVuZFRhbmdlbnQ7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbih0YW5nZW50KSkge1xuICAgICAgICB2YXIgdiA9IHRhbmdlbnQoKTtcbiAgICAgICAgcmVzdWx0LnB1c2goW2VuZFBvaW50LnggLSB2WzBdLCBlbmRQb2ludC55IC0gdlsxXV0pO1xuICAgICAgICByZXN1bHQucHVzaChbZW5kUG9pbnQueCwgZW5kUG9pbnQueV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW3N0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55XSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtlbmRQb2ludC54LCBlbmRQb2ludC55XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZ2V0UG9pbnQ6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICB2YXIgdENhY2hlID0gdGhpcy5fY2ZnLnRDYWNoZTtcbiAgICB2YXIgc3VidDtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBpZiAoIXRDYWNoZSkge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlQ3VydmUoKTtcblxuICAgICAgdGhpcy5fc2V0VGNhY2hlKCk7XG5cbiAgICAgIHRDYWNoZSA9IHRoaXMuX2NmZy50Q2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIGN1cnZlID0gdGhpcy5fY2ZnLmN1cnZlO1xuXG4gICAgaWYgKCF0Q2FjaGUpIHtcbiAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGN1cnZlWzBdWzFdLFxuICAgICAgICAgIHk6IGN1cnZlWzBdWzJdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaCh0Q2FjaGUsIGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICBpZiAodCA+PSB2WzBdICYmIHQgPD0gdlsxXSkge1xuICAgICAgICBzdWJ0ID0gKHQgLSB2WzBdKSAvICh2WzFdIC0gdlswXSk7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgc2VnID0gY3VydmVbaW5kZXhdO1xuXG4gICAgaWYgKFV0aWwuaXNOaWwoc2VnKSB8fCBVdGlsLmlzTmlsKGluZGV4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBzZWcubGVuZ3RoO1xuICAgIHZhciBuZXh0U2VnID0gY3VydmVbaW5kZXggKyAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogQ3ViaWNNYXRoLmF0KHNlZ1tsIC0gMl0sIG5leHRTZWdbMV0sIG5leHRTZWdbM10sIG5leHRTZWdbNV0sIDEgLSBzdWJ0KSxcbiAgICAgIHk6IEN1YmljTWF0aC5hdChzZWdbbCAtIDFdLCBuZXh0U2VnWzJdLCBuZXh0U2VnWzRdLCBuZXh0U2VnWzZdLCAxIC0gc3VidClcbiAgICB9O1xuICB9LFxuICBjcmVhdGVQYXRoOiBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gc2VsZi5nZXQoJ3NlZ21lbnRzJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNBcnJheShzZWdtZW50cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBzZWxmLmdldCgnY29udGV4dCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIHNlZ21lbnRzTGVuID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50c0xlbjsgaSsrKSB7XG4gICAgICBzZWdtZW50c1tpXS5kcmF3KGNvbnRleHQpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJQYXRoOiBmdW5jdGlvbiBhZnRlclBhdGgoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgc2VnbWVudHMgPSBzZWxmLmdldCgnc2VnbWVudHMnKTtcbiAgICB2YXIgcGF0aCA9IGF0dHJzLnBhdGg7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5nZXQoJ2NvbnRleHQnKTtcblxuICAgIGlmICghVXRpbC5pc0FycmF5KHNlZ21lbnRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJzLnN0YXJ0QXJyb3cgJiYgIWF0dHJzLmVuZEFycm93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ3onIHx8IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ1onIHx8IGF0dHJzLmZpbGwpIHtcbiAgICAgIC8vIOmXreWQiOi3r+W+hOS4jee7mOWItueureWktFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvaW50cyA9IHNlbGYuZ2V0U3RhcnRUYW5nZW50KCk7XG4gICAgQXJyb3cuYWRkU3RhcnRBcnJvdyhjb250ZXh0LCBhdHRycywgc3RhcnRQb2ludHNbMF1bMF0sIHN0YXJ0UG9pbnRzWzBdWzFdLCBzdGFydFBvaW50c1sxXVswXSwgc3RhcnRQb2ludHNbMV1bMV0pO1xuICAgIHZhciBlbmRQb2ludHMgPSBzZWxmLmdldEVuZFRhbmdlbnQoKTtcbiAgICBBcnJvdy5hZGRFbmRBcnJvdyhjb250ZXh0LCBhdHRycywgZW5kUG9pbnRzWzBdWzBdLCBlbmRQb2ludHNbMF1bMV0sIGVuZFBvaW50c1sxXVswXSwgZW5kUG9pbnRzWzFdWzFdKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cbi8qKiovIH0pLFxuLyogMTEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFBvbHlnb24gPSBmdW5jdGlvbiBQb2x5Z29uKGNmZykge1xuICBQb2x5Z29uLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuUG9seWdvbi5BVFRSUyA9IHtcbiAgcG9pbnRzOiBudWxsLFxuICBsaW5lV2lkdGg6IDFcbn07XG5VdGlsLmV4dGVuZChQb2x5Z29uLCBTaGFwZSk7XG5VdGlsLmF1Z21lbnQoUG9seWdvbiwge1xuICBjYW5GaWxsOiB0cnVlLFxuICBjYW5TdHJva2U6IHRydWUsXG4gIHR5cGU6ICdwb2x5Z29uJyxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVXaWR0aDogMVxuICAgIH07XG4gIH0sXG4gIGNhbGN1bGF0ZUJveDogZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuXG4gICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHggPSBwb2ludFswXTtcbiAgICAgIHZhciB5ID0gcG9pbnRbMV07XG5cbiAgICAgIGlmICh4IDwgbWluWCkge1xuICAgICAgICBtaW5YID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgIG1heFggPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgaGFsZldpZHRoID0gbGluZVdpZHRoIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCAtIGhhbGZXaWR0aCxcbiAgICAgIG1pblk6IG1pblkgLSBoYWxmV2lkdGgsXG4gICAgICBtYXhYOiBtYXhYICsgaGFsZldpZHRoLFxuICAgICAgbWF4WTogbWF4WSArIGhhbGZXaWR0aFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5nZXQoJ2NvbnRleHQnKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgQXJyb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxudmFyIExpbmVNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBQb2x5bGluZSA9IGZ1bmN0aW9uIFBvbHlsaW5lKGNmZykge1xuICBQb2x5bGluZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY2ZnKTtcbn07XG5cblBvbHlsaW5lLkFUVFJTID0ge1xuICBwb2ludHM6IG51bGwsXG4gIGxpbmVXaWR0aDogMSxcbiAgc3RhcnRBcnJvdzogZmFsc2UsXG4gIGVuZEFycm93OiBmYWxzZSxcbiAgdENhY2hlOiBudWxsXG59O1xuVXRpbC5leHRlbmQoUG9seWxpbmUsIFNoYXBlKTtcblV0aWwuYXVnbWVudChQb2x5bGluZSwge1xuICBjYW5TdHJva2U6IHRydWUsXG4gIHR5cGU6ICdwb2x5bGluZScsXG4gIHRDYWNoZTogbnVsbCxcbiAgLy8g57yT5a2Y5ZCE54K555qEdFxuICBnZXREZWZhdWx0QXR0cnM6IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgc3RhcnRBcnJvdzogZmFsc2UsXG4gICAgICBlbmRBcnJvdzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjYWxjdWxhdGVCb3g6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0SGl0TGluZVdpZHRoKCk7XG4gICAgdmFyIHBvaW50cyA9IGF0dHJzLnBvaW50cztcblxuICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRbMF07XG4gICAgICB2YXIgeSA9IHBvaW50WzFdO1xuXG4gICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgbWluWCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICBtYXhYID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGhhbGZXaWR0aCA9IGxpbmVXaWR0aCAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IG1pblggLSBoYWxmV2lkdGgsXG4gICAgICBtaW5ZOiBtaW5ZIC0gaGFsZldpZHRoLFxuICAgICAgbWF4WDogbWF4WCArIGhhbGZXaWR0aCxcbiAgICAgIG1heFk6IG1heFkgKyBoYWxmV2lkdGhcbiAgICB9O1xuICB9LFxuICBfc2V0VGNhY2hlOiBmdW5jdGlvbiBfc2V0VGNhY2hlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gICAgdmFyIHRlbXBMZW5ndGggPSAwO1xuICAgIHZhciB0Q2FjaGUgPSBbXTtcbiAgICB2YXIgc2VnbWVudFQ7XG4gICAgdmFyIHNlZ21lbnRMO1xuXG4gICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICBpZiAocG9pbnRzW2kgKyAxXSkge1xuICAgICAgICB0b3RhbExlbmd0aCArPSBMaW5lTWF0aC5sZW4ocFswXSwgcFsxXSwgcG9pbnRzW2kgKyAxXVswXSwgcG9pbnRzW2kgKyAxXVsxXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodG90YWxMZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICBpZiAocG9pbnRzW2kgKyAxXSkge1xuICAgICAgICBzZWdtZW50VCA9IFtdO1xuICAgICAgICBzZWdtZW50VFswXSA9IHRlbXBMZW5ndGggLyB0b3RhbExlbmd0aDtcbiAgICAgICAgc2VnbWVudEwgPSBMaW5lTWF0aC5sZW4ocFswXSwgcFsxXSwgcG9pbnRzW2kgKyAxXVswXSwgcG9pbnRzW2kgKyAxXVsxXSk7XG4gICAgICAgIHRlbXBMZW5ndGggKz0gc2VnbWVudEw7XG4gICAgICAgIHNlZ21lbnRUWzFdID0gdGVtcExlbmd0aCAvIHRvdGFsTGVuZ3RoO1xuICAgICAgICB0Q2FjaGUucHVzaChzZWdtZW50VCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50Q2FjaGUgPSB0Q2FjaGU7XG4gIH0sXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuICAgIHZhciBsO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5nZXQoJ2NvbnRleHQnKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcblxuICAgIGZvciAoaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgIH1cblxuICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tsXVswXSwgcG9pbnRzW2xdWzFdKTtcbiAgfSxcbiAgZ2V0U3RhcnRUYW5nZW50OiBmdW5jdGlvbiBnZXRTdGFydFRhbmdlbnQoKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMuX19hdHRycy5wb2ludHM7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0pO1xuICAgIHJlc3VsdC5wdXNoKFtwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIGdldEVuZFRhbmdlbnQ6IGZ1bmN0aW9uIGdldEVuZFRhbmdlbnQoKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMuX19hdHRycy5wb2ludHM7XG4gICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goW3BvaW50c1tsIC0gMV1bMF0sIHBvaW50c1tsIC0gMV1bMV1dKTtcbiAgICByZXN1bHQucHVzaChbcG9pbnRzW2xdWzBdLCBwb2ludHNbbF1bMV1dKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBhZnRlclBhdGg6IGZ1bmN0aW9uIGFmdGVyUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuX2F0dHJzO1xuICAgIHZhciBwb2ludHMgPSBhdHRycy5wb2ludHM7XG4gICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBzZWxmLmdldCgnY29udGV4dCcpO1xuXG4gICAgaWYgKGF0dHJzLnN0YXJ0QXJyb3cpIHtcbiAgICAgIEFycm93LmFkZFN0YXJ0QXJyb3coY29udGV4dCwgYXR0cnMsIHBvaW50c1sxXVswXSwgcG9pbnRzWzFdWzFdLCBwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJzLmVuZEFycm93KSB7XG4gICAgICBBcnJvdy5hZGRFbmRBcnJvdyhjb250ZXh0LCBhdHRycywgcG9pbnRzW2wgLSAxXVswXSwgcG9pbnRzW2wgLSAxXVsxXSwgcG9pbnRzW2xdWzBdLCBwb2ludHNbbF1bMV0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0UG9pbnQ6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuICAgIHZhciB0Q2FjaGUgPSB0aGlzLnRDYWNoZTtcbiAgICB2YXIgc3VidDtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBpZiAoIXRDYWNoZSkge1xuICAgICAgdGhpcy5fc2V0VGNhY2hlKCk7XG5cbiAgICAgIHRDYWNoZSA9IHRoaXMudENhY2hlO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaCh0Q2FjaGUsIGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICBpZiAodCA+PSB2WzBdICYmIHQgPD0gdlsxXSkge1xuICAgICAgICBzdWJ0ID0gKHQgLSB2WzBdKSAvICh2WzFdIC0gdlswXSk7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTGluZU1hdGguYXQocG9pbnRzW2luZGV4XVswXSwgcG9pbnRzW2luZGV4ICsgMV1bMF0sIHN1YnQpLFxuICAgICAgeTogTGluZU1hdGguYXQocG9pbnRzW2luZGV4XVsxXSwgcG9pbnRzW2luZGV4ICsgMV1bMV0sIHN1YnQpXG4gICAgfTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlsaW5lO1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpLFxuICAgIHBhcnNlUmFkaXVzID0gX3JlcXVpcmUucGFyc2VSYWRpdXM7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBSZWN0ID0gZnVuY3Rpb24gUmVjdChjZmcpIHtcbiAgUmVjdC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY2ZnKTtcbn07XG5cblJlY3QuQVRUUlMgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHJhZGl1czogMCxcbiAgbGluZVdpZHRoOiAxXG59O1xuVXRpbC5leHRlbmQoUmVjdCwgU2hhcGUpO1xuVXRpbC5hdWdtZW50KFJlY3QsIHtcbiAgY2FuRmlsbDogdHJ1ZSxcbiAgY2FuU3Ryb2tlOiB0cnVlLFxuICB0eXBlOiAncmVjdCcsXG4gIGdldERlZmF1bHRBdHRyczogZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICByYWRpdXM6IDBcbiAgICB9O1xuICB9LFxuICBjYWxjdWxhdGVCb3g6IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgd2lkdGggPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuICAgIHZhciBoYWxmV2lkdGggPSBsaW5lV2lkdGggLyAyO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiB4IC0gaGFsZldpZHRoLFxuICAgICAgbWluWTogeSAtIGhhbGZXaWR0aCxcbiAgICAgIG1heFg6IHggKyB3aWR0aCArIGhhbGZXaWR0aCxcbiAgICAgIG1heFk6IHkgKyBoZWlnaHQgKyBoYWxmV2lkdGhcbiAgICB9O1xuICB9LFxuICBjcmVhdGVQYXRoOiBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgd2lkdGggPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gYXR0cnMuaGVpZ2h0O1xuICAgIHZhciByYWRpdXMgPSBhdHRycy5yYWRpdXM7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgc2VsZi5nZXQoJ2NvbnRleHQnKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKHJhZGl1cyA9PT0gMCkge1xuICAgICAgLy8g5pS55oiQ5Y6f55Sf55qEcmVjdOaWueazlVxuICAgICAgY29udGV4dC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgciA9IHBhcnNlUmFkaXVzKHJhZGl1cyk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgci5yMSwgeSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgd2lkdGggLSByLnIyLCB5KTtcbiAgICAgIHIucjIgIT09IDAgJiYgY29udGV4dC5hcmMoeCArIHdpZHRoIC0gci5yMiwgeSArIHIucjIsIHIucjIsIC1NYXRoLlBJIC8gMiwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByLnIzKTtcbiAgICAgIHIucjMgIT09IDAgJiYgY29udGV4dC5hcmMoeCArIHdpZHRoIC0gci5yMywgeSArIGhlaWdodCAtIHIucjMsIHIucjMsIDAsIE1hdGguUEkgLyAyKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyByLnI0LCB5ICsgaGVpZ2h0KTtcbiAgICAgIHIucjQgIT09IDAgJiYgY29udGV4dC5hcmMoeCArIHIucjQsIHkgKyBoZWlnaHQgLSByLnI0LCByLnI0LCBNYXRoLlBJIC8gMiwgTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4LCB5ICsgci5yMSk7XG4gICAgICByLnIxICE9PSAwICYmIGNvbnRleHQuYXJjKHggKyByLnIxLCB5ICsgci5yMSwgci5yMSwgTWF0aC5QSSwgTWF0aC5QSSAqIDEuNSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlY3Q7XG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIENUZXh0ID0gZnVuY3Rpb24gQ1RleHQoY2ZnKSB7XG4gIENUZXh0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuQ1RleHQuQVRUUlMgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHRleHQ6IG51bGwsXG4gIGZvbnRTaXplOiAxMixcbiAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICBmb250U3R5bGU6ICdub3JtYWwnLFxuICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gIHRleHRCYXNlbGluZTogJ2JvdHRvbScsXG4gIGxpbmVIZWlnaHQ6IG51bGwsXG4gIHRleHRBcnI6IG51bGxcbn07XG5VdGlsLmV4dGVuZChDVGV4dCwgU2hhcGUpO1xuVXRpbC5hdWdtZW50KENUZXh0LCB7XG4gIGNhbkZpbGw6IHRydWUsXG4gIGNhblN0cm9rZTogdHJ1ZSxcbiAgdHlwZTogJ3RleHQnLFxuICBnZXREZWZhdWx0QXR0cnM6IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgbGluZUNvdW50OiAxLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnYm90dG9tJ1xuICAgIH07XG4gIH0sXG4gIGluaXRUcmFuc2Zvcm06IGZ1bmN0aW9uIGluaXRUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fYXR0cnMuZm9udFNpemU7XG5cbiAgICBpZiAoZm9udFNpemUgJiYgK2ZvbnRTaXplIDwgMTIpIHtcbiAgICAgIC8vIOWwj+S6jiAxMiDlg4/ntKDnmoTmlofmnKzov5vooYwgc2NhbGUg5aSE55CGXG4gICAgICB0aGlzLnRyYW5zZm9ybShbWyd0JywgLTEgKiB0aGlzLl9hdHRycy54LCAtMSAqIHRoaXMuX2F0dHJzLnldLCBbJ3MnLCArZm9udFNpemUgLyAxMiwgK2ZvbnRTaXplIC8gMTJdLCBbJ3QnLCB0aGlzLl9hdHRycy54LCB0aGlzLl9hdHRycy55XV0pO1xuICAgIH1cbiAgfSxcbiAgX2Fzc2VtYmxlRm9udDogZnVuY3Rpb24gX2Fzc2VtYmxlRm9udCgpIHtcbiAgICAvLyB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIGZvbnRTaXplID0gYXR0cnMuZm9udFNpemU7XG4gICAgdmFyIGZvbnRGYW1pbHkgPSBhdHRycy5mb250RmFtaWx5O1xuICAgIHZhciBmb250V2VpZ2h0ID0gYXR0cnMuZm9udFdlaWdodDtcbiAgICB2YXIgZm9udFN0eWxlID0gYXR0cnMuZm9udFN0eWxlOyAvLyBzZWxmLmF0dHIoJ2ZvbnRTdHlsZScpO1xuXG4gICAgdmFyIGZvbnRWYXJpYW50ID0gYXR0cnMuZm9udFZhcmlhbnQ7IC8vIHNlbGYuYXR0cignZm9udFZhcmlhbnQnKTtcbiAgICAvLyBzZWxmLmF0dHIoJ2ZvbnQnLCBbZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUgKyAncHgnLCBmb250RmFtaWx5XS5qb2luKCcgJykpO1xuXG4gICAgYXR0cnMuZm9udCA9IFtmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSArICdweCcsIGZvbnRGYW1pbHldLmpvaW4oJyAnKTtcbiAgfSxcbiAgX3NldEF0dHJUZXh0OiBmdW5jdGlvbiBfc2V0QXR0clRleHQoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIHRleHQgPSBhdHRycy50ZXh0O1xuICAgIHZhciB0ZXh0QXJyID0gbnVsbDtcblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKHRleHQpICYmIHRleHQuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICB0ZXh0QXJyID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgbGluZUNvdW50ID0gdGV4dEFyci5sZW5ndGg7XG4gICAgICBhdHRycy5saW5lQ291bnQgPSBsaW5lQ291bnQ7XG4gICAgfVxuXG4gICAgYXR0cnMudGV4dEFyciA9IHRleHRBcnI7XG4gIH0sXG4gIF9nZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbiBfZ2V0VGV4dEhlaWdodCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgICB2YXIgbGluZUNvdW50ID0gYXR0cnMubGluZUNvdW50O1xuICAgIHZhciBmb250U2l6ZSA9IGF0dHJzLmZvbnRTaXplICogMTtcblxuICAgIGlmIChsaW5lQ291bnQgPiAxKSB7XG4gICAgICB2YXIgc3BhY2VpbmdZID0gdGhpcy5fZ2V0U3BhY2VpbmdZKCk7XG5cbiAgICAgIHJldHVybiBmb250U2l6ZSAqIGxpbmVDb3VudCArIHNwYWNlaW5nWSAqIChsaW5lQ291bnQgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udFNpemU7XG4gIH0sXG4gIGlzSGl0Qm94OiBmdW5jdGlvbiBpc0hpdEJveCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGNhbGN1bGF0ZUJveDogZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgY2ZnID0gdGhpcy5fY2ZnO1xuXG4gICAgaWYgKCFjZmcuYXR0cnMgfHwgY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXNzZW1ibGVGb250KCk7XG5cbiAgICAgIHRoaXMuX3NldEF0dHJUZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRycy50ZXh0QXJyKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyVGV4dCgpO1xuICAgIH1cblxuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG4gICAgdmFyIHdpZHRoID0gc2VsZi5tZWFzdXJlVGV4dCgpOyAvLyBhdHRycy53aWR0aFxuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgLy8g5aaC5p6cd2lkdGjkuI3lrZjlnKjvvIzlm5vngrnlhbHlhbblrp7ngrlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IHgsXG4gICAgICAgIG1pblk6IHksXG4gICAgICAgIG1heFg6IHgsXG4gICAgICAgIG1heFk6IHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodCA9IHNlbGYuX2dldFRleHRIZWlnaHQoKTsgLy8gYXR0cnMuaGVpZ2h0XG5cblxuICAgIHZhciB0ZXh0QWxpZ24gPSBhdHRycy50ZXh0QWxpZ247XG4gICAgdmFyIHRleHRCYXNlbGluZSA9IGF0dHJzLnRleHRCYXNlbGluZTtcbiAgICB2YXIgbGluZVdpZHRoID0gc2VsZi5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSAtIGhlaWdodFxuICAgIH07XG5cbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnZW5kJyB8fCB0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcG9pbnQueCAtPSB3aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBwb2ludC54IC09IHdpZHRoIC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAndG9wJykge1xuICAgICAgICBwb2ludC55ICs9IGhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICBwb2ludC55ICs9IGhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoJ3N0YXJ0UG9pbnQnLCBwb2ludCk7XG4gICAgdmFyIGhhbGZXaWR0aCA9IGxpbmVXaWR0aCAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHBvaW50LnggLSBoYWxmV2lkdGgsXG4gICAgICBtaW5ZOiBwb2ludC55IC0gaGFsZldpZHRoLFxuICAgICAgbWF4WDogcG9pbnQueCArIHdpZHRoICsgaGFsZldpZHRoLFxuICAgICAgbWF4WTogcG9pbnQueSArIGhlaWdodCArIGhhbGZXaWR0aFxuICAgIH07XG4gIH0sXG4gIF9nZXRTcGFjZWluZ1k6IGZ1bmN0aW9uIF9nZXRTcGFjZWluZ1koKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBhdHRycy5saW5lSGVpZ2h0O1xuICAgIHZhciBmb250U2l6ZSA9IGF0dHJzLmZvbnRTaXplICogMTtcbiAgICByZXR1cm4gbGluZUhlaWdodCA/IGxpbmVIZWlnaHQgLSBmb250U2l6ZSA6IGZvbnRTaXplICogMC4xNDtcbiAgfSxcbiAgZHJhd0lubmVyOiBmdW5jdGlvbiBkcmF3SW5uZXIoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgY2ZnID0gdGhpcy5fY2ZnO1xuXG4gICAgaWYgKCFjZmcuYXR0cnMgfHwgY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXNzZW1ibGVGb250KCk7XG5cbiAgICAgIHRoaXMuX3NldEF0dHJUZXh0KCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5mb250ID0gYXR0cnMuZm9udDtcbiAgICB2YXIgdGV4dCA9IGF0dHJzLnRleHQ7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dEFyciA9IGF0dHJzLnRleHRBcnI7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKHNlbGYuaGFzU3Ryb2tlKCkpIHtcbiAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXR0cnMuc3Ryb2tlT3BhY2l0eTtcblxuICAgICAgaWYgKCFVdGlsLmlzTmlsKHN0cm9rZU9wYWNpdHkpICYmIHN0cm9rZU9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0QXJyKSB7XG4gICAgICAgIHNlbGYuX2RyYXdUZXh0QXJyKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaGFzRmlsbCgpKSB7XG4gICAgICB2YXIgZmlsbE9wYWNpdHkgPSBhdHRycy5maWxsT3BhY2l0eTtcblxuICAgICAgaWYgKCFVdGlsLmlzTmlsKGZpbGxPcGFjaXR5KSAmJiBmaWxsT3BhY2l0eSAhPT0gMSkge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZmlsbE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0QXJyKSB7XG4gICAgICAgIHNlbGYuX2RyYXdUZXh0QXJyKGNvbnRleHQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZmcuaGFzVXBkYXRlID0gZmFsc2U7XG4gIH0sXG4gIF9kcmF3VGV4dEFycjogZnVuY3Rpb24gX2RyYXdUZXh0QXJyKGNvbnRleHQsIGZpbGwpIHtcbiAgICB2YXIgdGV4dEFyciA9IHRoaXMuX2F0dHJzLnRleHRBcnI7XG4gICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuX2F0dHJzLnRleHRCYXNlbGluZTtcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLl9hdHRycy5mb250U2l6ZSAqIDE7XG5cbiAgICB2YXIgc3BhY2VpbmdZID0gdGhpcy5fZ2V0U3BhY2VpbmdZKCk7XG5cbiAgICB2YXIgeCA9IHRoaXMuX2F0dHJzLng7XG4gICAgdmFyIHkgPSB0aGlzLl9hdHRycy55O1xuICAgIHZhciBib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICB2YXIgaGVpZ2h0ID0gYm94Lm1heFkgLSBib3gubWluWTtcbiAgICB2YXIgc3ViWTtcbiAgICBVdGlsLmVhY2godGV4dEFyciwgZnVuY3Rpb24gKHN1YlRleHQsIGluZGV4KSB7XG4gICAgICBzdWJZID0geSArIGluZGV4ICogKHNwYWNlaW5nWSArIGZvbnRTaXplKSAtIGhlaWdodCArIGZvbnRTaXplOyAvLyBib3R0b207XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSBzdWJZICs9IGhlaWdodCAtIGZvbnRTaXplIC0gKGhlaWdodCAtIGZvbnRTaXplKSAvIDI7XG4gICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAndG9wJykgc3ViWSArPSBoZWlnaHQgLSBmb250U2l6ZTtcblxuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChzdWJUZXh0LCB4LCBzdWJZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChzdWJUZXh0LCB4LCBzdWJZKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgdGV4dCA9IGF0dHJzLnRleHQ7XG4gICAgdmFyIGZvbnQgPSBhdHRycy5mb250O1xuICAgIHZhciB0ZXh0QXJyID0gYXR0cnMudGV4dEFycjtcbiAgICB2YXIgbWVhc3VyZVdpZHRoO1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgaWYgKFV0aWwuaXNOaWwodGV4dCkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG5cbiAgICBpZiAodGV4dEFycikge1xuICAgICAgVXRpbC5lYWNoKHRleHRBcnIsIGZ1bmN0aW9uIChzdWJUZXh0KSB7XG4gICAgICAgIG1lYXN1cmVXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQoc3ViVGV4dCkud2lkdGg7XG5cbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZVdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBtZWFzdXJlV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBDVGV4dDtcblxuLyoqKi8gfSksXG4vKiAxMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcmNfdmFsdWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NyY192YWx1ZV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfYXJyYXlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIyKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludGVycG9sYXRlQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY19hcnJheV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfYmFzaXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVCYXNpc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc3JjX2Jhc2lzX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3NyY19iYXNpc0Nsb3NlZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fc3JjX2Jhc2lzQ2xvc2VkX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3NyY19kYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnBvbGF0ZURhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX3NyY19kYXRlX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3NyY19udW1iZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVOdW1iZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX3NyY19udW1iZXJfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fc3JjX29iamVjdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX3NyY19vYmplY3RfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fc3JjX3JvdW5kX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnBvbGF0ZVJvdW5kXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19zcmNfcm91bmRfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fc3JjX3N0cmluZ19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVTdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3NyY19zdHJpbmdfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fc3JjX3RyYW5zZm9ybV9pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDYpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3NyY190cmFuc2Zvcm1faW5kZXhfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3NyY190cmFuc2Zvcm1faW5kZXhfX1tcImJcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX3NyY196b29tX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnBvbGF0ZVpvb21cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19zcmNfem9vbV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fc3JjX3JnYl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVSZ2JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19zcmNfcmdiX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludGVycG9sYXRlUmdiQmFzaXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19zcmNfcmdiX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludGVycG9sYXRlUmdiQmFzaXNDbG9zZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19zcmNfcmdiX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19zcmNfaHNsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnBvbGF0ZUhzbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3NyY19oc2xfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVIc2xMb25nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fc3JjX2hzbF9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fc3JjX2xhYl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVMYWJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19zcmNfbGFiX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19zcmNfaGNsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnBvbGF0ZUhjbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX3NyY19oY2xfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVIY2xMb25nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fc3JjX2hjbF9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fc3JjX2N1YmVoZWxpeF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTMpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW50ZXJwb2xhdGVDdWJlaGVsaXhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19zcmNfY3ViZWhlbGl4X19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludGVycG9sYXRlQ3ViZWhlbGl4TG9uZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3NyY19jdWJlaGVsaXhfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX3NyY19xdWFudGl6ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicXVhbnRpemVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19zcmNfcXVhbnRpemVfX1tcImFcIl07IH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqKi8gfSksXG4vKiAxMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZzJyYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByYWQyZGVnOyB9KTtcbnZhciBkZWcycmFkID0gTWF0aC5QSSAvIDE4MDtcbnZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYkJhc2lzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmdiQmFzaXNDbG9zZWQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19iYXNpc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19iYXNpc0Nsb3NlZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2NvbG9yX19bXCJiXCIgLyogZ2FtbWEgKi9dKSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fW1wiZlwiIC8qIHJnYiAqL10pKHN0YXJ0KSkuciwgKGVuZCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImZcIiAvKiByZ2IgKi9dKShlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG4gIHJldHVybiByZ2I7XG59KSgxKSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksXG4gICAgICAgIGNvbG9yO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX19bXCJmXCIgLyogcmdiICovXSkoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG5cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fYmFzaXNfX1tcImJcIiAvKiBkZWZhdWx0ICovXSk7XG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19iYXNpc0Nsb3NlZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuLyoqKi8gfSksXG4vKiAxMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYXNpc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFzaXNfX1tcImFcIiAvKiBiYXNpcyAqL10pKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdmFsdWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdmFsdWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoYVtpXSwgYltpXSk7XG5cbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG5cbiAgICByZXR1cm4gYztcbiAgfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICsgYiAqIHQpLCBkO1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdmFsdWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3ZhbHVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG5cbiAgICByZXR1cm4gYztcbiAgfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX251bWJlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbmUoYikge1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLFxuICAgICAgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICBhbSxcbiAgICAgIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICBibSxcbiAgICAgIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICBicyxcbiAgICAgIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gIGkgPSAtMSxcbiAgICAgIC8vIGluZGV4IGluIHNcbiAgcyA9IFtdLFxuICAgICAgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiOyAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSkgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7XG4gICAgICAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuXG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7XG4gICAgICAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSxcbiAgICAgICAgeDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbnVtYmVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGFtLCBibSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfSAvLyBBZGQgcmVtYWlucyBvZiBiLlxuXG5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH0gLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG5cblxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gcVswXSA/IG9uZShxWzBdLngpIDogemVybyhiKSA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uICh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcblxuICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBEZWZhdWx0IGFuaW1hdGlvbiBjb25maWd1cmF0aW9uIGZvciBnZW9tc1xuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEFjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwKTtcblxudmFyIGRlZmF1bHRBbmltYXRpb25DZmcgPSB7XG4gIGFwcGVhcjoge1xuICAgIGR1cmF0aW9uOiA0NTAsXG4gICAgZWFzaW5nOiAnZWFzZVF1YWRPdXQnXG4gIH0sXG4gIC8vIOWIneWni+WFpeWcuuWKqOeUu+mFjee9rlxuICB1cGRhdGU6IHtcbiAgICBkdXJhdGlvbjogNDUwLFxuICAgIGVhc2luZzogJ2Vhc2VRdWFkSW5PdXQnXG4gIH0sXG4gIC8vIOabtOaWsOaXtuWPkeeUn+WPmOabtOeahOWKqOeUu+mFjee9rlxuICBlbnRlcjoge1xuICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgZWFzaW5nOiAnZWFzZVF1YWRJbk91dCcsXG4gICAgZGVsYXk6IDEwMFxuICB9LFxuICAvLyDmm7TmlrDml7bmlrDlop7lhYPntKDnmoTlhaXlnLrliqjnlLvphY3nva5cbiAgbGVhdmU6IHtcbiAgICBkdXJhdGlvbjogMzUwLFxuICAgIGVhc2luZzogJ2Vhc2VRdWFkSW4nIC8vIOabtOaWsOaXtumUgOavgeWKqOeUu+mFjee9rlxuXG4gIH1cbn07XG52YXIgQW5pbWF0ZSA9IHtcbiAgbGluZToge1xuICAgIGFwcGVhcjogZnVuY3Rpb24gYXBwZWFyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuY2xpcEluO1xuICAgIH0sXG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5lbnRlci5jbGlwSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLmxpbmVXaWR0aE91dDtcbiAgICB9XG4gIH0sXG4gIHBhdGg6IHtcbiAgICBhcHBlYXI6IGZ1bmN0aW9uIGFwcGVhcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uYXBwZWFyLmNsaXBJbjtcbiAgICB9LFxuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uZW50ZXIuY2xpcEluO1xuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5sZWF2ZS5saW5lV2lkdGhPdXQ7XG4gICAgfVxuICB9LFxuICBhcmVhOiB7XG4gICAgYXBwZWFyOiBmdW5jdGlvbiBhcHBlYXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmFwcGVhci5jbGlwSW47XG4gICAgfSxcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmVudGVyLmZhZGVJbjtcbiAgICB9LFxuICAgIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZSgpIHtcbiAgICAgIHJldHVybiBBY3Rpb24ubGVhdmUuZmFkZU91dDtcbiAgICB9LFxuICAgIGNmZzoge1xuICAgICAgYXBwZWFyOiB7XG4gICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VRdWFkT3V0J1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICBkdXJhdGlvbjogNDUwLFxuICAgICAgICBlYXNpbmc6ICdlYXNlUXVhZEluT3V0J1xuICAgICAgfSxcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGR1cmF0aW9uOiA2MDAsXG4gICAgICAgIGRlbGF5OiAxNTAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VRdWFkSW5PdXQnXG4gICAgICB9LFxuICAgICAgbGVhdmU6IHtcbiAgICAgICAgZWFzaW5nOiAnZWFzZVF1YWRPdXQnLFxuICAgICAgICBkdXJhdGlvbjogMzUwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2x5Z29uOiB7XG4gICAgYXBwZWFyOiBmdW5jdGlvbiBhcHBlYXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmFwcGVhci56b29tSW47XG4gICAgfSxcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmVudGVyLnpvb21JbjtcbiAgICB9LFxuICAgIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZSgpIHtcbiAgICAgIHJldHVybiBBY3Rpb24ubGVhdmUuem9vbU91dDtcbiAgICB9XG4gIH0sXG4gIGVkZ2U6IHtcbiAgICBhcHBlYXI6IGZ1bmN0aW9uIGFwcGVhcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uYXBwZWFyLnBhdGhJbjtcbiAgICB9LFxuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uZW50ZXIucGF0aEluO1xuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5sZWF2ZS5wYXRoT3V0O1xuICAgIH1cbiAgfSxcbiAgaW50ZXJ2YWw6IHtcbiAgICBhcHBlYXI6IGZ1bmN0aW9uIGFwcGVhcihjb29yZCkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGNvb3JkLmlzUG9sYXIpIHtcbiAgICAgICAgcmVzdWx0ID0gQWN0aW9uLmFwcGVhci56b29tSW47XG5cbiAgICAgICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCB8fCBjb29yZC50eXBlID09PSAndGhldGEnKSB7XG4gICAgICAgICAgcmVzdWx0ID0gQWN0aW9uLmFwcGVhci5mYW5JbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb29yZC5pc1JlY3QpIHtcbiAgICAgICAgcmVzdWx0ID0gY29vcmQuaXNUcmFuc3Bvc2VkID8gQWN0aW9uLmFwcGVhci5zY2FsZUluWCA6IEFjdGlvbi5hcHBlYXIuc2NhbGVJblk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBBY3Rpb24uYXBwZWFyLnpvb21JbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcihjb29yZCkge1xuICAgICAgaWYgKGNvb3JkLmlzUmVjdCB8fCBjb29yZC5pc1RyYW5zcG9zZWQgfHwgY29vcmQudHlwZSA9PT0gJ3RoZXRhJykge1xuICAgICAgICByZXR1cm4gQWN0aW9uLmVudGVyLmZhZGVJbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEFjdGlvbi5lbnRlci56b29tSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLmZhZGVPdXQ7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShjb29yZCkge1xuICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICd0aGV0YScpIHtcbiAgICAgICAgcmV0dXJuIEFjdGlvbi51cGRhdGUuZmFuSW47XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDoge1xuICAgIGFwcGVhcjogZnVuY3Rpb24gYXBwZWFyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuem9vbUluO1xuICAgIH0sXG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5lbnRlci56b29tSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLnpvb21PdXQ7XG4gICAgfVxuICB9LFxuICBzY2hlbWE6IHtcbiAgICBhcHBlYXI6IGZ1bmN0aW9uIGFwcGVhcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uYXBwZWFyLmNsaXBJbjtcbiAgICB9LFxuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcigpIHtcbiAgICAgIHJldHVybiBBY3Rpb24uZW50ZXIuY2xpcEluO1xuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5sZWF2ZS5saW5lV2lkdGhPdXQ7XG4gICAgfVxuICB9LFxuICBjb250b3VyOiBudWxsLFxuICBoZWF0bWFwOiBudWxsLFxuICBsYWJlbDoge1xuICAgIGFwcGVhcjogZnVuY3Rpb24gYXBwZWFyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuZmFkZUluO1xuICAgIH0sXG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5lbnRlci5mYWRlSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLmZhZGVPdXQ7XG4gICAgfSxcbiAgICBjZmc6IHtcbiAgICAgIGFwcGVhcjoge1xuICAgICAgICBkdXJhdGlvbjogOTAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnYXhpcy1sYWJlbCc6IHtcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmFwcGVhci5mYWRlSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLmZhZGVPdXQ7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShjb29yZCkge1xuICAgICAgaWYgKGNvb3JkLmlzUG9sYXIpIHtcbiAgICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuZmFkZUluO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2F4aXMtdGlja3MnOiB7XG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuZmFkZUluO1xuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5sZWF2ZS5mYWRlT3V0O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoY29vcmQpIHtcbiAgICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICAgIHJldHVybiBBY3Rpb24uYXBwZWFyLmZhZGVJbjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdheGlzLWdyaWQnOiB7XG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5hcHBlYXIuZmFkZUluO1xuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgcmV0dXJuIEFjdGlvbi5sZWF2ZS5mYWRlT3V0O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoY29vcmQpIHtcbiAgICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICAgIHJldHVybiBBY3Rpb24uYXBwZWFyLmZhZGVJbjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdheGlzLWdyaWQtcmVjdCc6IHtcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmFwcGVhci5mYWRlSW47XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmxlYXZlLmZhZGVPdXQ7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHJldHVybiBBY3Rpb24ubGVhdmUuZmFkZUluO1xuICAgIH1cbiAgfSxcbiAgbGFiZWxMaW5lOiB7XG4gICAgYXBwZWFyOiBmdW5jdGlvbiBhcHBlYXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmFwcGVhci5wYXRoSW47XG4gICAgfSxcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICByZXR1cm4gQWN0aW9uLmVudGVyLnBhdGhJbjtcbiAgICB9LFxuICAgIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZSgpIHtcbiAgICAgIHJldHVybiBBY3Rpb24ubGVhdmUucGF0aE91dDtcbiAgICB9XG4gIH1cbn07XG5BbmltYXRlLkFjdGlvbiA9IEFjdGlvbjtcbkFuaW1hdGUuZGVmYXVsdENmZyA9IGRlZmF1bHRBbmltYXRpb25DZmc7IC8vIOiOt+WPluWKqOeUu1xuXG5BbmltYXRlLmdldEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChnZW9tVHlwZSwgY29vcmQsIGFuaW1hdGlvblR5cGUpIHtcbiAgdmFyIGdlb21BbmltYXRlQ2ZnID0gdGhpc1tnZW9tVHlwZV07XG5cbiAgaWYgKGdlb21BbmltYXRlQ2ZnKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IGdlb21BbmltYXRlQ2ZnW2FuaW1hdGlvblR5cGVdO1xuXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihhbmltYXRpb24pKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uKGNvb3JkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyDojrflj5bliqjnlLvphY3nva5cblxuXG5BbmltYXRlLmdldEFuaW1hdGVDZmcgPSBmdW5jdGlvbiAoZ2VvbVR5cGUsIGFuaW1hdGlvblR5cGUpIHtcbiAgdmFyIGRlZmF1bHRDZmcgPSBkZWZhdWx0QW5pbWF0aW9uQ2ZnW2FuaW1hdGlvblR5cGVdO1xuXG4gIGlmICh0aGlzW2dlb21UeXBlXSAmJiB0aGlzW2dlb21UeXBlXS5jZmcgJiYgdGhpc1tnZW9tVHlwZV0uY2ZnW2FuaW1hdGlvblR5cGVdKSB7XG4gICAgcmV0dXJuIFV0aWwuZGVlcE1peCh7fSwgZGVmYXVsdENmZywgdGhpc1tnZW9tVHlwZV0uY2ZnW2FuaW1hdGlvblR5cGVdKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2ZnO1xufTsgLy8g5rOo5YaM5Yqo55S7XG5cblxuQW5pbWF0ZS5yZWdpc3RlckFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb25UeXBlLCBhbmltYXRpb25OYW1lLCBhbmltYXRpb25GdW4pIHtcbiAgaWYgKCF0aGlzLkFjdGlvblthbmltYXRpb25UeXBlXSkge1xuICAgIHRoaXMuQWN0aW9uW2FuaW1hdGlvblR5cGVdID0ge307XG4gIH1cblxuICB0aGlzLkFjdGlvblthbmltYXRpb25UeXBlXVthbmltYXRpb25OYW1lXSA9IGFuaW1hdGlvbkZ1bjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0ZTtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgbWl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTsgLy8gY29sbGVjdGlvbnNcblxuXG52YXIgRE9NVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjI4KTtcblxudmFyIGFycmF5VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3KTtcblxudmFyIGV2ZW50VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ4KTtcblxudmFyIGZvcm1hdFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MSk7XG5cbnZhciBtYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjU1KTtcblxudmFyIG1hdHJpeFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxudmFyIG9iamVjdFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NCk7XG5cbnZhciBwYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY4KTtcblxudmFyIHN0cmluZ1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3NCk7XG5cbnZhciB0eXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjc4KTtcblxudmFyIHV0aWwgPSB7XG4gIC8vIGNvbGxlY3Rpb25zXG4gIERPTVV0aWw6IERPTVV0aWwsXG4gIERvbVV0aWw6IERPTVV0aWwsXG4gIE1hdHJpeFV0aWw6IG1hdHJpeFV0aWwsXG4gIFBhdGhVdGlsOiBwYXRoVXRpbCxcbiAgYXJyYXlVdGlsOiBhcnJheVV0aWwsXG4gIGRvbVV0aWw6IERPTVV0aWwsXG4gIGV2ZW50VXRpbDogZXZlbnRVdGlsLFxuICBmb3JtYXRVdGlsOiBmb3JtYXRVdGlsLFxuICBtYXRoVXRpbDogbWF0aFV0aWwsXG4gIG1hdHJpeFV0aWw6IG1hdHJpeFV0aWwsXG4gIG9iamVjdFV0aWw6IG9iamVjdFV0aWwsXG4gIHN0cmluZ1V0aWw6IHN0cmluZ1V0aWwsXG4gIHBhdGhVdGlsOiBwYXRoVXRpbCxcbiAgdHlwZVV0aWw6IHR5cGVVdGlsLFxuICAvLyBvdGhlcnNcbiAgYXVnbWVudDogX193ZWJwYWNrX3JlcXVpcmVfXyg4OSksXG4gIGNsb25lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSxcbiAgZGVib3VuY2U6IF9fd2VicGFja19yZXF1aXJlX18oMjg0KSxcbiAgZGVlcE1peDogX193ZWJwYWNrX3JlcXVpcmVfXyg0NyksXG4gIGVhY2g6IGVhY2gsXG4gIGV4dGVuZDogX193ZWJwYWNrX3JlcXVpcmVfXyg4OCksXG4gIGZpbHRlcjogX193ZWJwYWNrX3JlcXVpcmVfXyg2MyksXG4gIGdyb3VwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NCksXG4gIGdyb3VwQnk6IF9fd2VicGFja19yZXF1aXJlX18oMTQ2KSxcbiAgZ3JvdXBUb01hcDogX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpLFxuICBpbmRleE9mOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NSksXG4gIGlzRW1wdHk6IF9fd2VicGFja19yZXF1aXJlX18oODMpLFxuICBpc0VxdWFsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KSxcbiAgaXNFcXVhbFdpdGg6IF9fd2VicGFja19yZXF1aXJlX18oMjg2KSxcbiAgbWFwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NyksXG4gIG1peDogbWl4LFxuICBwaWNrOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4OCksXG4gIHRocm90dGxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4OSksXG4gIHRvQXJyYXk6IF9fd2VicGFja19yZXF1aXJlX18oMzQpLFxuICB0b1N0cmluZzogX193ZWJwYWNrX3JlcXVpcmVfXygyMyksXG4gIHVuaXF1ZUlkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KVxufTtcbmVhY2goW0RPTVV0aWwsIGFycmF5VXRpbCwgZXZlbnRVdGlsLCBmb3JtYXRVdGlsLCBtYXRoVXRpbCwgbWF0cml4VXRpbCwgb2JqZWN0VXRpbCwgcGF0aFV0aWwsIHN0cmluZ1V0aWwsIHR5cGVVdGlsXSwgZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgbWl4KHV0aWwsIGNvbGxlY3Rpb24pO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpO1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBpc01hdGNoKG9iaiwgYXR0cnMpIHtcbiAgdmFyIF9rZXlzID0ga2V5cyhhdHRycyk7XG5cbiAgdmFyIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgaWYgKGlzTmlsKG9iaikpIHJldHVybiAhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIga2V5ID0gX2tleXNbaV07XG5cbiAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWF0Y2g7XG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmICghKGlzRnVuY3Rpb24ob2JqKSAmJiBrZXkgPT09ICdwcm90b3R5cGUnKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBzcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXG52YXIgcHVsbEF0ID0gZnVuY3Rpb24gcHVsbEF0KGFyciwgaW5kZXhlcykge1xuICBpZiAoIWlzQXJyYXlMaWtlKGFycikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyID8gaW5kZXhlcy5sZW5ndGggOiAwO1xuICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIHByZXZpb3VzID0gdm9pZCAwO1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcblxuICAgIGlmIChsZW5ndGggPT09IGxhc3QgfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgc3BsaWNlLmNhbGwoYXJyLCBpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHVsbEF0O1xuXG4vKioqLyB9KSxcbi8qIDEzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBjb250YWlucyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgdW5pcSA9IGZ1bmN0aW9uIHVuaXEoYXJyKSB7XG4gIHZhciByZXN1bHRBcnIgPSBbXTtcbiAgZWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFjb250YWlucyhyZXN1bHRBcnIsIGl0ZW0pKSB7XG4gICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0QXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogbWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAqIC8vID0+IHsgJ24nOiAyIH1cbiAqXG4gKiBtYXhCeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDIgfVxuICovXG5cblxudmFyIG1heEJ5ID0gZnVuY3Rpb24gbWF4QnkoYXJyLCBmbikge1xuICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgbWF4ID0gYXJyWzBdO1xuICB2YXIgbWF4RGF0YSA9IHZvaWQgMDtcblxuICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICBtYXhEYXRhID0gZm4oYXJyWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBtYXhEYXRhID0gYXJyWzBdW2ZuXTtcbiAgfVxuXG4gIHZhciBkYXRhID0gdm9pZCAwO1xuICBlYWNoKGFyciwgZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgZGF0YSA9IGZuKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB2YWxbZm5dO1xuICAgIH1cblxuICAgIGlmIChkYXRhID4gbWF4RGF0YSkge1xuICAgICAgbWF4ID0gdmFsO1xuICAgICAgbWF4RGF0YSA9IGRhdGE7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1heDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF4Qnk7XG5cbi8qKiovIH0pLFxuLyogMTMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VJbnQ7XG5cbi8qKiovIH0pLFxuLyogMTM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIHZhbHVlcyA9IE9iamVjdC52YWx1ZXMgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmICghKGlzRnVuY3Rpb24ob2JqKSAmJiBrZXkgPT09ICdwcm90b3R5cGUnKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cbi8qKiovIH0pLFxuLyogMTM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZVBhdGhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTM3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gIGlmIChyKSB7XG4gICAgcmV0dXJuIFtbJ00nLCAreCArICtyLCB5XSwgWydsJywgdyAtIHIgKiAyLCAwXSwgWydhJywgciwgciwgMCwgMCwgMSwgciwgcl0sIFsnbCcsIDAsIGggLSByICogMl0sIFsnYScsIHIsIHIsIDAsIDAsIDEsIC1yLCByXSwgWydsJywgciAqIDIgLSB3LCAwXSwgWydhJywgciwgciwgMCwgMCwgMSwgLXIsIC1yXSwgWydsJywgMCwgciAqIDIgLSBoXSwgWydhJywgciwgciwgMCwgMCwgMSwgciwgLXJdLCBbJ3onXV07XG4gIH1cblxuICB2YXIgcmVzID0gW1snTScsIHgsIHldLCBbJ2wnLCB3LCAwXSwgWydsJywgMCwgaF0sIFsnbCcsIC13LCAwXSwgWyd6J11dO1xuICByZXMucGFyc2VQYXRoQXJyYXkgPSBwYXJzZVBhdGhBcnJheTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKiovIH0pLFxuLyogMTM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBwMnMgPSAvLD8oW2Etel0pLD8vZ2k7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQYXRoQXJyYXkocGF0aCkge1xuICByZXR1cm4gcGF0aC5qb2luKCcsJykucmVwbGFjZShwMnMsICckMScpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhdGhUb0Fic29sdXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzkpO1xuXG52YXIgYTJjID0gZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICBpZiAocnggPT09IHJ5KSB7XG4gICAgcnggKz0gMTtcbiAgfVxuXG4gIHZhciBfMTIwID0gTWF0aC5QSSAqIDEyMCAvIDE4MDtcblxuICB2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCAqICgrYW5nbGUgfHwgMCk7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIHh5ID0gdm9pZCAwO1xuICB2YXIgZjEgPSB2b2lkIDA7XG4gIHZhciBmMiA9IHZvaWQgMDtcbiAgdmFyIGN4ID0gdm9pZCAwO1xuICB2YXIgY3kgPSB2b2lkIDA7XG5cbiAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCByYWQpIHtcbiAgICB2YXIgWCA9IHggKiBNYXRoLmNvcyhyYWQpIC0geSAqIE1hdGguc2luKHJhZCk7XG4gICAgdmFyIFkgPSB4ICogTWF0aC5zaW4ocmFkKSArIHkgKiBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBYLFxuICAgICAgeTogWVxuICAgIH07XG4gIH07XG5cbiAgaWYgKCFyZWN1cnNpdmUpIHtcbiAgICB4eSA9IHJvdGF0ZSh4MSwgeTEsIC1yYWQpO1xuICAgIHgxID0geHkueDtcbiAgICB5MSA9IHh5Lnk7XG4gICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICB4MiA9IHh5Lng7XG4gICAgeTIgPSB4eS55O1xuXG4gICAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICAgIC8vIOiLpeW8p+eahOi1t+Wni+eCueWSjOe7iOeCuemHjeWPoOWImemUmeW8gOS4gOeCuVxuICAgICAgeDIgKz0gMTtcbiAgICAgIHkyICs9IDE7XG4gICAgfSAvLyBjb25zdCBjb3MgPSBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogYW5nbGUpO1xuICAgIC8vIGNvbnN0IHNpbiA9IE1hdGguc2luKE1hdGguUEkgLyAxODAgKiBhbmdsZSk7XG5cblxuICAgIHZhciB4ID0gKHgxIC0geDIpIC8gMjtcbiAgICB2YXIgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgdmFyIGggPSB4ICogeCAvIChyeCAqIHJ4KSArIHkgKiB5IC8gKHJ5ICogcnkpO1xuXG4gICAgaWYgKGggPiAxKSB7XG4gICAgICBoID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgcnggPSBoICogcng7XG4gICAgICByeSA9IGggKiByeTtcbiAgICB9XG5cbiAgICB2YXIgcngyID0gcnggKiByeDtcbiAgICB2YXIgcnkyID0gcnkgKiByeTtcbiAgICB2YXIgayA9IChsYXJnZV9hcmNfZmxhZyA9PT0gc3dlZXBfZmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoTWF0aC5hYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSk7XG4gICAgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyO1xuICAgIGN5ID0gayAqIC1yeSAqIHggLyByeCArICh5MSArIHkyKSAvIDI7XG4gICAgZjEgPSBNYXRoLmFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcbiAgICBmMiA9IE1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuICAgIGYxID0geDEgPCBjeCA/IE1hdGguUEkgLSBmMSA6IGYxO1xuICAgIGYyID0geDIgPCBjeCA/IE1hdGguUEkgLSBmMiA6IGYyO1xuICAgIGYxIDwgMCAmJiAoZjEgPSBNYXRoLlBJICogMiArIGYxKTtcbiAgICBmMiA8IDAgJiYgKGYyID0gTWF0aC5QSSAqIDIgKyBmMik7XG5cbiAgICBpZiAoc3dlZXBfZmxhZyAmJiBmMSA+IGYyKSB7XG4gICAgICBmMSA9IGYxIC0gTWF0aC5QSSAqIDI7XG4gICAgfVxuXG4gICAgaWYgKCFzd2VlcF9mbGFnICYmIGYyID4gZjEpIHtcbiAgICAgIGYyID0gZjIgLSBNYXRoLlBJICogMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZjEgPSByZWN1cnNpdmVbMF07XG4gICAgZjIgPSByZWN1cnNpdmVbMV07XG4gICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgY3kgPSByZWN1cnNpdmVbM107XG4gIH1cblxuICB2YXIgZGYgPSBmMiAtIGYxO1xuXG4gIGlmIChNYXRoLmFicyhkZikgPiBfMTIwKSB7XG4gICAgdmFyIGYyb2xkID0gZjI7XG4gICAgdmFyIHgyb2xkID0geDI7XG4gICAgdmFyIHkyb2xkID0geTI7XG4gICAgZjIgPSBmMSArIF8xMjAgKiAoc3dlZXBfZmxhZyAmJiBmMiA+IGYxID8gMSA6IC0xKTtcbiAgICB4MiA9IGN4ICsgcnggKiBNYXRoLmNvcyhmMik7XG4gICAgeTIgPSBjeSArIHJ5ICogTWF0aC5zaW4oZjIpO1xuICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gIH1cblxuICBkZiA9IGYyIC0gZjE7XG4gIHZhciBjMSA9IE1hdGguY29zKGYxKTtcbiAgdmFyIHMxID0gTWF0aC5zaW4oZjEpO1xuICB2YXIgYzIgPSBNYXRoLmNvcyhmMik7XG4gIHZhciBzMiA9IE1hdGguc2luKGYyKTtcbiAgdmFyIHQgPSBNYXRoLnRhbihkZiAvIDQpO1xuICB2YXIgaHggPSA0IC8gMyAqIHJ4ICogdDtcbiAgdmFyIGh5ID0gNCAvIDMgKiByeSAqIHQ7XG4gIHZhciBtMSA9IFt4MSwgeTFdO1xuICB2YXIgbTIgPSBbeDEgKyBoeCAqIHMxLCB5MSAtIGh5ICogYzFdO1xuICB2YXIgbTMgPSBbeDIgKyBoeCAqIHMyLCB5MiAtIGh5ICogYzJdO1xuICB2YXIgbTQgPSBbeDIsIHkyXTtcbiAgbTJbMF0gPSAyICogbTFbMF0gLSBtMlswXTtcbiAgbTJbMV0gPSAyICogbTFbMV0gLSBtMlsxXTtcblxuICBpZiAocmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocmVzKTtcbiAgfVxuXG4gIHJlcyA9IFttMiwgbTMsIG00XS5jb25jYXQocmVzKS5qb2luKCkuc3BsaXQoJywnKTtcbiAgdmFyIG5ld3JlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgbmV3cmVzW2ldID0gaSAlIDIgPyByb3RhdGUocmVzW2kgLSAxXSwgcmVzW2ldLCByYWQpLnkgOiByb3RhdGUocmVzW2ldLCByZXNbaSArIDFdLCByYWQpLng7XG4gIH1cblxuICByZXR1cm4gbmV3cmVzO1xufTtcblxudmFyIGwyYyA9IGZ1bmN0aW9uIGwyYyh4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyLCB4MiwgeTJdO1xufTtcblxudmFyIHEyYyA9IGZ1bmN0aW9uIHEyYyh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG4gIHZhciBfMTMgPSAxIC8gMztcblxuICB2YXIgXzIzID0gMiAvIDM7XG5cbiAgcmV0dXJuIFtfMTMgKiB4MSArIF8yMyAqIGF4LCBfMTMgKiB5MSArIF8yMyAqIGF5LCBfMTMgKiB4MiArIF8yMyAqIGF4LCBfMTMgKiB5MiArIF8yMyAqIGF5LCB4MiwgeTJdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXRoVG9jdXJ2ZShwYXRoLCBwYXRoMikge1xuICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpO1xuICB2YXIgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMik7XG4gIHZhciBhdHRycyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgYng6IDAsXG4gICAgYnk6IDAsXG4gICAgWDogMCxcbiAgICBZOiAwLFxuICAgIHF4OiBudWxsLFxuICAgIHF5OiBudWxsXG4gIH07XG4gIHZhciBhdHRyczIgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGJ4OiAwLFxuICAgIGJ5OiAwLFxuICAgIFg6IDAsXG4gICAgWTogMCxcbiAgICBxeDogbnVsbCxcbiAgICBxeTogbnVsbFxuICB9O1xuICB2YXIgcGNvbXMxID0gW107IC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG5cbiAgdmFyIHBjb21zMiA9IFtdOyAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcDJcblxuICB2YXIgcGZpcnN0ID0gJyc7IC8vIHRlbXBvcmFyeSBob2xkZXIgZm9yIG9yaWdpbmFsIHBhdGggY29tbWFuZFxuXG4gIHZhciBwY29tID0gJyc7IC8vIGhvbGRlciBmb3IgcHJldmlvdXMgcGF0aCBjb21tYW5kIG9mIG9yaWdpbmFsIHBhdGhcblxuICB2YXIgaWkgPSB2b2lkIDA7XG5cbiAgdmFyIHByb2Nlc3NQYXRoID0gZnVuY3Rpb24gcHJvY2Vzc1BhdGgocGF0aCwgZCwgcGNvbSkge1xuICAgIHZhciBueCA9IHZvaWQgMCxcbiAgICAgICAgbnkgPSB2b2lkIDA7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHJldHVybiBbJ0MnLCBkLngsIGQueSwgZC54LCBkLnksIGQueCwgZC55XTtcbiAgICB9XG5cbiAgICAhKHBhdGhbMF0gaW4ge1xuICAgICAgVDogMSxcbiAgICAgIFE6IDFcbiAgICB9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcblxuICAgIHN3aXRjaCAocGF0aFswXSkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChhMmMuYXBwbHkoMCwgW2QueCwgZC55XS5jb25jYXQocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICBpZiAocGNvbSA9PT0gJ0MnIHx8IHBjb20gPT09ICdTJykge1xuICAgICAgICAgIC8vIEluIFwiU1wiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgIG54ID0gZC54ICogMiAtIGQuYng7IC8vIEFuZCByZWZsZWN0IHRoZSBwcmV2aW91c1xuXG4gICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBbJ0MnLCBueCwgbnldLmNvbmNhdChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICBpZiAocGNvbSA9PT0gJ1EnIHx8IHBjb20gPT09ICdUJykge1xuICAgICAgICAgIC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgLy8gQW5kIG1ha2UgYSByZWZsZWN0aW9uIHNpbWlsYXJcblxuICAgICAgICAgIGQucXkgPSBkLnkgKiAyIC0gZC5xeTsgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgZC5xeSA9IHBhdGhbMl07XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQocTJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdLCBwYXRoWzNdLCBwYXRoWzRdKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KGwyYyhkLngsIGQueSwgcGF0aFsxXSwgZC55KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChsMmMoZC54LCBkLnksIGQueCwgcGF0aFsxXSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQobDJjKGQueCwgZC55LCBkLlgsIGQuWSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgdmFyIGZpeEFyYyA9IGZ1bmN0aW9uIGZpeEFyYyhwcCwgaSkge1xuICAgIGlmIChwcFtpXS5sZW5ndGggPiA3KSB7XG4gICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgdmFyIHBpID0gcHBbaV07XG5cbiAgICAgIHdoaWxlIChwaS5sZW5ndGgpIHtcbiAgICAgICAgcGNvbXMxW2ldID0gJ0EnOyAvLyBpZiBjcmVhdGVkIG11bHRpcGxlIEM6cywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG5cbiAgICAgICAgcDIgJiYgKHBjb21zMltpXSA9ICdBJyk7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG5cbiAgICAgICAgcHAuc3BsaWNlKGkrKywgMCwgWydDJ10uY29uY2F0KHBpLnNwbGljZSgwLCA2KSkpO1xuICAgICAgfVxuXG4gICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBmaXhNID0gZnVuY3Rpb24gZml4TShwYXRoMSwgcGF0aDIsIGExLCBhMiwgaSkge1xuICAgIGlmIChwYXRoMSAmJiBwYXRoMiAmJiBwYXRoMVtpXVswXSA9PT0gJ00nICYmIHBhdGgyW2ldWzBdICE9PSAnTScpIHtcbiAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbJ00nLCBhMi54LCBhMi55XSk7XG4gICAgICBhMS5ieCA9IDA7XG4gICAgICBhMS5ieSA9IDA7XG4gICAgICBhMS54ID0gcGF0aDFbaV1bMV07XG4gICAgICBhMS55ID0gcGF0aDFbaV1bMl07XG4gICAgICBpaSA9IE1hdGgubWF4KHAubGVuZ3RoLCBwMiAmJiBwMi5sZW5ndGggfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIGlpID0gTWF0aC5tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICBwW2ldICYmIChwZmlyc3QgPSBwW2ldWzBdKTsgLy8gc2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuXG4gICAgaWYgKHBmaXJzdCAhPT0gJ0MnKSB7XG4gICAgICAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgICAgaSAmJiAocGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICB9XG5cbiAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgIGlmIChwY29tczFbaV0gIT09ICdBJyAmJiBwZmlyc3QgPT09ICdDJykgcGNvbXMxW2ldID0gJ0MnOyAvLyBBIGlzIHRoZSBvbmx5IGNvbW1hbmRcbiAgICAvLyB3aGljaCBtYXkgcHJvZHVjZSBtdWx0aXBsZSBDOnNcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgIGZpeEFyYyhwLCBpKTsgLy8gZml4QXJjIGFkZHMgYWxzbyB0aGUgcmlnaHQgYW1vdW50IG9mIEE6cyB0byBwY29tczFcblxuICAgIGlmIChwMikge1xuICAgICAgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICBwMltpXSAmJiAocGZpcnN0ID0gcDJbaV1bMF0pO1xuXG4gICAgICBpZiAocGZpcnN0ICE9PSAnQycpIHtcbiAgICAgICAgcGNvbXMyW2ldID0gcGZpcnN0O1xuICAgICAgICBpICYmIChwY29tID0gcGNvbXMyW2kgLSAxXSk7XG4gICAgICB9XG5cbiAgICAgIHAyW2ldID0gcHJvY2Vzc1BhdGgocDJbaV0sIGF0dHJzMiwgcGNvbSk7XG5cbiAgICAgIGlmIChwY29tczJbaV0gIT09ICdBJyAmJiBwZmlyc3QgPT09ICdDJykge1xuICAgICAgICBwY29tczJbaV0gPSAnQyc7XG4gICAgICB9XG5cbiAgICAgIGZpeEFyYyhwMiwgaSk7XG4gICAgfVxuXG4gICAgZml4TShwLCBwMiwgYXR0cnMsIGF0dHJzMiwgaSk7XG4gICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgdmFyIHNlZyA9IHBbaV07XG4gICAgdmFyIHNlZzIgPSBwMiAmJiBwMltpXTtcbiAgICB2YXIgc2VnbGVuID0gc2VnLmxlbmd0aDtcbiAgICB2YXIgc2VnMmxlbiA9IHAyICYmIHNlZzIubGVuZ3RoO1xuICAgIGF0dHJzLnggPSBzZWdbc2VnbGVuIC0gMl07XG4gICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICBhdHRycy5ieCA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgIGF0dHJzLmJ5ID0gcGFyc2VGbG9hdChzZWdbc2VnbGVuIC0gM10pIHx8IGF0dHJzLnk7XG4gICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHBhcnNlRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICBhdHRyczIuYnkgPSBwMiAmJiAocGFyc2VGbG9hdChzZWcyW3NlZzJsZW4gLSAzXSkgfHwgYXR0cnMyLnkpO1xuICAgIGF0dHJzMi54ID0gcDIgJiYgc2VnMltzZWcybGVuIC0gMl07XG4gICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgfVxuXG4gIHJldHVybiBwMiA/IFtwLCBwMl0gOiBwO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhcnNlUGF0aFN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKTtcblxudmFyIGNhdG11bGxSb20yYmV6aWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDEpO1xuXG5mdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIGlmIChhID09PSBudWxsICYmIHJ5ID09PSBudWxsKSB7XG4gICAgcnkgPSByeDtcbiAgfVxuXG4gIHggPSAreDtcbiAgeSA9ICt5O1xuICByeCA9ICtyeDtcbiAgcnkgPSArcnk7XG5cbiAgaWYgKGEgIT09IG51bGwpIHtcbiAgICB2YXIgcmFkID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgeDEgPSB4ICsgcnggKiBNYXRoLmNvcygtcnkgKiByYWQpO1xuICAgIHZhciB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKTtcbiAgICB2YXIgeTEgPSB5ICsgcnggKiBNYXRoLnNpbigtcnkgKiByYWQpO1xuICAgIHZhciB5MiA9IHkgKyByeCAqIE1hdGguc2luKC1hICogcmFkKTtcbiAgICByZXMgPSBbWydNJywgeDEsIHkxXSwgWydBJywgcngsIHJ4LCAwLCArKGEgLSByeSA+IDE4MCksIDAsIHgyLCB5Ml1dO1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IFtbJ00nLCB4LCB5XSwgWydtJywgMCwgLXJ5XSwgWydhJywgcngsIHJ5LCAwLCAxLCAxLCAwLCAyICogcnldLCBbJ2EnLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLCBbJ3onXV07XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuICBwYXRoQXJyYXkgPSBwYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcblxuICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBbWydNJywgMCwgMF1dO1xuICB9XG5cbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIG14ID0gMDtcbiAgdmFyIG15ID0gMDtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHBhMCA9IHZvaWQgMDtcbiAgdmFyIGRvdHMgPSB2b2lkIDA7XG5cbiAgaWYgKHBhdGhBcnJheVswXVswXSA9PT0gJ00nKSB7XG4gICAgeCA9ICtwYXRoQXJyYXlbMF1bMV07XG4gICAgeSA9ICtwYXRoQXJyYXlbMF1bMl07XG4gICAgbXggPSB4O1xuICAgIG15ID0geTtcbiAgICBzdGFydCsrO1xuICAgIHJlc1swXSA9IFsnTScsIHgsIHldO1xuICB9XG5cbiAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT09IDMgJiYgcGF0aEFycmF5WzBdWzBdID09PSAnTScgJiYgcGF0aEFycmF5WzFdWzBdLnRvVXBwZXJDYXNlKCkgPT09ICdSJyAmJiBwYXRoQXJyYXlbMl1bMF0udG9VcHBlckNhc2UoKSA9PT0gJ1onO1xuXG4gIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICByZXMucHVzaChyID0gW10pO1xuICAgIHBhID0gcGF0aEFycmF5W2ldO1xuICAgIHBhMCA9IHBhWzBdO1xuXG4gICAgaWYgKHBhMCAhPT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgcls2XSA9ICtwYVs2XSArIHg7XG4gICAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgclsxXSA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgZG90cyA9IFt4LCB5XS5jb25jYXQocGEuc2xpY2UoMSkpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDIsIGpqID0gZG90cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICBkb3RzW2pdID0gK2RvdHNbal0gKyB4O1xuICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ08nOlxuICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0sIHBhWzNdKSk7XG4gICAgICAgICAgciA9IFsnVSddLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgbXggPSArcGFbMV0gKyB4O1xuICAgICAgICAgIG15ID0gK3BhWzJdICsgeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZm9yIGxpbnRcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZvciAodmFyIF9qID0gMSwgX2pqID0gcGEubGVuZ3RoOyBfaiA8IF9qajsgX2orKykge1xuICAgICAgICAgICAgcltfal0gPSArcGFbX2pdICsgKF9qICUgMiA/IHggOiB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhMCA9PT0gJ1InKSB7XG4gICAgICBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICByZXMucG9wKCk7XG4gICAgICByZXMgPSByZXMuY29uY2F0KGNhdG11bGxSb20yYmV6aWVyKGRvdHMsIGNyeikpO1xuICAgICAgciA9IFsnUiddLmNvbmNhdChwYS5zbGljZSgtMikpO1xuICAgIH0gZWxzZSBpZiAocGEwID09PSAnTycpIHtcbiAgICAgIHJlcy5wb3AoKTtcbiAgICAgIGRvdHMgPSBlbGxpcHNlUGF0aCh4LCB5LCBwYVsxXSwgcGFbMl0pO1xuICAgICAgZG90cy5wdXNoKGRvdHNbMF0pO1xuICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICB9IGVsc2UgaWYgKHBhMCA9PT0gJ1UnKSB7XG4gICAgICByZXMucG9wKCk7XG4gICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgIHIgPSBbJ1UnXS5jb25jYXQocmVzW3Jlcy5sZW5ndGggLSAxXS5zbGljZSgtMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYTAgPSBwYTAudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChwYTAgIT09ICdPJykge1xuICAgICAgc3dpdGNoIChyWzBdKSB7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHggPSArbXg7XG4gICAgICAgICAgeSA9ICtteTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICB4ID0gclsxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZm9yIGxpbnRcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbnZhciBTUEFDRVMgPSAnXFx0XFxuXFx4MEJcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjknO1xudmFyIFBBVEhfQ09NTUFORCA9IG5ldyBSZWdFeHAoJyhbYS16XSlbJyArIFNQQUNFUyArICcsXSooKC0/XFxcXGQqXFxcXC4/XFxcXGQqKD86ZVtcXFxcLStdP1xcXFxkKyk/WycgKyBTUEFDRVMgKyAnXSosP1snICsgU1BBQ0VTICsgJ10qKSspJywgJ2lnJyk7XG52YXIgUEFUSF9WQUxVRVMgPSBuZXcgUmVnRXhwKCcoLT9cXFxcZCpcXFxcLj9cXFxcZCooPzplW1xcXFwtK10/XFxcXGQrKT8pWycgKyBTUEFDRVMgKyAnXSosP1snICsgU1BBQ0VTICsgJ10qJywgJ2lnJyk7IC8vIFBhcnNlcyBnaXZlbiBwYXRoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwYXRoIHNlZ21lbnRzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcbiAgaWYgKCFwYXRoU3RyaW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBwYXRoU3RyaW5nID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoU3RyaW5nKSkgPT09IF90eXBlb2YoW10pKSB7XG4gICAgcmV0dXJuIHBhdGhTdHJpbmc7XG4gIH1cblxuICB2YXIgcGFyYW1Db3VudHMgPSB7XG4gICAgYTogNyxcbiAgICBjOiA2LFxuICAgIG86IDIsXG4gICAgaDogMSxcbiAgICBsOiAyLFxuICAgIG06IDIsXG4gICAgcjogNCxcbiAgICBxOiA0LFxuICAgIHM6IDQsXG4gICAgdDogMixcbiAgICB2OiAxLFxuICAgIHU6IDMsXG4gICAgejogMFxuICB9O1xuICB2YXIgZGF0YSA9IFtdO1xuICBTdHJpbmcocGF0aFN0cmluZykucmVwbGFjZShQQVRIX0NPTU1BTkQsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIHZhciBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuICAgIGMucmVwbGFjZShQQVRIX1ZBTFVFUywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgIH0pO1xuXG4gICAgaWYgKG5hbWUgPT09ICdtJyAmJiBwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCAyKSkpO1xuICAgICAgbmFtZSA9ICdsJztcbiAgICAgIGIgPSBiID09PSAnbScgPyAnbCcgOiAnTCc7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdvJyAmJiBwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBkYXRhLnB1c2goW2IsIHBhcmFtc1swXV0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAncicpIHtcbiAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocGFyYW1zLmxlbmd0aCA+PSBwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW25hbWVdKSkpO1xuXG4gICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cDovL3NjaGVwZXJzLmNjL2dldHRpbmctdG8tdGhlLXBvaW50XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICB2YXIgZCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY3JwLmxlbmd0aDsgaUxlbiAtIDIgKiAheiA+IGk7IGkgKz0gMikge1xuICAgIHZhciBwID0gW3tcbiAgICAgIHg6ICtjcnBbaSAtIDJdLFxuICAgICAgeTogK2NycFtpIC0gMV1cbiAgICB9LCB7XG4gICAgICB4OiArY3JwW2ldLFxuICAgICAgeTogK2NycFtpICsgMV1cbiAgICB9LCB7XG4gICAgICB4OiArY3JwW2kgKyAyXSxcbiAgICAgIHk6ICtjcnBbaSArIDNdXG4gICAgfSwge1xuICAgICAgeDogK2NycFtpICsgNF0sXG4gICAgICB5OiArY3JwW2kgKyA1XVxuICAgIH1dO1xuXG4gICAgaWYgKHopIHtcbiAgICAgIGlmICghaSkge1xuICAgICAgICBwWzBdID0ge1xuICAgICAgICAgIHg6ICtjcnBbaUxlbiAtIDJdLFxuICAgICAgICAgIHk6ICtjcnBbaUxlbiAtIDFdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09PSBpKSB7XG4gICAgICAgIHBbM10gPSB7XG4gICAgICAgICAgeDogK2NycFswXSxcbiAgICAgICAgICB5OiArY3JwWzFdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09PSBpKSB7XG4gICAgICAgIHBbMl0gPSB7XG4gICAgICAgICAgeDogK2NycFswXSxcbiAgICAgICAgICB5OiArY3JwWzFdXG4gICAgICAgIH07XG4gICAgICAgIHBbM10gPSB7XG4gICAgICAgICAgeDogK2NycFsyXSxcbiAgICAgICAgICB5OiArY3JwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpTGVuIC0gNCA9PT0gaSkge1xuICAgICAgICBwWzNdID0gcFsyXTtcbiAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgcFswXSA9IHtcbiAgICAgICAgICB4OiArY3JwW2ldLFxuICAgICAgICAgIHk6ICtjcnBbaSArIDFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZC5wdXNoKFsnQycsICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LCAoLXBbMF0ueSArIDYgKiBwWzFdLnkgKyBwWzJdLnkpIC8gNiwgKHBbMV0ueCArIDYgKiBwWzJdLnggLSBwWzNdLngpIC8gNiwgKHBbMV0ueSArIDYgKiBwWzJdLnkgLSBwWzNdLnkpIC8gNiwgcFsyXS54LCBwWzJdLnldKTtcbiAgfVxuXG4gIHJldHVybiBkO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBsb3dlckNhc2UgPSBmdW5jdGlvbiBsb3dlckNhc2Uoc3RyKSB7XG4gIHJldHVybiB0b1N0cmluZyhzdHIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvd2VyQ2FzZTtcblxuLyoqKi8gfSksXG4vKiAxNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciB1cHBlckNhc2UgPSBmdW5jdGlvbiB1cHBlckNhc2Uoc3RyKSB7XG4gIHJldHVybiB0b1N0cmluZyhzdHIpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVwcGVyQ2FzZTtcblxuLyoqKi8gfSksXG4vKiAxNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdyb3VwVG9NYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NSk7XG5cbnZhciBncm91cCA9IGZ1bmN0aW9uIGdyb3VwKGRhdGEsIGNvbmRpdGlvbikge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHJldHVybiBbZGF0YV07XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gZ3JvdXBUb01hcChkYXRhLCBjb25kaXRpb24pO1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGFycmF5LnB1c2goZ3JvdXBzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ3JvdXA7XG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGdyb3VwQnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nik7XG5cbnZhciBncm91cFRvTWFwID0gZnVuY3Rpb24gZ3JvdXBUb01hcChkYXRhLCBjb25kaXRpb24pIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgMDogZGF0YVxuICAgIH07XG4gIH1cblxuICBpZiAoIWlzRnVuY3Rpb24oY29uZGl0aW9uKSkge1xuICAgIHZhciBwYXJhbXNDb25kaXRpb24gPSBpc0FycmF5KGNvbmRpdGlvbikgPyBjb25kaXRpb24gOiBjb25kaXRpb24ucmVwbGFjZSgvXFxzKy9nLCAnJykuc3BsaXQoJyonKTtcblxuICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uIGNvbmRpdGlvbihyb3cpIHtcbiAgICAgIHZhciB1bmlxdWUgPSAnXyc7IC8vIOmBv+WFjeWHuueOsOaVsOWtl+S9nOS4uktleeeahOaDheWGte+8jOS8mui/m+ihjOaMieeFp+aVsOWtl+eahOaOkuW6j1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmFtc0NvbmRpdGlvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdW5pcXVlICs9IHJvd1twYXJhbXNDb25kaXRpb25baV1dICYmIHJvd1twYXJhbXNDb25kaXRpb25baV1dLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmlxdWU7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBncm91cHMgPSBncm91cEJ5KGRhdGEsIGNvbmRpdGlvbik7XG4gIHJldHVybiBncm91cHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdyb3VwVG9NYXA7XG5cbi8qKiovIH0pLFxuLyogMTQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZ3JvdXBCeSA9IGZ1bmN0aW9uIGdyb3VwQnkoZGF0YSwgY29uZGl0aW9uKSB7XG4gIGlmICghY29uZGl0aW9uIHx8ICFpc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICBlYWNoKGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAga2V5ID0gY29uZGl0aW9uKGl0ZW0pO1xuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XS5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IFtpdGVtXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBncm91cEJ5O1xuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEcyIOWbvuihqOeahOWFpeWPo+aWh+S7tlxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MSk7XG5cbnZhciBHID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBDYW52YXMgPSBHLkNhbnZhcztcbnZhciBEb21VdGlsID0gVXRpbC5Eb21VdGlsO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIFBsb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1Nik7XG5cbnZhciBDb250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpO1xuXG52YXIgbWVyZ2VCQm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjcpO1xuXG52YXIgYmJveE9mQmFja1Bsb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Nik7XG5cbnZhciBwbG90UmFuZ2UyQkJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4KTtcblxudmFyIEFVVE9fU1RSID0gJ2F1dG8nO1xuXG5mdW5jdGlvbiBfaXNTY2FsZUV4aXN0KHNjYWxlcywgY29tcGFyZVNjYWxlKSB7XG4gIHZhciBmbGFnID0gZmFsc2U7XG4gIFV0aWwuZWFjaChzY2FsZXMsIGZ1bmN0aW9uIChzY2FsZSkge1xuICAgIHZhciBzY2FsZVZhbHVlcyA9IFtdLmNvbmNhdChzY2FsZS52YWx1ZXMpO1xuICAgIHZhciBjb21wYXJlU2NhbGVWYWx1ZXMgPSBbXS5jb25jYXQoY29tcGFyZVNjYWxlLnZhbHVlcyk7XG5cbiAgICBpZiAoc2NhbGUudHlwZSA9PT0gY29tcGFyZVNjYWxlLnR5cGUgJiYgc2NhbGUuZmllbGQgPT09IGNvbXBhcmVTY2FsZS5maWVsZCAmJiBzY2FsZVZhbHVlcy5zb3J0KCkudG9TdHJpbmcoKSA9PT0gY29tcGFyZVNjYWxlVmFsdWVzLnNvcnQoKS50b1N0cmluZygpKSB7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhZztcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEFycmF5KGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIFV0aWwuaXNFcXVhbFdpdGgoYXJyMSwgYXJyMiwgZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiB2MSA9PT0gdjI7XG4gIH0pO1xufVxuLyoqXG4gKiDlm77ooajnmoTlhaXlj6NcbiAqIEBjbGFzcyBDaGFydFxuICovXG5cblxudmFyIENoYXJ0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfVmlldykge1xuICBfaW5oZXJpdHNMb29zZShDaGFydCwgX1ZpZXcpO1xuXG4gIGZ1bmN0aW9uIENoYXJ0KCkge1xuICAgIHJldHVybiBfVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hhcnQucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciB2aWV3Q2ZnID0gX1ZpZXcucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh2aWV3Q2ZnLCB7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGZvcmNlRml0OiBmYWxzZSxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIHdyYXBwZXJFbDogbnVsbCxcbiAgICAgIGNhbnZhczogbnVsbCxcbiAgICAgIHdpZHRoOiA1MDAsXG4gICAgICBoZWlnaHQ6IDUwMCxcbiAgICAgIHBpeGVsUmF0aW86IG51bGwsXG4gICAgICBiYWNrUGxvdDogbnVsbCxcbiAgICAgIGZyb250UGxvdDogbnVsbCxcbiAgICAgIHBsb3RCYWNrZ3JvdW5kOiBudWxsLFxuICAgICAgcGFkZGluZzogR2xvYmFsLnBsb3RDZmcucGFkZGluZyxcbiAgICAgIGJhY2tncm91bmQ6IG51bGwsXG4gICAgICBhdXRvUGFkZGluZ0FwcGVuZDogNSxcbiAgICAgIGxpbWl0SW5QbG90OiBmYWxzZSxcbiAgICAgIHJlbmRlcmVyOiBHbG9iYWwucmVuZGVyZXIsXG4gICAgICAvLyByZW5kZXJlcjogJ3N2ZycsXG4gICAgICB2aWV3czogW11cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLmdldCgndmlld1RoZW1lJyk7XG5cbiAgICBzZWxmLl9pbml0Q2FudmFzKCk7XG5cbiAgICBzZWxmLl9pbml0UGxvdCgpO1xuXG4gICAgc2VsZi5faW5pdEV2ZW50cygpO1xuXG4gICAgX1ZpZXcucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0b29sdGlwQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyLlRvb2x0aXAoe1xuICAgICAgY2hhcnQ6IHNlbGYsXG4gICAgICB2aWV3VGhlbWU6IHZpZXdUaGVtZSxcbiAgICAgIG9wdGlvbnM6IHt9XG4gICAgfSk7XG4gICAgc2VsZi5zZXQoJ3Rvb2x0aXBDb250cm9sbGVyJywgdG9vbHRpcENvbnRyb2xsZXIpO1xuICAgIHZhciBsZWdlbmRDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIuTGVnZW5kKHtcbiAgICAgIGNoYXJ0OiBzZWxmLFxuICAgICAgdmlld1RoZW1lOiB2aWV3VGhlbWVcbiAgICB9KTtcbiAgICBzZWxmLnNldCgnbGVnZW5kQ29udHJvbGxlcicsIGxlZ2VuZENvbnRyb2xsZXIpO1xuICAgIHNlbGYuc2V0KCdfaWQnLCAnY2hhcnQnKTsgLy8g6Ziy5q2i5ZCM55So5oi36K6+5a6a55qEIGlkIOWQjOWQjVxuXG4gICAgc2VsZi5lbWl0KCdhZnRlcmluaXQnKTsgLy8g5Yid5aeL5YyW5a6M5q+VXG4gIH07XG5cbiAgX3Byb3RvLl9pc0F1dG9QYWRkaW5nID0gZnVuY3Rpb24gX2lzQXV0b1BhZGRpbmcoKSB7XG4gICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldCgncGFkZGluZycpO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheShwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHBhZGRpbmcuaW5kZXhPZihBVVRPX1NUUikgIT09IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwYWRkaW5nID09PSBBVVRPX1NUUjtcbiAgfTtcblxuICBfcHJvdG8uX2dldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gX2dldEF1dG9QYWRkaW5nKCkge1xuICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXQoJ3BhZGRpbmcnKTsgLy8g5Zu+5L6L5Zyo5pyA5YmN6Z2i55qE5LiA5bGCXG5cbiAgICB2YXIgZnJvbnRQbG90ID0gdGhpcy5nZXQoJ2Zyb250UGxvdCcpO1xuICAgIHZhciBmcm9udEJCb3ggPSBmcm9udFBsb3QuZ2V0QkJveCgpOyAvLyDlnZDmoIfovbTlnKjmnIDlkI7pnaLnmoTkuIDlsYJcblxuICAgIHZhciBiYWNrUGxvdCA9IHRoaXMuZ2V0KCdiYWNrUGxvdCcpO1xuICAgIHZhciBiYWNrQkJveCA9IGJib3hPZkJhY2tQbG90KGJhY2tQbG90LCBwbG90UmFuZ2UyQkJveCh0aGlzLmdldCgncGxvdFJhbmdlJykpKTtcbiAgICB2YXIgYm94ID0gbWVyZ2VCQm94KGZyb250QkJveCwgYmFja0JCb3gpO1xuICAgIHZhciBvdXR0ZXIgPSBbMCAtIGJveC5taW5ZLCAvLyDkuIrpnaLotoXlh7rnmoTpg6jliIZcbiAgICBib3gubWF4WCAtIHRoaXMuZ2V0KCd3aWR0aCcpLCAvLyDlj7PovrnotoXlh7rnmoTpg6jliIZcbiAgICBib3gubWF4WSAtIHRoaXMuZ2V0KCdoZWlnaHQnKSwgLy8g5LiL6L656LaF5Ye655qE6YOo5YiGXG4gICAgMCAtIGJveC5taW5YXTsgLy8g5aaC5p6c5Y6f5aeL55qEIHBhZGRpbmcg5YaF6YOo5a2Y5ZyoICdhdXRvJyDliJnmm7/mjaLlr7nlupTnmoTovrlcblxuICAgIHZhciBhdXRvUGFkZGluZyA9IFV0aWwudG9BbGxQYWRkaW5nKHBhZGRpbmcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdXRvUGFkZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGF1dG9QYWRkaW5nW2ldID09PSBBVVRPX1NUUikge1xuICAgICAgICB2YXIgdG1wID0gTWF0aC5tYXgoMCwgb3V0dGVyW2ldKTtcbiAgICAgICAgYXV0b1BhZGRpbmdbaV0gPSB0bXAgKyB0aGlzLmdldCgnYXV0b1BhZGRpbmdBcHBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXV0b1BhZGRpbmc7XG4gIH07IC8vIOWIneWni+WMlueUu+W4g1xuXG5cbiAgX3Byb3RvLl9pbml0Q2FudmFzID0gZnVuY3Rpb24gX2luaXRDYW52YXMoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgaWQgPSB0aGlzLmdldCgnaWQnKTsgLy8g5aaC5p6c5pyq6K6+572uIGNvbnRhaW5lciDkvb/nlKggSUQsIOWFvOWuuSAyLngg54mI5pysXG5cbiAgICBpZiAoIWNvbnRhaW5lciAmJiBpZCkge1xuICAgICAgY29udGFpbmVyID0gaWQ7XG4gICAgICB0aGlzLnNldCgnY29udGFpbmVyJywgaWQpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgICBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSBjb250YWluZXIgZm9yIHRoZSBjaGFydCEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQoJ2NvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIHdyYXBwZXJFbCA9IERvbVV0aWwuY3JlYXRlRG9tKCc8ZGl2IHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmU7XCI+PC9kaXY+Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBwZXJFbCk7XG4gICAgdGhpcy5zZXQoJ3dyYXBwZXJFbCcsIHdyYXBwZXJFbCk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2ZvcmNlRml0JykpIHtcbiAgICAgIHdpZHRoID0gRG9tVXRpbC5nZXRXaWR0aChjb250YWluZXIsIHdpZHRoKTtcbiAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdldCgncmVuZGVyZXInKTtcbiAgICB2YXIgY2FudmFzID0gbmV3IENhbnZhcyh7XG4gICAgICBjb250YWluZXJET006IHdyYXBwZXJFbCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgLy8gTk9USUNFOiDmnInpl67popjmib7pnZLmubNcbiAgICAgIHBpeGVsUmF0aW86IHJlbmRlcmVyID09PSAnc3ZnJyA/IDEgOiB0aGlzLmdldCgncGl4ZWxSYXRpbycpLFxuICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyXG4gICAgfSk7XG4gICAgdGhpcy5zZXQoJ2NhbnZhcycsIGNhbnZhcyk7XG4gIH07IC8vIOWIneWni+WMlue7mOWbvuWMuumXtFxuXG5cbiAgX3Byb3RvLl9pbml0UGxvdCA9IGZ1bmN0aW9uIF9pbml0UGxvdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9pbml0UGxvdEJhY2soKTsgLy8g5pyA5bqV5bGC55qE5piv6IOM5pmv55u45YWz55qEIGdyb3VwXG5cblxuICAgIHZhciBjYW52YXMgPSBzZWxmLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIGJhY2tQbG90ID0gY2FudmFzLmFkZEdyb3VwKHtcbiAgICAgIHpJbmRleDogMVxuICAgIH0pOyAvLyDlm77ooajmnIDlkI7pnaLnmoTlrrnlmahcblxuICAgIHZhciBwbG90Q29udGFpbmVyID0gY2FudmFzLmFkZEdyb3VwKHtcbiAgICAgIHpJbmRleDogMFxuICAgIH0pOyAvLyDlm77ooajmiYDlnKjnmoTlrrnlmahcblxuICAgIHZhciBmcm9udFBsb3QgPSBjYW52YXMuYWRkR3JvdXAoe1xuICAgICAgekluZGV4OiAzXG4gICAgfSk7IC8vIOWbvuihqOWJjemdoueahOWuueWZqFxuXG4gICAgc2VsZi5zZXQoJ2JhY2tQbG90JywgYmFja1Bsb3QpO1xuICAgIHNlbGYuc2V0KCdtaWRkbGVQbG90JywgcGxvdENvbnRhaW5lcik7XG4gICAgc2VsZi5zZXQoJ2Zyb250UGxvdCcsIGZyb250UGxvdCk7XG4gIH07IC8vIOWIneWni+WMluiDjOaZr1xuXG5cbiAgX3Byb3RvLl9pbml0UGxvdEJhY2sgPSBmdW5jdGlvbiBfaW5pdFBsb3RCYWNrKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FudmFzID0gc2VsZi5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLmdldCgndmlld1RoZW1lJyk7XG4gICAgdmFyIHBsb3QgPSBjYW52YXMuYWRkR3JvdXAoUGxvdCwge1xuICAgICAgcGFkZGluZzogdGhpcy5nZXQoJ3BhZGRpbmcnKSxcbiAgICAgIHBsb3RCYWNrZ3JvdW5kOiBVdGlsLm1peCh7fSwgdmlld1RoZW1lLnBsb3RCYWNrZ3JvdW5kLCBzZWxmLmdldCgncGxvdEJhY2tncm91bmQnKSksXG4gICAgICBiYWNrZ3JvdW5kOiBVdGlsLm1peCh7fSwgdmlld1RoZW1lLmJhY2tncm91bmQsIHNlbGYuZ2V0KCdiYWNrZ3JvdW5kJykpXG4gICAgfSk7XG4gICAgc2VsZi5zZXQoJ3Bsb3QnLCBwbG90KTtcbiAgICBzZWxmLnNldCgncGxvdFJhbmdlJywgcGxvdC5nZXQoJ3Bsb3RSYW5nZScpKTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiBfaW5pdEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5nZXQoJ2ZvcmNlRml0JykpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX2luaXRGb3JjZUZpdEV2ZW50JykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2luaXRGb3JjZUZpdEV2ZW50ID0gZnVuY3Rpb24gX2luaXRGb3JjZUZpdEV2ZW50KCkge1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ2ZvcmNlRml0JyksIDIwMCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ2V0KCdyZXNpemVUaW1lcicpKTtcbiAgICB0aGlzLnNldCgncmVzaXplVGltZXInLCB0aW1lcik7XG4gIH07IC8vIOe7mOWItuWbvuS+i1xuXG5cbiAgX3Byb3RvLl9yZW5kZXJMZWdlbmRzID0gZnVuY3Rpb24gX3JlbmRlckxlZ2VuZHMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldCgnb3B0aW9ucycpO1xuICAgIHZhciBsZWdlbmRPcHRpb25zID0gb3B0aW9ucy5sZWdlbmRzO1xuXG4gICAgaWYgKFV0aWwuaXNOaWwobGVnZW5kT3B0aW9ucykgfHwgbGVnZW5kT3B0aW9ucyAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIOayoeacieWFs+mXreWbvuS+i1xuICAgICAgdmFyIGxlZ2VuZENvbnRyb2xsZXIgPSB0aGlzLmdldCgnbGVnZW5kQ29udHJvbGxlcicpO1xuICAgICAgbGVnZW5kQ29udHJvbGxlci5vcHRpb25zID0gbGVnZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgIGxlZ2VuZENvbnRyb2xsZXIucGxvdFJhbmdlID0gdGhpcy5nZXQoJ3Bsb3RSYW5nZScpO1xuXG4gICAgICBpZiAobGVnZW5kT3B0aW9ucyAmJiBsZWdlbmRPcHRpb25zLmN1c3RvbSkge1xuICAgICAgICAvLyDnlKjmiLfoh6rlrprkuYnlm77kvotcbiAgICAgICAgbGVnZW5kQ29udHJvbGxlci5hZGRDdXN0b21MZWdlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0QWxsR2VvbXMoKTtcbiAgICAgICAgdmFyIHNjYWxlcyA9IFtdO1xuICAgICAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBnZW9tLmdldCgndmlldycpO1xuICAgICAgICAgIHZhciBhdHRycyA9IGdlb20uZ2V0QXR0cnNGb3JMZWdlbmQoKTtcbiAgICAgICAgICBVdGlsLmVhY2goYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGF0dHIudHlwZTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGF0dHIuZ2V0U2NhbGUodHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChzY2FsZS5maWVsZCAmJiBzY2FsZS50eXBlICE9PSAnaWRlbnRpdHknICYmICFfaXNTY2FsZUV4aXN0KHNjYWxlcywgc2NhbGUpKSB7XG4gICAgICAgICAgICAgIHNjYWxlcy5wdXNoKHNjYWxlKTtcbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkVmFsdWVzID0gdmlldy5nZXRGaWx0ZXJlZE91dFZhbHVlcyhzY2FsZS5maWVsZCk7XG4gICAgICAgICAgICAgIGxlZ2VuZENvbnRyb2xsZXIuYWRkTGVnZW5kKHNjYWxlLCBhdHRyLCBnZW9tLCBmaWx0ZXJlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyDlj4zovbTnmoTmg4XlhrVcblxuICAgICAgICB2YXIgeVNjYWxlcyA9IHRoaXMuZ2V0WVNjYWxlcygpO1xuXG4gICAgICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwICYmIHlTY2FsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGxlZ2VuZENvbnRyb2xsZXIuYWRkTWl4ZWRMZWdlbmQoeVNjYWxlcywgZ2VvbXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlZ2VuZENvbnRyb2xsZXIuYWxpZ25MZWdlbmRzKCk7XG4gICAgfVxuICB9OyAvLyDnu5jliLYgdG9vbHRpcFxuXG5cbiAgX3Byb3RvLl9yZW5kZXJUb29sdGlwcyA9IGZ1bmN0aW9uIF9yZW5kZXJUb29sdGlwcygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdvcHRpb25zJyk7XG5cbiAgICBpZiAoVXRpbC5pc05pbChvcHRpb25zLnRvb2x0aXApIHx8IG9wdGlvbnMudG9vbHRpcCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIOeUqOaIt+ayoeacieWFs+mXrSB0b29sdGlwXG4gICAgICB2YXIgdG9vbHRpcENvbnRyb2xsZXIgPSB0aGlzLmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcbiAgICAgIHRvb2x0aXBDb250cm9sbGVyLm9wdGlvbnMgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG4gICAgICB0b29sdGlwQ29udHJvbGxlci5yZW5kZXJUb29sdGlwKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICog6I635Y+W5omA5pyJ55qE5Yeg5L2V5qCH6K6wXG4gICAqIEByZXR1cm4ge0FycmF5fSDmiYDmnInnmoTlh6DkvZXmoIforrBcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0QWxsR2VvbXMgPSBmdW5jdGlvbiBnZXRBbGxHZW9tcygpIHtcbiAgICB2YXIgZ2VvbXMgPSBbXTtcbiAgICBnZW9tcyA9IGdlb21zLmNvbmNhdCh0aGlzLmdldCgnZ2VvbXMnKSk7XG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXQoJ3ZpZXdzJyk7XG4gICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgZ2VvbXMgPSBnZW9tcy5jb25jYXQodmlldy5nZXQoJ2dlb21zJykpO1xuICAgIH0pO1xuICAgIHJldHVybiBnZW9tcztcbiAgfTtcbiAgLyoqXG4gICAqIOiHqumAguW6lOWuveW6plxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEByZXR1cm4ge0NoYXJ0fSDlm77ooajlr7nosaFcbiAgICovXG5cblxuICBfcHJvdG8uZm9yY2VGaXQgPSBmdW5jdGlvbiBmb3JjZUZpdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYgfHwgc2VsZi5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBvbGRXaWR0aCA9IHNlbGYuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciB3aWR0aCA9IERvbVV0aWwuZ2V0V2lkdGgoY29udGFpbmVyLCBvbGRXaWR0aCk7XG5cbiAgICBpZiAod2lkdGggIT09IDAgJiYgd2lkdGggIT09IG9sZFdpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gc2VsZi5nZXQoJ2hlaWdodCcpO1xuICAgICAgc2VsZi5jaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIF9wcm90by5yZXNldFBsb3QgPSBmdW5jdGlvbiByZXNldFBsb3QoKSB7XG4gICAgdmFyIHBsb3QgPSB0aGlzLmdldCgncGxvdCcpO1xuICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXQoJ3BhZGRpbmcnKTtcblxuICAgIGlmICghaXNFcXVhbEFycmF5KHBhZGRpbmcsIHBsb3QuZ2V0KCdwYWRkaW5nJykpKSB7XG4gICAgICAvLyDph43nva4gcGFkZGluZ++8jOS7heW9k3BhZGRpbmcg5Y+R55Sf5pu05pS5XG4gICAgICBwbG90LnNldCgncGFkZGluZycsIHBhZGRpbmcpO1xuICAgICAgcGxvdC5yZXBhaW50KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICog5pS55Y+Y5aSn5bCPXG4gICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggIOWbvuihqOWuveW6plxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodCDlm77ooajpq5jluqZcbiAgICogQHJldHVybiB7Q2hhcnR9IOWbvuihqOWvueixoVxuICAgKi9cblxuXG4gIF9wcm90by5jaGFuZ2VTaXplID0gZnVuY3Rpb24gY2hhbmdlU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBzZWxmLmdldCgnY2FudmFzJyk7XG4gICAgY2FudmFzLmNoYW5nZVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHBsb3QgPSB0aGlzLmdldCgncGxvdCcpO1xuICAgIHNlbGYuc2V0KCd3aWR0aCcsIHdpZHRoKTtcbiAgICBzZWxmLnNldCgnaGVpZ2h0JywgaGVpZ2h0KTsgLy8gY2hhbmdlIHNpemUg5pe26YeN5paw6K6h566X6L655qGGXG5cbiAgICBwbG90LnJlcGFpbnQoKTsgLy8g5L+d5oyB6L655qGG5LiN5Y+Y77yM6Ziy5q2i6Ieq5YqoIHBhZGRpbmcg5pe257uY5Yi25aSa6YGNXG5cbiAgICB0aGlzLnNldCgna2VlcFBhZGRpbmcnLCB0cnVlKTtcbiAgICBzZWxmLnJlcGFpbnQoKTtcbiAgICB0aGlzLnNldCgna2VlcFBhZGRpbmcnLCBmYWxzZSk7XG4gICAgdGhpcy5lbWl0KCdhZnRlcmNoYW5nZXNpemUnKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcbiAgLyoqXG4gICAqIOaUueWPmOWuveW6plxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoICDlm77ooajlrr3luqZcbiAgICogQHJldHVybiB7Q2hhcnR9IOWbvuihqOWvueixoVxuICAgKi9cblxuXG4gIF9wcm90by5jaGFuZ2VXaWR0aCA9IGZ1bmN0aW9uIGNoYW5nZVdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlU2l6ZSh3aWR0aCwgdGhpcy5nZXQoJ2hlaWdodCcpKTtcbiAgfTtcbiAgLyoqXG4gICAqIOaUueWPmOWuveW6plxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodCAg5Zu+6KGo6auY5bqmXG4gICAqIEByZXR1cm4ge0NoYXJ0fSDlm77ooajlr7nosaFcbiAgICovXG5cblxuICBfcHJvdG8uY2hhbmdlSGVpZ2h0ID0gZnVuY3Rpb24gY2hhbmdlSGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZVNpemUodGhpcy5nZXQoJ3dpZHRoJyksIGhlaWdodCk7XG4gIH07XG4gIC8qKlxuICAgKiDliJvlu7rkuIDkuKrop4blm75cbiAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcg6KeG5Zu+55qE6YWN572u6aG5XG4gICAqIEByZXR1cm4ge1ZpZXd9IOinhuWbvuWvueixoVxuICAgKi9cblxuXG4gIF9wcm90by52aWV3ID0gZnVuY3Rpb24gdmlldyhjZmcpIHtcbiAgICBjZmcgPSBjZmcgfHwge307XG4gICAgY2ZnLnRoZW1lID0gdGhpcy5nZXQoJ3RoZW1lJyk7XG4gICAgY2ZnLnBhcmVudCA9IHRoaXM7XG4gICAgY2ZnLmJhY2tQbG90ID0gdGhpcy5nZXQoJ2JhY2tQbG90Jyk7XG4gICAgY2ZnLm1pZGRsZVBsb3QgPSB0aGlzLmdldCgnbWlkZGxlUGxvdCcpO1xuICAgIGNmZy5mcm9udFBsb3QgPSB0aGlzLmdldCgnZnJvbnRQbG90Jyk7XG4gICAgY2ZnLmNhbnZhcyA9IHRoaXMuZ2V0KCdjYW52YXMnKTtcblxuICAgIGlmIChVdGlsLmlzTmlsKGNmZy5hbmltYXRlKSkge1xuICAgICAgY2ZnLmFuaW1hdGUgPSB0aGlzLmdldCgnYW5pbWF0ZScpO1xuICAgIH1cblxuICAgIGNmZy5vcHRpb25zID0gVXRpbC5taXgoe30sIHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoKSwgY2ZnLm9wdGlvbnMpO1xuICAgIHZhciB2aWV3ID0gbmV3IFZpZXcoY2ZnKTtcbiAgICB2aWV3LnNldCgnX2lkJywgJ3ZpZXcnICsgdGhpcy5nZXQoJ3ZpZXdzJykubGVuZ3RoKTsgLy8g5qCH6K+GIElE77yM6Ziy5q2i5ZCM55So5oi36K6+5a6a55qEIGlkIOmHjeWQjVxuXG4gICAgdGhpcy5nZXQoJ3ZpZXdzJykucHVzaCh2aWV3KTtcbiAgICB0aGlzLmVtaXQoJ2FkZHZpZXcnLCB7XG4gICAgICB2aWV3OiB2aWV3XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpZXc7XG4gIH07IC8vIGlzU2hhcGVJblZpZXcoKSB7XG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuXG4gIF9wcm90by5yZW1vdmVWaWV3ID0gZnVuY3Rpb24gcmVtb3ZlVmlldyh2aWV3KSB7XG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXQoJ3ZpZXdzJyk7XG4gICAgVXRpbC5BcnJheS5yZW1vdmUodmlld3MsIHZpZXcpO1xuICAgIHZpZXcuZGVzdHJveSgpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U2hhcmVkT3B0aW9ucyA9IGZ1bmN0aW9uIF9nZXRTaGFyZWRPcHRpb25zKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXQoJ29wdGlvbnMnKTtcbiAgICB2YXIgc2hhcmVkT3B0aW9ucyA9IHt9O1xuICAgIFV0aWwuZWFjaChbJ3NjYWxlcycsICdjb29yZCcsICdheGVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzaGFyZWRPcHRpb25zW25hbWVdID0gVXRpbC5jbG9uZURlZXAob3B0aW9uc1tuYW1lXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYXJlZE9wdGlvbnM7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICog5b2T5YmNY2hhcnQg55qE6IyD5Zu0XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFZpZXdSZWdpb24gPSBmdW5jdGlvbiBnZXRWaWV3UmVnaW9uKCkge1xuICAgIHZhciBwbG90UmFuZ2UgPSB0aGlzLmdldCgncGxvdFJhbmdlJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwbG90UmFuZ2UuYmwsXG4gICAgICBlbmQ6IHBsb3RSYW5nZS50clxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiDorr7nva7lm77kvovphY3nva7kv6Hmga9cbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZmllbGQg5a2X5q615ZCNXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2NmZ10g5Zu+5L6L55qE6YWN572u6aG5XG4gICAqIEByZXR1cm4ge0NoYXJ0fSDlvZPliY3nmoTlm77ooajlr7nosaFcbiAgICovXG5cblxuICBfcHJvdG8ubGVnZW5kID0gZnVuY3Rpb24gbGVnZW5kKGZpZWxkLCBjZmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdvcHRpb25zJyk7XG5cbiAgICBpZiAoIW9wdGlvbnMubGVnZW5kcykge1xuICAgICAgb3B0aW9ucy5sZWdlbmRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGxlZ2VuZHMgPSB7fTtcblxuICAgIGlmIChmaWVsZCA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMubGVnZW5kcyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgIGxlZ2VuZHMgPSBmaWVsZDtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgICBsZWdlbmRzW2ZpZWxkXSA9IGNmZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGVnZW5kcyA9IGNmZztcbiAgICB9XG5cbiAgICBVdGlsLm1peChvcHRpb25zLmxlZ2VuZHMsIGxlZ2VuZHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog6K6+572u5o+Q56S65L+h5oGvXG4gICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IHZpc2libGUg5piv5ZCm5Y+v6KeBXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2NmZ10g5o+Q56S65L+h5oGv55qE6YWN572u6aG5XG4gICAqIEByZXR1cm4ge0NoYXJ0fSDlvZPliY3nmoTlm77ooajlr7nosaFcbiAgICovXG5cblxuICBfcHJvdG8udG9vbHRpcCA9IGZ1bmN0aW9uIHRvb2x0aXAodmlzaWJsZSwgY2ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldCgnb3B0aW9ucycpO1xuXG4gICAgaWYgKCFvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgIG9wdGlvbnMudG9vbHRpcCA9IHt9O1xuICAgIH1cblxuICAgIGlmICh2aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy50b29sdGlwID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzT2JqZWN0KHZpc2libGUpKSB7XG4gICAgICBVdGlsLm1peChvcHRpb25zLnRvb2x0aXAsIHZpc2libGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlsLm1peChvcHRpb25zLnRvb2x0aXAsIGNmZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiDmuIXnqbrlm77ooahcbiAgICogQHJldHVybiB7Q2hhcnR9IOW9k+WJjeeahOWbvuihqOWvueixoVxuICAgKi9cblxuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuZW1pdCgnYmVmb3JlY2xlYXInKTtcbiAgICB2YXIgdmlld3MgPSB0aGlzLmdldCgndmlld3MnKTtcblxuICAgIHdoaWxlICh2aWV3cy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdmlldyA9IHZpZXdzLnNoaWZ0KCk7XG4gICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBfVmlldy5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzKTtcblxuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgdGhpcy5yZXNldFBsb3QoKTtcbiAgICBjYW52YXMuZHJhdygpO1xuICAgIHRoaXMuZW1pdCgnYWZ0ZXJjbGVhcicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhcklubmVyID0gZnVuY3Rpb24gY2xlYXJJbm5lcigpIHtcbiAgICB2YXIgdmlld3MgPSB0aGlzLmdldCgndmlld3MnKTtcbiAgICBVdGlsLmVhY2godmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICB2aWV3LmNsZWFySW5uZXIoKTtcbiAgICB9KTtcbiAgICB2YXIgdG9vbHRpcENvbnRyb2xsZXIgPSB0aGlzLmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcbiAgICB0b29sdGlwQ29udHJvbGxlciAmJiB0b29sdGlwQ29udHJvbGxlci5jbGVhcigpO1xuXG4gICAgaWYgKCF0aGlzLmdldCgna2VlcExlZ2VuZCcpKSB7XG4gICAgICB2YXIgbGVnZW5kQ29udHJvbGxlciA9IHRoaXMuZ2V0KCdsZWdlbmRDb250cm9sbGVyJyk7XG4gICAgICBsZWdlbmRDb250cm9sbGVyICYmIGxlZ2VuZENvbnRyb2xsZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBfVmlldy5wcm90b3R5cGUuY2xlYXJJbm5lci5jYWxsKHRoaXMpO1xuICB9OyAvLyBjaGFydCDpmaTkuoZ2aWV3IOS4iue7mOWItueahOe7hOS7tuWklu+8jOi/mOS8mue7mOWItuWbvuS+i+WSjCB0b29sdGlwXG5cblxuICBfcHJvdG8uZHJhd0NvbXBvbmVudHMgPSBmdW5jdGlvbiBkcmF3Q29tcG9uZW50cygpIHtcbiAgICBfVmlldy5wcm90b3R5cGUuZHJhd0NvbXBvbmVudHMuY2FsbCh0aGlzKTsgLy8g5LiA6Iis5piv54K55Ye75Zu+5L6L5pe277yM5LuF5LuF6ZqQ6JeP5p+Q5Lqb6YCJ6aG577yM6ICM5LiN6ZSA5q+B5Zu+5L6LXG5cblxuICAgIGlmICghdGhpcy5nZXQoJ2tlZXBMZWdlbmQnKSkge1xuICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kcygpOyAvLyDmuLLmn5Plm77kvotcblxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIOe7mOWItuWbvuihqFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8g6ZyA6KaB6Ieq5Yqo6K6h566X6L655qGG77yM5YiZ6YeN5paw6K6+572uXG5cbiAgICBpZiAoIXNlbGYuZ2V0KCdrZWVwUGFkZGluZycpICYmIHNlbGYuX2lzQXV0b1BhZGRpbmcoKSkge1xuICAgICAgc2VsZi5iZWZvcmVSZW5kZXIoKTsgLy8g5Yid5aeL5YyW5ZCE5LiqIHZpZXcg5ZKMIOe7mOWItlxuXG4gICAgICBzZWxmLmRyYXdDb21wb25lbnRzKCk7XG5cbiAgICAgIHZhciBhdXRvUGFkZGluZyA9IHNlbGYuX2dldEF1dG9QYWRkaW5nKCk7XG5cbiAgICAgIHZhciBwbG90ID0gc2VsZi5nZXQoJ3Bsb3QnKTsgLy8g5Zyo6K6h566X5Ye65p2l55qE6L655qGG5LiN5LiA6Ie055qE5oOF5Ya177yM6YeN5paw5pS55Y+Y6L655qGGXG5cbiAgICAgIGlmICghaXNFcXVhbEFycmF5KHBsb3QuZ2V0KCdwYWRkaW5nJyksIGF1dG9QYWRkaW5nKSkge1xuICAgICAgICBwbG90LnNldCgncGFkZGluZycsIGF1dG9QYWRkaW5nKTtcbiAgICAgICAgcGxvdC5yZXBhaW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pZGRsZVBsb3QgPSBzZWxmLmdldCgnbWlkZGxlUGxvdCcpO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdsaW1pdEluUGxvdCcpICYmICFtaWRkbGVQbG90LmF0dHIoJ2NsaXAnKSkge1xuICAgICAgdmFyIGNsaXAgPSBVdGlsLmdldENsaXBCeVJhbmdlKHNlbGYuZ2V0KCdwbG90UmFuZ2UnKSk7IC8vIFRPRE8gUG9sYXIgY29vcmRcblxuICAgICAgbWlkZGxlUGxvdC5hdHRyKCdjbGlwJywgY2xpcCk7IC8vIGNsaXAuYXR0cignZmlsbCcsICdncmV5Jyk7XG4gICAgICAvLyBjbGlwLmF0dHIoJ29wYWNpdHknLCAwLjUpO1xuICAgICAgLy8gbWlkZGxlUGxvdC5hZGQoY2xpcCk7XG4gICAgfVxuXG4gICAgX1ZpZXcucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gICAgc2VsZi5fcmVuZGVyVG9vbHRpcHMoKTsgLy8g5riy5p+TIHRvb2x0aXBcblxuICB9O1xuXG4gIF9wcm90by5yZXBhaW50ID0gZnVuY3Rpb24gcmVwYWludCgpIHtcbiAgICAvLyDph43nu5jml7bpnIDopoHliKTlrprlvZPliY3nmoQgcGFkZGluZyDmmK/lkKblj5HnlJ/ov4fmlLnlj5jvvIzlpoLmnpzlj5HnlJ/ov4fmlLnlj5jov5vooYzosIPmlbRcbiAgICAvLyDpnIDopoHliKTlrprmmK/lkKbkvb/nlKjkuoboh6rliqggcGFkZGluZ1xuICAgIGlmICghdGhpcy5nZXQoJ2tlZXBQYWRkaW5nJykpIHtcbiAgICAgIHRoaXMucmVzZXRQbG90KCk7XG4gICAgfVxuXG4gICAgX1ZpZXcucHJvdG90eXBlLnJlcGFpbnQuY2FsbCh0aGlzKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiDmmL7npLrmiJbogIXpmpDol49cbiAgICovXG5cblxuICBfcHJvdG8uY2hhbmdlVmlzaWJsZSA9IGZ1bmN0aW9uIGNoYW5nZVZpc2libGUodmlzaWJsZSkge1xuICAgIHZhciB3cmFwcGVyRWwgPSB0aGlzLmdldCgnd3JhcHBlckVsJyk7XG4gICAgdmFyIHZpc2libGVTdHIgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgd3JhcHBlckVsLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlU3RyO1xuICB9O1xuICAvKipcbiAgICog6L+U5Zue5Zu+6KGo55qEIGRhdGFVcmwg55So5LqO55Sf5oiQ5Zu+54mHXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGF0YVVybCDot6/lvoRcbiAgICovXG5cblxuICBfcHJvdG8udG9EYXRhVVJMID0gZnVuY3Rpb24gdG9EYXRhVVJMKCkge1xuICAgIHZhciBjaGFydCA9IHRoaXM7XG4gICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHJlbmRlcmVyID0gY2hhcnQuZ2V0KCdyZW5kZXJlcicpO1xuICAgIHZhciBjYW52YXNEb20gPSBjYW52YXMuZ2V0KCdlbCcpO1xuICAgIHZhciBkYXRhVVJMID0gJyc7XG5cbiAgICBpZiAocmVuZGVyZXIgPT09ICdzdmcnKSB7XG4gICAgICB2YXIgY2xvbmUgPSBjYW52YXNEb20uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdmFyIHN2Z0RvY1R5cGUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUoJ3N2ZycsICctLy9XM0MvL0RURCBTVkcgMS4xLy9FTicsICdodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQnKTtcbiAgICAgIHZhciBzdmdEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudCgnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJywgc3ZnRG9jVHlwZSk7XG4gICAgICBzdmdEb2MucmVwbGFjZUNoaWxkKGNsb25lLCBzdmdEb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgIHZhciBzdmdEYXRhID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmdEb2MpO1xuICAgICAgZGF0YVVSTCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGY4LCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnRGF0YSk7XG4gICAgfSBlbHNlIGlmIChyZW5kZXJlciA9PT0gJ2NhbnZhcycpIHtcbiAgICAgIGRhdGFVUkwgPSBjYW52YXNEb20udG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVVSTDtcbiAgfTtcbiAgLyoqXG4gICAqIOWbvuihqOWvvOWHuuWKn+iDvVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtuYW1lXSDlm77niYfnmoTlkI3np7DvvIzpu5jorqTkuLogY2hhcnQoLnBuZ3wuc3ZnKVxuICAgKi9cblxuXG4gIF9wcm90by5kb3dubG9hZEltYWdlID0gZnVuY3Rpb24gZG93bmxvYWRJbWFnZShuYW1lKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcbiAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBjaGFydC5nZXQoJ3JlbmRlcmVyJyk7XG4gICAgdmFyIGZpbGVuYW1lID0gKG5hbWUgfHwgJ2NoYXJ0JykgKyAocmVuZGVyZXIgPT09ICdzdmcnID8gJy5zdmcnIDogJy5wbmcnKTtcbiAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgICBjYW52YXMuZ2V0KCd0aW1lbGluZScpLnN0b3BBbGxBbmltYXRpb25zKCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGF0YVVSTCA9IGNoYXJ0LnRvRGF0YVVSTCgpO1xuXG4gICAgICBpZiAod2luZG93LkJsb2IgJiYgd2luZG93LlVSTCAmJiByZW5kZXJlciAhPT0gJ3N2ZycpIHtcbiAgICAgICAgdmFyIGFyciA9IGRhdGFVUkwuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIG1pbWUgPSBhcnJbMF0ubWF0Y2goLzooLio/KTsvKVsxXTtcbiAgICAgICAgdmFyIGJzdHIgPSBhdG9iKGFyclsxXSk7XG4gICAgICAgIHZhciBuID0gYnN0ci5sZW5ndGg7XG4gICAgICAgIHZhciB1OGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuXG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICB1OGFycltuXSA9IGJzdHIuY2hhckNvZGVBdChuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9iT2JqID0gbmV3IEJsb2IoW3U4YXJyXSwge1xuICAgICAgICAgIHR5cGU6IG1pbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYikge1xuICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iT2JqLCBmaWxlbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2JPYmopO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgICAgICAgICBsaW5rLmhyZWYgPSBkYXRhVVJMO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgIGUuaW5pdEV2ZW50KCdjbGljaycsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBsaW5rLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfSwgMTYpO1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5Z2Q5qCH54K55pi+56S65a+55bqU55qEIHRvb2x0aXBcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDnlLvluIPkuIrnmoTngrlcbiAgICogQHJldHVybiB7Q2hhcnR9ICAgICAgIOi/lOWbniBjaGFydCDlrp7kvotcbiAgICovXG5cblxuICBfcHJvdG8uc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiBzaG93VG9vbHRpcChwb2ludCkge1xuICAgIHZhciB2aWV3cyA9IHRoaXMuZ2V0Vmlld3NCeVBvaW50KHBvaW50KTtcblxuICAgIGlmICh2aWV3cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0b29sdGlwQ29udHJvbGxlciA9IHRoaXMuZ2V0KCd0b29sdGlwQ29udHJvbGxlcicpO1xuICAgICAgdG9vbHRpcENvbnRyb2xsZXIuc2hvd1Rvb2x0aXAocG9pbnQsIHZpZXdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIOmakOiXjyB0b29sdGlwXG4gICogQHJldHVybiB7Q2hhcnR9ICAgICAgIOi/lOWbniBjaGFydCDlrp7kvotcbiAgICovXG5cblxuICBfcHJvdG8uaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB2YXIgdG9vbHRpcENvbnRyb2xsZXIgPSB0aGlzLmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcbiAgICB0b29sdGlwQ29udHJvbGxlci5oaWRlVG9vbHRpcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5Lyg5YWl55qE55S75biD5Z2Q5qCH77yM6I635Y+W6K+l5aSE55qEIHRvb2x0aXAg5LiK55qE6K6w5b2V5L+h5oGvXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9pbnQg55S75biD5Z2Q5qCH54K5XG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICDov5Tlm57nu5PmnpxcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VG9vbHRpcEl0ZW1zID0gZnVuY3Rpb24gZ2V0VG9vbHRpcEl0ZW1zKHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3cyA9IHNlbGYuZ2V0Vmlld3NCeVBvaW50KHBvaW50KTtcbiAgICB2YXIgcnN0ID0gW107XG4gICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgdmFyIGdlb21zID0gdmlldy5nZXQoJ2dlb21zJyk7XG4gICAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBnZW9tLmdldCgnZGF0YUFycmF5Jyk7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBVdGlsLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHZhciB0bXBQb2ludCA9IGdlb20uZmluZFBvaW50KHBvaW50LCBkYXRhKTtcblxuICAgICAgICAgIGlmICh0bXBQb2ludCkge1xuICAgICAgICAgICAgdmFyIHN1Ykl0ZW1zID0gZ2VvbS5nZXRUaXBJdGVtcyh0bXBQb2ludCk7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChzdWJJdGVtcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnN0ID0gcnN0LmNvbmNhdChpdGVtcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIOmUgOavgeWbvuihqFxuICAgKi9cblxuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZWRlc3Ryb3knKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5nZXQoJ3Jlc2l6ZVRpbWVyJykpO1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHdyYXBwZXJFbCA9IHRoaXMuZ2V0KCd3cmFwcGVyRWwnKTtcbiAgICB3cmFwcGVyRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyRWwpO1xuXG4gICAgX1ZpZXcucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIGNhbnZhcy5kZXN0cm95KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdfaW5pdEZvcmNlRml0RXZlbnQnKSk7XG4gICAgdGhpcy5lbWl0KCdhZnRlcmRlc3Ryb3knKTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcnQ7XG59KFZpZXcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0O1xuXG4vKioqLyB9KSxcbi8qIDE0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IENoYXJ044CBVmlld+OAgUdlb21ldHJ5IOeahOWfuuexu1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHNMb29zZShCYXNlLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3Byb3RvID0gQmFzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICBmdW5jdGlvbiBCYXNlKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdENmZyA9IF90aGlzLmdldERlZmF1bHRDZmcoKTtcblxuICAgIF90aGlzLl9hdHRycyA9IGF0dHJzO1xuICAgIFV0aWwuYXNzaWduKGF0dHJzLCBkZWZhdWx0Q2ZnLCBjZmcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdmFyIHZpc2libGUgPSB0aGlzLmdldCgndmlzaWJsZScpO1xuXG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdmFyIHZpc2libGUgPSB0aGlzLmdldCgndmlzaWJsZScpO1xuXG4gICAgaWYgKHZpc2libGUpIHtcbiAgICAgIHRoaXMuc2V0KCd2aXNpYmxlJywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSDmmK/lkKblj6/op4FcbiAgICog5pi+56S644CB6ZqQ6JePXG4gICAqL1xuXG5cbiAgX3Byb3RvLmNoYW5nZVZpc2libGUgPSBmdW5jdGlvbiBjaGFuZ2VWaXNpYmxlKClcbiAgLyogdmlzaWJsZSAqL1xuICB7fTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fYXR0cnMgPSB7fTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gQmFzZTtcbn0oRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDE0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg6aKc6Imy6K6h566X55qE6L6F5Yqp5pa55rOVXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTsgLy8gY29uc3QgUkdCX1JFRyA9IC9yZ2JcXCgoXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpLztcblxuXG52YXIgUkdCX1JFRyA9IC9yZ2JhP1xcKChbXFxzLiwwLTldKylcXCkvOyAvLyDliJvlu7rovoXliqkgdGFnIOWPluminOiJslxuXG5mdW5jdGlvbiBjcmVhdGVUbXAoKSB7XG4gIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuICBpLnRpdGxlID0gJ1dlYiBDb2xvdXIgUGlja2VyJztcbiAgaS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGkpO1xuICByZXR1cm4gaTtcbn0gLy8g6I635Y+W6aKc6Imy5LmL6Ze055qE5o+S5YC8XG5cblxuZnVuY3Rpb24gZ2V0VmFsdWUoc3RhcnQsIGVuZCwgcGVyY2VudCwgaW5kZXgpIHtcbiAgdmFyIHZhbHVlID0gc3RhcnRbaW5kZXhdICsgKGVuZFtpbmRleF0gLSBzdGFydFtpbmRleF0pICogcGVyY2VudDtcbiAgcmV0dXJuIHZhbHVlO1xufSAvLyDmlbDnu4TovazmjaLmiJDpopzoibJcblxuXG5mdW5jdGlvbiBhcnIycmdiKGFycikge1xuICByZXR1cm4gJyMnICsgdG9IZXgoYXJyWzBdKSArIHRvSGV4KGFyclsxXSkgKyB0b0hleChhcnJbMl0pO1xufSAvLyDlsIbmlbDlgLzku44gMC0yNTUg6L2s5o2i5oiQMTbov5vliLblrZfnrKbkuLJcblxuXG5mdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcblxuICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2FsQ29sb3IoY29sb3JzLCBwZXJjZW50KSB7XG4gIGlmIChpc05hTihwZXJjZW50KSB8fCAhaXNOdW1iZXIocGVyY2VudCkgfHwgcGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfVxuXG4gIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG5cbiAgdmFyIHN0ZXBzID0gY29sb3JzLmxlbmd0aCAtIDE7XG4gIHZhciBzdGVwID0gTWF0aC5mbG9vcihzdGVwcyAqIHBlcmNlbnQpO1xuICB2YXIgbGVmdCA9IHN0ZXBzICogcGVyY2VudCAtIHN0ZXA7XG4gIHZhciBzdGFydCA9IGNvbG9yc1tzdGVwXTtcbiAgdmFyIGVuZCA9IHN0ZXAgPT09IHN0ZXBzID8gc3RhcnQgOiBjb2xvcnNbc3RlcCArIDFdO1xuICB2YXIgcmdiID0gYXJyMnJnYihbZ2V0VmFsdWUoc3RhcnQsIGVuZCwgbGVmdCwgMCksIGdldFZhbHVlKHN0YXJ0LCBlbmQsIGxlZnQsIDEpLCBnZXRWYWx1ZShzdGFydCwgZW5kLCBsZWZ0LCAyKV0pO1xuICByZXR1cm4gcmdiO1xufSAvLyByZ2Ig6aKc6Imy6L2s5o2i5oiQ5pWw57uEXG5cblxuZnVuY3Rpb24gcmdiMmFycihzdHIpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBhcnIucHVzaChwYXJzZUludChzdHIuc3Vic3RyKDEsIDIpLCAxNikpO1xuICBhcnIucHVzaChwYXJzZUludChzdHIuc3Vic3RyKDMsIDIpLCAxNikpO1xuICBhcnIucHVzaChwYXJzZUludChzdHIuc3Vic3RyKDUsIDIpLCAxNikpO1xuICByZXR1cm4gYXJyO1xufVxuXG52YXIgY29sb3JDYWNoZSA9IHt9O1xudmFyIGlFbCA9IG51bGw7XG52YXIgQ29sb3JVdGlsID0ge1xuICAvKipcbiAgICog5bCG6aKc6Imy6L2s5o2i5YiwIHJnYiDnmoTmoLzlvI9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBjb2xvciDpopzoibJcbiAgICogQHJldHVybiB7U3RyaW5nfSDlsIbpopzoibLovazmjaLliLAgJyNmZmZmZmYnIOeahOagvOW8j1xuICAgKi9cbiAgdG9SR0I6IGZ1bmN0aW9uIHRvUkdCKGNvbG9yKSB7XG4gICAgLy8g5aaC5p6c5bey57uP5pivIHJnYueahOagvOW8j1xuICAgIGlmIChjb2xvclswXSA9PT0gJyMnICYmIGNvbG9yLmxlbmd0aCA9PT0gNykge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIGlmICghaUVsKSB7XG4gICAgICAvLyDpmLLmraLpmLLmraLlnKjpobXlpLTmiqXplJlcbiAgICAgIGlFbCA9IGNyZWF0ZVRtcCgpO1xuICAgIH1cblxuICAgIHZhciByc3Q7XG5cbiAgICBpZiAoY29sb3JDYWNoZVtjb2xvcl0pIHtcbiAgICAgIHJzdCA9IGNvbG9yQ2FjaGVbY29sb3JdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpRWwuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICAgIHJzdCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoaUVsLCAnJykuZ2V0UHJvcGVydHlWYWx1ZSgnY29sb3InKTtcbiAgICAgIHZhciBtYXRjaHMgPSBSR0JfUkVHLmV4ZWMocnN0KTtcbiAgICAgIHZhciBjQXJyYXkgPSBtYXRjaHNbMV0uc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgcnN0ID0gYXJyMnJnYihjQXJyYXkpO1xuICAgICAgY29sb3JDYWNoZVtjb2xvcl0gPSByc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfSxcbiAgcmdiMmFycjogcmdiMmFycixcblxuICAvKipcbiAgICog6I635Y+W5riQ5Y+Y5Ye95pWwXG4gICAqIEBwYXJhbSAge0FycmF5fSBjb2xvcnMg5aSa5Liq6aKc6ImyXG4gICAqIEByZXR1cm4ge1N0cmluZ30g6aKc6Imy5YC8XG4gICAqL1xuICBncmFkaWVudDogZnVuY3Rpb24gZ3JhZGllbnQoY29sb3JzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgaWYgKGlzU3RyaW5nKGNvbG9ycykpIHtcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5zcGxpdCgnLScpO1xuICAgIH1cblxuICAgIGVhY2goY29sb3JzLCBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIGlmIChjb2xvci5pbmRleE9mKCcjJykgPT09IC0xKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3JVdGlsLnRvUkdCKGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRzLnB1c2gocmdiMmFycihjb2xvcikpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgcmV0dXJuIGNhbENvbG9yKHBvaW50cywgcGVyY2VudCk7XG4gICAgfTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDE1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVGQVVMVF9ZID0gMDsgLy8g6buY6K6k55qEeeeahOWAvFxuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBBcnJheVV0aWwgPSB7XG4gIHZhbHVlczogX193ZWJwYWNrX3JlcXVpcmVfXyg2NClcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIOWvueW6lOeahOe7tOW6puaYr+WQpuWPr+S7peiwg+aVtFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGRpbU5hbWUg5Y+v5Lul6LCD5pW055qE57u05bqmIHgseVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSDmmK/lkKblj6/ku6XosIPmlbRcbiAgICovXG4gIGlzQWRqdXN0OiBmdW5jdGlvbiBpc0FkanVzdChkaW1OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRqdXN0TmFtZXMuaW5kZXhPZihkaW1OYW1lKSA+PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIOiOt+WPluWPr+iwg+aVtOW6pumHj+WvueW6lOeahOWAvFxuICAgKiBAcGFyYW0gIHtGcmFtZX0gbWVyZ2VEYXRhIOaVsOaNrlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOWAvOeahOaYoOWwhFxuICAgKi9cbiAgX2dldERpbVZhbHVlczogZnVuY3Rpb24gX2dldERpbVZhbHVlcyhtZXJnZURhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZhbHVlc01hcCA9IHt9O1xuICAgIHZhciBkaW1zID0gW107XG5cbiAgICBpZiAoc2VsZi54RmllbGQgJiYgc2VsZi5pc0FkanVzdCgneCcpKSB7XG4gICAgICBkaW1zLnB1c2goc2VsZi54RmllbGQpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnlGaWVsZCAmJiBzZWxmLmlzQWRqdXN0KCd5JykpIHtcbiAgICAgIGRpbXMucHVzaChzZWxmLnlGaWVsZCk7XG4gICAgfVxuXG4gICAgZWFjaChkaW1zLCBmdW5jdGlvbiAoZGltKSB7XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXlVdGlsLnZhbHVlcyhtZXJnZURhdGEsIGRpbSk7XG4gICAgICB2YWx1ZXMuc29ydChmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHJldHVybiB2MSAtIHYyO1xuICAgICAgfSk7XG4gICAgICB2YWx1ZXNNYXBbZGltXSA9IHZhbHVlcztcbiAgICB9KTtcblxuICAgIGlmICghc2VsZi55RmllbGQgJiYgc2VsZi5pc0FkanVzdCgneScpKSB7XG4gICAgICAvLyDlj6rmnInkuIDnu7TnmoTmg4XlhrXkuIss5ZCM5pe26LCD5pW0eVxuICAgICAgdmFyIGRpbSA9ICd5JztcbiAgICAgIHZhciB2YWx1ZXMgPSBbREVGQVVMVF9ZLCAxXTsgLy8g6buY6K6k5YiG5biD5Zyoeei9tOeahCAwLjEg5LiOIDAuMiDkuYvpl7RcblxuICAgICAgdmFsdWVzTWFwW2RpbV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlc01hcDtcbiAgfSxcbiAgYWRqdXN0RGF0YTogZnVuY3Rpb24gYWRqdXN0RGF0YShkYXRhQXJyYXksIG1lcmdlRGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciB2YWx1ZXNNYXAgPSBzZWxmLl9nZXREaW1WYWx1ZXMobWVyZ2VEYXRhKTtcblxuICAgIGVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0YSwgaW5kZXgpIHtcbiAgICAgIC8vIOmBjeWOhuaJgOacieaVsOaNrumbhuWQiFxuICAgICAgZWFjaCh2YWx1ZXNNYXAsIGZ1bmN0aW9uICh2YWx1ZXMsIGRpbSkge1xuICAgICAgICAvLyDmoLnmja7kuI3lkIznmoTluqbph4/liIbliKvosIPmlbTkvY3nva5cbiAgICAgICAgc2VsZi5hZGp1c3REaW0oZGltLCB2YWx1ZXMsIGRhdGEsIGRhdGFBcnJheS5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRBZGp1c3RSYW5nZTogZnVuY3Rpb24gZ2V0QWRqdXN0UmFuZ2UoZGltLCBrZXksIHZhbHVlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZihrZXkpO1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBwcmU7XG4gICAgdmFyIG5leHQ7XG5cbiAgICBpZiAoIXNlbGYueUZpZWxkICYmIHNlbGYuaXNBZGp1c3QoJ3knKSkge1xuICAgICAgcHJlID0gMDtcbiAgICAgIG5leHQgPSAxO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgcHJlID0gaW5kZXggPT09IDAgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICAgIG5leHQgPSBpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IHZhbHVlc1tsZW5ndGggLSAxXSA6IHZhbHVlc1tpbmRleCArIDFdO1xuXG4gICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgcHJlICs9IChrZXkgLSBwcmUpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZSAtPSAobmV4dCAtIGtleSkgLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggIT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dCAtPSAobmV4dCAtIGtleSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCArPSAoa2V5IC0gdmFsdWVzW2xlbmd0aCAtIDJdKSAvIDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZSA9IGtleSA9PT0gMCA/IDAgOiBrZXkgLSAwLjU7XG4gICAgICBuZXh0ID0ga2V5ID09PSAwID8gMSA6IGtleSArIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJlOiBwcmUsXG4gICAgICBuZXh0OiBuZXh0XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICog5a+55pWw5o2u6L+b6KGM5YiG57uEXG4gICAqIEBwYXJhbSAge0FycmF5fSBkYXRhIOaVsOaNrlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpbSDliIbnu4TnmoTlrZfmrrVcbiAgICogQHJldHVybiB7T2JqZWN0fSAg5YiG57uE55qE6ZSu5YC85a+55pig5bCEXG4gICAqL1xuICBncm91cERhdGE6IGZ1bmN0aW9uIGdyb3VwRGF0YShkYXRhLCBkaW0pIHtcbiAgICB2YXIgZ3JvdXBzID0ge307XG4gICAgZWFjaChkYXRhLCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICB2YXIgdmFsdWUgPSByZWNvcmRbZGltXTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSByZWNvcmRbZGltXSA9IERFRkFVTFRfWTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFncm91cHNbdmFsdWVdKSB7XG4gICAgICAgIGdyb3Vwc1t2YWx1ZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgZ3JvdXBzW3ZhbHVlXS5wdXNoKHJlY29yZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZW1lIGVudHJ5XG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFRoZW1lID0ge1xuICBkZWZhdWx0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MiksXG4gIGRhcms6IF9fd2VicGFja19yZXF1aXJlX18oMzA0KVxufTtcbm1vZHVsZS5leHBvcnRzID0gVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMTUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBfaHRtbCwgX3Rvb2x0aXA7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBHMiAzLjAgZGVmYXVsdCB0aGVtZVxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBERUZBVUxUX0NPTE9SID0gJyMxODkwRkYnO1xudmFyIENPTE9SX1BMQVRFXzggPSBbJyMxODkwRkYnLCAnIzJGQzI1QicsICcjRkFDQzE0JywgJyMyMjMyNzMnLCAnIzg1NDNFMCcsICcjMTNDMkMyJywgJyMzNDM2QzcnLCAnI0YwNDg2NCddO1xudmFyIENPTE9SX1BMQVRFXzE2ID0gWycjMTg5MEZGJywgJyM0MUQ5QzcnLCAnIzJGQzI1QicsICcjRkFDQzE0JywgJyNFNjk2NUMnLCAnIzIyMzI3MycsICcjNzU2NENDJywgJyM4NTQzRTAnLCAnIzVDOEVFNicsICcjMTNDMkMyJywgJyM1Q0EzRTYnLCAnIzM0MzZDNycsICcjQjM4MUU2JywgJyNGMDQ4NjQnLCAnI0Q1OThEOSddO1xudmFyIENPTE9SX1BMQVRFXzI0ID0gWycjMTg5MEZGJywgJyM2NkI1RkYnLCAnIzQxRDlDNycsICcjMkZDMjVCJywgJyM2RURCOEYnLCAnIzlBRTY1QycsICcjRkFDQzE0JywgJyNFNjk2NUMnLCAnIzU3QUQ3MScsICcjMjIzMjczJywgJyM3MzhBRTYnLCAnIzc1NjRDQycsICcjODU0M0UwJywgJyNBODc3RUQnLCAnIzVDOEVFNicsICcjMTNDMkMyJywgJyM3MEUwRTAnLCAnIzVDQTNFNicsICcjMzQzNkM3JywgJyM4MDgyRkYnLCAnI0REODFFNicsICcjRjA0ODY0JywgJyNGQTdEOTInLCAnI0Q1OThEOSddO1xudmFyIENPTE9SX1BJRSA9IFsnIzE4OTBGRicsICcjMTNDMkMyJywgJyMyRkMyNUInLCAnI0ZBQ0MxNCcsICcjRjA0ODY0JywgJyM4NTQzRTAnLCAnIzM0MzZDNycsICcjMjIzMjczJ107XG52YXIgQ09MT1JfUElFXzE2ID0gWycjMTg5MEZGJywgJyM3M0M5RTYnLCAnIzEzQzJDMicsICcjNkNEOUIzJywgJyMyRkMyNUInLCAnIzlERDk2QycsICcjRkFDQzE0JywgJyNFNjk2NUMnLCAnI0YwNDg2NCcsICcjRDY2QkNBJywgJyM4NTQzRTAnLCAnIzhFNzdFRCcsICcjMzQzNkM3JywgJyM3MzdFRTYnLCAnIzIyMzI3MycsICcjN0VBMkU2J107XG52YXIgRk9OVF9GQU1JTFkgPSAnXCItYXBwbGUtc3lzdGVtXCIsIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sXCJIZWx2ZXRpY2EgTmV1ZVwiLCBIZWx2ZXRpY2EsIFwiUGluZ0ZhbmcgU0NcIiwgXCJIaXJhZ2lubyBTYW5zIEdCXCIsIFwiTWljcm9zb2Z0IFlhSGVpXCIsU2ltU3VuLCBcInNhbnMtc2VyaWZcIic7IC8vIHRvb2x0aXAg55u45YWzIGRvbSDnmoQgY3NzIOexu+WQjVxuXG52YXIgVE9PTFRJUF9DT05UQUlORVJfQ0xBU1MgPSAnZzItdG9vbHRpcCc7XG52YXIgVE9PTFRJUF9USVRMRV9DTEFTUyA9ICdnMi10b29sdGlwLXRpdGxlJztcbnZhciBUT09MVElQX0xJU1RfQ0xBU1MgPSAnZzItdG9vbHRpcC1saXN0JztcbnZhciBUT09MVElQX0xJU1RfSVRFTV9DTEFTUyA9ICdnMi10b29sdGlwLWxpc3QtaXRlbSc7XG52YXIgVE9PTFRJUF9NQVJLRVJfQ0xBU1MgPSAnZzItdG9vbHRpcC1tYXJrZXInO1xudmFyIFRPT0xUSVBfVkFMVUVfQ0xBU1MgPSAnZzItdG9vbHRpcC12YWx1ZSc7IC8vIGh0bWwg5riy5p+T55qEIGxlZ2VuZCDnm7jlhbMgZG9tIOeahCBjc3Mg57G75Z6LXG5cbnZhciBMRUdFTkRfQ09OVEFJTkVSX0NMQVNTID0gJ2cyLWxlZ2VuZCc7XG52YXIgTEVHRU5EX1RJVExFX0NMQVNTID0gJ2cyLWxlZ2VuZC10aXRsZSc7XG52YXIgTEVHRU5EX0xJU1RfQ0xBU1MgPSAnZzItbGVnZW5kLWxpc3QnO1xudmFyIExFR0VORF9MSVNUX0lURU1fQ0xBU1MgPSAnZzItbGVnZW5kLWxpc3QtaXRlbSc7XG52YXIgTEVHRU5EX01BUktFUl9DTEFTUyA9ICdnMi1sZWdlbmQtbWFya2VyJztcbnZhciBUaGVtZSA9IHtcbiAgZGVmYXVsdENvbG9yOiBERUZBVUxUX0NPTE9SLFxuICAvLyDpu5jorqTkuLvpopjoibJcbiAgcGxvdENmZzoge1xuICAgIHBhZGRpbmc6IFsyMCwgMjAsIDk1LCA4MF1cbiAgfSxcbiAgZm9udEZhbWlseTogRk9OVF9GQU1JTFksXG4gIGRlZmF1bHRMZWdlbmRQb3NpdGlvbjogJ2JvdHRvbScsXG4gIC8vIOm7mOiupOWbvuS+i+eahOWxleekuuS9jee9rlxuICBjb2xvcnM6IENPTE9SX1BMQVRFXzgsXG4gIGNvbG9yc18xNjogQ09MT1JfUExBVEVfMTYsXG4gIGNvbG9yc18yNDogQ09MT1JfUExBVEVfMjQsXG4gIGNvbG9yc19waWU6IENPTE9SX1BJRSxcbiAgY29sb3JzX3BpZV8xNjogQ09MT1JfUElFXzE2LFxuICBzaGFwZXM6IHtcbiAgICBwb2ludDogWydob2xsb3dDaXJjbGUnLCAnaG9sbG93U3F1YXJlJywgJ2hvbGxvd0RpYW1vbmQnLCAnaG9sbG93Qm93dGllJywgJ2hvbGxvd1RyaWFuZ2xlJywgJ2hvbGxvd0hleGFnb24nLCAnY3Jvc3MnLCAndGljaycsICdwbHVzJywgJ2h5cGhlbicsICdsaW5lJ10sXG4gICAgbGluZTogWydsaW5lJywgJ2Rhc2gnLCAnZG90J10sXG4gICAgYXJlYTogWydhcmVhJ11cbiAgfSxcbiAgc2l6ZXM6IFsxLCAxMF0sXG4gIG9wYWNpdGllczogWzAuMSwgMC45XSxcbiAgYXhpczoge1xuICAgIHRvcDoge1xuICAgICAgLy8gekluZGV4OiAxLCAvLyDpu5jorqTkuIrkuIvmlrnlkJHnmoTlnZDmoIfovbTkvY3kuo7lt6blj7PlnZDmoIfovbTnmoTkuIrmlrlcbiAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgb2Zmc2V0OiAxNixcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJyM1NDU0NTQnLFxuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxNixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH0sXG4gICAgICAgIGF1dG9Sb3RhdGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0JGQkZCRidcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGFsaWduV2l0aExhYmVsOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgb2Zmc2V0OiAxNixcbiAgICAgICAgYXV0b1JvdGF0ZTogdHJ1ZSxcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJyM1NDU0NTQnLFxuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxNixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0JGQkZCRidcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGFsaWduV2l0aExhYmVsOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBvZmZzZXQ6IDgsXG4gICAgICAgIGF1dG9Sb3RhdGU6IHRydWUsXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgIGZpbGw6ICcjNTQ1NDU0JyxcbiAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgbGluZUhlaWdodDogMTYsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIHRpY2tMaW5lOiBudWxsLFxuICAgICAgZ3JpZDoge1xuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICBzdHJva2U6ICcjRTlFOUU5JyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgbGluZURhc2g6IFszLCAzXVxuICAgICAgICB9LFxuICAgICAgICBoaWRlRmlyc3RMaW5lOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIG9mZnNldDogOCxcbiAgICAgICAgYXV0b1JvdGF0ZTogdHJ1ZSxcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJyM1NDU0NTQnLFxuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxNixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgdGlja0xpbmU6IG51bGwsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgIHN0cm9rZTogJyNFOUU5RTknLFxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICBsaW5lRGFzaDogWzMsIDNdXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVGaXJzdExpbmU6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGNpcmNsZToge1xuICAgICAgekluZGV4OiAxLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBvZmZzZXQ6IDgsXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgIGZpbGw6ICcjNTQ1NDU0JyxcbiAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgbGluZUhlaWdodDogMTYsXG4gICAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6ICcjQkZCRkJGJ1xuICAgICAgfSxcbiAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0JGQkZCRicsXG4gICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgYWxpZ25XaXRoTGFiZWw6IHRydWVcbiAgICAgIH0sXG4gICAgICBncmlkOiB7XG4gICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgIHN0cm9rZTogJyNFOUU5RTknLFxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICBsaW5lRGFzaDogWzMsIDNdXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVGaXJzdExpbmU6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHJhZGl1czoge1xuICAgICAgekluZGV4OiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgb2Zmc2V0OiAxMixcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJyM1NDU0NTQnLFxuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IDE2LFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0JGQkZCRidcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIGFsaWduV2l0aExhYmVsOiB0cnVlXG4gICAgICB9LFxuICAgICAgZ3JpZDoge1xuICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICBzdHJva2U6ICcjRTlFOUU5JyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgbGluZURhc2g6IFszLCAzXVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAnY2lyY2xlJ1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVsaXg6IHtcbiAgICAgIGdyaWQ6IG51bGwsXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgbGluZToge1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnXG4gICAgICB9LFxuICAgICAgdGlja0xpbmU6IHtcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgIHN0cm9rZTogJyNCRkJGQkYnLFxuICAgICAgICBhbGlnbldpdGhMYWJlbDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbGFiZWw6IHtcbiAgICBvZmZzZXQ6IDIwLFxuICAgIHRleHRTdHlsZToge1xuICAgICAgZmlsbDogJyM1NDU0NTQnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgfVxuICB9LFxuICB0cmVlbWFwTGFiZWxzOiB7XG4gICAgb2Zmc2V0OiAxMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIHRleHRCYXNlbGluZTogJ3RvcCcsXG4gICAgICBmb250U3R5bGU6ICdib2xkJyxcbiAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgfVxuICB9LFxuICBpbm5lckxhYmVsczoge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgfVxuICB9LFxuICAvLyDlnKh0aGV0YeWdkOagh+ezu+S4i+eahOmlvOWbvuaWh+acrOWGhemDqOeahOagt+W8j1xuICB0aGV0YUxhYmVsczoge1xuICAgIGxhYmVsSGVpZ2h0OiAxNCxcbiAgICBvZmZzZXQ6IDMwIC8vIOWcqHRoZXRh5Z2Q5qCH57O75LiL55qE6aW85Zu+5paH5pys55qE5qC35byPXG5cbiAgfSxcbiAgbGVnZW5kOiB7XG4gICAgcmlnaHQ6IHtcbiAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxuICAgICAgaXRlbU1hcmdpbkJvdHRvbTogOCxcbiAgICAgIC8vIGxheW91dCDkuLogdmVydGljYWwg5pe25ZCE5Liq5Zu+5L6L6aG555qE6Ze06LedXG4gICAgICB3aWR0aDogMTYsXG4gICAgICBoZWlnaHQ6IDE1NixcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgbGVnZW5kU3R5bGU6IHtcbiAgICAgICAgTElTVF9DTEFTUzoge1xuICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyM4QzhDOEMnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgbGluZUhlaWdodDogMCxcbiAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFlcbiAgICAgIH0sXG4gICAgICAvLyDlm77kvovpobnmlofmnKznmoTmoLflvI9cbiAgICAgIHVuQ2hlY2tDb2xvcjogJyNiZmJmYmYnXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxuICAgICAgaXRlbU1hcmdpbkJvdHRvbTogOCxcbiAgICAgIHdpZHRoOiAxNixcbiAgICAgIGhlaWdodDogMTU2LFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyM4QzhDOEMnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgbGluZUhlaWdodDogMjAsXG4gICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICB9LFxuICAgICAgLy8g5Zu+5L6L6aG55paH5pys55qE5qC35byPXG4gICAgICB1bkNoZWNrQ29sb3I6ICcjYmZiZmJmJ1xuICAgIH0sXG4gICAgdG9wOiB7XG4gICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICBvZmZzZXQ6IFswLCA2XSxcbiAgICAgIGxheW91dDogJ2hvcml6b250YWwnLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICBpdGVtR2FwOiAxMCxcbiAgICAgIHdpZHRoOiAxNTYsXG4gICAgICBoZWlnaHQ6IDE2LFxuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjOEM4QzhDJyxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDIwLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgfSxcbiAgICAgIC8vIOWbvuS+i+mhueaWh+acrOeahOagt+W8j1xuICAgICAgdW5DaGVja0NvbG9yOiAnI2JmYmZiZidcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgb2Zmc2V0OiBbMCwgNl0sXG4gICAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgaXRlbUdhcDogMTAsXG4gICAgICB3aWR0aDogMTU2LFxuICAgICAgaGVpZ2h0OiAxNixcbiAgICAgIHRleHRTdHlsZToge1xuICAgICAgICBmaWxsOiAnIzhDOEM4QycsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAyMCxcbiAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFlcbiAgICAgIH0sXG4gICAgICAvLyDlm77kvovpobnmlofmnKznmoTmoLflvI9cbiAgICAgIHVuQ2hlY2tDb2xvcjogJyNiZmJmYmYnXG4gICAgfSxcbiAgICAvLyDlrprkuYkgaHRtbCDmuLLmn5Plm77kvovnmoTmoLflvI9cbiAgICBodG1sOiAoX2h0bWwgPSB7fSwgX2h0bWxbXCJcIiArIExFR0VORF9DT05UQUlORVJfQ0xBU1NdID0ge1xuICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZLFxuICAgICAgbGluZUhlaWdodDogJzIwcHgnLFxuICAgICAgY29sb3I6ICcjOEM4QzhDJ1xuICAgIH0sIF9odG1sW1wiXCIgKyBMRUdFTkRfVElUTEVfQ0xBU1NdID0ge1xuICAgICAgbWFyZ2luQm90dG9tOiAnNHB4J1xuICAgIH0sIF9odG1sW1wiXCIgKyBMRUdFTkRfTElTVF9DTEFTU10gPSB7XG4gICAgICBsaXN0U3R5bGVUeXBlOiAnbm9uZScsXG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSwgX2h0bWxbXCJcIiArIExFR0VORF9MSVNUX0lURU1fQ0xBU1NdID0ge1xuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBtYXJnaW5Cb3R0b206ICc1cHgnLFxuICAgICAgbWFyZ2luUmlnaHQ6ICcyNHB4J1xuICAgIH0sIF9odG1sW1wiXCIgKyBMRUdFTkRfTUFSS0VSX0NMQVNTXSA9IHtcbiAgICAgIHdpZHRoOiAnOXB4JyxcbiAgICAgIGhlaWdodDogJzlweCcsXG4gICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBtYXJnaW5SaWdodDogJzhweCcsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIH0sIF9odG1sKSxcbiAgICAvLyDkuI3og73mu5HliqjnmoTov57nu63lm77kvovmoLflvI9cbiAgICBncmFkaWVudDoge1xuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjOEM4QzhDJyxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAyMCxcbiAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFlcbiAgICAgIH0sXG4gICAgICAvLyDlm77kvovpobnmlofmnKznmoTmoLflvI9cbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNmZmYnXG4gICAgICB9LFxuICAgICAgdW5DaGVja0NvbG9yOiAnI2JmYmZiZidcbiAgICB9LFxuICAgIG1hcmdpbjogWzAsIDUsIDI0LCA1XSxcbiAgICAvLyDlm77kvovot5/lm5vkuKrovrnnmoTlnZDmoIfovbTjgIHnu5jlm77ljLrln5/nmoTpl7Tot51cbiAgICBsZWdlbmRNYXJnaW46IDI0IC8vIOWbvuS+i+S5i+mXtOeahOmXtOi3nVxuXG4gIH0sXG4gIHRvb2x0aXA6IChfdG9vbHRpcCA9IHtcbiAgICB1c2VIdG1sOiB0cnVlLFxuICAgIGNyb3NzaGFpcnM6IGZhbHNlLFxuICAgIG9mZnNldDogMTVcbiAgfSwgX3Rvb2x0aXBbXCJcIiArIFRPT0xUSVBfQ09OVEFJTkVSX0NMQVNTXSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICAvLyBAMjAxOC0wNy0yNSBieSBibHVlLmxiIOi/memHjOWOu+aOiea1ruWKqO+8jOeBq+eLkOS4iuWtmOWcqOagt+W8j+mUmeS9jVxuICAgIC8vIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHpJbmRleDogOCxcbiAgICB0cmFuc2l0aW9uOiAndmlzaWJpbGl0eSAwLjJzIGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKSwgbGVmdCAwLjRzIGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKSwgdG9wIDAuNHMgY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknLFxuICAgIGJveFNoYWRvdzogJzBweCAwcHggMTBweCAjYWVhZWFlJyxcbiAgICBib3JkZXJSYWRpdXM6ICczcHgnLFxuICAgIGNvbG9yOiAncmdiKDg3LCA4NywgODcpJyxcbiAgICBmb250U2l6ZTogJzEycHgnLFxuICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZLFxuICAgIGxpbmVIZWlnaHQ6ICcyMHB4JyxcbiAgICBwYWRkaW5nOiAnMTBweCAxMHB4IDZweCAxMHB4J1xuICB9LCBfdG9vbHRpcFtcIlwiICsgVE9PTFRJUF9USVRMRV9DTEFTU10gPSB7XG4gICAgbWFyZ2luQm90dG9tOiAnNHB4J1xuICB9LCBfdG9vbHRpcFtcIlwiICsgVE9PTFRJUF9MSVNUX0NMQVNTXSA9IHtcbiAgICBtYXJnaW46IDAsXG4gICAgbGlzdFN0eWxlVHlwZTogJ25vbmUnLFxuICAgIHBhZGRpbmc6IDBcbiAgfSwgX3Rvb2x0aXBbXCJcIiArIFRPT0xUSVBfTElTVF9JVEVNX0NMQVNTXSA9IHtcbiAgICBtYXJnaW5Cb3R0b206ICc0cHgnXG4gIH0sIF90b29sdGlwW1wiXCIgKyBUT09MVElQX01BUktFUl9DTEFTU10gPSB7XG4gICAgd2lkdGg6ICc1cHgnLFxuICAgIGhlaWdodDogJzVweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBtYXJnaW5SaWdodDogJzhweCdcbiAgfSwgX3Rvb2x0aXBbXCJcIiArIFRPT0xUSVBfVkFMVUVfQ0xBU1NdID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIGZsb2F0OiAncmlnaHQnLFxuICAgIG1hcmdpbkxlZnQ6ICczMHB4J1xuICB9LCBfdG9vbHRpcCksXG4gIHRvb2x0aXBNYXJrZXI6IHtcbiAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbCh4LCB5LCByKSB7XG4gICAgICByZXR1cm4gW1snTScsIHgsIHldLCBbJ20nLCAtciwgMF0sIFsnYScsIHIsIHIsIDAsIDEsIDAsIHIgKiAyLCAwXSwgWydhJywgciwgciwgMCwgMSwgMCwgLXIgKiAyLCAwXV07XG4gICAgfSxcbiAgICBzdHJva2U6ICcjZmZmJyxcbiAgICBzaGFkb3dCbHVyOiAxMCxcbiAgICBzaGFkb3dPZmZzZXRYOiAwLFxuICAgIHNoYWRvd09mZlNldFk6IDAsXG4gICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMDkpJyxcbiAgICBsaW5lV2lkdGg6IDIsXG4gICAgcmFkaXVzOiA0XG4gIH0sXG4gIC8vIOaPkOekuuS/oeaBr+WcqOaKmOe6v+WbvuOAgeWMuuWfn+WbvuS4iuW9ouaIkOeCueeahOagt+W8j1xuICB0b29sdGlwQ3Jvc3NoYWlyc1JlY3Q6IHtcbiAgICB0eXBlOiAncmVjdCcsXG4gICAgcmVjdFN0eWxlOiB7XG4gICAgICBmaWxsOiAnI0NDRDZFQycsXG4gICAgICBvcGFjaXR5OiAwLjNcbiAgICB9XG4gIH0sXG4gIC8vIHRvb2x0aXAg6L6F5Yqp6IOM5pmv5qGG5qC35byPXG4gIHRvb2x0aXBDcm9zc2hhaXJzTGluZToge1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgICBsaW5lV2lkdGg6IDFcbiAgICB9XG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgcG9pbnQ6IHtcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGZpbGw6IERFRkFVTFRfQ09MT1IsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LFxuICAgIGhvbGxvd1BvaW50OiB7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzdHJva2U6IERFRkFVTFRfQ09MT1IsXG4gICAgICByYWRpdXM6IDNcbiAgICB9LFxuICAgIGludGVydmFsOiB7XG4gICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICBmaWxsOiBERUZBVUxUX0NPTE9SLFxuICAgICAgZmlsbE9wYWNpdHk6IDAuODVcbiAgICB9LFxuICAgIGhvbGxvd0ludGVydmFsOiB7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBzdHJva2U6IERFRkFVTFRfQ09MT1IsXG4gICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgIGxpbmVXaWR0aDogMlxuICAgIH0sXG4gICAgYXJlYToge1xuICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgZmlsbDogREVGQVVMVF9DT0xPUixcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjZcbiAgICB9LFxuICAgIHBvbHlnb246IHtcbiAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgIGZpbGw6IERFRkFVTFRfQ09MT1IsXG4gICAgICBmaWxsT3BhY2l0eTogMVxuICAgIH0sXG4gICAgaG9sbG93UG9seWdvbjoge1xuICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgc3Ryb2tlOiBERUZBVUxUX0NPTE9SLFxuICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICBsaW5lV2lkdGg6IDJcbiAgICB9LFxuICAgIGhvbGxvd0FyZWE6IHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIHN0cm9rZTogREVGQVVMVF9DT0xPUixcbiAgICAgIGZpbGxPcGFjaXR5OiAwLFxuICAgICAgbGluZVdpZHRoOiAyXG4gICAgfSxcbiAgICBsaW5lOiB7XG4gICAgICBzdHJva2U6IERFRkFVTFRfQ09MT1IsXG4gICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICBmaWxsOiBudWxsXG4gICAgfSxcbiAgICBlZGdlOiB7XG4gICAgICBzdHJva2U6IERFRkFVTFRfQ09MT1IsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBmaWxsOiBudWxsXG4gICAgfSxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHN0cm9rZTogREVGQVVMVF9DT0xPUixcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGZpbGw6IG51bGxcbiAgICB9XG4gIH0sXG4gIGd1aWRlOiB7XG4gICAgbGluZToge1xuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgLjY1KScsXG4gICAgICAgIGxpbmVEYXNoOiBbMiwgMl0sXG4gICAgICAgIGxpbmVXaWR0aDogMVxuICAgICAgfSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgIGF1dG9Sb3RhdGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJ3JnYmEoMCwgMCwgMCwgLjQ1KScsXG4gICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWSxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdib3R0b20nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLC41KScsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaW9uOiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgIC8vIOi+heWKqeahhueahOi+ueahhuWuveW6plxuICAgICAgICBmaWxsOiAnIzAwMCcsXG4gICAgICAgIC8vIOi+heWKqeahhuWhq+WFheeahOminOiJslxuICAgICAgICBmaWxsT3BhY2l0eTogMC4wNCAvLyDovoXliqnmoYbnmoTog4zmma/pgI/mmI7luqZcbiAgICAgICAgLy8g6L6F5Yqp5qGG55qE5Zu+5b2i5qC35byP5bGe5oCnXG5cbiAgICAgIH1cbiAgICB9LFxuICAgIGh0bWw6IHtcbiAgICAgIGFsaWduWDogJ21pZGRsZScsXG4gICAgICBhbGlnblk6ICdtaWRkbGUnXG4gICAgfSxcbiAgICBkYXRhUmVnaW9uOiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICByZWdpb246IHtcbiAgICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgIG9wYWNpdHk6IDAuMDRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnYm90dG9tJyxcbiAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgZmlsbDogJ3JnYmEoMCwgMCwgMCwgLjY1KSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YU1hcmtlcjoge1xuICAgICAgdG9wOiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICByOiAzLFxuICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJyxcbiAgICAgICAgICBzdHJva2U6ICcjMTg5MEZGJyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIHN0cm9rZTogJyNBM0IxQkYnLFxuICAgICAgICAgIGxpbmVXaWR0aDogMVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgZmlsbDogJ3JnYmEoMCwgMCwgMCwgLjY1KScsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5OiB7XG4gICAgICAgIHBvaW50OiB0cnVlLFxuICAgICAgICBsaW5lOiB0cnVlLFxuICAgICAgICB0ZXh0OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZUxlbmd0aDogMjAsXG4gICAgICBkaXJlY3Rpb246ICd1cHdhcmQnLFxuICAgICAgYXV0b0FkanVzdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgcGl4ZWxSYXRpbzogbnVsbFxufTtcbm1vZHVsZS5leHBvcnRzID0gVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMTUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSksXG4gICAgR3JvdXAgPSBfcmVxdWlyZS5Hcm91cDtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgR3JpZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dyb3VwKSB7XG4gIF9pbmhlcml0c0xvb3NlKEdyaWQsIF9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gR3JpZCgpIHtcbiAgICByZXR1cm4gX0dyb3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBHcmlkLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgLy8gY29uc3QgY2ZnID0gc3VwZXIuZ2V0RGVmYXVsdENmZygpO1xuICAgIHJldHVybiB7XG4gICAgICB6SW5kZXg6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICog5qCF5qC857q/55qE57G75Z6LXG4gICAgICAgKiAgLSBsaW5lIOS4jeWwgemXreeahOe6v1xuICAgICAgICogIC0gcG9seWdvbiDlsIHpl63nmoTlpJrovrnlvaJcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgLyoqXG4gICAgICAgKiDnur/nmoTmoLflvI/phY3nva5cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGxpbmVTdHlsZTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDnur/pm4blkIjnmoTphY3nva5cbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Li6572R5qC86K6+572u5Lqk5pu/55qE6IOM5pmv6Imy77yM5oyH5a6a5LiA5Liq5YC85YiZ5YWI5riy5p+T5aWH5pWw5bGC77yM5Lik5Liq5YC85YiZ5Lqk5pu/5riy5p+TXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nIHwgQXJyYXl9XG4gICAgICAgKi9cbiAgICAgIGFsdGVybmF0ZUNvbG9yOiBudWxsLFxuICAgICAgbWF0cml4OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpumakOiXj+esrOS4gOadoee9keagvOe6v++8jOm7mOiupOS4uiBmYWxzZVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGhpZGVGaXJzdExpbmU6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpumakOiXj+acgOWQjuS4gOadoee9keagvOe6v++8jOm7mOiupOS4uiBmYWxzZVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGhpZGVMYXN0TGluZTogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogMOWfuue6v+S4jeWcqOi9tOe6v+S4iuaXtu+8jOaYr+WQpuW8uuiwgzDln7rnur9cbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBoaWdodExpZ2h0WmVybzogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogMOWfuue6v+agt+W8j1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgemVyb0xpbmVTdHlsZToge1xuICAgICAgICBzdHJva2U6ICcjNTk1OTU5JyxcbiAgICAgICAgbGluZURhc2g6IFswLCAwXVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJVSSA9IGZ1bmN0aW9uIF9yZW5kZXJVSSgpIHtcbiAgICBfR3JvdXAucHJvdG90eXBlLl9yZW5kZXJVSS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fZHJhd0xpbmVzKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9kcmF3TGluZXMgPSBmdW5jdGlvbiBfZHJhd0xpbmVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGluZVN0eWxlID0gc2VsZi5nZXQoJ2xpbmVTdHlsZScpO1xuICAgIHZhciBpdGVtcyA9IHNlbGYuZ2V0KCdpdGVtcycpO1xuXG4gICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgc2VsZi5fcHJlY2Vzc0l0ZW1zKGl0ZW1zKTtcblxuICAgICAgc2VsZi5fZHJhd0dyaWRMaW5lcyhpdGVtcywgbGluZVN0eWxlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9wcmVjZXNzSXRlbXMgPSBmdW5jdGlvbiBfcHJlY2Vzc0l0ZW1zKGl0ZW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcmVJdGVtO1xuICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBpZiAocHJlSXRlbSAmJiBzZWxmLmdldCgnYWx0ZXJuYXRlQ29sb3InKSkge1xuICAgICAgICBzZWxmLl9kcmF3QWx0ZXJuYXRpdmVCZyhpdGVtLCBwcmVJdGVtLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHByZUl0ZW0gPSBpdGVtO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd0dyaWRMaW5lcyA9IGZ1bmN0aW9uIF9kcmF3R3JpZExpbmVzKGl0ZW1zLCBsaW5lU3R5bGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSB0aGlzLmdldCgndHlwZScpO1xuICAgIHZhciBncmlkTGluZTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2ZnO1xuICAgIHZhciBwb2ludHM7XG4gICAgdmFyIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lJyB8fCB0eXBlID09PSAncG9seWdvbicpIHtcbiAgICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGVGaXJzdExpbmUnKSAmJiBpZHggPT09IDApIHtcbiAgICAgICAgICAvLyDkuI3lsZXnpLrnrKzkuIDmnaHnvZHmoLznur9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGVMYXN0TGluZScpICYmIGlkeCA9PT0gaXRlbXNMZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8g5LiN5bGV56S65pyA5ZCO5LiA5p2h572R5qC857q/XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnRzID0gaXRlbS5wb2ludHM7XG4gICAgICAgIHBhdGggPSBbXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFsnTScsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV0pO1xuICAgICAgICAgIHBhdGgucHVzaChbJ0wnLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLngsIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0ueV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICBwYXRoLnB1c2goWydNJywgcG9pbnQueCwgcG9pbnQueV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF0aC5wdXNoKFsnTCcsIHBvaW50LngsIHBvaW50LnldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9kcmF3WmVyb0xpbmUodHlwZSwgaWR4KSkge1xuICAgICAgICAgIGNmZyA9IFV0aWwubWl4KHt9LCBzZWxmLmdldCgnemVyb0xpbmVTdHlsZScpLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2ZnID0gVXRpbC5taXgoe30sIGxpbmVTdHlsZSwge1xuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZExpbmUgPSBzZWxmLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgICAgIGF0dHJzOiBjZmdcbiAgICAgICAgfSk7XG4gICAgICAgIGdyaWRMaW5lLm5hbWUgPSAnYXhpcy1ncmlkJztcbiAgICAgICAgZ3JpZExpbmUuX2lkID0gaXRlbS5faWQ7XG4gICAgICAgIGdyaWRMaW5lLnNldCgnY29vcmQnLCBzZWxmLmdldCgnY29vcmQnKSk7XG4gICAgICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgZ3JpZExpbmUuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZUZpcnN0TGluZScpICYmIGlkeCA9PT0gMCkge1xuICAgICAgICAgIC8vIOS4jeWxleekuuesrOS4gOadoee9keagvOe6v1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZUxhc3RMaW5lJykgJiYgaWR4ID09PSBpdGVtc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyDkuI3lsZXnpLrmnIDlkI7kuIDmnaHnvZHmoLznur9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludHMgPSBpdGVtLnBvaW50cztcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IHBvaW50LnJhZGl1cztcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFsnTScsIHBvaW50LngsIHBvaW50LnldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFsnQScsIHJhZGl1cywgcmFkaXVzLCAwLCAwLCBwb2ludC5mbGFnLCBwb2ludC54LCBwb2ludC55XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2ZnID0gVXRpbC5taXgoe30sIGxpbmVTdHlsZSwge1xuICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGdyaWRMaW5lID0gc2VsZi5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgICAgICBhdHRyczogY2ZnXG4gICAgICAgIH0pO1xuICAgICAgICBncmlkTGluZS5uYW1lID0gJ2F4aXMtZ3JpZCc7XG4gICAgICAgIGdyaWRMaW5lLl9pZCA9IGl0ZW0uX2lkO1xuICAgICAgICBncmlkTGluZS5zZXQoJ2Nvb3JkJywgc2VsZi5nZXQoJ2Nvb3JkJykpO1xuICAgICAgICBzZWxmLmdldCgnYXBwZW5kSW5mbycpICYmIGdyaWRMaW5lLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fZHJhd1plcm9MaW5lID0gZnVuY3Rpb24gX2RyYXdaZXJvTGluZSh0eXBlLCBpZHgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRpY2tWYWx1ZXMgPSBzZWxmLmdldCgndGlja1ZhbHVlcycpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiB0aWNrVmFsdWVzKSB7XG4gICAgICBpZiAodGlja1ZhbHVlc1tpZHhdID09PSAwICYmIHNlbGYuZ2V0KCdoaWdodExpZ2h0WmVybycpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uX2RyYXdBbHRlcm5hdGl2ZUJnID0gZnVuY3Rpb24gX2RyYXdBbHRlcm5hdGl2ZUJnKGl0ZW0sIHByZUl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhbHRlcm5hdGVDb2xvciA9IHNlbGYuZ2V0KCdhbHRlcm5hdGVDb2xvcicpO1xuICAgIHZhciBhdHRycztcbiAgICB2YXIgb2RkQ29sb3I7XG4gICAgdmFyIGV2ZW5Db2xvcjtcblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKGFsdGVybmF0ZUNvbG9yKSkge1xuICAgICAgb2RkQ29sb3IgPSBhbHRlcm5hdGVDb2xvcjtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNBcnJheShhbHRlcm5hdGVDb2xvcikpIHtcbiAgICAgIG9kZENvbG9yID0gYWx0ZXJuYXRlQ29sb3JbMF07XG4gICAgICBldmVuQ29sb3IgPSBhbHRlcm5hdGVDb2xvclsxXTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICBpZiAoZXZlbkNvbG9yKSB7XG4gICAgICAgIGF0dHJzID0gc2VsZi5fZ2V0QmFja0l0ZW0ocHJlSXRlbS5wb2ludHMsIGl0ZW0ucG9pbnRzLCBldmVuQ29sb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2RkQ29sb3IpIHtcbiAgICAgIGF0dHJzID0gc2VsZi5fZ2V0QmFja0l0ZW0ocHJlSXRlbS5wb2ludHMsIGl0ZW0ucG9pbnRzLCBvZGRDb2xvcik7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gc2VsZi5hZGRTaGFwZSgnUGF0aCcsIHtcbiAgICAgIGF0dHJzOiBhdHRyc1xuICAgIH0pO1xuICAgIHNoYXBlLm5hbWUgPSAnYXhpcy1ncmlkLXJlY3QnO1xuICAgIHNoYXBlLl9pZCA9IGl0ZW0uX2lkICYmIGl0ZW0uX2lkLnJlcGxhY2UoJ2dyaWQnLCAnZ3JpZC1yZWN0Jyk7XG4gICAgc2hhcGUuc2V0KCdjb29yZCcsIHNlbGYuZ2V0KCdjb29yZCcpKTtcbiAgICBzZWxmLmdldCgnYXBwZW5kSW5mbycpICYmIHNoYXBlLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0QmFja0l0ZW0gPSBmdW5jdGlvbiBfZ2V0QmFja0l0ZW0oc3RhcnQsIGVuZCwgYmdDb2xvcikge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHR5cGUgPSB0aGlzLmdldCgndHlwZScpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdsaW5lJykge1xuICAgICAgcGF0aC5wdXNoKFsnTScsIHN0YXJ0WzBdLngsIHN0YXJ0WzBdLnldKTtcbiAgICAgIHBhdGgucHVzaChbJ0wnLCBzdGFydFtzdGFydC5sZW5ndGggLSAxXS54LCBzdGFydFtzdGFydC5sZW5ndGggLSAxXS55XSk7XG4gICAgICBwYXRoLnB1c2goWydMJywgZW5kW2VuZC5sZW5ndGggLSAxXS54LCBlbmRbZW5kLmxlbmd0aCAtIDFdLnldKTtcbiAgICAgIHBhdGgucHVzaChbJ0wnLCBlbmRbMF0ueCwgZW5kWzBdLnldKTtcbiAgICAgIHBhdGgucHVzaChbJ1onXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncG9seWdvbicpIHtcbiAgICAgIFV0aWwuZWFjaChzdGFydCwgZnVuY3Rpb24gKHN1Ykl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHBhdGgucHVzaChbJ00nLCBzdWJJdGVtLngsIHN1Ykl0ZW0ueV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChbJ0wnLCBzdWJJdGVtLngsIHN1Ykl0ZW0ueV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IGVuZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBwYXRoLnB1c2goWydMJywgZW5kW2ldLngsIGVuZFtpXS55XSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGgucHVzaChbJ1onXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmbGFnID0gc3RhcnRbMF0uZmxhZztcbiAgICAgIFV0aWwuZWFjaChzdGFydCwgZnVuY3Rpb24gKHN1Ykl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBzdWJJdGVtLnJhZGl1cztcblxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydNJywgc3ViSXRlbS54LCBzdWJJdGVtLnldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydBJywgcmFkaXVzLCByYWRpdXMsIDAsIDAsIHN1Ykl0ZW0uZmxhZywgc3ViSXRlbS54LCBzdWJJdGVtLnldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGogPSBlbmQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGVuZFN1Ykl0ZW0gPSBlbmRbal07XG4gICAgICAgIHZhciBlbmRSYWRpdXMgPSBlbmRTdWJJdGVtLnJhZGl1cztcblxuICAgICAgICBpZiAoaiA9PT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydNJywgZW5kU3ViSXRlbS54LCBlbmRTdWJJdGVtLnldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydBJywgZW5kUmFkaXVzLCBlbmRSYWRpdXMsIDAsIDAsIGZsYWcgPT09IDEgPyAwIDogMSwgZW5kU3ViSXRlbS54LCBlbmRTdWJJdGVtLnldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBiZ0NvbG9yLFxuICAgICAgcGF0aDogcGF0aFxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEdyaWQ7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuXG4vKioqLyB9KSxcbi8qIDE1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIERvbVV0aWwgPSBVdGlsLkRvbVV0aWw7XG5cbnZhciBDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxudmFyIHBvc2l0aW9uQWRqdXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcpO1xuXG52YXIgc3BpcmlhbEFkanVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzA4KTtcblxudmFyIGJib3hBZGp1c3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwOSk7XG5cbnZhciBMQVlPVVRTID0ge1xuICBzY2F0dGVyOiBwb3NpdGlvbkFkanVzdCxcbiAgbWFwOiBzcGlyaWFsQWRqdXN0LFxuICB0cmVlbWFwOiBiYm94QWRqdXN0XG59O1xuXG52YXIgTGFiZWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGFiZWwsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExhYmVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMYWJlbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgbmFtZTogJ2xhYmVsJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBsYWJlbOexu+Wei1xuICAgICAgICogQHR5cGUgeyhTdHJpbmcpfVxuICAgICAgICovXG4gICAgICB0eXBlOiAnZGVmYXVsdCcsXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6k5paH5pys5qC35byPXG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHRleHRTdHlsZTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDmlofmnKzmmL7npLrmoLzlvI/ljJblm57osIPlh73mlbBcbiAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAqL1xuICAgICAgZm9ybWF0dGVyOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYvuekuueahOaWh+acrOmbhuWQiFxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBpdGVtczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDmmK/lkKbkvb/nlKhodG1s5riy5p+TbGFiZWxcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHVzZUh0bWw6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGh0bWwg5riy5p+T5pe255So55qE5a655Zmo55qE5qih5p2/77yM5b+F6aG75a2Y5ZyoIGNsYXNzID0gXCJnLWxhYmVsc1wiXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBjb250YWluZXJUcGw6ICc8ZGl2IGNsYXNzPVwiZy1sYWJlbHNcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtcIj48L2Rpdj4nLFxuXG4gICAgICAvKipcbiAgICAgICAqIGh0bWwg5riy5p+T5pe25Y2V5LiqIGxhYmVsIOeahOaooeadv++8jOW/hemhu+WtmOWcqCBjbGFzcyA9IFwiZy1sYWJlbFwiXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBpdGVtVHBsOiAnPGRpdiBjbGFzcz1cImctbGFiZWxcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO1wiPnt0ZXh0fTwvZGl2PicsXG5cbiAgICAgIC8qKlxuICAgICAgICogbGFiZWznibXlvJXnur/lrprkuYlcbiAgICAgICAqIEB0eXBlIHtTdHJpbmcgfHwgT2JqZWN0fVxuICAgICAgICovXG4gICAgICBsYWJlbExpbmU6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGxhYmVs54m15byV57q/5a655ZmoXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqL1xuICAgICAgbGluZUdyb3VwOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOmcgOa3u+WKoGxhYmVs55qEc2hhcGVcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICBzaGFwZXM6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6k5Li6dHJ1ZeOAguS4umZhbHNl5pe25oyH5a6a55u05o6l55SoaXRlbXPmuLLmn5PmlofmnKzvvIzkuI3ov5vooYxjb25maWdcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICBjb25maWc6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICog5piv5ZCm6L+b6KGM5ou+5Y+WXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqL1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICAvKlxuICAgKiDmuIXnqbpsYWJlbOWuueWZqFxuICAgKi9cblxuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ2V0KCdncm91cCcpO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG5cbiAgICBpZiAoZ3JvdXAgJiYgIWdyb3VwLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIGdyb3VwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gIH07XG4gIC8qKlxuICAgKiDplIDmr4Fncm91cFxuICAgKi9cblxuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgaWYgKCFncm91cC5kZXN0cm95KSB7XG4gICAgICBncm91cC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIGxhYmVs57uY5Yi25YWo6L+H56iLXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG5cbiAgICB0aGlzLmJlZm9yZURyYXcoKTtcbiAgICB0aGlzLmRyYXcoKTtcbiAgICB0aGlzLmFmdGVyRHJhdygpO1xuICB9O1xuXG4gIF9wcm90by5fZHJ5RHJhdyA9IGZ1bmN0aW9uIF9kcnlEcmF3KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBzZWxmLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBzZWxmLmdldExhYmVscygpO1xuICAgIHZhciBjb3VudCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgY291bnQpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBzZWxmLmNoYW5nZUxhYmVsKGxhYmVsLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYWJlbFNoYXBlID0gc2VsZi5fYWRkTGFiZWwoaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgIGlmIChsYWJlbFNoYXBlKSB7XG4gICAgICAgICAgbGFiZWxTaGFwZS5faWQgPSBpdGVtLl9pZDtcbiAgICAgICAgICBsYWJlbFNoYXBlLnNldCgnY29vcmQnLCBpdGVtLmNvb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IGNvdW50IC0gMTsgaSA+PSBpdGVtcy5sZW5ndGg7IGktLSkge1xuICAgICAgY2hpbGRyZW5baV0ucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgc2VsZi5fYWRqdXN0TGFiZWxzKCk7XG5cbiAgICBpZiAoc2VsZi5nZXQoJ2xhYmVsTGluZScpIHx8ICFzZWxmLmdldCgnY29uZmlnJykpIHtcbiAgICAgIHNlbGYuZHJhd0xpbmVzKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICog5pu05pawbGFiZWxcbiAgICogMS4g5bCGaXRlbXPkuI5ncm91cOS4reeahGNoaWxkcmVu5a+55q+U77yM5pu05pawL+aWsOWini/liKDpmaRsYWJlbHNcbiAgICogMi4gbGFiZWxz5biD5bGA5LyY5YyWXG4gICAqIDMuIOeUu2xhYmVs6L+e5o6l57q/XG4gICAqIDQuIOe7mOWItuWIsOeUu+W4g1xuICAgKi9cblxuXG4gIF9wcm90by5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICB0aGlzLl9kcnlEcmF3KCk7XG5cbiAgICB0aGlzLmdldCgnY2FudmFzJykuZHJhdygpO1xuICB9O1xuICAvKlxuICAgKiDmm7TmlrBsYWJlbFxuICAgKiBvbGRMYWJlbCBzaGFwZeaIlmxhYmVsIGRvbVxuICAgKiBuZXdMYWJlbCBsYWJlbCBkYXRhXG4gICAqIGluZGV4IGl0ZW1z5Lit55qE5LiL5qCHXG4gICAqL1xuXG5cbiAgX3Byb3RvLmNoYW5nZUxhYmVsID0gZnVuY3Rpb24gY2hhbmdlTGFiZWwob2xkTGFiZWwsIG5ld0xhYmVsKSB7XG4gICAgaWYgKCFvbGRMYWJlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvbGRMYWJlbC50YWdOYW1lKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2NyZWF0ZURvbShuZXdMYWJlbCk7XG5cbiAgICAgIG9sZExhYmVsLmlubmVySFRNTCA9IG5vZGUuaW5uZXJIVE1MO1xuXG4gICAgICB0aGlzLl9zZXRDdXN0b21Qb3NpdGlvbihuZXdMYWJlbCwgb2xkTGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRMYWJlbC5faWQgPSBuZXdMYWJlbC5faWQ7XG4gICAgICBvbGRMYWJlbC5hdHRyKCd0ZXh0JywgbmV3TGFiZWwudGV4dCk7XG5cbiAgICAgIGlmIChvbGRMYWJlbC5hdHRyKCd4JykgIT09IG5ld0xhYmVsLnggfHwgb2xkTGFiZWwuYXR0cigneScpICE9PSBuZXdMYWJlbC55KSB7XG4gICAgICAgIG9sZExhYmVsLnJlc2V0TWF0cml4KCk7XG5cbiAgICAgICAgaWYgKG5ld0xhYmVsLnRleHRTdHlsZS5yb3RhdGUpIHtcbiAgICAgICAgICBvbGRMYWJlbC5yb3RhdGVBdFN0YXJ0KG5ld0xhYmVsLnRleHRTdHlsZS5yb3RhdGUpO1xuICAgICAgICAgIGRlbGV0ZSBuZXdMYWJlbC50ZXh0U3R5bGUucm90YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWwuYXR0cihuZXdMYWJlbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICog5pi+56S6bGFiZWxcbiAgICovXG5cblxuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2dyb3VwJyk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcblxuICAgIGlmIChncm91cCkge1xuICAgICAgZ3JvdXAuc2hvdygpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiDpmpDol49sYWJlbFxuICAgKi9cblxuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICBncm91cC5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIOeUu2xhYmVs6L+e5o6l57q/XG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyYXdMaW5lcyA9IGZ1bmN0aW9uIGRyYXdMaW5lcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxpbmVTdHlsZSA9IHNlbGYuZ2V0KCdsYWJlbExpbmUnKTtcblxuICAgIGlmICh0eXBlb2YgbGluZVN0eWxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHNlbGYuc2V0KCdsYWJlbExpbmUnLCB7fSk7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVHcm91cCA9IHNlbGYuZ2V0KCdsaW5lR3JvdXAnKTtcblxuICAgIGlmICghbGluZUdyb3VwIHx8IGxpbmVHcm91cC5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICBsaW5lR3JvdXAgPSBzZWxmLmdldCgnZ3JvdXAnKS5hZGRHcm91cCh7XG4gICAgICAgIGVsQ2xzOiAneC1saW5lLWdyb3VwJ1xuICAgICAgfSk7XG4gICAgICBzZWxmLnNldCgnbGluZUdyb3VwJywgbGluZUdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZUdyb3VwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgVXRpbC5lYWNoKHNlbGYuZ2V0KCdpdGVtcycpLCBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgIHNlbGYubGluZVRvTGFiZWwobGFiZWwsIGxpbmVHcm91cCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmxpbmVUb0xhYmVsID0gZnVuY3Rpb24gbGluZVRvTGFiZWwobGFiZWwsIGxpbmVHcm91cCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghc2VsZi5nZXQoJ2NvbmZpZycpICYmICFsYWJlbC5sYWJlbExpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGluZVN0eWxlID0gbGFiZWwubGFiZWxMaW5lIHx8IHNlbGYuZ2V0KCdsYWJlbExpbmUnKTtcbiAgICB2YXIgY2FwdHVyZSA9IHR5cGVvZiBsYWJlbC5jYXB0dXJlID09PSAndW5kZWZpbmVkJyA/IHNlbGYuZ2V0KCdjYXB0dXJlJykgOiBsYWJlbC5jYXB0dXJlO1xuICAgIHZhciBwYXRoID0gbGluZVN0eWxlLnBhdGg7XG5cbiAgICBpZiAocGF0aCAmJiBVdGlsLmlzRnVuY3Rpb24obGluZVN0eWxlLnBhdGgpKSB7XG4gICAgICBwYXRoID0gbGluZVN0eWxlLnBhdGgobGFiZWwpO1xuICAgIH1cblxuICAgIGlmICghcGF0aCkge1xuICAgICAgdmFyIHN0YXJ0ID0gbGFiZWwuc3RhcnQgfHwge1xuICAgICAgICB4OiBsYWJlbC54IC0gbGFiZWwuX29mZnNldC54LFxuICAgICAgICB5OiBsYWJlbC55IC0gbGFiZWwuX29mZnNldC55XG4gICAgICB9O1xuICAgICAgcGF0aCA9IFtbJ00nLCBzdGFydC54LCBzdGFydC55XSwgWydMJywgbGFiZWwueCwgbGFiZWwueV1dO1xuICAgIH1cblxuICAgIHZhciBzdHJva2UgPSBsYWJlbC5jb2xvcjtcblxuICAgIGlmICghc3Ryb2tlKSB7XG4gICAgICBpZiAobGFiZWwudGV4dFN0eWxlICYmIGxhYmVsLnRleHRTdHlsZS5maWxsKSB7XG4gICAgICAgIHN0cm9rZSA9IGxhYmVsLnRleHRTdHlsZS5maWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0gJyMwMDAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaW5lU2hhcGUgPSBsaW5lR3JvdXAuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgfSwgbGluZVN0eWxlKSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgICB9KTsgLy8gbGFiZWwg5a+55bqU57q/55qE5Yqo55S75YWz6ZetXG5cbiAgICBsaW5lU2hhcGUubmFtZSA9IHNlbGYuZ2V0KCduYW1lJyk7IC8vIGdlbmVyYXRlIGxhYmVsTGluZSBpZCBhY2NvcmRpbmcgdG8gbGFiZWwgaWRcblxuICAgIGxpbmVTaGFwZS5faWQgPSBsYWJlbC5faWQgJiYgbGFiZWwuX2lkLnJlcGxhY2UoJ2dsYWJlbCcsICdnbGFiZWxsaW5lJyk7XG4gICAgbGluZVNoYXBlLnNldCgnY29vcmQnLCBzZWxmLmdldCgnY29vcmQnKSk7XG4gIH07IC8vIOagueaNrnR5cGXlr7lsYWJlbOW4g+WxgFxuXG5cbiAgX3Byb3RvLl9hZGp1c3RMYWJlbHMgPSBmdW5jdGlvbiBfYWRqdXN0TGFiZWxzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IHNlbGYuZ2V0KCd0eXBlJyk7XG4gICAgdmFyIGxhYmVscyA9IHNlbGYuZ2V0TGFiZWxzKCk7XG4gICAgdmFyIHNoYXBlcyA9IHNlbGYuZ2V0KCdzaGFwZXMnKTtcbiAgICB2YXIgbGF5b3V0ID0gTEFZT1VUU1t0eXBlXTtcblxuICAgIGlmICh0eXBlID09PSAnZGVmYXVsdCcgfHwgIWxheW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheW91dChsYWJlbHMsIHNoYXBlcyk7XG4gIH07XG4gIC8qKlxuICAgKiDojrflj5blvZPliY3miYDmnIlsYWJlbOWunuS+i1xuICAgKiBAcmV0dXJuIHtBcnJheX0g5b2T5YmNbGFiZWzlrp7kvotcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0TGFiZWxzID0gZnVuY3Rpb24gZ2V0TGFiZWxzKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gVXRpbC50b0FycmF5KGNvbnRhaW5lci5jaGlsZE5vZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQoJ2dyb3VwJykuZ2V0KCdjaGlsZHJlbicpO1xuICB9OyAvLyDlhYjorqHnrpdsYWJlbOeahOaJgOaciemFjee9rumhue+8jOeEtuWQjueUn+aIkGxhYmVs5a6e5L6LXG5cblxuICBfcHJvdG8uX2FkZExhYmVsID0gZnVuY3Rpb24gX2FkZExhYmVsKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIGNmZyA9IGl0ZW07XG5cbiAgICBpZiAodGhpcy5nZXQoJ2NvbmZpZycpKSB7XG4gICAgICBjZmcgPSB0aGlzLl9nZXRMYWJlbENmZyhpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVRleHQoY2ZnKTtcbiAgfTtcblxuICBfcHJvdG8uX2dldExhYmVsQ2ZnID0gZnVuY3Rpb24gX2dldExhYmVsQ2ZnKGl0ZW0sIGluZGV4KSB7XG4gICAgdmFyIHRleHRTdHlsZSA9IHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKSB8fCB7fTtcbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5nZXQoJ2Zvcm1hdHRlcicpO1xuICAgIHZhciBodG1sVGVtcGxhdGUgPSB0aGlzLmdldCgnaHRtbFRlbXBsYXRlJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbS50ZXh0ID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24odGV4dFN0eWxlKSkge1xuICAgICAgdGV4dFN0eWxlID0gdGV4dFN0eWxlKGl0ZW0udGV4dCwgaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGl0ZW0udGV4dCA9IGZvcm1hdHRlcihpdGVtLnRleHQsIGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbFRlbXBsYXRlKSB7XG4gICAgICBpdGVtLnVzZUh0bWwgPSB0cnVlO1xuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGh0bWxUZW1wbGF0ZSkpIHtcbiAgICAgICAgaXRlbS50ZXh0ID0gaHRtbFRlbXBsYXRlKGl0ZW0udGV4dCwgaXRlbSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChVdGlsLmlzTmlsKGl0ZW0udGV4dCkpIHtcbiAgICAgIGl0ZW0udGV4dCA9ICcnO1xuICAgIH1cblxuICAgIGl0ZW0udGV4dCA9IGl0ZW0udGV4dCArICcnOyAvLyA/IOS4uuS7gOS5iOi9rOaNouS4uuWtl+espuS4slxuXG4gICAgdmFyIGNmZyA9IFV0aWwubWl4KHt9LCBpdGVtLCB7XG4gICAgICB0ZXh0U3R5bGU6IHRleHRTdHlsZVxuICAgIH0sIHtcbiAgICAgIHg6IGl0ZW0ueCB8fCAwLFxuICAgICAgeTogaXRlbS55IHx8IDBcbiAgICB9KTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuICAvKipcbiAgICogbGFiZWzliJ3lp4vljJbvvIzkuLvopoHpkojlr7lodG1s5a655ZmoXG4gICAqL1xuXG5cbiAgX3Byb3RvLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgaWYgKCF0aGlzLmdldCgnZ3JvdXAnKSkge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2NhbnZhcycpLmFkZEdyb3VwKHtcbiAgICAgICAgaWQ6ICdsYWJlbC1ncm91cCdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXQoJ2dyb3VwJywgZ3JvdXApO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW5pdEh0bWxDb250YWluZXIgPSBmdW5jdGlvbiBpbml0SHRtbENvbnRhaW5lcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJUcGwgPSB0aGlzLmdldCgnY29udGFpbmVyVHBsJyk7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJykucGFyZW50Tm9kZTtcbiAgICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlRG9tKGNvbnRhaW5lclRwbCk7XG4gICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgIHRoaXMuc2V0KCdjb250YWluZXInLCBjb250YWluZXIpO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgICBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpO1xuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuc2V0KCdjb250YWluZXInLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH07IC8vIOWIhmh0bWwgZG9t5ZKMRyBzaGFwZeS4pOenjeaDheWGteeUn+aIkGxhYmVs5a6e5L6LXG5cblxuICBfcHJvdG8uX2NyZWF0ZVRleHQgPSBmdW5jdGlvbiBfY3JlYXRlVGV4dChjZmcpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBjYXB0dXJlID0gdHlwZW9mIGNmZy5jYXB0dXJlID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZ2V0KCdjYXB0dXJlJykgOiBjZmcuY2FwdHVyZTtcbiAgICB2YXIgbGFiZWxTaGFwZTtcblxuICAgIGlmIChjZmcudXNlSHRtbCB8fCBjZmcuaHRtbFRlbXBsYXRlKSB7XG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIgPSB0aGlzLmluaXRIdG1sQ29udGFpbmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5fY3JlYXRlRG9tKGNmZyk7XG5cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgdGhpcy5fc2V0Q3VzdG9tUG9zaXRpb24oY2ZnLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldCgnbmFtZScpO1xuICAgICAgdmFyIG9yaWdpbiA9IGNmZy5wb2ludDtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuZ2V0KCdncm91cCcpO1xuICAgICAgZGVsZXRlIGNmZy5wb2ludDsgLy8g5Li05pe26Kej5Yaz77yM5ZCm5YiZ5b2x5ZON5Yqo55S7XG5cbiAgICAgIHZhciByb3RhdGUgPSBjZmcucm90YXRlOyAvLyB0ZXh0U3R5bGXkuK3nmoRyb3RhdGXomb3nhLblj6/ku6XmraPluLjnlLvlh7rvvIzkvYbmmK/lnKjlgZrliqjnlLvnmoTml7blgJnlj6/og73kvJrlr7zoh7TliqjnlLvlvILluLjjgILnp7vlh7rvvIzlnKjlrprkuYnlpb1zaGFwZeWQjumAmui/h3RyYW5zZm9ybeWunueOsOaViOaenOOAglxuXG4gICAgICBpZiAoY2ZnLnRleHRTdHlsZSkge1xuICAgICAgICBpZiAoY2ZnLnRleHRTdHlsZS5yb3RhdGUpIHtcbiAgICAgICAgICByb3RhdGUgPSBjZmcudGV4dFN0eWxlLnJvdGF0ZTtcbiAgICAgICAgICBkZWxldGUgY2ZnLnRleHRTdHlsZS5yb3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjZmcgPSBVdGlsLm1peCh7XG4gICAgICAgICAgeDogY2ZnLngsXG4gICAgICAgICAgeTogY2ZnLnksXG4gICAgICAgICAgdGV4dEFsaWduOiBjZmcudGV4dEFsaWduLFxuICAgICAgICAgIHRleHQ6IGNmZy50ZXh0XG4gICAgICAgIH0sIGNmZy50ZXh0U3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBsYWJlbFNoYXBlID0gZ3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICAgIGF0dHJzOiBjZmcsXG4gICAgICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgIC8vIHJvdGF0ZeaYr+eUqOinkuW6puWumuS5ieeahO+8jOi9rOaNouS4uuW8p+W6plxuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRlKSA+IE1hdGguUEkgKiAyKSB7XG4gICAgICAgICAgcm90YXRlID0gcm90YXRlIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsU2hhcGUudHJhbnNmb3JtKFtbJ3QnLCAtY2ZnLngsIC1jZmcueV0sIFsncicsIHJvdGF0ZV0sIFsndCcsIGNmZy54LCBjZmcueV1dKTtcbiAgICAgIH1cblxuICAgICAgbGFiZWxTaGFwZS5zZXRTaWxlbnQoJ29yaWdpbicsIG9yaWdpbiB8fCBjZmcpO1xuICAgICAgbGFiZWxTaGFwZS5uYW1lID0gbmFtZTsgLy8g55So5LqO5LqL5Lu25qCH5rOoXG5cbiAgICAgIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykgJiYgbGFiZWxTaGFwZS5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCB0aGlzLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgICAgIHJldHVybiBsYWJlbFNoYXBlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NyZWF0ZURvbSA9IGZ1bmN0aW9uIF9jcmVhdGVEb20oY2ZnKSB7XG4gICAgdmFyIGl0ZW1UcGwgPSB0aGlzLmdldCgnaXRlbVRwbCcpO1xuICAgIHZhciBzdHIgPSBVdGlsLnN1YnN0aXR1dGUoaXRlbVRwbCwge1xuICAgICAgdGV4dDogY2ZnLnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gRG9tVXRpbC5jcmVhdGVEb20oc3RyKTtcbiAgfTsgLy8g5qC55o2u5paH5pys5a+56b2Q5pa55byP56Gu5a6aZG9t5L2N572uXG5cblxuICBfcHJvdG8uX3NldEN1c3RvbVBvc2l0aW9uID0gZnVuY3Rpb24gX3NldEN1c3RvbVBvc2l0aW9uKGNmZywgaHRtbERvbSkge1xuICAgIHZhciB0ZXh0QWxpZ24gPSBjZmcudGV4dEFsaWduIHx8ICdsZWZ0JztcbiAgICB2YXIgdG9wID0gY2ZnLnk7XG4gICAgdmFyIGxlZnQgPSBjZmcueDtcbiAgICB2YXIgd2lkdGggPSBEb21VdGlsLmdldE91dGVyV2lkdGgoaHRtbERvbSk7XG4gICAgdmFyIGhlaWdodCA9IERvbVV0aWwuZ2V0T3V0ZXJIZWlnaHQoaHRtbERvbSk7XG4gICAgdG9wID0gdG9wIC0gaGVpZ2h0IC8gMjtcblxuICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICBsZWZ0ID0gbGVmdCAtIHdpZHRoIC8gMjtcbiAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgbGVmdCA9IGxlZnQgLSB3aWR0aDtcbiAgICB9XG5cbiAgICBodG1sRG9tLnN0eWxlLnRvcCA9IHBhcnNlSW50KHRvcCwgMTApICsgJ3B4JztcbiAgICBodG1sRG9tLnN0eWxlLmxlZnQgPSBwYXJzZUludChsZWZ0LCAxMCkgKyAncHgnO1xuICB9O1xuXG4gIHJldHVybiBMYWJlbDtcbn0oQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYWJlbDtcblxuLyoqKi8gfSksXG4vKiAxNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIEdyZWVkeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyZWVkeSgpIHtcbiAgICB0aGlzLmJpdG1hcCA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEdyZWVkeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc0dhcCA9IGZ1bmN0aW9uIGhhc0dhcChiYm94KSB7XG4gICAgdmFyIGhhc0dhcCA9IHRydWU7XG4gICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgIHZhciBtaW5YID0gTWF0aC5mbG9vcihiYm94Lm1pblgpO1xuICAgIHZhciBtYXhYID0gTWF0aC5jZWlsKGJib3gubWF4WCk7XG4gICAgdmFyIG1pblkgPSBNYXRoLmZsb29yKGJib3gubWluWSk7XG4gICAgdmFyIG1heFkgPSBNYXRoLmNlaWwoYmJveC5tYXhZKSAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gbWluWDsgaSA8IG1heFg7IGkrKykge1xuICAgICAgaWYgKCFiaXRtYXBbaV0pIHtcbiAgICAgICAgYml0bWFwW2ldID0gW107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gbWluWCB8fCBpID09PSBtYXhYIC0gMSkge1xuICAgICAgICBmb3IgKHZhciBqID0gbWluWTsgaiA8PSBtYXhZOyBqKyspIHtcbiAgICAgICAgICBpZiAoYml0bWFwW2ldW2pdKSB7XG4gICAgICAgICAgICBoYXNHYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJpdG1hcFtpXVttaW5ZXSB8fCBiaXRtYXBbaV1bbWF4WV0pIHtcbiAgICAgICAgICBoYXNHYXAgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNHYXA7XG4gIH07XG5cbiAgX3Byb3RvLmZpbGxHYXAgPSBmdW5jdGlvbiBmaWxsR2FwKGJib3gpIHtcbiAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgdmFyIG1pblggPSBNYXRoLmZsb29yKGJib3gubWluWCk7XG4gICAgdmFyIG1heFggPSBNYXRoLmNlaWwoYmJveC5tYXhYKSAtIDE7XG4gICAgdmFyIG1pblkgPSBNYXRoLmZsb29yKGJib3gubWluWSk7XG4gICAgdmFyIG1heFkgPSBNYXRoLmNlaWwoYmJveC5tYXhZKSAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gbWluWDsgaSA8PSBtYXhYOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSBtaW5ZOyBqIDwgbWF4WTsgaiArPSA4KSB7XG4gICAgICAgIGlmICghYml0bWFwW2ldKSB7XG4gICAgICAgICAgYml0bWFwW2ldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBiaXRtYXBbaV1bal0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBiaXRtYXBbaV1bbWF4WV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gbWluWTsgX2kgPD0gbWF4WTsgX2krKykge1xuICAgICAgYml0bWFwW21pblhdW19pXSA9IHRydWU7XG4gICAgICBiaXRtYXBbbWF4WF1bX2ldID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEdyZWVkeTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmVlZHk7XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEZpcnN0U2NhbGU6IGZ1bmN0aW9uIGdldEZpcnN0U2NhbGUoc2NhbGVzKSB7XG4gICAgdmFyIGZpcnN0U2NhbGU7XG4gICAgVXRpbC5lYWNoKHNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgZmlyc3RTY2FsZSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpcnN0U2NhbGU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgTGVnZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZOyAvLyBjb25zdCBEb21VdGlsID0gVXRpbC5Eb21VdGlsO1xuXG5cbnZhciBFdmVudCA9IFV0aWwuRXZlbnQ7XG52YXIgR3JvdXAgPSBVdGlsLkdyb3VwOyAvLyBjb25zdCBHbG9iYWwgPSByZXF1aXJlKCcuLi8uLi9nbG9iYWwnKTtcbi8vIGNvbnN0IENPTlRBSU5FUl9DTEFTUyA9ICdnMi1sZWdlbmQnO1xuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtcywgcmVmZXIpIHtcbiAgdmFyIHJzdCA9IG51bGw7XG4gIHZhciB2YWx1ZSA9IHJlZmVyIGluc3RhbmNlb2YgR3JvdXAgfHwgcmVmZXIubmFtZSA9PT0gJ2xlZ2VuZEdyb3VwJyA/IHJlZmVyLmdldCgndmFsdWUnKSA6IHJlZmVyO1xuICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByc3QgPSBpdGVtO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByc3Q7XG59XG5cbmZ1bmN0aW9uIGZpbmRTaGFwZUJ5TmFtZShncm91cCwgbmFtZSkge1xuICByZXR1cm4gZ3JvdXAuZmluZEJ5KGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gbmFtZTtcbiAgfSk7XG59XG5cbnZhciBDYXRlZ29yeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0xlZ2VuZCkge1xuICBfaW5oZXJpdHNMb29zZShDYXRlZ29yeSwgX0xlZ2VuZCk7XG5cbiAgZnVuY3Rpb24gQ2F0ZWdvcnkoKSB7XG4gICAgcmV0dXJuIF9MZWdlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhdGVnb3J5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9MZWdlbmQucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIHR5cGXmoIfor4ZcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdjYXRlZ29yeS1sZWdlbmQnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWtkOmhuembhuWQiFxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBpdGVtczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUT0RP77yacmVuYW1lXG4gICAgICAgKiDlm77kvovpobnmsLTlubPmlrnlkJHnmoTpl7Tot51cbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0ZW1HYXA6IDUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVE9ET++8mnJlbmFtZVxuICAgICAgICog5Zu+5L6L6aG55Z6C55u05pa55ZCR55qE6Ze06LedXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBpdGVtTWFyZ2luQm90dG9tOiA4LFxuXG4gICAgICAvKipcbiAgICAgICAqIOWbvuS+i+mhueWbvue7hFxuICAgICAgICogQHR5cGUge0dyb3VwfVxuICAgICAgICovXG4gICAgICBpdGVtc0dyb3VwOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOW4g+WxgOaWueW8j++8miBob3Jpem9udGFs77yMdmVydGljYWxcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGxheW91dDogJ2hvcml6b250YWwnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpuWFgeiuuOWFqOmDqOWPlua2iO+8jOm7mOiupCBmYWxzZe+8jOWNs+W/hemhu+S/neeVmeS4gOS4quiiq+mAieS4rVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGFsbG93QWxsQ2FuY2VsZWQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+ueahhuWGhei+uei3nVxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBiYWNrUGFkZGluZzogWzAsIDAsIDAsIDBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWbvuS+i+mhueWPlua2iOmAieS4reeahOminOiJslxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdW5DaGVja0NvbG9yOiAnI2NjYycsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5L6L6IOM5pmv5bGC5bGe5oCn6K6+572uXG4gICAgICAgKiBAdHlwZSB7T2JlamN0fVxuICAgICAgICovXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDBcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5L6L6aG555qE5a695bqm77yM5b2T5Zu+5L6L5pyJ5b6I5aSa5Zu+5L6L6aG577yM5bm25LiU55So5oi35oOz6KaB6L+Z5Lqb5Zu+5L6L6aG55Zyo5ZCM5LiA5bmz6Z2i5YaF5Z6C55u05a+56b2Q77yM5q2k5pe26L+Z5Liq5bGe5oCn5Y+v5biu55So5oi35a6e546w5q2k5pWI5p6cXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBpdGVtV2lkdGg6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5L6L5paH5a2X5qC35byPXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIHRleHRTdHlsZToge1xuICAgICAgICBmaWxsOiAnIzMzMycsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBtYXJrZXIg5ZKM5paH5a2X55qE6Led56a7XG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBfd29yZFNwYWNlaW5nOiA4LFxuXG4gICAgICAvKipcbiAgICAgICAqIOWbvuS+i+mhueaYr+WQpuWPr+eCueWHu++8jOm7mOiupOS4uiB0cnVlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgY2xpY2thYmxlOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRPRE86IHJlbmFtZVxuICAgICAgICog5Zu+5L6L6aG555qE6YCJ5oup5qih5byP77yM5aSa6YCJ5ZKM5Y2V6YCJIG11bHRpcGxl44CBc2luZ2xlXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBzZWxlY3RlZE1vZGU6ICdtdWx0aXBsZScsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5L6L6aG555qE6aG65bqP5piv5ZCm6KaB6YCG5bqP77yM6buY6K6k5Li6IGZhbHNlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgcmV2ZXJzZWQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpuiHquWKqOaNouihjFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGF1dG9XcmFwOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIOaYr+WQpuS7peWinuWKoCBib3JkZXIg55qE5pa55byP6auY5LquIGhvdmVyIOeahCBpdGVt44CC6Iul5Li6IGZhbHNlIO+8jOWImemZjeS9juWFtuS7liBpdGVtIOeahOmAj+aYjuW6puOAglxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGhpZ2hsaWdodDogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICog6Z2eaGlnaGxpZ2h05pa55byP5LiL77yM6byg5qCHaG92ZXLliLBsZWdlbmTmoLflvI9cbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGFjdGl2ZU9wYWNpdHk6IDAuNyxcblxuICAgICAgLyoqXG4gICAgICAgKiDpnZ5oaWdobGlnaHTmlrnlvI/kuIvvvIzpnZ7pvKDmoIdob3ZlcuWIsOeahGxlZ2VuZOagt+W8j1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgaW5hY3RpdmVPcGFjaXR5OiAxXG4gICAgfSk7XG4gIH07IC8vIHJlbmRlcmluZ1xuXG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBfTGVnZW5kLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3JlbmRlckl0ZW1zKCk7XG5cbiAgICB0aGlzLmdldCgnYXV0b1dyYXAnKSAmJiB0aGlzLl9hZGp1c3RJdGVtcygpOyAvLyDpu5jorqToh6rliqjmjaLooYxcbiAgfTsgLy8gdXNlciBpdGVyYWN0aW9uXG5cblxuICBfcHJvdG8uX2JpbmRFdmVudHMgPSBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5nZXQoJ2hvdmVyYWJsZScpKSB7XG4gICAgICB0aGlzLmdldCgnZ3JvdXAnKS5vbignbW91c2Vtb3ZlJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbk1vdXNlbW92ZScpKTtcbiAgICAgIHRoaXMuZ2V0KCdncm91cCcpLm9uKCdtb3VzZWxlYXZlJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbk1vdXNlbGVhdmUnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0KCdjbGlja2FibGUnKSkge1xuICAgICAgdGhpcy5nZXQoJ2dyb3VwJykub24oJ2NsaWNrJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbkNsaWNrJykpO1xuICAgIH1cbiAgfTsgLy8gcmV0dXJuIHRoZSB0YXJnZXQncyBwYXJlbnQgbGVnZW5kIG9iamVjdFxuXG5cbiAgX3Byb3RvLl9nZXRMZWdlbmRJdGVtID0gZnVuY3Rpb24gX2dldExlZ2VuZEl0ZW0odGFyZ2V0KSB7XG4gICAgdmFyIGl0ZW0gPSB0YXJnZXQuZ2V0KCdwYXJlbnQnKTtcblxuICAgIGlmIChpdGVtICYmIGl0ZW0ubmFtZSA9PT0gJ2xlZ2VuZEdyb3VwJykge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07IC8vIGFjdGl2YXRlIGFuIGl0ZW0gYnkgcmVkdWNlIHRoZSBvcGFjaXR5IG9mIG90aGVyIGl0ZW1zLlxuICAvLyBpdCBpcyByZXNlcnZlZCBmb3IgYmktZGlyZWN0aW9uIGludGVyYWN0aW9uIGJldHdlZW4gY2hhcnRzIC8gZ3JhcGggYW5kIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLmFjdGl2YXRlID0gZnVuY3Rpb24gYWN0aXZhdGUodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpdGVtc0dyb3VwID0gc2VsZi5nZXQoJ2l0ZW1zR3JvdXAnKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpdGVtc0dyb3VwLmdldCgnY2hpbGRyZW4nKTtcbiAgICB2YXIgbWFya2VySXRlbSA9IHZvaWQgMDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgbWFya2VySXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjaGlsZCwgJ2xlZ2VuZC1tYXJrZXInKTtcbiAgICAgIGlmICghbWFya2VySXRlbSkgcmV0dXJuO1xuICAgICAgdmFyIGNoZWNrZWQgPSBjaGlsZC5nZXQoJ2NoZWNrZWQnKTtcblxuICAgICAgaWYgKF90aGlzLmdldCgnaGlnaGxpZ2h0JykpIHtcbiAgICAgICAgLy8gY2hhbmdlIHN0cm9rZSBjb2xvclxuICAgICAgICBpZiAoY2hpbGQuZ2V0KCd2YWx1ZScpID09PSB2YWx1ZSAmJiBjaGVja2VkKSB7XG4gICAgICAgICAgbWFya2VySXRlbS5hdHRyKCdzdHJva2UnLCAnIzMzMycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoYW5nZSBvcGFjaXR5XG4gICAgICAgIGlmIChjaGlsZC5nZXQoJ3ZhbHVlJykgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbWFya2VySXRlbS5hdHRyKCdmaWxsT3BhY2l0eScsIHNlbGYuZ2V0KCdhY3RpdmVPcGFjaXR5JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgICByZXR1cm47XG4gIH07IC8vIHJlc3RvcmUgdGhlIG9wYWNpdHkgb2YgaXRlbXNcbiAgLy8gaXQgaXMgcmVzZXJ2ZWQgZm9yIGJpLWRpcmVjdGlvbiBpbnRlcmFjdGlvbiBiZXR3ZWVuIGNoYXJ0cyAvIGdyYXBoIGFuZCBsZWdlbmRcblxuXG4gIF9wcm90by5kZWFjdGl2YXRlID0gZnVuY3Rpb24gZGVhY3RpdmF0ZSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbXNHcm91cCA9IHNlbGYuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIG1hcmtlckl0ZW0gPSB2b2lkIDA7XG4gICAgdmFyIHVuQ2hlY2tDb2xvciA9IHRoaXMuZ2V0KCd1bkNoZWNrQ29sb3InKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgbWFya2VySXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjaGlsZCwgJ2xlZ2VuZC1tYXJrZXInKTtcbiAgICAgIGlmICghbWFya2VySXRlbSkgcmV0dXJuO1xuXG4gICAgICBpZiAoX3RoaXMyLmdldCgnaGlnaGxpZ2h0JykpIHtcbiAgICAgICAgdmFyIG9yaVN0cm9rZSA9IG1hcmtlckl0ZW0uZ2V0KCdvcmlTdHJva2UnKTtcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBjaGlsZC5nZXQoJ2NoZWNrZWQnKTtcbiAgICAgICAgaWYgKG9yaVN0cm9rZSAmJiAhY2hlY2tlZCkgb3JpU3Ryb2tlID0gdW5DaGVja0NvbG9yO2Vsc2Ugb3JpU3Ryb2tlID0gJyc7XG4gICAgICAgIG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJywgb3JpU3Ryb2tlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtlckl0ZW0uYXR0cignZmlsbE9wYWNpdHknLCBzZWxmLmdldCgnaW5hY3RpdmVPcGFjaXR5JykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZ2V0KCdjYW52YXMnKS5kcmF3KCk7XG4gICAgcmV0dXJuO1xuICB9OyAvLyBtb3VzZSBtb3ZlIGxpc3RlbmVyIG9mIGFuIGl0ZW1cbiAgLy8gd2hlbiBtb3VzZSBvdmVyIGFuIGl0ZW0sIHJlZHVjZSB0aGUgb3BhY2l0eSBvZiB0aGUgb3RoZXIgaXRlbXMuXG5cblxuICBfcHJvdG8uX29uTW91c2Vtb3ZlID0gZnVuY3Rpb24gX29uTW91c2Vtb3ZlKGV2KSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtKGV2LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5nZXQoJ2NoZWNrZWQnKSkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG4gICAgICB2YXIgaXRlbWhvdmVyID0gbmV3IEV2ZW50KCdpdGVtaG92ZXInLCBldiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpdGVtaG92ZXIuaXRlbSA9IGZpbmRJdGVtKGl0ZW1zLCBpdGVtKTtcbiAgICAgIGl0ZW1ob3Zlci5jaGVja2VkID0gaXRlbS5nZXQoJ2NoZWNrZWQnKTtcbiAgICAgIGl0ZW1ob3Zlci5jdXJyZW50VGFyZ2V0ID0gZXYuY3VycmVudFRhcmdldDsgLy8gY2hhbmdlIHRoZSBvcGFjaXR5IG9mIG90aGVyIGl0ZW1zXG5cbiAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5hY3RpdmF0ZShpdGVtLmdldCgndmFsdWUnKSk7XG4gICAgICB0aGlzLmVtaXQoJ2l0ZW1ob3ZlcicsIGl0ZW1ob3Zlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5lbWl0KCdpdGVtdW5ob3ZlcicsIGV2KTtcbiAgICB9XG5cbiAgICB0aGlzLmdldCgnY2FudmFzJykuZHJhdygpO1xuICAgIHJldHVybjtcbiAgfTsgLy8gbW91c2UgbGVhdmUgbGlzdGVuZXIgb2YgYW4gaXRlbVxuXG5cbiAgX3Byb3RvLl9vbk1vdXNlbGVhdmUgPSBmdW5jdGlvbiBfb25Nb3VzZWxlYXZlKGV2KSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgICB0aGlzLmVtaXQoJ2l0ZW11bmhvdmVyJywgZXYpO1xuICAgIHJldHVybjtcbiAgfTsgLy8gdGhlIGNsaWNrIGxpc3RlbmVyIG9mIGFuIGl0ZW1cblxuXG4gIF9wcm90by5fb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGV2KSB7XG4gICAgdmFyIGNsaWNrZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbShldi5jdXJyZW50VGFyZ2V0KTtcblxuICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KCdpdGVtcycpO1xuXG4gICAgaWYgKGNsaWNrZWRJdGVtICYmICFjbGlja2VkSXRlbS5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICB2YXIgY2hlY2tlZCA9IGNsaWNrZWRJdGVtLmdldCgnY2hlY2tlZCcpO1xuICAgICAgdmFyIG1vZGUgPSB0aGlzLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgICB2YXIgaXRlbSA9IGZpbmRJdGVtKGl0ZW1zLCBjbGlja2VkSXRlbSk7XG4gICAgICB2YXIgaXRlbWNsaWNrID0gbmV3IEV2ZW50KCdpdGVtY2xpY2snLCBldiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpdGVtY2xpY2suaXRlbSA9IGl0ZW07XG4gICAgICBpdGVtY2xpY2suY3VycmVudFRhcmdldCA9IGNsaWNrZWRJdGVtO1xuICAgICAgaXRlbWNsaWNrLmFwcGVuZEluZm8gPSBldi5jdXJyZW50VGFyZ2V0LmdldCgnYXBwZW5kSW5mbycpO1xuICAgICAgaXRlbWNsaWNrLmNoZWNrZWQgPSBtb2RlID09PSAnc2luZ2xlJyA/IHRydWUgOiAhY2hlY2tlZDtcblxuICAgICAgaWYgKCF0aGlzLmdldCgnYWxsb3dBbGxDYW5jZWxlZCcpICYmIGNoZWNrZWQgJiYgdGhpcy5nZXRDaGVja2VkQ291bnQoKSA9PT0gMSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NsaWNrbGFzdGl0ZW0nLCBpdGVtY2xpY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1bkNoZWNrQ29sb3IgPSB0aGlzLmdldCgndW5DaGVja0NvbG9yJyk7XG4gICAgICB2YXIgY2hlY2tDb2xvciA9IHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKS5maWxsO1xuICAgICAgdmFyIG1hcmtlckl0ZW0gPSB2b2lkIDA7XG4gICAgICB2YXIgdGV4dEl0ZW0gPSB2b2lkIDA7XG4gICAgICB2YXIgbGVnZW5kSXRlbSA9IHZvaWQgMDtcblxuICAgICAgaWYgKG1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIHZhciBpdGVtc0dyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgICAgIFV0aWwuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgbWFya2VySXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjaGlsZCwgJ2xlZ2VuZC1tYXJrZXInKTtcbiAgICAgICAgICB0ZXh0SXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjaGlsZCwgJ2xlZ2VuZC10ZXh0Jyk7XG4gICAgICAgICAgbGVnZW5kSXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjaGlsZCwgJ2xlZ2VuZC1pdGVtJyk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQgIT09IGNsaWNrZWRJdGVtKSB7XG4gICAgICAgICAgICBpZiAobWFya2VySXRlbS5hdHRyKCdmaWxsJykpIHtcbiAgICAgICAgICAgICAgbWFya2VySXRlbS5hdHRyKCdmaWxsJywgdW5DaGVja0NvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJykpIHtcbiAgICAgICAgICAgICAgbWFya2VySXRlbS5hdHRyKCdzdHJva2UnLCB1bkNoZWNrQ29sb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0SXRlbS5hdHRyKCdmaWxsJywgdW5DaGVja0NvbG9yKTtcbiAgICAgICAgICAgIG1hcmtlckl0ZW0uc2V0U2lsZW50KCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgdGV4dEl0ZW0uc2V0U2lsZW50KCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgbGVnZW5kSXRlbS5zZXRTaWxlbnQoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBjaGlsZC5zZXRTaWxlbnQoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXJrZXJJdGVtLmF0dHIoJ2ZpbGwnKSkge1xuICAgICAgICAgICAgICBpdGVtICYmIGl0ZW0ubWFya2VyICYmIG1hcmtlckl0ZW0uYXR0cignZmlsbCcsIGl0ZW0ubWFya2VyLmZpbGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWFya2VySXRlbS5hdHRyKCdzdHJva2UnKSkge1xuICAgICAgICAgICAgICBpdGVtICYmIGl0ZW0ubWFya2VyICYmIG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJywgaXRlbS5tYXJrZXIuc3Ryb2tlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dEl0ZW0uYXR0cignZmlsbCcsIGNoZWNrQ29sb3IpO1xuICAgICAgICAgICAgbWFya2VySXRlbS5zZXRTaWxlbnQoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHRleHRJdGVtLnNldFNpbGVudCgnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICAgICAgbGVnZW5kSXRlbS5zZXRTaWxlbnQoJ2NoZWNrZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGNoaWxkLnNldFNpbGVudCgnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZXJJdGVtID0gZmluZFNoYXBlQnlOYW1lKGNsaWNrZWRJdGVtLCAnbGVnZW5kLW1hcmtlcicpO1xuICAgICAgICB0ZXh0SXRlbSA9IGZpbmRTaGFwZUJ5TmFtZShjbGlja2VkSXRlbSwgJ2xlZ2VuZC10ZXh0Jyk7XG4gICAgICAgIGxlZ2VuZEl0ZW0gPSBmaW5kU2hhcGVCeU5hbWUoY2xpY2tlZEl0ZW0sICdsZWdlbmQtaXRlbScpO1xuXG4gICAgICAgIGlmIChtYXJrZXJJdGVtLmF0dHIoJ2ZpbGwnKSkge1xuICAgICAgICAgIGl0ZW0gJiYgaXRlbS5tYXJrZXIgJiYgbWFya2VySXRlbS5hdHRyKCdmaWxsJywgY2hlY2tlZCA/IHVuQ2hlY2tDb2xvciA6IGl0ZW0ubWFya2VyLmZpbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJykpIHtcbiAgICAgICAgICBpdGVtICYmIGl0ZW0ubWFya2VyICYmIG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJywgY2hlY2tlZCA/IHVuQ2hlY2tDb2xvciA6IGl0ZW0ubWFya2VyLnN0cm9rZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0SXRlbS5hdHRyKCdmaWxsJywgY2hlY2tlZCA/IHVuQ2hlY2tDb2xvciA6IGNoZWNrQ29sb3IpO1xuICAgICAgICBjbGlja2VkSXRlbS5zZXRTaWxlbnQoJ2NoZWNrZWQnLCAhY2hlY2tlZCk7XG4gICAgICAgIG1hcmtlckl0ZW0uc2V0U2lsZW50KCdjaGVja2VkJywgIWNoZWNrZWQpO1xuICAgICAgICB0ZXh0SXRlbS5zZXRTaWxlbnQoJ2NoZWNrZWQnLCAhY2hlY2tlZCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uc2V0U2lsZW50KCdjaGVja2VkJywgIWNoZWNrZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ2l0ZW1jbGljaycsIGl0ZW1jbGljayk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgICByZXR1cm47XG4gIH07IC8vIHJlbmRlciB0aGUgaXRlbXNcblxuXG4gIF9wcm90by5fcmVuZGVySXRlbXMgPSBmdW5jdGlvbiBfcmVuZGVySXRlbXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcblxuICAgIGlmICh0aGlzLmdldCgncmV2ZXJzZWQnKSkge1xuICAgICAgaXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBfdGhpczMuX2FkZEl0ZW0oaXRlbSwgaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdoaWdobGlnaHQnKSkge1xuICAgICAgdmFyIGl0ZW1zR3JvdXAgPSB0aGlzLmdldCgnaXRlbXNHcm91cCcpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgICB2YXIgbWFya2VySXRlbSA9IHZvaWQgMDtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIG1hcmtlckl0ZW0gPSBmaW5kU2hhcGVCeU5hbWUoY2hpbGQsICdsZWdlbmQtbWFya2VyJyk7XG4gICAgICAgIHZhciBvcmlTdHJva2UgPSBtYXJrZXJJdGVtLmdldCgnb3JpU3Ryb2tlJyk7XG5cbiAgICAgICAgaWYgKCFvcmlTdHJva2UpIHtcbiAgICAgICAgICBpZiAobWFya2VySXRlbS5hdHRyKCdzdHJva2UnKSkgbWFya2VySXRlbS5zZXQoJ29yaVN0cm9rZScsIG1hcmtlckl0ZW0uYXR0cignc3Ryb2tlJykpO2Vsc2UgbWFya2VySXRlbS5zZXQoJ29yaVN0cm9rZScsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9OyAvLyBmb3JtYXQgdGhlIGl0ZW0gdmFsdWVcblxuXG4gIF9wcm90by5fZm9ybWF0SXRlbVZhbHVlID0gZnVuY3Rpb24gX2Zvcm1hdEl0ZW1WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmdldCgnZm9ybWF0dGVyJykgfHwgdGhpcy5nZXQoJ2l0ZW1Gb3JtYXR0ZXInKTtcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHZhbHVlID0gZm9ybWF0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTsgLy8gZmluZCB4IG9mIG5leHQgaXRlbVxuXG5cbiAgX3Byb3RvLl9nZXROZXh0WCA9IGZ1bmN0aW9uIF9nZXROZXh0WCgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuICAgIHZhciBpdGVtR2FwID0gdGhpcy5nZXQoJ2l0ZW1HYXAnKTtcbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIGl0ZW1XaWR0aCA9IHRoaXMuZ2V0KCdpdGVtV2lkdGgnKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpdGVtc0dyb3VwLmdldCgnY2hpbGRyZW4nKTtcbiAgICB2YXIgbmV4dFggPSAwO1xuXG4gICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAvLyDmsLTlubPluIPlsYBcbiAgICAgIFV0aWwuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgbmV4dFggKz0gKGl0ZW1XaWR0aCA/IGl0ZW1XaWR0aCA6IHYuZ2V0QkJveCgpLndpZHRoKSArIGl0ZW1HYXA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFg7XG4gIH07IC8vIGZpbmQgeSBvZiBuZXh0IGl0ZW1cblxuXG4gIF9wcm90by5fZ2V0TmV4dFkgPSBmdW5jdGlvbiBfZ2V0TmV4dFkoKSB7XG4gICAgdmFyIGl0ZW1NYXJnaW5Cb3R0b20gPSB0aGlzLmdldCgnaXRlbU1hcmdpbkJvdHRvbScpO1xuICAgIHZhciB0aXRsZUdhcCA9IHRoaXMuZ2V0KCd0aXRsZVNoYXBlJykgPyB0aGlzLmdldCgndGl0bGVHYXAnKSA6IDA7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIHRpdGxlU2hhcGUgPSB0aGlzLmdldCgndGl0bGVTaGFwZScpO1xuICAgIHZhciBjaGlsZHJlbiA9IGl0ZW1zR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciBuZXh0WSA9IHRpdGxlR2FwO1xuXG4gICAgaWYgKHRpdGxlU2hhcGUpIHtcbiAgICAgIG5leHRZICs9IHRpdGxlU2hhcGUuZ2V0QkJveCgpLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICAvLyDnq5bnm7TluIPlsYBcbiAgICAgIFV0aWwuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgbmV4dFkgKz0gdi5nZXRCQm94KCkuaGVpZ2h0ICsgaXRlbU1hcmdpbkJvdHRvbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0WTtcbiAgfTsgLy8gYWRkIGFuIGl0ZW0gdG8gdGhlIGNhbnZhc1xuXG5cbiAgX3Byb3RvLl9hZGRJdGVtID0gZnVuY3Rpb24gX2FkZEl0ZW0oaXRlbSkge1xuICAgIHZhciBpdGVtc0dyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKTtcblxuICAgIHZhciB4ID0gdGhpcy5fZ2V0TmV4dFgoKTtcblxuICAgIHZhciB5ID0gdGhpcy5fZ2V0TmV4dFkoKTtcblxuICAgIHZhciB1bkNoZWNrQ29sb3IgPSB0aGlzLmdldCgndW5DaGVja0NvbG9yJyk7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IGl0ZW1zR3JvdXAuYWRkR3JvdXAoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGl0ZW0uY2hlY2tlZFxuICAgIH0pOyAvLyBAMjAxOC0xMC0yMCBieSBibHVlLmxiIOmcgOimgeiuvue9rnZpZXdJZO+8jOWQpuWImeWcqGVtaXTnmoTml7blgJnvvIxwYXJlbnTojrflj5bkuI3liLB2aWV3SWRcblxuICAgIGl0ZW1Hcm91cC5zZXQoJ3ZpZXdJZCcsIHRoaXMuZ2V0KCd2aWV3SWQnKSk7XG4gICAgdmFyIHRleHRTdHlsZSA9IHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKTtcbiAgICB2YXIgd29yZFNwYWNlID0gdGhpcy5nZXQoJ193b3JkU3BhY2VpbmcnKTtcbiAgICB2YXIgc3RhcnRYID0gMDtcblxuICAgIGlmIChpdGVtLm1hcmtlcikge1xuICAgICAgLy8g5aaC5p6c5pyJbWFya2Vy5re75YqgbWFya2VyXG4gICAgICB2YXIgbWFya2VyQXR0cnMgPSBVdGlsLm1peCh7fSwgaXRlbS5tYXJrZXIsIHtcbiAgICAgICAgeDogaXRlbS5tYXJrZXIucmFkaXVzICsgeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaXRlbS5jaGVja2VkKSB7XG4gICAgICAgIGlmIChtYXJrZXJBdHRycy5maWxsKSB7XG4gICAgICAgICAgbWFya2VyQXR0cnMuZmlsbCA9IHVuQ2hlY2tDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrZXJBdHRycy5zdHJva2UpIHtcbiAgICAgICAgICBtYXJrZXJBdHRycy5zdHJva2UgPSB1bkNoZWNrQ29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmtlclNoYXBlID0gaXRlbUdyb3VwLmFkZFNoYXBlKCdtYXJrZXInLCB7XG4gICAgICAgIHR5cGU6ICdtYXJrZXInLFxuICAgICAgICBhdHRyczogbWFya2VyQXR0cnNcbiAgICAgIH0pO1xuICAgICAgbWFya2VyU2hhcGUuYXR0cignY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICAgIG1hcmtlclNoYXBlLm5hbWUgPSAnbGVnZW5kLW1hcmtlcic7XG4gICAgICBzdGFydFggKz0gbWFya2VyU2hhcGUuZ2V0QkJveCgpLndpZHRoICsgd29yZFNwYWNlO1xuICAgIH1cblxuICAgIHZhciB0ZXh0QXR0cnMgPSBVdGlsLm1peCh7fSwge1xuICAgICAgZmlsbDogJyMzMzMnLFxuICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgfSwgdGV4dFN0eWxlLCB7XG4gICAgICB4OiBzdGFydFggKyB4LFxuICAgICAgeTogeSxcbiAgICAgIHRleHQ6IHRoaXMuX2Zvcm1hdEl0ZW1WYWx1ZShpdGVtLnZhbHVlKVxuICAgIH0pO1xuXG4gICAgaWYgKCFpdGVtLmNoZWNrZWQpIHtcbiAgICAgIFV0aWwubWl4KHRleHRBdHRycywge1xuICAgICAgICBmaWxsOiB1bkNoZWNrQ29sb3JcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0ZXh0U2hhcGUgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogdGV4dEF0dHJzXG4gICAgfSk7XG4gICAgdGV4dFNoYXBlLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgdGV4dFNoYXBlLm5hbWUgPSAnbGVnZW5kLXRleHQnO1xuICAgIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykgJiYgdGV4dFNoYXBlLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykpOyAvLyDmt7vliqDkuIDkuKrljIXlm7Tnn6nlvaLvvIznlKjkuo7kuovku7bmlK/mjIFcblxuICAgIHZhciBiYm94ID0gaXRlbUdyb3VwLmdldEJCb3goKTtcbiAgICB2YXIgaXRlbVdpZHRoID0gdGhpcy5nZXQoJ2l0ZW1XaWR0aCcpO1xuICAgIHZhciB3cmFwcGVyU2hhcGUgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5IC0gYmJveC5oZWlnaHQgLyAyLFxuICAgICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLFxuICAgICAgICB3aWR0aDogaXRlbVdpZHRoIHx8IGJib3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3cmFwcGVyU2hhcGUuYXR0cignY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICB3cmFwcGVyU2hhcGUuc2V0U2lsZW50KCdvcmlnaW4nLCBpdGVtKTsgLy8g5L+d5a2Y5Zu+5L6L6aG555u45YWz55qE5pWw5o2u77yM5L6/5LqO5LqL5Lu25pON5L2cXG5cbiAgICB3cmFwcGVyU2hhcGUubmFtZSA9ICdsZWdlbmQtaXRlbSc7XG4gICAgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSAmJiB3cmFwcGVyU2hhcGUuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgaXRlbUdyb3VwLm5hbWUgPSAnbGVnZW5kR3JvdXAnO1xuICAgIHJldHVybiBpdGVtR3JvdXA7XG4gIH07IC8vIGF1dG8gYnJlYWsgdGhlIGxpbmUgZm9yIGhvcml6b250YWwgbGF5b3V0XG5cblxuICBfcHJvdG8uX2FkanVzdEhvcml6b250YWwgPSBmdW5jdGlvbiBfYWRqdXN0SG9yaXpvbnRhbCgpIHtcbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIG1heExlbmd0aCA9IHRoaXMuZ2V0KCdtYXhMZW5ndGgnKTtcbiAgICB2YXIgaXRlbUdhcCA9IHRoaXMuZ2V0KCdpdGVtR2FwJyk7XG4gICAgdmFyIGl0ZW1NYXJnaW5Cb3R0b20gPSB0aGlzLmdldCgnaXRlbU1hcmdpbkJvdHRvbScpO1xuICAgIHZhciB0aXRsZUdhcCA9IHRoaXMuZ2V0KCd0aXRsZVNoYXBlJykgPyB0aGlzLmdldCgndGl0bGVHYXAnKSA6IDA7XG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIHJvd0xlbmd0aCA9IDA7XG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgdmFyIGJveCA9IHZvaWQgMDtcbiAgICB2YXIgaXRlbVdpZHRoID0gdGhpcy5nZXQoJ2l0ZW1XaWR0aCcpO1xuXG4gICAgaWYgKGl0ZW1zR3JvdXAuZ2V0QkJveCgpLndpZHRoID4gbWF4TGVuZ3RoKSB7XG4gICAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBib3ggPSBjaGlsZC5nZXRCQm94KCk7XG4gICAgICAgIHdpZHRoID0gaXRlbVdpZHRoIHx8IGJveC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCArIGl0ZW1NYXJnaW5Cb3R0b207XG5cbiAgICAgICAgaWYgKG1heExlbmd0aCAtIHJvd0xlbmd0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgICAgcm93TGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLm1vdmUocm93TGVuZ3RoLCByb3cgKiBoZWlnaHQgKyB0aXRsZUdhcCk7XG4gICAgICAgIHJvd0xlbmd0aCArPSB3aWR0aCArIGl0ZW1HYXA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07IC8vIGF1dG8gYnJlYWsgdGhlIGNvbHVtbiBmb3IgdmVydGljYWwgbGF5b3V0XG5cblxuICBfcHJvdG8uX2FkanVzdFZlcnRpY2FsID0gZnVuY3Rpb24gX2FkanVzdFZlcnRpY2FsKCkge1xuICAgIHZhciBpdGVtc0dyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKTtcbiAgICB2YXIgdGl0bGVTaGFwZSA9IHRoaXMuZ2V0KCd0aXRsZVNoYXBlJyk7XG4gICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgdmFyIG1heExlbmd0aCA9IHRoaXMuZ2V0KCdtYXhMZW5ndGgnKTsgLy8g5Z6C55u05biD5bGA77yM5YiZIG1heExlbmd0aCDku6PooajlrrnlmajnmoTpq5jluqZcblxuICAgIHZhciBpdGVtR2FwID0gdGhpcy5nZXQoJ2l0ZW1HYXAnKTtcbiAgICB2YXIgaXRlbU1hcmdpbkJvdHRvbSA9IHRoaXMuZ2V0KCdpdGVtTWFyZ2luQm90dG9tJyk7XG4gICAgdmFyIHRpdGxlR2FwID0gdGhpcy5nZXQoJ3RpdGxlR2FwJyk7XG4gICAgdmFyIHRpdGxlSGVpZ2h0ID0gdGl0bGVTaGFwZSA/IHRpdGxlU2hhcGUuZ2V0QkJveCgpLmhlaWdodCArIHRpdGxlR2FwIDogMDtcbiAgICB2YXIgaXRlbVdpZHRoID0gdGhpcy5nZXQoJ2l0ZW1XaWR0aCcpO1xuICAgIHZhciBjb2xMZW5ndGggPSB0aXRsZUhlaWdodDtcbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgYm94ID0gdm9pZCAwO1xuICAgIHZhciBtYXhJdGVtV2lkdGggPSAwO1xuICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICBpZiAoaXRlbXNHcm91cC5nZXRCQm94KCkuaGVpZ2h0ID4gbWF4TGVuZ3RoKSB7XG4gICAgICBVdGlsLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGJveCA9IHYuZ2V0QkJveCgpO1xuICAgICAgICB3aWR0aCA9IGJveC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodDtcblxuICAgICAgICBpZiAoaXRlbVdpZHRoKSB7XG4gICAgICAgICAgbWF4SXRlbVdpZHRoID0gaXRlbVdpZHRoICsgaXRlbUdhcDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA+IG1heEl0ZW1XaWR0aCkge1xuICAgICAgICAgIG1heEl0ZW1XaWR0aCA9IHdpZHRoICsgaXRlbUdhcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhMZW5ndGggLSBjb2xMZW5ndGggPCBoZWlnaHQpIHtcbiAgICAgICAgICBjb2xMZW5ndGggPSB0aXRsZUhlaWdodDtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBtYXhJdGVtV2lkdGg7XG4gICAgICAgICAgdi5tb3ZlKHRvdGFsTGVuZ3RoLCB0aXRsZUhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi5tb3ZlKHRvdGFsTGVuZ3RoLCBjb2xMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sTGVuZ3RoICs9IGhlaWdodCArIGl0ZW1NYXJnaW5Cb3R0b207XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07IC8vIGF1dG9tYXRpY2FsbHkgYnJlYWsgdGhlIGxpbmUgLyBjb2x1bW4gd2hpbGUgdGhlIHdpZHRoIC8gaGVpZ2h0IGV4Y2VlZHMgbWF4TGVuZ3RoXG5cblxuICBfcHJvdG8uX2FkanVzdEl0ZW1zID0gZnVuY3Rpb24gX2FkanVzdEl0ZW1zKCkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG5cbiAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHRoaXMuX2FkanVzdEhvcml6b250YWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRqdXN0VmVydGljYWwoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIF9MZWdlbmQucHJvdG90eXBlLmdldFdpZHRoLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gX0xlZ2VuZC5wcm90b3R5cGUuZ2V0SGVpZ2h0LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICBfTGVnZW5kLnByb3RvdHlwZS5tb3ZlLmNhbGwodGhpcywgeCwgeSk7XG4gIH07XG5cbiAgcmV0dXJuIENhdGVnb3J5O1xufShMZWdlbmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGVnb3J5O1xuXG4vKioqLyB9KSxcbi8qIDE1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZO1xuXG52YXIgTGVnZW5kID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKExlZ2VuZCwgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9wcm90byA9IExlZ2VuZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEdyb3VwIOWuueWZqFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWbvuS+i+agh+mimOmFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgdGl0bGU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Zu+5L6L6aG55paH5pys5qC85byP5YyWXG4gICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIGZvcm1hdHRlcjogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDpvKDmoIcgaG92ZXIg5Yiw5Zu+5L6L5LiK55qE6buY6K6k5Lqk5LqS5piv5ZCm5byA5ZCvXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaG92ZXJhYmxlOiB0cnVlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRPRE/vvJpyZW5hbWVcbiAgICAgICAqIOWbvuS+i+agh+mimOi3neemu+WbvuS+i+mhueeahOi3neemu1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGl0bGVHYXA6IDE1LFxuXG4gICAgICAvKipcbiAgICAgICAqIGxlZ2VuZCDnm7jlr7nkuo4gY29udGFpbmVyIOeahOS9jee9rlxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogWzAsIDBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIGxlZ2VuZCDlnKggcG9zaXRpb24g5L2N572u5LiK55qE5YGP56e76YePXG4gICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIG9mZnNldDogWzAsIDBdLFxuXG4gICAgICAvKipcbiAgICAgICAqIGxlZ2VuZCDlnKggcG9zaXRpb24g5L2N572u5LiK5rK/IHgg6L2055qE5YGP56e76YeP44CC6Iul5ZCM5pe26K6+572u5LqGIG9mZnNldCDlkowgb2Zmc2V0WO+8jCDku6Ugb2Zmc2V0WCDkuLrlh4ZcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG9mZnNldFg6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogbGVnZW5kIOWcqCBwb3NpdGlvbiDkvY3nva7kuIrmsr8geSDovbTnmoTlgY/np7vph4/jgILoi6XlkIzml7borr7nva7kuoYgb2Zmc2V0IOWSjCBvZmZzZXRZ77yMIOS7pSBvZmZzZXRZIOS4uuWHhlxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0WTogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gTGVnZW5kKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIGNmZykgfHwgdGhpcztcblxuICAgIF90aGlzLl9pbml0KCk7XG5cbiAgICBfdGhpcy5iZWZvcmVSZW5kZXIoKTtcblxuICAgIF90aGlzLnJlbmRlcigpO1xuXG4gICAgX3RoaXMuX2FkanVzdFBvc2l0aW9uT2Zmc2V0KCk7XG5cbiAgICBfdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2dyb3VwJyk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcbiAgICB0aGlzLnNldCgnY2FudmFzJywgY29udGFpbmVyLmdldCgnY2FudmFzJykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0KCdwb3NpdGlvbicpO1xuICAgIGlmICghZ3JvdXApIGdyb3VwID0gY29udGFpbmVyLmFkZEdyb3VwKHtcbiAgICAgIHg6IDAgLSBwb3NpdGlvblswXSxcbiAgICAgIHk6IDAgLSBwb3NpdGlvblsxXVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdncm91cCcsIGdyb3VwKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkanVzdFBvc2l0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gX2FkanVzdFBvc2l0aW9uT2Zmc2V0KCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldCgnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldFggPSB0aGlzLmdldCgnb2Zmc2V0WCcpO1xuICAgIHZhciBvZmZzZXRZID0gdGhpcy5nZXQoJ29mZnNldFknKTtcblxuICAgIGlmICghVXRpbC5pc0FycmF5KG9mZnNldCkpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgICBvZmZzZXQgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBbb2Zmc2V0LCAwXSA6IFswLCBvZmZzZXRdO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRYKSBvZmZzZXRbMF0gPSBvZmZzZXRYO1xuICAgIGlmIChvZmZzZXRZKSBvZmZzZXRbMV0gPSBvZmZzZXRZO1xuICAgIHZhciBiYm94ID0gdGhpcy5nZXQoJ2dyb3VwJykuZ2V0QkJveCgpO1xuICAgIHRoaXMubW92ZSgtYmJveC5taW5YICsgcG9zaXRpb25bMF0gKyBvZmZzZXRbMF0sIC1iYm94Lm1pblkgKyBwb3NpdGlvblsxXSArIG9mZnNldFsxXSk7XG4gIH07XG5cbiAgX3Byb3RvLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlcigpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgaXRlbXNHcm91cCA9IGdyb3VwLmFkZEdyb3VwKCk7XG4gICAgdGhpcy5zZXQoJ2l0ZW1zR3JvdXAnLCBpdGVtc0dyb3VwKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMuX3JlbmRlclRpdGxlKCk7XG4gIH07IC8vIHJlbmRlciB0aGUgdGl0bGUgb2YgdGhlIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLl9yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uIF9yZW5kZXJUaXRsZSgpIHtcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldCgndGl0bGUnKTtcbiAgICB2YXIgdGl0bGVHYXAgPSB0aGlzLmdldCgndGl0bGVHYXAnKTtcbiAgICB0aXRsZUdhcCA9IHRpdGxlR2FwIHx8IDA7XG5cbiAgICBpZiAodGl0bGUgJiYgdGl0bGUudGV4dCkge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2dyb3VwJyk7XG4gICAgICB2YXIgdGl0bGVTaGFwZSA9IGdyb3VwLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCAtIHRpdGxlR2FwLFxuICAgICAgICAgIGZpbGw6ICcjMzMzJyxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICAgIH0sIHRpdGxlKVxuICAgICAgfSk7XG4gICAgICB0aXRsZVNoYXBlLm5hbWUgPSAnbGVnZW5kLXRpdGxlJztcbiAgICAgIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykgJiYgdGl0bGVTaGFwZS5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCB0aGlzLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgICAgIHRoaXMuc2V0KCd0aXRsZVNoYXBlJywgdGl0bGVTaGFwZSk7XG4gICAgfVxuICB9OyAvLyByZXR1cm4gdGhlIGNvdW50IG9mIGNoZWNrZWQgaXRlbXNcblxuXG4gIF9wcm90by5nZXRDaGVja2VkQ291bnQgPSBmdW5jdGlvbiBnZXRDaGVja2VkQ291bnQoKSB7XG4gICAgdmFyIGl0ZW1zR3JvdXAgPSB0aGlzLmdldCgnaXRlbXNHcm91cCcpO1xuICAgIHZhciBpdGVtcyA9IGl0ZW1zR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciBjaGVja2VkQXJyID0gVXRpbC5maWx0ZXIoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5nZXQoJ2NoZWNrZWQnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hlY2tlZEFyci5sZW5ndGg7XG4gIH07IC8vIHNldCBpdGVtcyBmb3IgdGhlIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLnNldEl0ZW1zID0gZnVuY3Rpb24gc2V0SXRlbXMoaXRlbXMpIHtcbiAgICB0aGlzLnNldCgnaXRlbXMnLCBpdGVtcyk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07IC8vIGFkZCBhbiBpdGVtIGludG8gdGhlIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGl0ZW0pIHtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9OyAvLyBjbGVhciBhbGwgdGhlIGl0ZW1zIG9mIHRoZSBsZWdlbmRcblxuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBpdGVtc0dyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKTtcbiAgICBpdGVtc0dyb3VwLmNsZWFyKCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2dyb3VwJyk7XG4gICAgZ3JvdXAuY2xlYXIoKTtcbiAgICB0aGlzLmJlZm9yZVJlbmRlcigpO1xuICB9OyAvLyBkZXN0cm95IHRoZSBsZWdlbmRcblxuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICBncm91cC5kZXN0cm95KCk7XG4gICAgdGhpcy5fYXR0cnMgPSB7fTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTsgLy8gcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgbGVnZW5kXG5cblxuICBfcHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICB2YXIgYmJveCA9IHRoaXMuZ2V0KCdncm91cCcpLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveC53aWR0aDtcbiAgfTsgLy8gcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICB2YXIgYmJveCA9IHRoaXMuZ2V0KCdncm91cCcpLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveC5oZWlnaHQ7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICB0aGlzLmdldCgnZ3JvdXAnKS5tb3ZlKHgsIHkpO1xuICB9O1xuXG4gIF9wcm90by5kcmF3ID0gZnVuY3Rpb24gZHJhdygpIHtcbiAgICB0aGlzLmdldCgnY2FudmFzJykuZHJhdygpO1xuICB9O1xuXG4gIHJldHVybiBMZWdlbmQ7XG59KENvbXBvbmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVnZW5kO1xuXG4vKioqLyB9KSxcbi8qIDE1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIENhdGVnb3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTcpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZO1xuXG52YXIgRG9tVXRpbCA9IFV0aWwuRG9tVXRpbDtcbnZhciBHcm91cCA9IFV0aWwuR3JvdXA7XG52YXIgQ09OVEFJTkVSX0NMQVNTID0gJ2cyLWxlZ2VuZCc7XG52YXIgVElUTEVfQ0xBU1MgPSAnZzItbGVnZW5kLXRpdGxlJztcbnZhciBMSVNUX0NMQVNTID0gJ2cyLWxlZ2VuZC1saXN0JztcbnZhciBJVEVNX0NMQVNTID0gJ2cyLWxlZ2VuZC1saXN0LWl0ZW0nO1xudmFyIFRFWFRfQ0xBU1MgPSAnZzItbGVnZW5kLXRleHQnO1xudmFyIE1BUktFUl9DTEFTUyA9ICdnMi1sZWdlbmQtbWFya2VyJzsgLy8gZmluZCBhIGRvbSBub2RlIGZyb20gdGhlIGNoaWRyZW4gb2YgdGhlIG5vZGUgd2l0aCBjbGFzc05hbWUuXG5cbmZ1bmN0aW9uIGZpbmROb2RlQnlDbGFzcyhub2RlLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUsIGNsYXNzTmFtZSkge1xuICB2YXIgbm9kZUNsYXNzID0gbm9kZS5jbGFzc05hbWU7XG5cbiAgaWYgKFV0aWwuaXNOaWwobm9kZUNsYXNzKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgbm9kZUNsYXNzID0gbm9kZUNsYXNzLnNwbGl0KCcgJyk7XG5cbiAgaWYgKG5vZGVDbGFzcy5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUuY2xhc3NOYW1lID09PSBDT05UQUlORVJfQ0xBU1MpIHtcbiAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFBhcmVudE5vZGUobm9kZS5wYXJlbnROb2RlLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW1zLCByZWZlcikge1xuICB2YXIgcnN0ID0gbnVsbDtcbiAgdmFyIHZhbHVlID0gcmVmZXIgaW5zdGFuY2VvZiBHcm91cCA/IHJlZmVyLmdldCgndmFsdWUnKSA6IHJlZmVyO1xuICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByc3QgPSBpdGVtO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByc3Q7XG59XG5cbnZhciBDYXRIdG1sID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ2F0ZWdvcnkpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2F0SHRtbCwgX0NhdGVnb3J5KTtcblxuICBmdW5jdGlvbiBDYXRIdG1sKCkge1xuICAgIHJldHVybiBfQ2F0ZWdvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhdEh0bWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0NhdGVnb3J5LnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgKiB0eXBlIOagh+ivhlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2NhdGVnb3J5LWxlZ2VuZCcsXG5cbiAgICAgIC8qKlxuICAgICAgICogaHRtbCDlrrnlmahcbiAgICAgICAqIEB0eXBlIHtET019XG4gICAgICAgKi9cbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDkvb/nlKhodG1s5pe255qE5aSW5bGC5qih5p2/XG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBjb250YWluZXJUcGw6ICc8ZGl2IGNsYXNzPVwiJyArIENPTlRBSU5FUl9DTEFTUyArICdcIj4nICsgJzxoNCBjbGFzcz1cIicgKyBUSVRMRV9DTEFTUyArICdcIj48L2g0PicgKyAnPHVsIGNsYXNzPVwiJyArIExJU1RfQ0xBU1MgKyAnXCI+PC91bD4nICsgJzwvZGl2PicsXG5cbiAgICAgIC8qKlxuICAgICAgICogaHRtbCDmqKHmnb9cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIGl0ZW1UcGw6ICc8bGkgY2xhc3M9XCInICsgSVRFTV9DTEFTUyArICcgaXRlbS17aW5kZXh9IHtjaGVja2VkfVwiIGRhdGEtY29sb3I9XCJ7b3JpZ2luQ29sb3J9XCIgZGF0YS12YWx1ZT1cIntvcmlnaW5WYWx1ZX1cIj4nICsgJzxpIGNsYXNzPVwiJyArIE1BUktFUl9DTEFTUyArICdcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6e2NvbG9yfTtcIj48L2k+JyArICc8c3BhbiBjbGFzcz1cIicgKyBURVhUX0NMQVNTICsgJ1wiPnt2YWx1ZX08L3NwYW4+PC9saT4nLFxuXG4gICAgICAvKipcbiAgICAgICAqIGh0bWwgc3R5bGVcbiAgICAgICAqIEB0eXBlIHtBdHRyc31cbiAgICAgICAqL1xuICAgICAgbGVnZW5kU3R5bGU6IHt9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOWbvuS+i+aWh+Wtl+agt+W8j1xuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyMzMzMnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIHRleHRBbGlnbjogJ21pZGRsZScsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCcsXG4gICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOW9k+aWh+acrOWkqumVv+aXtuaYr+WQpui/m+ihjOe8qeeVpVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGFicmlkZ2VUZXh0OiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBhYnJpZGdlVGV4dCDkuLogdHJ1ZSDml7bvvIzpvKDmoIfmlL7nva7lnKggaXRlbSDkuIrml7bmmL7npLrlhajnp7DnmoTmgqzmta4gZGl2IOeahCBodG1sIOaooeadv1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdGlwVHBsOiAnPGRpdiBjbGFzcz1cInRleHRUaXBcIj48L2Rpdj4nLFxuXG4gICAgICAvKipcbiAgICAgICAqIGFicmlkZ2VUZXh0IOS4uiB0cnVlIOaXtu+8jOm8oOagh+aUvue9ruWcqCBpdGVtIOS4iuaXtuaYvuekuuWFqOensOeahOaCrOa1riBkaXYg55qE5qC35byPXG4gICAgICAgKiBAdHlwZSB7QXR0cnN9XG4gICAgICAgKi9cbiAgICAgIHRpcFN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogJ2F1dG8nLFxuICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICAgIGJveFNoYWRvdzogJzJweCAycHggNXB4ICM4ODgnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHVzZUh0bWwg5Li6IHRydWUg5pe255Sf5pWI77yM55So5LqO6Ieq5Yqo5a6a5L2NXG4gICAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAgICovXG4gICAgICBhdXRvUG9zaXRpb246IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXQgPSBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlcigpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLl9yZW5kZXJIVE1MKCk7XG4gIH07IC8vIHVzZXIgaW50ZXJhY3Rpb25cblxuXG4gIF9wcm90by5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kV3JhcHBlciA9IHRoaXMuZ2V0KCdsZWdlbmRXcmFwcGVyJyk7XG4gICAgdmFyIGl0ZW1MaXN0RG9tID0gZmluZE5vZGVCeUNsYXNzKGxlZ2VuZFdyYXBwZXIsIExJU1RfQ0xBU1MpO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdob3ZlcmFibGUnKSkge1xuICAgICAgaXRlbUxpc3REb20ub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9vbk1vdXNlbW92ZShldik7XG4gICAgICB9O1xuXG4gICAgICBpdGVtTGlzdERvbS5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fb25Nb3VzZWxlYXZlKGV2KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0KCdjbGlja2FibGUnKSkge1xuICAgICAgaXRlbUxpc3REb20ub25jbGljayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gX3RoaXMuX29uQ2xpY2soZXYpO1xuICAgICAgfTtcbiAgICB9XG4gIH07IC8vIG1vdXNlIG1vdmUgbGlzdGVuZXIgb2YgYW4gaXRlbVxuICAvLyB3aGVuIG1vdXNlIG92ZXIgYW4gaXRlbSwgcmVkdWNlIHRoZSBvcGFjaXR5IG9mIHRoZSBvdGhlciBpdGVtcy5cblxuXG4gIF9wcm90by5fb25Nb3VzZW1vdmUgPSBmdW5jdGlvbiBfb25Nb3VzZW1vdmUoZXYpIHtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgIHZhciB0YXJnZXRDbGFzcyA9IHRhcmdldC5jbGFzc05hbWU7XG4gICAgdGFyZ2V0Q2xhc3MgPSB0YXJnZXRDbGFzcy5zcGxpdCgnICcpO1xuXG4gICAgaWYgKHRhcmdldENsYXNzLmluZGV4T2YoQ09OVEFJTkVSX0NMQVNTKSA+IC0xIHx8IHRhcmdldENsYXNzLmluZGV4T2YoTElTVF9DTEFTUykgPiAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnREb20gPSBnZXRQYXJlbnROb2RlKHRhcmdldCwgSVRFTV9DTEFTUyk7XG4gICAgdmFyIGhvdmVyZWRJdGVtID0gZmluZEl0ZW0oaXRlbXMsIHBhcmVudERvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSk7XG5cbiAgICBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIC8vIGNoYW5nZSB0aGUgb3BhY2l0eSBvZiBvdGhlciBpdGVtc1xuICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLmFjdGl2YXRlKHBhcmVudERvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSk7XG4gICAgICB0aGlzLmVtaXQoJ2l0ZW1ob3ZlcicsIHtcbiAgICAgICAgaXRlbTogaG92ZXJlZEl0ZW0sXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IHBhcmVudERvbSxcbiAgICAgICAgY2hlY2tlZDogaG92ZXJlZEl0ZW0uY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaG92ZXJlZEl0ZW0pIHtcbiAgICAgIC8vIHJlc3RvcmUgdGhlIG9wYWNpdHkgb2YgYWxsIHRoZSBpdGVtc1xuICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLmVtaXQoJ2l0ZW11bmhvdmVyJywgZXYpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfTsgLy8gbW91c2UgbGVhdmUgbGlzdGVuZXIgb2YgYW4gaXRlbVxuXG5cbiAgX3Byb3RvLl9vbk1vdXNlbGVhdmUgPSBmdW5jdGlvbiBfb25Nb3VzZWxlYXZlKGV2KSB7XG4gICAgLy8gcmVzdG9yZSB0aGUgb3BhY2l0eSBvZiBhbGwgdGhlIGl0ZW1zIHdoZW4gbW91c2UgbGVhdmVcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLmVtaXQoJ2l0ZW11bmhvdmVyJywgZXYpO1xuICAgIHJldHVybjtcbiAgfTsgLy8gdGhlIGNsaWNrIGxpc3RlbmVyIG9mIGFuIGl0ZW1cblxuXG4gIF9wcm90by5fb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGV2KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kV3JhcHBlciA9IHRoaXMuZ2V0KCdsZWdlbmRXcmFwcGVyJyk7XG4gICAgdmFyIGl0ZW1MaXN0RG9tID0gZmluZE5vZGVCeUNsYXNzKGxlZ2VuZFdyYXBwZXIsIExJU1RfQ0xBU1MpO1xuICAgIHZhciB1bkNoZWNrZWRDb2xvciA9IHRoaXMuZ2V0KCd1bkNoZWNrQ29sb3InKTtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgbW9kZSA9IHRoaXMuZ2V0KCdzZWxlY3RlZE1vZGUnKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IGl0ZW1MaXN0RG9tLmNoaWxkTm9kZXM7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICB2YXIgdGFyZ2V0Q2xhc3MgPSB0YXJnZXQuY2xhc3NOYW1lO1xuICAgIHRhcmdldENsYXNzID0gdGFyZ2V0Q2xhc3Muc3BsaXQoJyAnKTtcblxuICAgIGlmICh0YXJnZXRDbGFzcy5pbmRleE9mKENPTlRBSU5FUl9DTEFTUykgPiAtMSB8fCB0YXJnZXRDbGFzcy5pbmRleE9mKExJU1RfQ0xBU1MpID4gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50RG9tID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXQsIElURU1fQ0xBU1MpO1xuICAgIHZhciB0ZXh0RG9tID0gZmluZE5vZGVCeUNsYXNzKHBhcmVudERvbSwgVEVYVF9DTEFTUyk7XG4gICAgdmFyIG1hcmtlckRvbSA9IGZpbmROb2RlQnlDbGFzcyhwYXJlbnREb20sIE1BUktFUl9DTEFTUyk7XG4gICAgdmFyIGNsaWNrZWRJdGVtID0gZmluZEl0ZW0oaXRlbXMsIHBhcmVudERvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSk7XG5cbiAgICBpZiAoIWNsaWNrZWRJdGVtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRvbUNsYXNzID0gcGFyZW50RG9tLmNsYXNzTmFtZTtcbiAgICB2YXIgb3JpZ2luQ29sb3IgPSBwYXJlbnREb20uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbG9yJyk7XG5cbiAgICBpZiAobW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIC8vIOWNlemAieaooeW8j1xuICAgICAgLy8gdXBkYXRlIGNoZWNrZWQgc3RhdHVzXG4gICAgICBjbGlja2VkSXRlbS5jaGVja2VkID0gdHJ1ZTsgLy8g5YW25LuW5Zu+5L6L6aG55YWo6YOo572u54GwXG5cbiAgICAgIFV0aWwuZWFjaChjaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICE9PSBwYXJlbnREb20pIHtcbiAgICAgICAgICB2YXIgY2hpbGRNYXJrZXJEb20gPSBmaW5kTm9kZUJ5Q2xhc3MoY2hpbGQsIE1BUktFUl9DTEFTUyk7XG4gICAgICAgICAgY2hpbGRNYXJrZXJEb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdW5DaGVja2VkQ29sb3I7XG4gICAgICAgICAgY2hpbGQuY2xhc3NOYW1lID0gY2hpbGQuY2xhc3NOYW1lLnJlcGxhY2UoJ2NoZWNrZWQnLCAndW5DaGVja2VkJyk7XG4gICAgICAgICAgY2hpbGQuc3R5bGUuY29sb3IgPSB1bkNoZWNrZWRDb2xvcjtcbiAgICAgICAgICB2YXIgY2hpbGRJdGVtID0gZmluZEl0ZW0oaXRlbXMsIGNoaWxkLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpKTtcbiAgICAgICAgICBjaGlsZEl0ZW0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0ZXh0RG9tKSB7XG4gICAgICAgICAgICB0ZXh0RG9tLnN0eWxlLmNvbG9yID0gX3RoaXMyLmdldCgndGV4dFN0eWxlJykuZmlsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWFya2VyRG9tKSB7XG4gICAgICAgICAgICBtYXJrZXJEb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3JpZ2luQ29sb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RG9tLmNsYXNzTmFtZSA9IGRvbUNsYXNzLnJlcGxhY2UoJ3VuQ2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDmt7flkIjmqKHlvI9cbiAgICAgIHZhciBjbGlja2VkSXRlbUNoZWNrZWQgPSBkb21DbGFzcy5pbmRleE9mKCdjaGVja2VkJykgIT09IC0xOyAvLyBkb21DbGFzcy5pbmNsdWRlcygnY2hlY2tlZCcpO1xuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgVXRpbC5lYWNoKGNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuY2xhc3NOYW1lLmluZGV4T2YoJ2NoZWNrZWQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyAuaW5jbHVkZXMoJ2NoZWNrZWQnKVxuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuZ2V0KCdhbGxvd0FsbENhbmNlbGVkJykgJiYgY2xpY2tlZEl0ZW1DaGVja2VkICYmIGNvdW50ID09PSAxKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xpY2tsYXN0aXRlbScsIHtcbiAgICAgICAgICBpdGVtOiBjbGlja2VkSXRlbSxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBwYXJlbnREb20sXG4gICAgICAgICAgY2hlY2tlZDogbW9kZSA9PT0gJ3NpbmdsZScgPyB0cnVlIDogY2xpY2tlZEl0ZW0uY2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyDlnKjliKTmlq3mnIDlkI7kuIDkuKrlm77kvovlkI7lho3mm7TmlrBjaGVja2Vk54q25oCB77yM6Ziy5q2i54K55Ye75pyA5ZCO5LiA5Liq5Zu+5L6LaXRlbeaXtuWbvuS+i+agt+W8j+ayoeacieWPmOWMluS9huaYr2NoZWNrZWTnirbmgIHmlLnlj5jkuoYgZml4ICM0MjJcblxuXG4gICAgICBjbGlja2VkSXRlbS5jaGVja2VkID0gIWNsaWNrZWRJdGVtLmNoZWNrZWQ7XG5cbiAgICAgIGlmIChjbGlja2VkSXRlbUNoZWNrZWQpIHtcbiAgICAgICAgaWYgKG1hcmtlckRvbSkge1xuICAgICAgICAgIG1hcmtlckRvbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB1bkNoZWNrZWRDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudERvbS5jbGFzc05hbWUgPSBkb21DbGFzcy5yZXBsYWNlKCdjaGVja2VkJywgJ3VuQ2hlY2tlZCcpO1xuICAgICAgICBwYXJlbnREb20uc3R5bGUuY29sb3IgPSB1bkNoZWNrZWRDb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtYXJrZXJEb20pIHtcbiAgICAgICAgICBtYXJrZXJEb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3JpZ2luQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnREb20uY2xhc3NOYW1lID0gZG9tQ2xhc3MucmVwbGFjZSgndW5DaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgcGFyZW50RG9tLnN0eWxlLmNvbG9yID0gdGhpcy5nZXQoJ3RleHRTdHlsZScpLmZpbGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdpdGVtY2xpY2snLCB7XG4gICAgICBpdGVtOiBjbGlja2VkSXRlbSxcbiAgICAgIGN1cnJlbnRUYXJnZXQ6IHBhcmVudERvbSxcbiAgICAgIGNoZWNrZWQ6IG1vZGUgPT09ICdzaW5nbGUnID8gdHJ1ZSA6IGNsaWNrZWRJdGVtLmNoZWNrZWRcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH07IC8vIGFjdGl2YXRlIGFuIGl0ZW0gYnkgcmVkdWNlIHRoZSBvcGFjaXR5IG9mIG90aGVyIGl0ZW1zLlxuICAvLyBpdCBpcyByZXNlcnZlZCBmb3IgYmktZGlyZWN0aW9uIGludGVyYWN0aW9uIGJldHdlZW4gY2hhcnRzIC8gZ3JhcGggYW5kIGxlZ2VuZFxuXG5cbiAgX3Byb3RvLmFjdGl2YXRlID0gZnVuY3Rpb24gYWN0aXZhdGUodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBzZWxmLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgaXRlbSA9IGZpbmRJdGVtKGl0ZW1zLCB2YWx1ZSk7XG4gICAgdmFyIGxlZ2VuZFdyYXBwZXIgPSBzZWxmLmdldCgnbGVnZW5kV3JhcHBlcicpO1xuICAgIHZhciBpdGVtTGlzdERvbSA9IGZpbmROb2RlQnlDbGFzcyhsZWdlbmRXcmFwcGVyLCBMSVNUX0NMQVNTKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IGl0ZW1MaXN0RG9tLmNoaWxkTm9kZXM7XG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWFya2VyRG9tID0gZmluZE5vZGVCeUNsYXNzKGNoaWxkLCBNQVJLRVJfQ0xBU1MpO1xuICAgICAgdmFyIGNoaWxkSXRlbSA9IGZpbmRJdGVtKGl0ZW1zLCBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSk7XG5cbiAgICAgIGlmIChfdGhpczMuZ2V0KCdoaWdobGlnaHQnKSkge1xuICAgICAgICBpZiAoY2hpbGRJdGVtID09PSBpdGVtICYmIGNoaWxkSXRlbS5jaGVja2VkKSB7XG4gICAgICAgICAgY2hpbGRNYXJrZXJEb20uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjMzMzJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaGlsZEl0ZW0gPT09IGl0ZW0pIHtcbiAgICAgICAgICBjaGlsZE1hcmtlckRvbS5zdHlsZS5vcGFjaXR5ID0gc2VsZi5nZXQoJ2FjdGl2ZU9wYWNpdHknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hpbGRJdGVtLmNoZWNrZWQpIGNoaWxkTWFya2VyRG9tLnN0eWxlLm9wYWNpdHkgPSBzZWxmLmdldCgnaW5hY3RpdmVPcGFjaXR5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgKGNoaWxkSXRlbSAhPT0gaXRlbSAmJiBjaGlsZEl0ZW0uY2hlY2tlZCkge1xuICAgICAgLy8gICBpZiAodGhpcy5nZXQoJ2hpZ2hsaWdodCcpKSB7XG4gICAgICAvLyAgICAgY2hpbGRNYXJrZXJEb20uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjZmZmJztcbiAgICAgIC8vICAgfSBlbHNlIGNoaWxkTWFya2VyRG9tLnN0eWxlLm9wYWNpdHkgPSAwLjU7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBpZiAodGhpcy5nZXQoJ2hpZ2hsaWdodCcpKSB7XG4gICAgICAvLyAgICAgY2hpbGRNYXJrZXJEb20uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjMzMzJztcbiAgICAgIC8vICAgfSBlbHNlIGNoaWxkTWFya2VyRG9tLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgLy8gfVxuXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9OyAvLyByZXN0b3JlIHRoZSBvcGFjaXR5IG9mIGl0ZW1zXG4gIC8vIGl0IGlzIHJlc2VydmVkIGZvciBiaS1kaXJlY3Rpb24gaW50ZXJhY3Rpb24gYmV0d2VlbiBjaGFydHMgLyBncmFwaCBhbmQgbGVnZW5kXG5cblxuICBfcHJvdG8uZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIGRlYWN0aXZhdGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlZ2VuZFdyYXBwZXIgPSBzZWxmLmdldCgnbGVnZW5kV3JhcHBlcicpO1xuICAgIHZhciBpdGVtTGlzdERvbSA9IGZpbmROb2RlQnlDbGFzcyhsZWdlbmRXcmFwcGVyLCBMSVNUX0NMQVNTKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IGl0ZW1MaXN0RG9tLmNoaWxkTm9kZXM7XG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWFya2VyRG9tID0gZmluZE5vZGVCeUNsYXNzKGNoaWxkLCBNQVJLRVJfQ0xBU1MpO1xuXG4gICAgICBpZiAoX3RoaXM0LmdldCgnaGlnaGxpZ2h0JykpIHtcbiAgICAgICAgY2hpbGRNYXJrZXJEb20uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjZmZmJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkTWFya2VyRG9tLnN0eWxlLm9wYWNpdHkgPSBzZWxmLmdldCgnaW5hY3RpdmVPcGFjaXR5Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVySFRNTCA9IGZ1bmN0aW9uIF9yZW5kZXJIVE1MKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzOyAvLyBjb25zdCBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG5cblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7IC8vIGNvbnN0IG91dHRlck5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcblxuICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0KCd0aXRsZScpO1xuICAgIHZhciBjb250YWluZXJUcGwgPSB0aGlzLmdldCgnY29udGFpbmVyVHBsJyk7XG4gICAgdmFyIGxlZ2VuZFdyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZURvbShjb250YWluZXJUcGwpO1xuICAgIHZhciB0aXRsZURvbSA9IGZpbmROb2RlQnlDbGFzcyhsZWdlbmRXcmFwcGVyLCBUSVRMRV9DTEFTUyk7XG4gICAgdmFyIGl0ZW1MaXN0RG9tID0gZmluZE5vZGVCeUNsYXNzKGxlZ2VuZFdyYXBwZXIsIExJU1RfQ0xBU1MpOyAvLyB1bFxuXG4gICAgdmFyIHVuQ2hlY2tlZENvbG9yID0gdGhpcy5nZXQoJ3VuQ2hlY2tDb2xvcicpO1xuICAgIHZhciBMRUdFTkRfU1RZTEUgPSBVdGlsLmRlZXBNaXgoe30sIHtcbiAgICAgIENPTlRBSU5FUl9DTEFTUzoge1xuICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWSxcbiAgICAgICAgbGluZUhlaWdodDogJzIwcHgnLFxuICAgICAgICBjb2xvcjogJyM4QzhDOEMnXG4gICAgICB9LFxuICAgICAgVElUTEVfQ0xBU1M6IHtcbiAgICAgICAgbWFyZ2luQm90dG9tOiB0aGlzLmdldCgndGl0bGVHYXAnKSArICdweCcsXG4gICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICAgIC8vIOm7mOiupOagt+W8j1xuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgfSxcbiAgICAgIExJU1RfQ0xBU1M6IHtcbiAgICAgICAgbGlzdFN0eWxlVHlwZTogJ25vbmUnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICBMSVNUX0lURU1fQ0xBU1M6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogJzVweCcsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAnMjRweCdcbiAgICAgIH0sXG4gICAgICBNQVJLRVJfQ0xBU1M6IHtcbiAgICAgICAgd2lkdGg6ICc5cHgnLFxuICAgICAgICBoZWlnaHQ6ICc5cHgnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgbWFyZ2luUmlnaHQ6ICc0cHgnLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgIH0sIHRoaXMuZ2V0KCdsZWdlbmRTdHlsZScpKTsgLy8gZml477yaSUUgOSDlhbzlrrnpl67popjvvIzlhYjliqDlhaUgbGVnZW5kV3JhcHBlclxuICAgIC8vIGxldCBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG5cbiAgICBpZiAoL15cXCMvLnRlc3QoY29udGFpbmVyKSB8fCB0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJyAmJiBjb250YWluZXIuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgLy8g5aaC5p6c5Lyg5YWlIGRvbSDoioLngrnnmoQgaWRcbiAgICAgIHZhciBpZCA9IGNvbnRhaW5lci5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxlZ2VuZFdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3Bvc2l0aW9uID0gdGhpcy5nZXQoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIHZhciByYW5nZVN0eWxlID0ge307XG5cbiAgICAgIGlmIChfcG9zaXRpb24gPT09ICdsZWZ0JyB8fCBfcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmFuZ2VTdHlsZSA9IHtcbiAgICAgICAgICBtYXhIZWlnaHQ6ICh0aGlzLmdldCgnbWF4TGVuZ3RoJykgfHwgY29udGFpbmVyLm9mZnNldEhlaWdodCkgKyAncHgnXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVN0eWxlID0ge1xuICAgICAgICAgIG1heFdpZHRoOiAodGhpcy5nZXQoJ21heExlbmd0aCcpIHx8IGNvbnRhaW5lci5vZmZzZXRXaWR0aCkgKyAncHgnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIERvbVV0aWwubW9kaWZ5Q1NTKGxlZ2VuZFdyYXBwZXIsIFV0aWwubWl4KHt9LCBMRUdFTkRfU1RZTEUuQ09OVEFJTkVSX0NMQVNTLCByYW5nZVN0eWxlLCB0aGlzLmdldChDT05UQUlORVJfQ0xBU1MpKSk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGVnZW5kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgRG9tVXRpbC5tb2RpZnlDU1MoaXRlbUxpc3REb20sIFV0aWwubWl4KHt9LCBMRUdFTkRfU1RZTEUuTElTVF9DTEFTUywgdGhpcy5nZXQoTElTVF9DTEFTUykpKTsgLy8gcmVuZGVyIHRpdGxlXG5cbiAgICBpZiAodGl0bGVEb20pIHtcbiAgICAgIGlmICh0aXRsZSAmJiB0aXRsZS50ZXh0KSB7XG4gICAgICAgIHRpdGxlRG9tLmlubmVySFRNTCA9IHRpdGxlLnRleHQ7XG4gICAgICAgIERvbVV0aWwubW9kaWZ5Q1NTKHRpdGxlRG9tLCBVdGlsLm1peCh7fSwgTEVHRU5EX1NUWUxFLlRJVExFX0NMQVNTLCB0aGlzLmdldChUSVRMRV9DTEFTUyksIHRpdGxlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWdlbmRXcmFwcGVyLnJlbW92ZUNoaWxkKHRpdGxlRG9tKTtcbiAgICAgIH1cbiAgICB9IC8vIOW8gOWni+a4suafk+WbvuS+i+mhuVxuXG5cbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgaXRlbVRwbCA9IHRoaXMuZ2V0KCdpdGVtVHBsJyk7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgaXRlbURpc3BsYXkgPSBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyB8fCBwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IGxheW91dCA9PT0gJ3ZlcnRpY2FsJyA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJztcbiAgICB2YXIgaXRlbVN0eWxlID0gVXRpbC5taXgoe30sIExFR0VORF9TVFlMRS5MSVNUX0lURU1fQ0xBU1MsIHtcbiAgICAgIGRpc3BsYXk6IGl0ZW1EaXNwbGF5XG4gICAgfSwgdGhpcy5nZXQoSVRFTV9DTEFTUykpO1xuICAgIHZhciBtYXJrZXJTdHlsZSA9IFV0aWwubWl4KHt9LCBMRUdFTkRfU1RZTEUuTUFSS0VSX0NMQVNTLCB0aGlzLmdldChNQVJLRVJfQ0xBU1MpKTtcbiAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgdmFyIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG5cbiAgICAgIHZhciB2YWx1ZSA9IF90aGlzNS5fZm9ybWF0SXRlbVZhbHVlKGl0ZW0udmFsdWUpO1xuXG4gICAgICB2YXIgbWFya2VyQ29sb3IgPSBpdGVtLm1hcmtlci5maWxsIHx8IGl0ZW0ubWFya2VyLnN0cm9rZTtcbiAgICAgIHZhciBjb2xvciA9IGNoZWNrZWQgPyBtYXJrZXJDb2xvciA6IHVuQ2hlY2tlZENvbG9yO1xuICAgICAgdmFyIGRvbVN0cjtcblxuICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihpdGVtVHBsKSkge1xuICAgICAgICBkb21TdHIgPSBpdGVtVHBsKHZhbHVlLCBjb2xvciwgY2hlY2tlZCwgaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tU3RyID0gaXRlbVRwbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1EaXYgPSBVdGlsLnN1YnN0aXR1dGUoZG9tU3RyLCBVdGlsLm1peCh7fSwgaXRlbSwge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgPyAnY2hlY2tlZCcgOiAndW5DaGVja2VkJyxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIG9yaWdpbkNvbG9yOiBtYXJrZXJDb2xvcixcbiAgICAgICAgLy8gQDIwMTgtMDctMDkgYnkgYmx1ZS5sYiDkv67lpI3lpoLmnpxsZWdlbmTlgLzkuK3lrZjlnKjlj4zlvJXlj7dcIuaXtiwg5a+86Ie055qE5peg5rOV54K55Ye76Kem5Y+RbGVnZW5k5q2j5bi45pON5L2cYnVnXG4gICAgICAgIG9yaWdpblZhbHVlOiBpdGVtLnZhbHVlLnJlcGxhY2UoL1xcXCIvZywgJyZxdW90OycpXG4gICAgICB9KSk7IC8vIGxpXG5cbiAgICAgIHZhciBpdGVtRG9tID0gRG9tVXRpbC5jcmVhdGVEb20oaXRlbURpdik7XG4gICAgICBpdGVtRG9tLnN0eWxlLmNvbG9yID0gX3RoaXM1LmdldCgndGV4dFN0eWxlJykuZmlsbDtcbiAgICAgIHZhciBtYXJrZXJEb20gPSBmaW5kTm9kZUJ5Q2xhc3MoaXRlbURvbSwgTUFSS0VSX0NMQVNTKTtcbiAgICAgIHZhciB0ZXh0RG9tID0gZmluZE5vZGVCeUNsYXNzKGl0ZW1Eb20sIFRFWFRfQ0xBU1MpO1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1MoaXRlbURvbSwgaXRlbVN0eWxlKTtcbiAgICAgIG1hcmtlckRvbSAmJiBEb21VdGlsLm1vZGlmeUNTUyhtYXJrZXJEb20sIG1hcmtlclN0eWxlKTsgLy8gdGV4dERvbSAmJiBEb21VdGlsLm1vZGlmeUNTUyh0ZXh0RG9tLCB0aGlzLmdldCgndGV4dFN0eWxlJykpO1xuXG4gICAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgaXRlbURvbS5zdHlsZS5jb2xvciA9IHVuQ2hlY2tlZENvbG9yO1xuXG4gICAgICAgIGlmIChtYXJrZXJEb20pIHtcbiAgICAgICAgICBtYXJrZXJEb20uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdW5DaGVja2VkQ29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbUxpc3REb20uYXBwZW5kQ2hpbGQoaXRlbURvbSk7IC8vIGFicmlkZ2UgdGhlIHRleHQgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGV4Y2VlZHMgdGhlIHdpZHRoIG9mIHRoZSBpdGVtXG5cbiAgICAgIGlmIChfdGhpczUuZ2V0KCdhYnJpZGdlVGV4dCcpKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdmFsdWU7IC8vIGNvbnN0IGl0ZW1XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5nZXQoSVRFTV9DTEFTUykud2lkdGguc3Vic3RyKDAsIHRoaXMuZ2V0KElURU1fQ0xBU1MpLndpZHRoLmxlbmd0aCAtIDIpKTtcblxuICAgICAgICB2YXIgaXRlbVdpZHRoID0gaXRlbURvbS5vZmZzZXRXaWR0aDtcblxuICAgICAgICB2YXIgZnMgPSBfdGhpczUuZ2V0KCd0ZXh0U3R5bGUnKS5mb250U2l6ZTtcblxuICAgICAgICBpZiAoaXNOYU4oZnMpKSB7XG4gICAgICAgICAgLy8gNi41cHQgPSA2LjUgKiAxLzcyICogOTYgPSA4LjZweFxuICAgICAgICAgIGlmIChmcy5pbmRleE9mKCdwdCcpICE9PSAtMSkgZnMgPSBwYXJzZUZsb2F0KGZzLnN1YnN0cigwLCBmcy5sZW5ndGggLSAyKSkgKiAxIC8gNzIgKiA5NjtlbHNlIGlmIChmcy5pbmRleE9mKCdweCcpICE9PSAtMSkgZnMgPSBwYXJzZUZsb2F0KGZzLnN1YnN0cigwLCBmcy5sZW5ndGggLSAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gZnMgKiB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxldHRlck51bSA9IE1hdGguZmxvb3IoaXRlbVdpZHRoIC8gZnMpO1xuXG4gICAgICAgIGlmIChpdGVtV2lkdGggPCAyICogZnMpIHtcbiAgICAgICAgICAvLyB1bmFibGUgdG8gY29udGFpbiAnLi4uJ1xuICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtV2lkdGggPCB0ZXh0V2lkdGgpIHtcbiAgICAgICAgICAvLyByZXBsYWNlIHRoZSB0YWlsIGFzICcuLi5cbiAgICAgICAgICBpZiAobGV0dGVyTnVtID4gMSkgdGV4dCA9IHRleHQuc3Vic3RyKDAsIGxldHRlck51bSAtIDEpICsgJy4uLic7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0RG9tLmlubmVyVGV4dCA9IHRleHQ7IC8vIHNob3cgdGhlIHRleHQgdGlwIHdoaWxlIG1vdXNlIGhvdmVyaW5nIGFuIGl0ZW1cblxuICAgICAgICBpdGVtRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGlwRG9tID0gZmluZE5vZGVCeUNsYXNzKGxlZ2VuZFdyYXBwZXIucGFyZW50Tm9kZSwgJ3RleHRUaXAnKTtcbiAgICAgICAgICB0aXBEb20uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgdGlwRG9tLnN0eWxlLmxlZnQgPSBpdGVtRG9tLm9mZnNldExlZnQgKyBpdGVtRG9tLm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgICB0aXBEb20uc3R5bGUudG9wID0gaXRlbURvbS5vZmZzZXRUb3AgKyAxNSArICdweCc7XG4gICAgICAgICAgdGlwRG9tLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICB9KTsgLy8gaGlkZSB0aGUgdGV4dCB0aXAgd2hpbGUgbW91c2UgbGVhdmUgdGhlIGl0ZW1cblxuICAgICAgICBpdGVtRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0aXBEb20gPSBmaW5kTm9kZUJ5Q2xhc3MobGVnZW5kV3JhcHBlci5wYXJlbnROb2RlLCAndGV4dFRpcCcpO1xuICAgICAgICAgIHRpcERvbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gYXBwZW5kIHRoZSB0aXAgZGl2IGFzIGEgYnJvdGhlciBub2RlIG9mIGxlZ2VuZCBkb21cblxuICAgIGlmICh0aGlzLmdldCgnYWJyaWRnZVRleHQnKSkge1xuICAgICAgdmFyIHRpcFRwbCA9IHRoaXMuZ2V0KCd0aXBUcGwnKTtcbiAgICAgIHZhciB0aXBEb20gPSBEb21VdGlsLmNyZWF0ZURvbSh0aXBUcGwpO1xuICAgICAgdmFyIHRpcERvbVN0eWxlID0gdGhpcy5nZXQoJ3RpcFN0eWxlJyk7XG4gICAgICBEb21VdGlsLm1vZGlmeUNTUyh0aXBEb20sIHRpcERvbVN0eWxlKTtcbiAgICAgIGxlZ2VuZFdyYXBwZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aXBEb20pOyAvLyBoaWRlIHRoZSB0aXAgd2hpbGUgbW91c2UgZW50ZXJpbmcgdGhlIHRpcCBkb21cblxuICAgICAgdGlwRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGlwRG9tLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldCgnbGVnZW5kV3JhcHBlcicsIGxlZ2VuZFdyYXBwZXIpO1xuICB9O1xuXG4gIF9wcm90by5fYWRqdXN0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiBfYWRqdXN0UG9zaXRpb25PZmZzZXQoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuZ2V0KCdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0WCA9IHRoaXMuZ2V0KCdvZmZzZXRYJyk7XG4gICAgdmFyIG9mZnNldFkgPSB0aGlzLmdldCgnb2Zmc2V0WScpO1xuICAgIGlmIChvZmZzZXRYKSBvZmZzZXRbMF0gPSBvZmZzZXRYO1xuICAgIGlmIChvZmZzZXRZKSBvZmZzZXRbMV0gPSBvZmZzZXRZO1xuICAgIHZhciBsZWdlbmRXcmFwcGVyID0gdGhpcy5nZXQoJ2xlZ2VuZFdyYXBwZXInKTtcbiAgICBsZWdlbmRXcmFwcGVyLnN0eWxlLmxlZnQgPSBwb3NpdGlvblswXSArICdweCc7XG4gICAgbGVnZW5kV3JhcHBlci5zdHlsZS50b3AgPSBwb3NpdGlvblsxXSArICdweCc7XG4gICAgbGVnZW5kV3JhcHBlci5zdHlsZS5tYXJnaW5MZWZ0ID0gb2Zmc2V0WzBdICsgJ3B4JztcbiAgICBsZWdlbmRXcmFwcGVyLnN0eWxlLm1hcmdpblRvcCA9IG9mZnNldFsxXSArICdweCc7XG4gIH07XG5cbiAgX3Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIERvbVV0aWwuZ2V0T3V0ZXJXaWR0aCh0aGlzLmdldCgnbGVnZW5kV3JhcHBlcicpKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiBEb21VdGlsLmdldE91dGVySGVpZ2h0KHRoaXMuZ2V0KCdsZWdlbmRXcmFwcGVyJykpO1xuICB9O1xuXG4gIF9wcm90by5tb3ZlID0gZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgaWYgKCEvXlxcIy8udGVzdCh0aGlzLmdldCgnY29udGFpbmVyJykpKSB7XG4gICAgICBEb21VdGlsLm1vZGlmeUNTUyh0aGlzLmdldCgnbGVnZW5kV3JhcHBlcicpLCB7XG4gICAgICAgIGxlZnQ6IHggKyAncHgnLFxuICAgICAgICB0b3A6IHkgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0KCd4JywgeCk7XG4gICAgICB0aGlzLnNldCgneScsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfQ2F0ZWdvcnkucHJvdG90eXBlLm1vdmUuY2FsbCh0aGlzLCB4LCB5KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBsZWdlbmRXcmFwcGVyID0gdGhpcy5nZXQoJ2xlZ2VuZFdyYXBwZXInKTtcblxuICAgIGlmIChsZWdlbmRXcmFwcGVyICYmIGxlZ2VuZFdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgbGVnZW5kV3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxlZ2VuZFdyYXBwZXIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2F0SHRtbDtcbn0oQ2F0ZWdvcnkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdEh0bWw7XG5cbi8qKiovIH0pLFxuLyogMTYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBDcm9zc2hhaXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ3Jvc3NoYWlyLCBfQ29tcG9uZW50KTtcblxuICB2YXIgX3Byb3RvID0gQ3Jvc3NoYWlyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Db21wb25lbnQucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAgKiBjcm9zc2hhaXLnmoTnsbvlnotcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqL1xuICAgICAgdHlwZTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDnlLvlnKjlk6rlsYLop4blm75cbiAgICAgICAqIEB0eXBlIHtHLUVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHBsb3Q6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogeOi9tOS4iu+8jOenu+WKqOWIsOS9jee9rueahOWBj+enu+mHj1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgcGxvdFJhbmdlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOm7mOiupHJlY3QgY3Jvc3NoYWly5qC35byPXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICByZWN0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyNDQ0Q2RUMnLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICAqIOm7mOiupGxpbmUgY3Jvc3NoYWly5qC35byPXG4gICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgKi9cbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBzdHJva2U6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAgICAgbGluZVdpZHRoOiAxXG4gICAgICB9LFxuICAgICAgaXNUcmFuc3Bvc2VkOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENyb3NzaGFpcihjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5faW5pdF8oKTtcblxuICAgIF90aGlzLnJlbmRlcigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLl9pbml0XyA9IGZ1bmN0aW9uIF9pbml0XygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBsb3QgPSBzZWxmLmdldCgncGxvdCcpO1xuICAgIHZhciBncm91cDtcblxuICAgIGlmIChzZWxmLnR5cGUgPT09ICdyZWN0Jykge1xuICAgICAgZ3JvdXAgPSBwbG90LmFkZEdyb3VwKHtcbiAgICAgICAgekluZGV4OiAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBwbG90LmFkZEdyb3VwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoJ2NvbnRhaW5lcicsIGdyb3VwKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZExpbmVTaGFwZSA9IGZ1bmN0aW9uIF9hZGRMaW5lU2hhcGUoYXR0cnMsIHR5cGUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgYXR0cnM6IGF0dHJzXG4gICAgfSk7IC8vIHNoYXBlLmhpZGUoKTtcblxuICAgIHRoaXMuc2V0KCdjcm9zc0xpbmVTaGFwZScgKyB0eXBlLCBzaGFwZSk7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVySG9yaXpvbnRhbExpbmUgPSBmdW5jdGlvbiBfcmVuZGVySG9yaXpvbnRhbExpbmUoY2FudmFzLCBwbG90UmFuZ2UpIHtcbiAgICB2YXIgc3R5bGUgPSBVdGlsLm1peCh0aGlzLmdldCgnbGluZVN0eWxlJyksIHRoaXMuZ2V0KCdzdHlsZScpKTtcbiAgICB2YXIgYXR0cnMgPSBVdGlsLm1peCh7XG4gICAgICB4MTogcGxvdFJhbmdlID8gcGxvdFJhbmdlLmJsLnggOiBjYW52YXMuZ2V0KCd3aWR0aCcpLFxuICAgICAgeTE6IDAsXG4gICAgICB4MjogcGxvdFJhbmdlID8gcGxvdFJhbmdlLmJyLnggOiAwLFxuICAgICAgeTI6IDBcbiAgICB9LCBzdHlsZSk7XG5cbiAgICB0aGlzLl9hZGRMaW5lU2hhcGUoYXR0cnMsICdYJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJWZXJ0aWNhbExpbmUgPSBmdW5jdGlvbiBfcmVuZGVyVmVydGljYWxMaW5lKGNhbnZhcywgcGxvdFJhbmdlKSB7XG4gICAgdmFyIHN0eWxlID0gVXRpbC5taXgodGhpcy5nZXQoJ2xpbmVTdHlsZScpLCB0aGlzLmdldCgnc3R5bGUnKSk7XG4gICAgdmFyIGF0dHJzID0gVXRpbC5taXgoe1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogcGxvdFJhbmdlID8gcGxvdFJhbmdlLmJsLnkgOiBjYW52YXMuZ2V0KCdoZWlnaHQnKSxcbiAgICAgIHgyOiAwLFxuICAgICAgeTI6IHBsb3RSYW5nZSA/IHBsb3RSYW5nZS50bC55IDogMFxuICAgIH0sIHN0eWxlKTtcblxuICAgIHRoaXMuX2FkZExpbmVTaGFwZShhdHRycywgJ1knKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckJhY2tncm91bmQgPSBmdW5jdGlvbiBfcmVuZGVyQmFja2dyb3VuZChjYW52YXMsIHBsb3RSYW5nZSkge1xuICAgIHZhciBzdHlsZSA9IFV0aWwubWl4KHRoaXMuZ2V0KCdyZWN0U3R5bGUnKSwgdGhpcy5nZXQoJ3N0eWxlJykpO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgdmFyIGF0dHJzID0gVXRpbC5taXgoe1xuICAgICAgeDogcGxvdFJhbmdlID8gcGxvdFJhbmdlLnRsLnggOiAwLFxuICAgICAgeTogcGxvdFJhbmdlID8gcGxvdFJhbmdlLnRsLnkgOiBjYW52YXMuZ2V0KCdoZWlnaHQnKSxcbiAgICAgIHdpZHRoOiBwbG90UmFuZ2UgPyBwbG90UmFuZ2UuYnIueCAtIHBsb3RSYW5nZS5ibC54IDogY2FudmFzLmdldCgnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogcGxvdFJhbmdlID8gTWF0aC5hYnMocGxvdFJhbmdlLnRsLnkgLSBwbG90UmFuZ2UuYmwueSkgOiBjYW52YXMuZ2V0KCdoZWlnaHQnKVxuICAgIH0sIHN0eWxlKTtcbiAgICB2YXIgc2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBhdHRyczogYXR0cnMsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pOyAvLyBzaGFwZS5oaWRlKCk7XG5cbiAgICB0aGlzLnNldCgnY3Jvc3NoYWlyc1JlY3RTaGFwZScsIHNoYXBlKTtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVSZWN0U2hhcGUgPSBmdW5jdGlvbiBfdXBkYXRlUmVjdFNoYXBlKGl0ZW1zKSB7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgY3Jvc3NoYWlyc1JlY3RTaGFwZSA9IHRoaXMuZ2V0KCdjcm9zc2hhaXJzUmVjdFNoYXBlJyk7XG4gICAgdmFyIGlzVHJhbnNwb3NlZCA9IHRoaXMuZ2V0KCdpc1RyYW5zcG9zZWQnKTtcbiAgICB2YXIgZmlyc3RJdGVtID0gaXRlbXNbMF07XG4gICAgdmFyIGxhc3RJdGVtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGRpbSA9IGlzVHJhbnNwb3NlZCA/ICd5JyA6ICd4JztcbiAgICB2YXIgYXR0ciA9IGlzVHJhbnNwb3NlZCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgc3RhcnREaW0gPSBmaXJzdEl0ZW1bZGltXTtcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPiAxICYmIGZpcnN0SXRlbVtkaW1dID4gbGFzdEl0ZW1bZGltXSkge1xuICAgICAgc3RhcnREaW0gPSBsYXN0SXRlbVtkaW1dO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldCgnd2lkdGgnKSkge1xuICAgICAgLy8g55So5oi35a6a5LmJ5LqGIHdpZHRoXG4gICAgICBjcm9zc2hhaXJzUmVjdFNoYXBlLmF0dHIoZGltLCBzdGFydERpbSAtIHRoaXMuZ2V0KCdjcm9zc2hhaXJzJykud2lkdGggLyAyKTtcbiAgICAgIGNyb3NzaGFpcnNSZWN0U2hhcGUuYXR0cihhdHRyLCB0aGlzLmdldCgnd2lkdGgnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChVdGlsLmlzQXJyYXkoZmlyc3RJdGVtLnBvaW50W2RpbV0pICYmICFmaXJzdEl0ZW0uc2l6ZSkge1xuICAgICAgICAvLyDnm7Tmlrnlm75cbiAgICAgICAgdmFyIHdpZHRoID0gZmlyc3RJdGVtLnBvaW50W2RpbV1bMV0gLSBmaXJzdEl0ZW0ucG9pbnRbZGltXVswXTtcbiAgICAgICAgY3Jvc3NoYWlyc1JlY3RTaGFwZS5hdHRyKGRpbSwgZmlyc3RJdGVtLnBvaW50W2RpbV1bMF0pO1xuICAgICAgICBjcm9zc2hhaXJzUmVjdFNoYXBlLmF0dHIoYXR0ciwgd2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gMyAqIGZpcnN0SXRlbS5zaXplIC8gNDtcbiAgICAgICAgY3Jvc3NoYWlyc1JlY3RTaGFwZS5hdHRyKGRpbSwgc3RhcnREaW0gLSBvZmZzZXQpO1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjcm9zc2hhaXJzUmVjdFNoYXBlLmF0dHIoYXR0ciwgMyAqIGZpcnN0SXRlbS5zaXplIC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Jvc3NoYWlyc1JlY3RTaGFwZS5hdHRyKGF0dHIsIE1hdGguYWJzKGxhc3RJdGVtW2RpbV0gLSBmaXJzdEl0ZW1bZGltXSkgKyAyICogb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHBsb3RSYW5nZSA9IHRoaXMuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICB2YXIgaXNUcmFuc3Bvc2VkID0gdGhpcy5nZXQoJ2lzVHJhbnNwb3NlZCcpO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXQoJ3R5cGUnKSkge1xuICAgICAgY2FzZSAneCc6XG4gICAgICAgIHRoaXMuX3JlbmRlckhvcml6b250YWxMaW5lKGNhbnZhcywgcGxvdFJhbmdlKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneSc6XG4gICAgICAgIHRoaXMuX3JlbmRlclZlcnRpY2FsTGluZShjYW52YXMsIHBsb3RSYW5nZSk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgICAgdGhpcy5fcmVuZGVySG9yaXpvbnRhbExpbmUoY2FudmFzLCBwbG90UmFuZ2UpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclZlcnRpY2FsTGluZShjYW52YXMsIHBsb3RSYW5nZSk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGNhbnZhcywgcGxvdFJhbmdlKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaXNUcmFuc3Bvc2VkID8gdGhpcy5fcmVuZGVySG9yaXpvbnRhbExpbmUoY2FudmFzLCBwbG90UmFuZ2UpIDogdGhpcy5fcmVuZGVyVmVydGljYWxMaW5lKGNhbnZhcywgcGxvdFJhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5zaG93LmNhbGwodGhpcyk7XG5cbiAgICBjb250YWluZXIuc2hvdygpO1xuICB9O1xuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGlkZS5jYWxsKHRoaXMpO1xuXG4gICAgY29udGFpbmVyLmhpZGUoKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHRoaXMuc2V0KCdjcm9zc0xpbmVTaGFwZVgnLCBudWxsKTtcbiAgICB0aGlzLnNldCgnY3Jvc3NMaW5lU2hhcGVZJywgbnVsbCk7XG4gICAgdGhpcy5zZXQoJ2Nyb3NzaGFpcnNSZWN0U2hhcGUnLCBudWxsKTtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG5cbiAgICBjb250YWluZXIuY2xlYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5LCBpdGVtcykge1xuICAgIHZhciBjcm9zc0xpbmVTaGFwZVggPSB0aGlzLmdldCgnY3Jvc3NMaW5lU2hhcGVYJyk7XG4gICAgdmFyIGNyb3NzTGluZVNoYXBlWSA9IHRoaXMuZ2V0KCdjcm9zc0xpbmVTaGFwZVknKTtcbiAgICB2YXIgY3Jvc3NoYWlyc1JlY3RTaGFwZSA9IHRoaXMuZ2V0KCdjcm9zc2hhaXJzUmVjdFNoYXBlJyk7XG5cbiAgICBpZiAoY3Jvc3NMaW5lU2hhcGVZICYmICFjcm9zc0xpbmVTaGFwZVkuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgLy8g56ys5LiA5qyh6L+b5YWl5pe277yM55S75biD6ZyA6KaB5Y2V54us57uY5Yi277yM5omA5Lul6ZyA6KaB5YWI6K6+5a6aY29yc3PnmoTkvY3nva5cbiAgICAgIGNyb3NzTGluZVNoYXBlWS5tb3ZlKHgsIDApO1xuICAgIH1cblxuICAgIGlmIChjcm9zc0xpbmVTaGFwZVggJiYgIWNyb3NzTGluZVNoYXBlWC5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICBjcm9zc0xpbmVTaGFwZVgubW92ZSgwLCB5KTtcbiAgICB9XG5cbiAgICBpZiAoY3Jvc3NoYWlyc1JlY3RTaGFwZSAmJiAhY3Jvc3NoYWlyc1JlY3RTaGFwZS5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICB0aGlzLl91cGRhdGVSZWN0U2hhcGUoaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ3Jvc3NoYWlyO1xufShDb21wb25lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyb3NzaGFpcjtcblxuLyoqKi8gfSksXG4vKiAxNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIEdBUCA9IDIwO1xudmFyIFBvc2l0aW9uTWl4aW4gPSB7XG4gIF9jYWxjVG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbiBfY2FsY1Rvb2x0aXBQb3NpdGlvbih4LCB5LCBwb3NpdGlvbiwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgdGFyZ2V0KSB7XG4gICAgdmFyIHJlY3RXaWR0aCA9IDA7XG4gICAgdmFyIHJlY3RIZWlnaHQgPSAwO1xuICAgIHZhciBnYXAgPSAyMDtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICAgIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICB4ID0gcmVjdC54O1xuICAgICAgeSA9IHJlY3QueTtcbiAgICAgIGdhcCA9IDU7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgeCA9IHggKyByZWN0V2lkdGggLyAyIC0gY29udGFpbmVyV2lkdGggLyAyO1xuICAgICAgICB5ID0geSArIHJlY3RIZWlnaHQgLyAyIC0gY29udGFpbmVySGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHggPSB4ICsgcmVjdFdpZHRoIC8gMiAtIGNvbnRhaW5lcldpZHRoIC8gMjtcbiAgICAgICAgeSA9IHkgLSBjb250YWluZXJIZWlnaHQgLSBnYXA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgeCA9IHggLSBjb250YWluZXJXaWR0aCAtIGdhcDtcbiAgICAgICAgeSA9IHkgKyByZWN0SGVpZ2h0IC8gMiAtIGNvbnRhaW5lckhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHggPSB4ICsgcmVjdFdpZHRoICsgZ2FwO1xuICAgICAgICB5ID0geSArIHJlY3RIZWlnaHQgLyAyIC0gY29udGFpbmVySGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB4ID0geCArIHJlY3RXaWR0aCAvIDIgLSBjb250YWluZXJXaWR0aCAvIDI7XG4gICAgICAgIHkgPSB5ICsgcmVjdEhlaWdodCArIGdhcDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfSxcbiAgX2NvbnN0cmFpbnRQb3NpdGlvbkluQm91bmRhcnk6IGZ1bmN0aW9uIF9jb25zdHJhaW50UG9zaXRpb25JbkJvdW5kYXJ5KHgsIHksIHdpZHRoLCBoZWlnaHQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICAgIGlmICh4ICsgd2lkdGggKyBHQVAgPiB2aWV3V2lkdGgpIHtcbiAgICAgIHggLT0gd2lkdGggKyBHQVA7XG4gICAgICB4ID0geCA8IDAgPyAwIDogeDtcbiAgICB9IGVsc2UgaWYgKHggKyBHQVAgPCAwKSB7XG4gICAgICB4ID0gR0FQO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IEdBUDtcbiAgICB9XG5cbiAgICBpZiAoeSArIGhlaWdodCArIEdBUCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgIHkgLT0gaGVpZ2h0ICsgR0FQO1xuICAgICAgeSA9IHkgPCAwID8gMCA6IHk7XG4gICAgfSBlbHNlIGlmICh5ICsgR0FQIDwgMCkge1xuICAgICAgeSA9IEdBUDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBHQVA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfSxcbiAgX2NvbnN0cmFpbnRQb3NpdGlvbkluUGxvdDogZnVuY3Rpb24gX2NvbnN0cmFpbnRQb3NpdGlvbkluUGxvdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwbG90UmFuZ2UsIG9ubHlIb3Jpem9udGFsKSB7XG4gICAgaWYgKHggKyB3aWR0aCA+IHBsb3RSYW5nZS50ci54KSB7XG4gICAgICB4IC09IHdpZHRoICsgMiAqIEdBUDtcbiAgICB9XG5cbiAgICBpZiAoeCA8IHBsb3RSYW5nZS50bC54KSB7XG4gICAgICB4ID0gcGxvdFJhbmdlLnRsLng7XG4gICAgfVxuXG4gICAgaWYgKCFvbmx5SG9yaXpvbnRhbCkge1xuICAgICAgaWYgKHkgKyBoZWlnaHQgPiBwbG90UmFuZ2UuYmwueSkge1xuICAgICAgICB5IC09IGhlaWdodCArIDIgKiBHQVA7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgcGxvdFJhbmdlLnRsLnkpIHtcbiAgICAgICAgeSA9IHBsb3RSYW5nZS50bC55O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeCwgeV07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uTWl4aW47XG5cbi8qKiovIH0pLFxuLyogMTYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIE1hcmtlckdyb3VwTWl4aW4gPSB7XG4gIHNldE1hcmtlcnM6IGZ1bmN0aW9uIHNldE1hcmtlcnMobWFya2VySXRlbXMsIG1hcmtlckNmZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWFya2VyR3JvdXAgPSBzZWxmLmdldCgnbWFya2VyR3JvdXAnKTtcbiAgICB2YXIgZnJvbnRQbG90ID0gc2VsZi5nZXQoJ2Zyb250UGxvdCcpO1xuXG4gICAgaWYgKCFtYXJrZXJHcm91cCkge1xuICAgICAgbWFya2VyR3JvdXAgPSBmcm9udFBsb3QuYWRkR3JvdXAoe1xuICAgICAgICB6SW5kZXg6IDEsXG4gICAgICAgIGNhcHR1cmU6IGZhbHNlIC8vIOS4jei/m+ihjOaLvuWPllxuXG4gICAgICB9KTtcbiAgICAgIHNlbGYuc2V0KCdtYXJrZXJHcm91cCcsIG1hcmtlckdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyR3JvdXAuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBVdGlsLmVhY2gobWFya2VySXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBtYXJrZXJHcm91cC5hZGRTaGFwZSgnbWFya2VyJywge1xuICAgICAgICBjb2xvcjogaXRlbS5jb2xvcixcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICBmaWxsOiBpdGVtLmNvbG9yLFxuICAgICAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICAgICAgc2hhZG93Q29sb3I6IGl0ZW0uY29sb3JcbiAgICAgICAgfSwgbWFya2VyQ2ZnLCB7XG4gICAgICAgICAgeDogaXRlbS54LFxuICAgICAgICAgIHk6IGl0ZW0ueVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXQoJ21hcmtlckl0ZW1zJywgbWFya2VySXRlbXMpO1xuICB9LFxuICBjbGVhck1hcmtlcnM6IGZ1bmN0aW9uIGNsZWFyTWFya2VycygpIHtcbiAgICB2YXIgbWFya2VyR3JvdXAgPSB0aGlzLmdldCgnbWFya2VyR3JvdXAnKTtcbiAgICBtYXJrZXJHcm91cCAmJiBtYXJrZXJHcm91cC5jbGVhcigpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNYXJrZXJHcm91cE1peGluO1xuXG4vKioqLyB9KSxcbi8qIDE2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbnZhciBHID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBDcm9zc2hhaXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MCk7XG5cbnZhciBNYXJrZXJHcm91cE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjIpO1xuXG52YXIgUG9zaXRpb25NaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYxKTtcblxudmFyIFRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZO1xuXG52YXIgRG9tVXRpbCA9IFV0aWwuRG9tVXRpbDtcbnZhciBNYXRyaXhVdGlsID0gVXRpbC5NYXRyaXhVdGlsO1xuXG52YXIgQ2FudmFzVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Rvb2x0aXApIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2FudmFzVG9vbHRpcCwgX1Rvb2x0aXApO1xuXG4gIHZhciBfcHJvdG8gPSBDYW52YXNUb29sdGlwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Ub29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgKiDpu5jorqTog4zmma/mnb/moLflvI9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGJvYXJkU3R5bGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICAgIGZpbGw6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknLFxuICAgICAgICByYWRpdXM6IDQsXG4gICAgICAgIHN0cm9rZTogJyNlMmUyZTInLFxuICAgICAgICBsaW5lV2lkdGg6IDFcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kdGl0bGXmoLflvI9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHRpdGxlU3R5bGU6IHtcbiAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFksXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZpbGw6ICdyZ2IoODcsIDg3LCA4NyknLFxuICAgICAgICBsaW5lSGVpZ2h0OiAyMCxcbiAgICAgICAgcGFkZGluZzogMjBcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kbWFya2Vy5qC35byPXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBtYXJrZXJTdHlsZToge1xuICAgICAgICByYWRpdXM6IDRcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kbmFtZeagt+W8j1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgbmFtZVN0eWxlOiB7XG4gICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZpbGw6ICdyZ2IoODcsIDg3LCA4NyknLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgICAgIHBhZGRpbmc6IDhcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kdmFsdWXmoLflvI9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHZhbHVlU3R5bGU6IHtcbiAgICAgICAgZm9udEZhbWlseTogRk9OVF9GQU1JTFksXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZmlsbDogJ3JnYig4NywgODcsIDg3KScsXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgcGFkZGluZzogMzBcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kcGFkZGluZ+WAvFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogMjAsXG4gICAgICAgIGxlZnQ6IDIwXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOm7mOiupGl0ZW3kuYvpl7TnmoRnYXBcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0ZW1HYXA6IDEwLFxuXG4gICAgICAvKipcbiAgICAgICAqIOm7mOiupHRvb2x0aXDkvY3nva7np7vliqjliqjnlLvnmoTml7bplb9cbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAyMDBcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBDYW52YXNUb29sdGlwKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1Rvb2x0aXAuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFBvc2l0aW9uTWl4aW4pO1xuICAgIFV0aWwuYXNzaWduKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBNYXJrZXJHcm91cE1peGluKTsgLy8gY3Jvc3NoYWlyXG5cbiAgICB2YXIgY3Jvc3NoYWlyID0gX3RoaXMuZ2V0KCdjcm9zc2hhaXJzJyk7XG5cbiAgICBpZiAoY3Jvc3NoYWlyKSB7XG4gICAgICB2YXIgcGxvdCA9IGNyb3NzaGFpci50eXBlID09PSAncmVjdCcgPyBfdGhpcy5nZXQoJ2JhY2tQbG90JykgOiBfdGhpcy5nZXQoJ2Zyb250UGxvdCcpO1xuICAgICAgdmFyIGNyb3NzaGFpckdyb3VwID0gbmV3IENyb3NzaGFpcihVdGlsLm1peCh7XG4gICAgICAgIHBsb3Q6IHBsb3QsXG4gICAgICAgIHBsb3RSYW5nZTogX3RoaXMuZ2V0KCdwbG90UmFuZ2UnKSxcbiAgICAgICAgY2FudmFzOiBfdGhpcy5nZXQoJ2NhbnZhcycpXG4gICAgICB9LCBfdGhpcy5nZXQoJ2Nyb3NzaGFpcnMnKSkpO1xuICAgICAgY3Jvc3NoYWlyR3JvdXAuaGlkZSgpO1xuXG4gICAgICBfdGhpcy5zZXQoJ2Nyb3NzaGFpckdyb3VwJywgY3Jvc3NoYWlyR3JvdXApO1xuICAgIH1cblxuICAgIF90aGlzLl9pbml0XygpO1xuXG4gICAgaWYgKF90aGlzLmdldCgnaXRlbXMnKSkge1xuICAgICAgX3RoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLl9pbml0XyA9IGZ1bmN0aW9uIF9pbml0XygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhZGRpbmcgPSBzZWxmLmdldCgncGFkZGluZycpO1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLmdldCgnZnJvbnRQbG90Jyk7IC8vIG1hcmtlciBncm91cFxuXG4gICAgdmFyIG1hcmtlckdyb3VwID0gcGFyZW50LmFkZEdyb3VwKHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgc2VsZi5zZXQoJ21hcmtlckdyb3VwJywgbWFya2VyR3JvdXApOyAvLyBjb250YWluZXJcblxuICAgIHZhciBjb250YWluZXIgPSBwYXJlbnQuYWRkR3JvdXAoKTtcbiAgICBjb250YWluZXIuaGlkZSgpO1xuICAgIHNlbGYuc2V0KCdjb250YWluZXInLCBjb250YWluZXIpOyAvLyBib2FyZFxuXG4gICAgdmFyIGJvYXJkID0gY29udGFpbmVyLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHt9LCBzZWxmLmdldCgnYm9hcmRTdHlsZScpKVxuICAgIH0pO1xuICAgIHNlbGYuc2V0KCdib2FyZCcsIGJvYXJkKTsgLy8gdGl0bGVcblxuICAgIHZhciB0aXRsZVN0eWxlID0gc2VsZi5nZXQoJ3RpdGxlU3R5bGUnKTtcblxuICAgIGlmIChzZWxmLmdldCgnc2hvd1RpdGxlJykpIHtcbiAgICAgIHZhciB0aXRsZVNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgICAgICB5OiBwYWRkaW5nLnRvcFxuICAgICAgICB9LCB0aXRsZVN0eWxlKVxuICAgICAgfSk7XG4gICAgICBzZWxmLnNldCgndGl0bGVTaGFwZScsIHRpdGxlU2hhcGUpO1xuICAgICAgdGl0bGVTaGFwZS5uYW1lID0gJ3Rvb2x0aXAtdGl0bGUnO1xuICAgIH0gLy8gaXRlbXNcblxuXG4gICAgdmFyIGl0ZW1zR3JvdXAgPSBjb250YWluZXIuYWRkR3JvdXAoKTtcbiAgICBpdGVtc0dyb3VwLm1vdmUocGFkZGluZy5sZWZ0LCBwYWRkaW5nLnRvcCArIHRpdGxlU3R5bGUubGluZUhlaWdodCArIHRpdGxlU3R5bGUucGFkZGluZyk7XG4gICAgc2VsZi5zZXQoJ2l0ZW1zR3JvdXAnLCBpdGVtc0dyb3VwKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNsZWFyKCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgYm9hcmQgPSBzZWxmLmdldCgnYm9hcmQnKTtcbiAgICB2YXIgc2hvd1RpdGxlID0gc2VsZi5nZXQoJ3Nob3dUaXRsZScpO1xuICAgIHZhciB0aXRsZUNvbnRlbnQgPSBzZWxmLmdldCgndGl0bGVDb250ZW50Jyk7XG4gICAgdmFyIHRpdGxlU2hhcGUgPSB0aGlzLmdldCgndGl0bGVTaGFwZScpO1xuICAgIHZhciBpdGVtc0dyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKTtcbiAgICB2YXIgaXRlbXMgPSBzZWxmLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgcGFkZGluZyA9IHNlbGYuZ2V0KCdwYWRkaW5nJyk7XG5cbiAgICBpZiAodGl0bGVTaGFwZSAmJiBzaG93VGl0bGUpIHtcbiAgICAgIHRpdGxlU2hhcGUuYXR0cigndGV4dCcsIHRpdGxlQ29udGVudCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zR3JvdXApIHtcbiAgICAgIHZhciBpdGVtR2FwID0gc2VsZi5nZXQoJ2l0ZW1HYXAnKTtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGl0ZW1Hcm91cCA9IHNlbGYuX2FkZEl0ZW0oaXRlbSk7XG5cbiAgICAgICAgaXRlbUdyb3VwLm1vdmUoeCwgeSk7XG4gICAgICAgIGl0ZW1zR3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gaXRlbUdyb3VwLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIHkgKz0gaXRlbUhlaWdodCArIGl0ZW1HYXA7XG4gICAgICB9KTtcbiAgICB9IC8vIHVwZGF0ZSBib2FyZCBiYXNlZCBvbiBiYm94XG5cblxuICAgIHZhciBiYm94ID0gY29udGFpbmVyLmdldEJCb3goKTtcbiAgICB2YXIgd2lkdGggPSBiYm94LndpZHRoICsgcGFkZGluZy5yaWdodDtcbiAgICB2YXIgaGVpZ2h0ID0gYmJveC5oZWlnaHQgKyBwYWRkaW5nLmJvdHRvbTtcbiAgICBib2FyZC5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgICBib2FyZC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpOyAvLyBhbGlnbiB2YWx1ZSB0ZXh0IHRvIHJpZ2h0XG5cbiAgICBzZWxmLl9hbGlnblRvUmlnaHQod2lkdGgpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciB0aXRsZVNoYXBlID0gdGhpcy5nZXQoJ3RpdGxlU2hhcGUnKTtcbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIGJvYXJkID0gdGhpcy5nZXQoJ2JvYXJkJyk7XG4gICAgdGl0bGVTaGFwZS50ZXh0ID0gJyc7XG4gICAgaXRlbXNHcm91cC5jbGVhcigpO1xuICAgIGJvYXJkLmF0dHIoJ3dpZHRoJywgMCk7XG4gICAgYm9hcmQuYXR0cignaGVpZ2h0JywgMCk7XG4gIH07XG5cbiAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgY29udGFpbmVyLnNob3coKTtcbiAgICB2YXIgY3Jvc3NoYWlyR3JvdXAgPSB0aGlzLmdldCgnY3Jvc3NoYWlyR3JvdXAnKTtcbiAgICBjcm9zc2hhaXJHcm91cCAmJiBjcm9zc2hhaXJHcm91cC5zaG93KCk7XG4gICAgdmFyIG1hcmtlckdyb3VwID0gdGhpcy5nZXQoJ21hcmtlckdyb3VwJyk7XG4gICAgbWFya2VyR3JvdXAgJiYgbWFya2VyR3JvdXAuc2hvdygpO1xuXG4gICAgX1Rvb2x0aXAucHJvdG90eXBlLnNob3cuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuZ2V0KCdjYW52YXMnKS5kcmF3KCk7XG4gIH07XG5cbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgY29udGFpbmVyLmhpZGUoKTtcbiAgICB2YXIgY3Jvc3NoYWlyR3JvdXAgPSB0aGlzLmdldCgnY3Jvc3NoYWlyR3JvdXAnKTtcbiAgICBjcm9zc2hhaXJHcm91cCAmJiBjcm9zc2hhaXJHcm91cC5oaWRlKCk7XG4gICAgdmFyIG1hcmtlckdyb3VwID0gdGhpcy5nZXQoJ21hcmtlckdyb3VwJyk7XG4gICAgbWFya2VyR3JvdXAgJiYgbWFya2VyR3JvdXAuaGlkZSgpO1xuXG4gICAgX1Rvb2x0aXAucHJvdG90eXBlLmhpZGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuZ2V0KCdjYW52YXMnKS5kcmF3KCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgdmFyIGNyb3NzaGFpckdyb3VwID0gdGhpcy5nZXQoJ2Nyb3NzaGFpckdyb3VwJyk7XG4gICAgY3Jvc3NoYWlyR3JvdXAgJiYgY3Jvc3NoYWlyR3JvdXAuZGVzdHJveSgpO1xuICAgIHZhciBtYXJrZXJHcm91cCA9IHRoaXMuZ2V0KCdtYXJrZXJHcm91cCcpO1xuICAgIG1hcmtlckdyb3VwICYmIG1hcmtlckdyb3VwLnJlbW92ZSgpO1xuXG4gICAgX1Rvb2x0aXAucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5LCB0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBvdXR0ZXJOb2RlID0gdGhpcy5nZXQoJ2NhbnZhcycpLmdldCgnZWwnKTtcbiAgICB2YXIgdmlld1dpZHRoID0gRG9tVXRpbC5nZXRXaWR0aChvdXR0ZXJOb2RlKTtcbiAgICB2YXIgdmlld0hlaWdodCA9IERvbVV0aWwuZ2V0SGVpZ2h0KG91dHRlck5vZGUpO1xuICAgIHZhciBiYm94ID0gY29udGFpbmVyLmdldEJCb3goKTtcbiAgICB2YXIgY29udGFpbmVyV2lkdGggPSBiYm94LndpZHRoO1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBiYm94LmhlaWdodDtcbiAgICB2YXIgZW5keCA9IHg7XG4gICAgdmFyIGVuZHkgPSB5O1xuICAgIHZhciBwb3NpdGlvbjtcblxuICAgIGlmICh0aGlzLmdldCgncG9zaXRpb24nKSkge1xuICAgICAgdmFyIF9jb250YWluZXJXaWR0aCA9IGJib3gud2lkdGg7XG4gICAgICB2YXIgX2NvbnRhaW5lckhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjVG9vbHRpcFBvc2l0aW9uKHgsIHksIHRoaXMuZ2V0KCdwb3NpdGlvbicpLCBfY29udGFpbmVyV2lkdGgsIF9jb250YWluZXJIZWlnaHQsIHRhcmdldCk7XG4gICAgICB4ID0gcG9zaXRpb25bMF07XG4gICAgICB5ID0gcG9zaXRpb25bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fY29uc3RyYWludFBvc2l0aW9uSW5Cb3VuZGFyeSh4LCB5LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgICAgeCA9IHBvc2l0aW9uWzBdO1xuICAgICAgeSA9IHBvc2l0aW9uWzFdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldCgnaW5QbG90JykpIHtcbiAgICAgIC8vIHRvb2x0aXAg5b+F6aG76ZmQ5Yi25Zyo57uY5Zu+5Yy65Z+f5YaFXG4gICAgICB2YXIgcGxvdFJhbmdlID0gdGhpcy5nZXQoJ3Bsb3RSYW5nZScpO1xuICAgICAgcG9zaXRpb24gPSB0aGlzLl9jb25zdHJhaW50UG9zaXRpb25JblBsb3QoeCwgeSwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgcGxvdFJhbmdlLCB0aGlzLmdldCgnZW50ZXJhYmxlJykpO1xuICAgICAgeCA9IHBvc2l0aW9uWzBdO1xuICAgICAgeSA9IHBvc2l0aW9uWzFdO1xuICAgIH1cblxuICAgIHZhciBtYXJrZXJJdGVtcyA9IHRoaXMuZ2V0KCdtYXJrZXJJdGVtcycpO1xuXG4gICAgaWYgKCFVdGlsLmlzRW1wdHkobWFya2VySXRlbXMpKSB7XG4gICAgICBlbmR4ID0gbWFya2VySXRlbXNbMF0ueDtcbiAgICAgIGVuZHkgPSBtYXJrZXJJdGVtc1swXS55O1xuICAgIH1cblxuICAgIHZhciB1bE1hdHJpeCA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICB2YXIgbWF0ID0gTWF0cml4VXRpbC50cmFuc2Zvcm0odWxNYXRyaXgsIFtbJ3QnLCB4LCB5XV0pO1xuICAgIGNvbnRhaW5lci5zdG9wQW5pbWF0ZSgpO1xuICAgIGNvbnRhaW5lci5hbmltYXRlKHtcbiAgICAgIG1hdHJpeDogbWF0XG4gICAgfSwgdGhpcy5nZXQoJ2FuaW1hdGlvbkR1cmF0aW9uJykpO1xuICAgIHZhciBjcm9zc2hhaXJHcm91cCA9IHRoaXMuZ2V0KCdjcm9zc2hhaXJHcm91cCcpO1xuXG4gICAgaWYgKGNyb3NzaGFpckdyb3VwKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICAgIGNyb3NzaGFpckdyb3VwLnNldFBvc2l0aW9uKGVuZHgsIGVuZHksIGl0ZW1zKTtcbiAgICB9XG5cbiAgICBfVG9vbHRpcC5wcm90b3R5cGUuc2V0UG9zaXRpb24uY2FsbCh0aGlzLCB4LCB5KTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZEl0ZW0gPSBmdW5jdGlvbiBfYWRkSXRlbShpdGVtKSB7XG4gICAgdmFyIGdyb3VwID0gbmV3IEcuR3JvdXAoKTtcbiAgICB2YXIgbWFya2VyUmFkaXVzID0gdGhpcy5nZXQoJ21hcmtlclN0eWxlJykucmFkaXVzOyAvLyBtYXJrZXJcblxuICAgIGlmIChpdGVtLm1hcmtlcikge1xuICAgICAgdmFyIG1hcmtlckF0dHJzID0gVXRpbC5taXgoe30sIGl0ZW0ubWFya2VyLCB7XG4gICAgICAgIHg6IGl0ZW0ubWFya2VyLnJhZGl1cyAvIDIsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuICAgICAgZ3JvdXAuYWRkU2hhcGUoJ21hcmtlcicsIHtcbiAgICAgICAgYXR0cnM6IG1hcmtlckF0dHJzXG4gICAgICB9KTtcbiAgICAgIG1hcmtlclJhZGl1cyA9IGl0ZW0ubWFya2VyLnJhZGl1cztcbiAgICB9IC8vIG5hbWVcblxuXG4gICAgdmFyIG5hbWVTdHlsZSA9IHRoaXMuZ2V0KCduYW1lU3R5bGUnKTtcbiAgICBncm91cC5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IG1hcmtlclJhZGl1cyArIG5hbWVTdHlsZS5wYWRkaW5nLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0ZXh0OiBpdGVtLm5hbWVcbiAgICAgIH0sIG5hbWVTdHlsZSlcbiAgICB9KTsgLy8gdmFsdWVcblxuICAgIHZhciB2YWx1ZVN0eWxlID0gdGhpcy5nZXQoJ3ZhbHVlU3R5bGUnKTtcbiAgICBncm91cC5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IGdyb3VwLmdldEJCb3goKS53aWR0aCArIHZhbHVlU3R5bGUucGFkZGluZyxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdGV4dDogaXRlbS52YWx1ZVxuICAgICAgfSwgdmFsdWVTdHlsZSlcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH07XG5cbiAgX3Byb3RvLl9hbGlnblRvUmlnaHQgPSBmdW5jdGlvbiBfYWxpZ25Ub1JpZ2h0KHdpZHRoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJyk7XG4gICAgdmFyIGdyb3VwcyA9IGl0ZW1zR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgIFV0aWwuZWFjaChncm91cHMsIGZ1bmN0aW9uIChnKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBnLmdldCgnY2hpbGRyZW4nKTtcbiAgICAgIHZhciB2YWx1ZVRleHQgPSBjaGlsZHJlblsyXTtcbiAgICAgIHZhciB3ID0gdmFsdWVUZXh0LmdldEJCb3goKS53aWR0aDtcbiAgICAgIHZhciB4ID0gd2lkdGggLSB3IC0gX3RoaXMyLmdldCgncGFkZGluZycpLnJpZ2h0ICogMjtcbiAgICAgIHZhbHVlVGV4dC5hdHRyKCd4JywgeCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1Rvb2x0aXA7XG59KFRvb2x0aXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1Rvb2x0aXA7XG5cbi8qKiovIH0pLFxuLyogMTY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTGFiZWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbnZhciBQYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBQb2xhckxhYmVscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0xhYmVscykge1xuICBfaW5oZXJpdHNMb29zZShQb2xhckxhYmVscywgX0xhYmVscyk7XG5cbiAgZnVuY3Rpb24gUG9sYXJMYWJlbHMoKSB7XG4gICAgcmV0dXJuIF9MYWJlbHMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvbGFyTGFiZWxzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UG9pbnRSYXVpcyA9IGZ1bmN0aW9uIGdldFBvaW50UmF1aXMoY29vcmQsIHBvaW50KSB7XG4gICAgcmV0dXJuIFBhdGhVdGlsLmdldFBvaW50UmFkaXVzKGNvb3JkLCBwb2ludCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENpcmNsZVBvaW50ID0gZnVuY3Rpb24gZ2V0Q2lyY2xlUG9pbnQoYW5nbGUsIG9mZnNldCwgcG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGNlbnRlciA9IGNvb3JkLmdldENlbnRlcigpO1xuXG4gICAgdmFyIGxhYmVsRW1pdCA9IHNlbGYuX2lzRW1pdExhYmVscygpO1xuXG4gICAgdmFyIHIgPSBzZWxmLmdldFBvaW50UmF1aXMoY29vcmQsIHBvaW50KTtcblxuICAgIGlmIChyID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkICYmIHIgPiBvZmZzZXQgJiYgIWxhYmVsRW1pdCkge1xuICAgICAgdmFyIGFwcGVuZEFuZ2xlID0gTWF0aC5hc2luKG9mZnNldCAvICgyICogcikpO1xuICAgICAgYW5nbGUgPSBhbmdsZSArIGFwcGVuZEFuZ2xlICogMjtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHIgKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlci54ICsgciAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgIHI6IHJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRBcmNQb2ludCA9IGZ1bmN0aW9uIGdldEFyY1BvaW50KHBvaW50LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3V0ZXJQb2ludDsgLy8g5ZyG5byn5LiK55qE5Lit54K5XG4gICAgLy8gdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDA7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHBvaW50LngpIHx8IFV0aWwuaXNBcnJheShwb2ludC55KSkge1xuICAgICAgb3V0ZXJQb2ludCA9IHtcbiAgICAgICAgeDogVXRpbC5pc0FycmF5KHBvaW50LngpID8gcG9pbnQueFtpbmRleF0gOiBwb2ludC54LFxuICAgICAgICB5OiBVdGlsLmlzQXJyYXkocG9pbnQueSkgPyBwb2ludC55W2luZGV4XSA6IHBvaW50LnlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dGVyUG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICBzZWxmLnRyYW5zTGFiZWxQb2ludChvdXRlclBvaW50KTtcbiAgICByZXR1cm4gb3V0ZXJQb2ludDtcbiAgfTsgLy8g6I635Y+W54K55omA5Zyo55qE6KeS5bqmXG5cblxuICBfcHJvdG8uZ2V0UG9pbnRBbmdsZSA9IGZ1bmN0aW9uIGdldFBvaW50QW5nbGUocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgcmV0dXJuIFBhdGhVdGlsLmdldFBvaW50QW5nbGUoY29vcmQsIHBvaW50KTtcbiAgfTsgLy8g6I635Y+W5Lit5b+D55qE5L2N572uXG5cblxuICBfcHJvdG8uZ2V0TWlkZGxlUG9pbnQgPSBmdW5jdGlvbiBnZXRNaWRkbGVQb2ludChwb2ludHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgbWlkZGxlUG9pbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICBtaWRkbGVQb2ludC54ICs9IHBvaW50Lng7XG4gICAgICBtaWRkbGVQb2ludC55ICs9IHBvaW50Lnk7XG4gICAgfSk7XG4gICAgbWlkZGxlUG9pbnQueCAvPSBjb3VudDtcbiAgICBtaWRkbGVQb2ludC55IC89IGNvdW50O1xuICAgIG1pZGRsZVBvaW50ID0gY29vcmQuY29udmVydChtaWRkbGVQb2ludCk7XG4gICAgcmV0dXJuIG1pZGRsZVBvaW50O1xuICB9OyAvLyDmmK/lkKblsYXkuK1cblxuXG4gIF9wcm90by5faXNUb01pZGRsZSA9IGZ1bmN0aW9uIF9pc1RvTWlkZGxlKHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50LngubGVuZ3RoID4gMjtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6I635Y+W5paH5pys55qE5L2N572u5L+h5oGvXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxhYmVsIGxhYmVsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IGluZGV4XG4gICAqIEByZXR1cm4ge09iamVjdH0gcG9pbnRcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0TGFiZWxQb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUG9pbnQobGFiZWwsIHBvaW50LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGV4dCA9IGxhYmVsLnRleHRbaW5kZXhdO1xuICAgIHZhciBmYWN0b3IgPSAxO1xuICAgIHZhciBhcmNQb2ludDtcblxuICAgIGlmIChzZWxmLl9pc1RvTWlkZGxlKHBvaW50KSkge1xuICAgICAgYXJjUG9pbnQgPSBzZWxmLmdldE1pZGRsZVBvaW50KHBvaW50LnBvaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gMSAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICBpbmRleCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGZhY3RvciA9IC0xO1xuICAgICAgfVxuXG4gICAgICBhcmNQb2ludCA9IHNlbGYuZ2V0QXJjUG9pbnQocG9pbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gc2VsZi5nZXREZWZhdWx0T2Zmc2V0KGxhYmVsKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgKiBmYWN0b3I7XG4gICAgdmFyIG1pZGRsZUFuZ2xlID0gc2VsZi5nZXRQb2ludEFuZ2xlKGFyY1BvaW50KTtcbiAgICB2YXIgbGFiZWxQb2ludCA9IHNlbGYuZ2V0Q2lyY2xlUG9pbnQobWlkZGxlQW5nbGUsIG9mZnNldCwgYXJjUG9pbnQpO1xuXG4gICAgaWYgKCFsYWJlbFBvaW50KSB7XG4gICAgICBsYWJlbFBvaW50ID0ge1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxQb2ludC50ZXh0ID0gdGV4dDtcbiAgICAgIGxhYmVsUG9pbnQuYW5nbGUgPSBtaWRkbGVBbmdsZTtcbiAgICAgIGxhYmVsUG9pbnQuY29sb3IgPSBwb2ludC5jb2xvcjtcbiAgICB9XG5cbiAgICBpZiAobGFiZWwuYXV0b1JvdGF0ZSB8fCB0eXBlb2YgbGFiZWwuYXV0b1JvdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciByb3RhdGUgPSBsYWJlbFBvaW50LnRleHRTdHlsZSA/IGxhYmVsUG9pbnQudGV4dFN0eWxlLnJvdGF0ZSA6IG51bGw7XG5cbiAgICAgIGlmICghcm90YXRlKSB7XG4gICAgICAgIHJvdGF0ZSA9IGxhYmVsUG9pbnQucm90YXRlIHx8IHNlbGYuZ2V0TGFiZWxSb3RhdGUobWlkZGxlQW5nbGUsIG9mZnNldCwgcG9pbnQpO1xuICAgICAgfVxuXG4gICAgICBsYWJlbFBvaW50LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgICB9XG5cbiAgICBsYWJlbFBvaW50LnN0YXJ0ID0ge1xuICAgICAgeDogYXJjUG9pbnQueCxcbiAgICAgIHk6IGFyY1BvaW50LnlcbiAgICB9O1xuICAgIHJldHVybiBsYWJlbFBvaW50O1xuICB9O1xuXG4gIF9wcm90by5faXNFbWl0TGFiZWxzID0gZnVuY3Rpb24gX2lzRW1pdExhYmVscygpIHtcbiAgICB2YXIgbGFiZWxzID0gdGhpcy5nZXQoJ2xhYmVsJyk7XG4gICAgcmV0dXJuIGxhYmVscy5sYWJlbEVtaXQ7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIOiOt+WPluaWh+acrOaXi+i9rOeahOaWueWQkVxuICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgYW5nbGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRMYWJlbFJvdGF0ZSA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRlKGFuZ2xlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByb3RhdGU7XG4gICAgcm90YXRlID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgIHJvdGF0ZSArPSA5MDtcblxuICAgIGlmIChzZWxmLl9pc0VtaXRMYWJlbHMoKSkge1xuICAgICAgcm90YXRlIC09IDkwO1xuICAgIH1cblxuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgIGlmIChyb3RhdGUgPiA5MCkge1xuICAgICAgICByb3RhdGUgPSByb3RhdGUgLSAxODA7XG4gICAgICB9IGVsc2UgaWYgKHJvdGF0ZSA8IC05MCkge1xuICAgICAgICByb3RhdGUgPSByb3RhdGUgKyAxODA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdGF0ZSAvIDE4MCAqIE1hdGguUEk7XG4gIH07IC8vIG92ZXJyaWRlXG5cblxuICBfcHJvdG8uZ2V0TGFiZWxBbGlnbiA9IGZ1bmN0aW9uIGdldExhYmVsQWxpZ24ocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGFsaWduO1xuXG4gICAgaWYgKHNlbGYuX2lzRW1pdExhYmVscygpKSB7XG4gICAgICBpZiAocG9pbnQuYW5nbGUgPD0gTWF0aC5QSSAvIDIgJiYgcG9pbnQuYW5nbGUgPiAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICBhbGlnbiA9ICdjZW50ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2VsZi5nZXREZWZhdWx0T2Zmc2V0KHBvaW50KTtcblxuICAgICAgaWYgKE1hdGguYWJzKHBvaW50LnggLSBjZW50ZXIueCkgPCAxKSB7XG4gICAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9IGVsc2UgaWYgKHBvaW50LmFuZ2xlID4gTWF0aC5QSSB8fCBwb2ludC5hbmdsZSA8PSAwKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfTtcblxuICByZXR1cm4gUG9sYXJMYWJlbHM7XG59KExhYmVscyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sYXJMYWJlbHM7XG5cbi8qKiovIH0pLFxuLyogMTY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTY2FsZTogX193ZWJwYWNrX3JlcXVpcmVfXygzNDEpLFxuICBDb29yZDogX193ZWJwYWNrX3JlcXVpcmVfXygzNDIpLFxuICBBeGlzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NyksXG4gIEd1aWRlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0OCksXG4gIExlZ2VuZDogX193ZWJwYWNrX3JlcXVpcmVfXygzNTEpLFxuICBUb29sdGlwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1MyksXG4gIEV2ZW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NClcbn07XG5cbi8qKiovIH0pLFxuLyogMTY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBHID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIG1lcmdlQkJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY3KTtcblxuZnVuY3Rpb24gYXBwbHlNYXRyaXgocG9pbnQsIG1hdHJpeCwgdGFnKSB7XG4gIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgIHRhZyA9IDE7XG4gIH1cblxuICB2YXIgdmVjdG9yID0gW3BvaW50LngsIHBvaW50LnksIHRhZ107XG4gIFV0aWwudmVjMy50cmFuc2Zvcm1NYXQzKHZlY3RvciwgdmVjdG9yLCBtYXRyaXgpO1xuICByZXR1cm4ge1xuICAgIHg6IHZlY3RvclswXSxcbiAgICB5OiB2ZWN0b3JbMV1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGl0bGVCQm94KHRpdGxlKSB7XG4gIHZhciBiYm94ID0gdGl0bGUuZ2V0QkJveCgpO1xuICB2YXIgbGVmdFRvcCA9IHtcbiAgICB4OiBiYm94Lm1pblgsXG4gICAgeTogYmJveC5taW5ZXG4gIH07XG4gIHZhciByaWdodEJvdHRvbSA9IHtcbiAgICB4OiBiYm94Lm1heFgsXG4gICAgeTogYmJveC5tYXhZXG4gIH07XG4gIHZhciBtYXRyaXggPSB0aXRsZS5hdHRyKCdtYXRyaXgnKTtcbiAgbGVmdFRvcCA9IGFwcGx5TWF0cml4KGxlZnRUb3AsIG1hdHJpeCk7XG4gIHJpZ2h0Qm90dG9tID0gYXBwbHlNYXRyaXgocmlnaHRCb3R0b20sIG1hdHJpeCk7XG4gIHJldHVybiB7XG4gICAgbWluWDogbGVmdFRvcC54LFxuICAgIG1pblk6IGxlZnRUb3AueSxcbiAgICBtYXhYOiByaWdodEJvdHRvbS54LFxuICAgIG1heFk6IHJpZ2h0Qm90dG9tLnlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBCQm94T2ZCYWNrUGxvdChiYWNrUGxvdCwgZGVmYXVsdEJCb3gpIHtcbiAgdmFyIGJib3ggPSBkZWZhdWx0QkJveDtcbiAgVXRpbC5lYWNoKGJhY2tQbG90LmdldCgnY2hpbGRyZW4nKSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEcuR3JvdXAgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEcuUGF0aCkge1xuICAgICAgYmJveCA9IG1lcmdlQkJveChiYm94LCBlbGVtZW50LmdldEJCb3goKSk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRy5UZXh0KSB7XG4gICAgICAvLyB0aXRsZVxuICAgICAgdmFyIGVsZW1lbnRCQm94ID0gZ2V0VGl0bGVCQm94KGVsZW1lbnQpO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoZWxlbWVudEJCb3gubWF4WCAtIGVsZW1lbnRCQm94Lm1pblgpO1xuICAgICAgdmFyIGR5ID0gTWF0aC5hYnMoZWxlbWVudEJCb3gubWF4WSAtIGVsZW1lbnRCQm94Lm1pblkpO1xuXG4gICAgICBpZiAoZHggPCBkeSkge1xuICAgICAgICBiYm94ID0gbWVyZ2VCQm94KGJib3gsIFV0aWwubWl4KGJib3gsIHtcbiAgICAgICAgICBtaW5YOiBiYm94Lm1pblggLSBkeCxcbiAgICAgICAgICBtYXhYOiBiYm94Lm1heFggKyBkeFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYm94ID0gbWVyZ2VCQm94KGJib3gsIFV0aWwubWl4KGJib3gsIHtcbiAgICAgICAgICBtaW5ZOiBiYm94Lm1pblkgLSBkeSxcbiAgICAgICAgICBtYXhZOiBiYm94Lm1heFkgKyBkeVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJib3g7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQkJveChib3gxLCBib3gyKSB7XG4gIHJldHVybiB7XG4gICAgbWluWDogTWF0aC5taW4oYm94MS5taW5YLCBib3gyLm1pblgpLFxuICAgIG1pblk6IE1hdGgubWluKGJveDEubWluWSwgYm94Mi5taW5ZKSxcbiAgICBtYXhYOiBNYXRoLm1heChib3gxLm1heFgsIGJveDIubWF4WCksXG4gICAgbWF4WTogTWF0aC5tYXgoYm94MS5tYXhZLCBib3gyLm1heFkpXG4gIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDE2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBsb3RSYW5nZTJCQm94KHBsb3RSYW5nZSkge1xuICByZXR1cm4ge1xuICAgIG1pblg6IHBsb3RSYW5nZS50bC54LFxuICAgIG1pblk6IHBsb3RSYW5nZS50bC55LFxuICAgIG1heFg6IHBsb3RSYW5nZS5ici54LFxuICAgIG1heFk6IHBsb3RSYW5nZS5ici55XG4gIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDE2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gVHJhbnNpdGlvbjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJiXCJdID0gdHJhbnNpdGlvbjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gbmV3SWQ7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX3NlbGVjdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19hdHRyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19hdHRyVHdlZW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX2RlbGF5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19kdXJhdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fZWFzZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fZmlsdGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19tZXJnZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3JlbW92ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX3NlbGVjdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX3NlbGVjdEFsbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX3NlbGVjdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX3N0eWxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fc3R5bGVUd2Vlbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3RleHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X190cmFuc2l0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fdHdlZW5fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYyKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX19bXCJzZWxlY3Rpb25cIl0pKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cbmZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX3NlbGVjdGlvbl9fW1wic2VsZWN0aW9uXCJdLnByb3RvdHlwZTtcblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX3NlbGVjdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBzZWxlY3RBbGw6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX3NlbGVjdEFsbF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBmaWx0ZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fZmlsdGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIG1lcmdlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX21lcmdlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHNlbGVjdGlvbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fc2VsZWN0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHRyYW5zaXRpb246IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX3RyYW5zaXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX29uX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIGF0dHI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fYXR0cl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBhdHRyVHdlZW46IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fYXR0clR3ZWVuX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHN0eWxlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19zdHlsZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBzdHlsZVR3ZWVuOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19zdHlsZVR3ZWVuX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHRleHQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX3RleHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgcmVtb3ZlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3JlbW92ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICB0d2VlbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fdHdlZW5fX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZGVsYXk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fZGVsYXlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZHVyYXRpb246IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fZHVyYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgZWFzZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19lYXNlX19bXCJhXCIgLyogZGVmYXVsdCAqL11cbn07XG5cbi8qKiovIH0pLFxuLyogMTcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX3RpbWVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5vd1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX3RpbWVyX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRpbWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcmNfdGltZXJfX1tcImNcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidGltZXJGbHVzaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX3RpbWVyX19bXCJkXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY190aW1lb3V0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0aW1lb3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfdGltZW91dF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfaW50ZXJ2YWxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkyKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludGVydmFsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfaW50ZXJ2YWxfX1tcImFcIl07IH0pO1xuXG5cblxuXG4vKioqLyB9KSxcbi8qIDE3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBEb21VdGlsID0gVXRpbC5Eb21VdGlsO1xudmFyIEVWRU5UX1RZUEVTID0gWydzdGFydCcsICdwcm9jZXNzJywgJ2VuZCcsICdyZXNldCddO1xuXG52YXIgSW50ZXJhY3Rpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gSW50ZXJhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRFdmVudDogJ21vdXNlZG93bicsXG4gICAgICBwcm9jZXNzRXZlbnQ6ICdtb3VzZW1vdmUnLFxuICAgICAgZW5kRXZlbnQ6ICdtb3VzZXVwJyxcbiAgICAgIHJlc2V0RXZlbnQ6ICdkYmxjbGljaydcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fc3RhcnQgPSBmdW5jdGlvbiBfc3RhcnQoZXYpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLnByZVN0YXJ0ICYmIG1lLnByZVN0YXJ0KGV2KTtcbiAgICBtZS5zdGFydChldik7XG4gICAgbWUub25TdGFydCAmJiBtZS5vblN0YXJ0KGV2KTtcbiAgfTtcblxuICBfcHJvdG8uX3Byb2Nlc3MgPSBmdW5jdGlvbiBfcHJvY2Vzcyhldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUucHJlUHJvY2VzcyAmJiBtZS5wcmVQcm9jZXNzKGV2KTtcbiAgICBtZS5wcm9jZXNzKGV2KTtcbiAgICBtZS5vblByb2Nlc3MgJiYgbWUub25Qcm9jZXNzKGV2KTtcbiAgfTtcblxuICBfcHJvdG8uX2VuZCA9IGZ1bmN0aW9uIF9lbmQoZXYpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLnByZUVuZCAmJiBtZS5wcmVFbmQoZXYpO1xuICAgIG1lLmVuZChldik7XG4gICAgbWUub25FbmQgJiYgbWUub25FbmQoZXYpO1xuICB9O1xuXG4gIF9wcm90by5fcmVzZXQgPSBmdW5jdGlvbiBfcmVzZXQoZXYpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLnByZVJlc2V0ICYmIG1lLnByZVJlc2V0KGV2KTtcbiAgICBtZS5yZXNldChldik7XG4gICAgbWUub25SZXNldCAmJiBtZS5vblJlc2V0KGV2KTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHsvLyBUT0RPIG92ZXJyaWRlXG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkgey8vIFRPRE8gb3ZlcnJpZGVcbiAgfTtcblxuICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKCkgey8vIFRPRE8gb3ZlcnJpZGVcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHsvLyBUT0RPIG92ZXJyaWRlXG4gIH07XG5cbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oY2ZnLCB2aWV3KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgZGVmYXVsdENmZyA9IG1lLmdldERlZmF1bHRDZmcoKTtcbiAgICBVdGlsLmFzc2lnbihtZSwgZGVmYXVsdENmZywgY2ZnKTtcbiAgICBtZS52aWV3ID0gbWUuY2hhcnQgPSB2aWV3O1xuICAgIG1lLmNhbnZhcyA9IHZpZXcuZ2V0KCdjYW52YXMnKTtcblxuICAgIG1lLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfcHJvdG8uX2JpbmRFdmVudHMgPSBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG4gICAgdmFyIGNhbnZhc0RPTSA9IGNhbnZhcy5nZXQoJ2NhbnZhc0RPTScpO1xuXG4gICAgbWUuX2NsZWFyRXZlbnRzKCk7XG5cbiAgICBVdGlsLmVhY2goRVZFTlRfVFlQRVMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgdWNUeXBlID0gVXRpbC51cHBlckZpcnN0KHR5cGUpO1xuICAgICAgbWVbXCJfb25cIiArIHVjVHlwZSArIFwiTGlzdGVuZXJcIl0gPSBEb21VdGlsLmFkZEV2ZW50TGlzdGVuZXIoY2FudmFzRE9NLCBtZVt0eXBlICsgXCJFdmVudFwiXSwgVXRpbC53cmFwQmVoYXZpb3IobWUsIFwiX1wiICsgdHlwZSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fY2xlYXJFdmVudHMgPSBmdW5jdGlvbiBfY2xlYXJFdmVudHMoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBVdGlsLmVhY2goRVZFTlRfVFlQRVMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJOYW1lID0gXCJfb25cIiArIFV0aWwudXBwZXJGaXJzdCh0eXBlKSArIFwiTGlzdGVuZXJcIjtcbiAgICAgIG1lW2xpc3RlbmVyTmFtZV0gJiYgbWVbbGlzdGVuZXJOYW1lXS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcbiAgfTtcblxuICByZXR1cm4gSW50ZXJhY3Rpb247XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb247XG5cbi8qKiovIH0pLFxuLyogMTcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTY2FsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG52YXIgRyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgQW5pbWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcblxudmFyIENoYXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEcyID0ge1xuICAvLyB2ZXJzaW9uXG4gIHZlcnNpb246IEdsb2JhbC52ZXJzaW9uLFxuICAvLyB2aXN1YWwgZW5jb2RpbmdcbiAgQW5pbWF0ZTogQW5pbWF0ZSxcbiAgQ2hhcnQ6IENoYXJ0LFxuICBHbG9iYWw6IEdsb2JhbCxcbiAgU2NhbGU6IFNjYWxlLFxuICBTaGFwZTogU2hhcGUsXG4gIFV0aWw6IFV0aWwsXG4gIC8vIHJlbmRlciBlbmdpbmVcbiAgRzogRyxcbiAgRG9tVXRpbDogVXRpbC5Eb21VdGlsLFxuICBNYXRyaXhVdGlsOiBVdGlsLk1hdHJpeFV0aWwsXG4gIFBhdGhVdGlsOiBVdGlsLlBhdGhVdGlsXG59OyAvLyBHMi50cmFjayA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuLy8gICBHbG9iYWwudHJhY2thYmxlID0gZW5hYmxlO1xuLy8gfTtcbi8vIHJlcXVpcmUoJy4vdHJhY2snKTtcblxuRzIudHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybignRzIgdHJhY2tzIG5vdGhpbmcgOy0pJyk7XG59OyAvLyDkv53or4HkuKTkuKrniYjmnKzlhbHlrZhcblxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHdpbmRvdy5HMikge1xuICAgIGNvbnNvbGUud2FybihcIlRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBHMi4gVmVyc2lvbiBcIiArIEcyLnZlcnNpb24gKyBcIidzIHJlZmVyZW5jZSBpcyAnd2luZG93LkcyXzMnXCIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5HMiA9IEcyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRzI7XG5cbi8qKiovIH0pLFxuLyogMTczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX2xpbmVhcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTMpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUxpbmVhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX2xpbmVhcl9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfcXVhZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTQpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZVF1YWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY19xdWFkX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VRdWFkSW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY19xdWFkX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VRdWFkT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfcXVhZF9fW1wiY1wiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlUXVhZEluT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zcmNfcXVhZF9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfY3ViaWNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTk1KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VDdWJpY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc3JjX2N1YmljX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VDdWJpY0luXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfY3ViaWNfX1tcImFcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUN1YmljT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zcmNfY3ViaWNfX1tcImNcIl07IH0pO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUN1YmljSW5PdXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NyY19jdWJpY19fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zcmNfcG9seV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTYpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZVBvbHlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3NyY19wb2x5X19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VQb2x5SW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3NyY19wb2x5X19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VQb2x5T3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zcmNfcG9seV9fW1wiY1wiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlUG9seUluT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zcmNfcG9seV9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19zcmNfc2luX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5Nyk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlU2luXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19zcmNfc2luX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VTaW5JblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fc3JjX3Npbl9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlU2luT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19zcmNfc2luX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VTaW5Jbk91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fc3JjX3Npbl9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19zcmNfZXhwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5OCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlRXhwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19zcmNfZXhwX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VFeHBJblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fc3JjX2V4cF9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlRXhwT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19zcmNfZXhwX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VFeHBJbk91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fc3JjX2V4cF9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19zcmNfY2lyY2xlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5OSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlQ2lyY2xlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19zcmNfY2lyY2xlX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VDaXJjbGVJblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fc3JjX2NpcmNsZV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlQ2lyY2xlT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19zcmNfY2lyY2xlX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VDaXJjbGVJbk91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fc3JjX2NpcmNsZV9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19zcmNfYm91bmNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMCk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlQm91bmNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19zcmNfYm91bmNlX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VCb3VuY2VJblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fc3JjX2JvdW5jZV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlQm91bmNlT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19zcmNfYm91bmNlX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VCb3VuY2VJbk91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fc3JjX2JvdW5jZV9fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19zcmNfYmFja19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUJhY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3NyY19iYWNrX19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VCYWNrSW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX3NyY19iYWNrX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VCYWNrT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19zcmNfYmFja19fW1wiY1wiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlQmFja0luT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19zcmNfYmFja19fW1wiYlwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19zcmNfZWxhc3RpY19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUVsYXN0aWNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3NyY19lbGFzdGljX19bXCJjXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VFbGFzdGljSW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX3NyY19lbGFzdGljX19bXCJhXCJdOyB9KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VFbGFzdGljT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19zcmNfZWxhc3RpY19fW1wiY1wiXTsgfSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlRWxhc3RpY0luT3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19zcmNfZWxhc3RpY19fW1wiYlwiXTsgfSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqKi8gfSksXG4vKiAxNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOiHquWKqOiuoeeul+aVsOWtl+WdkOagh+i9tFxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBBdXRvVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG52YXIgTUlOX0NPVU5UID0gNTtcbnZhciBNQVhfQ09VTlQgPSA3O1xudmFyIFNOQVBfQ09VTlRfQVJSQVkgPSBbMCwgMSwgMS4yLCAxLjUsIDEuNiwgMiwgMi4yLCAyLjQsIDIuNSwgMywgNCwgNSwgNiwgNy41LCA4LCAxMF07XG52YXIgU05BUF9BUlJBWSA9IFswLCAxLCAyLCA0LCA1LCAxMF07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgdmFyIG1pbiA9IGluZm8ubWluO1xuICB2YXIgbWF4ID0gaW5mby5tYXg7XG4gIHZhciBpbnRlcnZhbCA9IGluZm8uaW50ZXJ2YWw7XG4gIHZhciBtaW5UaWNrSW50ZXJ2YWwgPSBpbmZvLm1pblRpY2tJbnRlcnZhbDtcbiAgdmFyIHRpY2tzID0gW107XG4gIHZhciBtaW5Db3VudCA9IGluZm8ubWluQ291bnQgfHwgTUlOX0NPVU5UO1xuICB2YXIgbWF4Q291bnQgPSBpbmZvLm1heENvdW50IHx8IE1BWF9DT1VOVDtcbiAgdmFyIGlzRml4ZWRDb3VudCA9IG1pbkNvdW50ID09PSBtYXhDb3VudDsgLy8g5piv5ZCm6ZmQ5a6a5q275LqG5Liq5pWwXG5cbiAgdmFyIG1pbkxpbWl0ID0gaXNOaWwoaW5mby5taW5MaW1pdCkgPyAtSW5maW5pdHkgOiBpbmZvLm1pbkxpbWl0OyAvLyDpmZDlrprnmoTmnIDlsI/lgLxcblxuICB2YXIgbWF4TGltaXQgPSBpc05pbChpbmZvLm1heExpbWl0KSA/IEluZmluaXR5IDogaW5mby5tYXhMaW1pdDsgLy8g6ZmQ5a6a5pyA5aSn5YC8XG5cbiAgdmFyIGF2Z0NvdW50ID0gKG1pbkNvdW50ICsgbWF4Q291bnQpIC8gMjtcbiAgdmFyIGNvdW50ID0gYXZnQ291bnQ7IC8vIOeUqOaIt+S8oOWFpeeahOmAvOi/keaVsOe7hFxuXG4gIHZhciBzbmFwQXJyYXkgPSBpbmZvLnNuYXBBcnJheSA/IGluZm8uc25hcEFycmF5IDogaXNGaXhlZENvdW50ID8gU05BUF9DT1VOVF9BUlJBWSA6IFNOQVBfQVJSQVk7IC8vIOWmguaenOmZkOWumuWkp+Wwj+iMg+WbtO+8jOWQjOaXtuWkp+Wwj+iMg+WbtOetieS6jueUqOaIt+S8oOWFpeeahOiMg+WbtO+8jOWQjOaXtumZkOWumuS6huS4quaVsO+8jGludGVydmFsIOaMieeFp+S4quaVsOWdh+WIhlxuXG4gIGlmIChtaW4gPT09IG1pbkxpbWl0ICYmIG1heCA9PT0gbWF4TGltaXQgJiYgaXNGaXhlZENvdW50KSB7XG4gICAgaW50ZXJ2YWwgPSAobWF4IC0gbWluKSAvIChjb3VudCAtIDEpO1xuICB9XG5cbiAgaWYgKGlzTmlsKG1pbikpIHtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgaWYgKGlzTmlsKG1heCkpIHtcbiAgICBtYXggPSAwO1xuICB9XG5cbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgaWYgKG1pbiA9PT0gMCkge1xuICAgICAgbWF4ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heCAtIG1pbiA8IDUgJiYgIWludGVydmFsICYmIG1heCAtIG1pbiA+PSAxKSB7XG4gICAgICBpbnRlcnZhbCA9IDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmlsKGludGVydmFsKSkge1xuICAgIC8vIOiuoeeul+mXtOi3nVxuICAgIHZhciB0ZW1wID0gKG1heCAtIG1pbikgLyAoYXZnQ291bnQgLSAxKTtcbiAgICBpbnRlcnZhbCA9IEF1dG9VdGlsLnNuYXBGYWN0b3JUbyh0ZW1wLCBzbmFwQXJyYXksICdjZWlsJyk7XG5cbiAgICBpZiAobWF4Q291bnQgIT09IG1pbkNvdW50KSB7XG4gICAgICBjb3VudCA9IHBhcnNlSW50KChtYXggLSBtaW4pIC8gaW50ZXJ2YWwsIDEwKTtcblxuICAgICAgaWYgKGNvdW50ID4gbWF4Q291bnQpIHtcbiAgICAgICAgY291bnQgPSBtYXhDb3VudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgY291bnQgPSBtaW5Db3VudDtcbiAgICAgIH0gLy8g5LiN56Gu5a6adGlja+eahOS4quaVsOaXtu+8jOS9v+W+l3RpY2vlgY/lsI9cblxuXG4gICAgICBpbnRlcnZhbCA9IEF1dG9VdGlsLnNuYXBGYWN0b3JUbygobWF4IC0gbWluKSAvIChjb3VudCAtIDEpLCBzbmFwQXJyYXksICdmbG9vcicpO1xuICAgIH1cbiAgfSAvLyBpbnRlcnZhbCBzaG91bGQgbm90IGJlIGxlc3MgdGhhbiBtaW5UaWNrSW50ZXJ2YWxcblxuXG4gIGlmIChpc051bWJlcihtaW5UaWNrSW50ZXJ2YWwpICYmIGludGVydmFsIDwgbWluVGlja0ludGVydmFsKSB7XG4gICAgaW50ZXJ2YWwgPSBtaW5UaWNrSW50ZXJ2YWw7XG4gIH1cblxuICBpZiAoaW5mby5pbnRlcnZhbCB8fCBtYXhDb3VudCAhPT0gbWluQ291bnQpIHtcbiAgICAvLyDmoKHmraMgbWF4IOWSjCBtaW5cbiAgICBtYXggPSBNYXRoLm1pbihBdXRvVXRpbC5zbmFwTXVsdGlwbGUobWF4LCBpbnRlcnZhbCwgJ2NlaWwnKSwgbWF4TGltaXQpOyAvLyDlkJHkuIrpgLzov5FcblxuICAgIG1pbiA9IE1hdGgubWF4KEF1dG9VdGlsLnNuYXBNdWx0aXBsZShtaW4sIGludGVydmFsLCAnZmxvb3InKSwgbWluTGltaXQpOyAvLyDlkJHkuIvpgLzov5FcblxuICAgIGNvdW50ID0gTWF0aC5yb3VuZCgobWF4IC0gbWluKSAvIGludGVydmFsKTtcbiAgICBtaW4gPSBBdXRvVXRpbC5maXhlZEJhc2UobWluLCBpbnRlcnZhbCk7XG4gICAgbWF4ID0gQXV0b1V0aWwuZml4ZWRCYXNlKG1heCwgaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGF2Z0NvdW50ID0gcGFyc2VJbnQoYXZnQ291bnQsIDEwKTsgLy8g5Y+W5pW0XG5cbiAgICB2YXIgYXZnID0gKG1heCArIG1pbikgLyAyO1xuICAgIHZhciBhdmdUaWNrID0gQXV0b1V0aWwuc25hcE11bHRpcGxlKGF2ZywgaW50ZXJ2YWwsICdjZWlsJyk7XG4gICAgdmFyIHNpZGVDb3VudCA9IE1hdGguZmxvb3IoKGF2Z0NvdW50IC0gMikgLyAyKTtcbiAgICB2YXIgbWF4VGljayA9IGF2Z1RpY2sgKyBzaWRlQ291bnQgKiBpbnRlcnZhbDtcbiAgICB2YXIgbWluVGljaztcblxuICAgIGlmIChhdmdDb3VudCAlIDIgPT09IDApIHtcbiAgICAgIG1pblRpY2sgPSBhdmdUaWNrIC0gc2lkZUNvdW50ICogaW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblRpY2sgPSBhdmdUaWNrIC0gKHNpZGVDb3VudCArIDEpICogaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgaWYgKG1heFRpY2sgPCBtYXgpIHtcbiAgICAgIG1heFRpY2sgPSBtYXhUaWNrICsgaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgaWYgKG1pblRpY2sgPiBtaW4pIHtcbiAgICAgIG1pblRpY2sgPSBtaW5UaWNrIC0gaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgbWF4ID0gQXV0b1V0aWwuZml4ZWRCYXNlKG1heFRpY2ssIGludGVydmFsKTtcbiAgICBtaW4gPSBBdXRvVXRpbC5maXhlZEJhc2UobWluVGljaywgaW50ZXJ2YWwpO1xuICB9XG5cbiAgbWF4ID0gTWF0aC5taW4obWF4LCBtYXhMaW1pdCk7XG4gIG1pbiA9IE1hdGgubWF4KG1pbiwgbWluTGltaXQpO1xuICB0aWNrcy5wdXNoKG1pbik7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgdmFyIHRpY2tWYWx1ZSA9IEF1dG9VdGlsLmZpeGVkQmFzZShpbnRlcnZhbCAqIGkgKyBtaW4sIGludGVydmFsKTtcblxuICAgIGlmICh0aWNrVmFsdWUgPCBtYXgpIHtcbiAgICAgIHRpY2tzLnB1c2godGlja1ZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGlja3NbdGlja3MubGVuZ3RoIC0gMV0gPCBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKG1heCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIGludGVydmFsOiBpbnRlcnZhbCxcbiAgICBjb3VudDogY291bnQsXG4gICAgdGlja3M6IHRpY2tzXG4gIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDE3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBJZGVudGl0eSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoSWRlbnRpdHksIF9CYXNlKTtcblxuICBmdW5jdGlvbiBJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElkZW50aXR5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9CYXNlLnByb3RvdHlwZS5faW5pdERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuaXNJZGVudGl0eSA9IHRydWU7XG4gICAgdGhpcy50eXBlID0gJ2lkZW50aXR5JztcbiAgICAvKipcbiAgICAgKiDluLjph4/lgLxcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cblxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSAmJiBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yYW5nZVswXTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIElkZW50aXR5O1xufShCYXNlKTtcblxuQmFzZS5JZGVudGl0eSA9IElkZW50aXR5O1xubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eTtcblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBtZWFzdXJlbWVudCBvZiBsaW5lYXIgZGF0YSBzY2FsZSBmdW5jdGlvblxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cblxuXG52YXIgZmVjaGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIExpbmVhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG52YXIgdGltZUF1dG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3Nyk7XG5cbnZhciBUaW1lVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuLyoqXG4gKiDml7bpl7Tluqbph4/nmoTmnoTpgKDlh73mlbBcbiAqIEBjbGFzcyBTY2FsZS5UaW1lXG4gKi9cblxuXG52YXIgVGltZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0xpbmVhcikge1xuICBfaW5oZXJpdHNMb29zZShUaW1lLCBfTGluZWFyKTtcblxuICBmdW5jdGlvbiBUaW1lKCkge1xuICAgIHJldHVybiBfTGluZWFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9MaW5lYXIucHJvdG90eXBlLl9pbml0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gJ3RpbWUnO1xuICAgIHRoaXMubWFzayA9ICdZWVlZLU1NLUREJztcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZhbHVlcyA9IHNlbGYudmFsdWVzO1xuXG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyDph43mlrDorqHnrpfmnIDlpKfmnIDlsI/lgLxcbiAgICAgIHZhciB0aW1lU3RhbXBzID0gW107XG4gICAgICB2YXIgbWluID0gSW5maW5pdHk7IC8vIOacgOWwj+WAvFxuXG4gICAgICB2YXIgc2Vjb25kTWluID0gbWluOyAvLyDmrKHlsI/lgLxcblxuICAgICAgdmFyIG1heCA9IDA7IC8vIOS9v+eUqOS4gOS4quW+queOr++8jOiuoeeul21pbixtYXgsc2Vjb25kTWluXG5cbiAgICAgIGVhY2godmFsdWVzLCBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgdGltZVN0YW1wID0gc2VsZi5fdG9UaW1lU3RhbXAodik7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRpbWVTdGFtcCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBUaW1lOiBcIiArIHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbiA+IHRpbWVTdGFtcCkge1xuICAgICAgICAgIHNlY29uZE1pbiA9IG1pbjtcbiAgICAgICAgICBtaW4gPSB0aW1lU3RhbXA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kTWluID4gdGltZVN0YW1wKSB7XG4gICAgICAgICAgc2Vjb25kTWluID0gdGltZVN0YW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCA8IHRpbWVTdGFtcCkge1xuICAgICAgICAgIG1heCA9IHRpbWVTdGFtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVTdGFtcHMucHVzaCh0aW1lU3RhbXApO1xuICAgICAgfSk7IC8vIOWtmOWcqOWkmuS4quWAvOaXtu+8jOiuvue9ruacgOWwj+mXtOi3nVxuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2VsZi5taW5UaWNrSW50ZXJ2YWwgPSBzZWNvbmRNaW4gLSBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05pbChzZWxmLm1pbikgfHwgc2VsZi5fdG9UaW1lU3RhbXAoc2VsZi5taW4pID4gbWluKSB7XG4gICAgICAgIHNlbGYubWluID0gbWluO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOaWwoc2VsZi5tYXgpIHx8IHNlbGYuX3RvVGltZVN0YW1wKHNlbGYubWF4KSA8IG1heCkge1xuICAgICAgICBzZWxmLm1heCA9IG1heDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfTGluZWFyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZVRpY2tzID0gZnVuY3Rpb24gY2FsY3VsYXRlVGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtaW4gPSBzZWxmLm1pbjtcbiAgICB2YXIgbWF4ID0gc2VsZi5tYXg7XG4gICAgdmFyIGNvdW50ID0gc2VsZi50aWNrQ291bnQ7XG4gICAgdmFyIGludGVydmFsID0gc2VsZi50aWNrSW50ZXJ2YWw7XG4gICAgdmFyIHRtcCA9IHRpbWVBdXRvKHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW5Db3VudDogY291bnQsXG4gICAgICBtYXhDb3VudDogY291bnQsXG4gICAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgICBtaW5JbnRlcnZhbDogc2VsZi5taW5UaWNrSW50ZXJ2YWxcbiAgICB9KTtcbiAgICByZXR1cm4gdG1wLnRpY2tzO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0KHZhbHVlKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZm9ybWF0dGVyO1xuICAgIHZhbHVlID0gdGhpcy50cmFuc2xhdGUodmFsdWUpO1xuICAgIHZhbHVlID0gZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IGZlY2hhLmZvcm1hdCh2YWx1ZSwgdGhpcy5tYXNrKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy50cmFuc2xhdGUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBfTGluZWFyLnByb3RvdHlwZS5zY2FsZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9UaW1lU3RhbXAodmFsdWUpO1xuICB9OyAvLyDlsIbml7bpl7TovazmjaLkuLrml7bpl7TmiLNcblxuXG4gIF9wcm90by5fdG9UaW1lU3RhbXAgPSBmdW5jdGlvbiBfdG9UaW1lU3RhbXAodmFsdWUpIHtcbiAgICByZXR1cm4gVGltZVV0aWwudG9UaW1lU3RhbXAodmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lO1xufShMaW5lYXIpO1xuXG5CYXNlLlRpbWUgPSBUaW1lO1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lO1xuXG4vKioqLyB9KSxcbi8qIDE3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg6K6h566X5pe26Ze05Z2Q5qCH6L20XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEF1dG9VdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBNQVhfQ09VTlQgPSA2O1xudmFyIFNOQVBfQVJSQVkgPSBbMSwgMiwgNCwgNiwgOCwgMTJdO1xudmFyIE1JTlVURV9NUyA9IDYwICogMTAwMDtcbnZhciBIT1VSX01TID0gMzYwMCAqIDEwMDA7XG52YXIgREFZX01TID0gMjQgKiAzNjAwICogMTAwMDtcblxuZnVuY3Rpb24gZ2V0WWVhcihkYXRlKSB7XG4gIHJldHVybiBuZXcgRGF0ZShkYXRlKS5nZXRGdWxsWWVhcigpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVZZWFyKHllYXIpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIDAsIDEpLmdldFRpbWUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9udGgoZGF0ZSkge1xuICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuZ2V0TW9udGgoKTtcbn1cblxuZnVuY3Rpb24gZGlmZk1vbnRoKG1pbiwgbWF4KSB7XG4gIHZhciBtaW5ZZWFyID0gZ2V0WWVhcihtaW4pO1xuICB2YXIgbWF4WWVhciA9IGdldFllYXIobWF4KTtcbiAgdmFyIG1pbk1vbnRoID0gZ2V0TW9udGgobWluKTtcbiAgdmFyIG1heE1vbnRoID0gZ2V0TW9udGgobWF4KTtcbiAgcmV0dXJuIChtYXhZZWFyIC0gbWluWWVhcikgKiAxMiArIChtYXhNb250aCAtIG1pbk1vbnRoKSAlIDEyO1xufVxuXG5mdW5jdGlvbiBjcmVhdE1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0VGltZSgpO1xufVxuXG5mdW5jdGlvbiBkaWZmRGF5KG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyBEQVlfTVMpO1xufVxuXG5mdW5jdGlvbiBkaWZmSG91cihtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gSE9VUl9NUyk7XG59XG5cbmZ1bmN0aW9uIGRpZmZNaW51cyhtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDYwICogMTAwMCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gIHZhciBtaW5JbnRlcnZhbCA9IGluZm8ubWluSW50ZXJ2YWw7XG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgbWluID0gaW5mby5taW47XG4gIHZhciBtYXggPSBpbmZvLm1heDtcbiAgdmFyIGludGVydmFsID0gaW5mby5pbnRlcnZhbDtcbiAgdmFyIGNvdW50OyAvLyDlpoLmnpzmnIDlpKflgLzlkozmnIDlsI/lgLznm7jnrYnvvIzliJnorr7nva7mnIDlpKflgLzlpKfkuo7mnIDlsI/lgLzkuIDlpKlcblxuICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICBtYXggPSBtaW4gKyBEQVlfTVM7XG4gIH0gLy8g6K6h566X6Ze06LedXG5cblxuICBpZiAoaXNOaWwoaW50ZXJ2YWwpKSB7XG4gICAgdmFyIGlubmVyVGltZSA9IG1heCAtIG1pbjtcbiAgICB2YXIgZG1zID0gREFZX01TOyAvLyDlpKnku6PooajnmoTnp5JcblxuICAgIHZhciB5bXMgPSAzNjUgKiBkbXM7IC8vIOW5tOS7o+ihqOeahOenklxuXG4gICAgaW50ZXJ2YWwgPSBwYXJzZUludChpbm5lclRpbWUgLyAoaW5mby5tYXhDb3VudCB8fCBNQVhfQ09VTlQpLCAxMCk7XG5cbiAgICBpZiAobWluSW50ZXJ2YWwgJiYgbWluSW50ZXJ2YWwgPiBpbnRlcnZhbCkge1xuICAgICAgaW50ZXJ2YWwgPSBtaW5JbnRlcnZhbDtcbiAgICB9XG5cbiAgICB2YXIgeWZhY3RvciA9IGludGVydmFsIC8geW1zO1xuICAgIHZhciBtaW5ZZWFyID0gZ2V0WWVhcihtaW4pOyAvLyDlpKfkuo7ljYrlubRcblxuICAgIGlmICh5ZmFjdG9yID4gMC41MSkge1xuICAgICAgdmFyIHllYXIgPSBNYXRoLmNlaWwoeWZhY3Rvcik7IC8vIGludGVydmFsID0geWVhciAqIHltcztcblxuICAgICAgdmFyIG1heFllYXIgPSBnZXRZZWFyKG1heCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBtaW5ZZWFyOyBpIDw9IG1heFllYXIgKyB5ZWFyOyBpID0gaSArIHllYXIpIHtcbiAgICAgICAgdGlja3MucHVzaChjcmVhdGVZZWFyKGkpKTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoeWZhY3RvciA+IDAuMDgzNCkge1xuICAgICAgLy8g5aSn5LqO5LiA5Liq5pyIXG4gICAgICB2YXIgbW9udGggPSBNYXRoLmNlaWwoeWZhY3RvciAvIDAuMDgzNCk7XG4gICAgICB2YXIgbW1Nb3RoID0gZ2V0TW9udGgobWluKTtcbiAgICAgIHZhciBkTW9udGhzID0gZGlmZk1vbnRoKG1pbiwgbWF4KTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8PSBkTW9udGhzICsgbW9udGg7IF9pID0gX2kgKyBtb250aCkge1xuICAgICAgICB0aWNrcy5wdXNoKGNyZWF0TW9udGgobWluWWVhciwgX2kgKyBtbU1vdGgpKTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiBkbXMgKiAwLjUpIHtcbiAgICAgIC8vIOWkp+S6juS4gOWkqVxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShtaW4pO1xuXG4gICAgICB2YXIgX3llYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgIHZhciBfbW9udGggPSBkYXRlLmdldE1vbnRoKG1pbik7XG5cbiAgICAgIHZhciBtZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICB2YXIgZGF5ID0gTWF0aC5jZWlsKGludGVydmFsIC8gZG1zKTtcbiAgICAgIHZhciBkZGF5cyA9IGRpZmZEYXkobWluLCBtYXgpO1xuICAgICAgaW50ZXJ2YWwgPSBkYXkgKiBkbXM7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGRkYXlzICsgZGF5OyBfaTIgPSBfaTIgKyBkYXkpIHtcbiAgICAgICAgdGlja3MucHVzaChuZXcgRGF0ZShfeWVhciwgX21vbnRoLCBtZGF5ICsgX2kyKS5nZXRUaW1lKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiBIT1VSX01TKSB7XG4gICAgICAvLyDlpKfkuo7kuIDkuKrlsI/ml7ZcbiAgICAgIHZhciBfZGF0ZSA9IG5ldyBEYXRlKG1pbik7XG5cbiAgICAgIHZhciBfeWVhcjIgPSBfZGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICB2YXIgX21vbnRoMiA9IF9kYXRlLmdldE1vbnRoKG1pbik7XG5cbiAgICAgIHZhciBfZGF5ID0gX2RhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICB2YXIgaG91ciA9IF9kYXRlLmdldEhvdXJzKCk7XG5cbiAgICAgIHZhciBob3VycyA9IEF1dG9VdGlsLnNuYXBUbyhTTkFQX0FSUkFZLCBNYXRoLmNlaWwoaW50ZXJ2YWwgLyBIT1VSX01TKSk7XG4gICAgICB2YXIgZEhvdXJzID0gZGlmZkhvdXIobWluLCBtYXgpO1xuICAgICAgaW50ZXJ2YWwgPSBob3VycyAqIEhPVVJfTVM7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8PSBkSG91cnMgKyBob3VyczsgX2kzID0gX2kzICsgaG91cnMpIHtcbiAgICAgICAgdGlja3MucHVzaChuZXcgRGF0ZShfeWVhcjIsIF9tb250aDIsIF9kYXksIGhvdXIgKyBfaTMpLmdldFRpbWUoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnRlcnZhbCA+IE1JTlVURV9NUykge1xuICAgICAgLy8g5pyA5bCP5Y2V5L2N5piv5YiG6ZKfXG4gICAgICB2YXIgZE1pbnVzID0gZGlmZk1pbnVzKG1pbiwgbWF4KTtcbiAgICAgIHZhciBtaW51dGVzID0gTWF0aC5jZWlsKGludGVydmFsIC8gTUlOVVRFX01TKTtcbiAgICAgIGludGVydmFsID0gbWludXRlcyAqIE1JTlVURV9NUztcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDw9IGRNaW51cyArIG1pbnV0ZXM7IF9pNCA9IF9pNCArIG1pbnV0ZXMpIHtcbiAgICAgICAgdGlja3MucHVzaChtaW4gKyBfaTQgKiBNSU5VVEVfTVMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPCAxMDAwKSB7XG4gICAgICAgIGludGVydmFsID0gMTAwMDtcbiAgICAgIH1cblxuICAgICAgbWluID0gTWF0aC5mbG9vcihtaW4gLyAxMDAwKSAqIDEwMDA7XG4gICAgICB2YXIgZFNlY29uZHMgPSBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAxMDAwKTtcbiAgICAgIHZhciBzZWNvbmRzID0gTWF0aC5jZWlsKGludGVydmFsIC8gMTAwMCk7XG4gICAgICBpbnRlcnZhbCA9IHNlY29uZHMgKiAxMDAwO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBkU2Vjb25kcyArIHNlY29uZHM7IF9pNSA9IF9pNSArIHNlY29uZHMpIHtcbiAgICAgICAgdGlja3MucHVzaChtaW4gKyBfaTUgKiAxMDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXRpY2tzLmxlbmd0aCkge1xuICAgIG1pbiA9IE1hdGguZmxvb3IobWluIC8gMTAwMCkgKiAxMDAwO1xuICAgIG1heCA9IE1hdGguY2VpbChtYXggLyAxMDAwKSAqIDEwMDA7XG4gICAgY291bnQgPSAobWF4IC0gbWluKSAvIGludGVydmFsO1xuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDw9IGNvdW50OyBfaTYrKykge1xuICAgICAgdGlja3MucHVzaChBdXRvVXRpbC5maXhlZEJhc2UoaW50ZXJ2YWwgKiBfaTYgKyBtaW4sIGludGVydmFsKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXg6IG1heCxcbiAgICBtaW46IG1pbixcbiAgICBpbnRlcnZhbDogaW50ZXJ2YWwsXG4gICAgdGlja3M6IHRpY2tzLFxuICAgIGNvdW50OiB0aWNrcy5sZW5ndGhcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cbi8qKlxuICogQGZpbGVPdmVydmlldyDml7bpl7TmlbDmja7kvZzkuLrliIbnsbvnsbvlnotcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG5cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIENhdGVnb3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG5cbnZhciBmZWNoYSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xuXG52YXIgY2F0QXV0byA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG52YXIgVGltZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaXNOdW1iZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKipcbiAqIOW6pumHj+eahOaehOmAoOWHveaVsFxuICogQGNsYXNzIFNjYWxlLlRpbWVDYXRlZ29yeVxuICovXG5cblxudmFyIFRpbWVDYXRlZ29yeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NhdGVnb3J5KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVDYXRlZ29yeSwgX0NhdGVnb3J5KTtcblxuICBmdW5jdGlvbiBUaW1lQ2F0ZWdvcnkoKSB7XG4gICAgcmV0dXJuIF9DYXRlZ29yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGltZUNhdGVnb3J5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9DYXRlZ29yeS5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSAndGltZUNhdCc7XG4gICAgLyoqXG4gICAgICog5piv5ZCm6ZyA6KaB5o6S5bqP77yM6buY6K6k6L+b6KGM5o6S5bqPXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnRpY2tDb3VudCA9IDU7XG4gICAgLyoqXG4gICAgICog5pe26Ze05qC85byP5YyWXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMubWFzayA9ICdZWVlZLU1NLUREJztcbiAgfTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlczsgLy8g6ZKI5a+55pe26Ze05YiG57G757G75Z6L77yM5Lya5bCG5pe26Ze057uf5LiA6L2s5o2i5Li65pe26Ze05oizXG5cbiAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHNlbGYuX3RvVGltZVN0YW1wKHYpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuc29ydGFibGUpIHtcbiAgICAgIC8vIOWFgeiuuOaOkuW6j1xuICAgICAgdmFsdWVzLnNvcnQoZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gdjEgLSB2MjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghc2VsZi50aWNrcykge1xuICAgICAgc2VsZi50aWNrcyA9IHRoaXMuY2FsY3VsYXRlVGlja3MoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiDorqHnrpcgdGlja3NcbiAgICogQHJldHVybiB7YXJyYXl9IOi/lOWbniB0aWNrcyDmlbDnu4RcbiAgICovXG5cblxuICBfcHJvdG8uY2FsY3VsYXRlVGlja3MgPSBmdW5jdGlvbiBjYWxjdWxhdGVUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvdW50ID0gc2VsZi50aWNrQ291bnQ7XG4gICAgdmFyIHRpY2tzO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB2YXIgdGVtcCA9IGNhdEF1dG8oe1xuICAgICAgICBtYXhDb3VudDogY291bnQsXG4gICAgICAgIGRhdGE6IHNlbGYudmFsdWVzLFxuICAgICAgICBpc1JvdW5kaW5nOiBzZWxmLmlzUm91bmRpbmdcbiAgICAgIH0pO1xuICAgICAgdGlja3MgPSB0ZW1wLnRpY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcyA9IHNlbGYudmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRoaXMuX3RvVGltZVN0YW1wKHZhbHVlKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGlmIChpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPCB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gTmFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSk7XG4gICAgdmFyIHBlcmNlbnQ7XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAxIHx8IGlzTmFOKGluZGV4KSkge1xuICAgICAgLy8gaXMgaW5kZXggaXMgTkFOIHNob3VsZCBub3QgYmUgc2V0IGFzIDBcbiAgICAgIHBlcmNlbnQgPSBpbmRleDtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHBlcmNlbnQgPSBpbmRleCAvICh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlTWluICsgcGVyY2VudCAqIChyYW5nZU1heCAtIHJhbmdlTWluKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXI7XG4gICAgcmVzdWx0ID0gcGFyc2VJbnQocmVzdWx0LCAxMCk7XG4gICAgcmVzdWx0ID0gZm9ybWF0dGVyID8gZm9ybWF0dGVyKHJlc3VsdCkgOiBmZWNoYS5mb3JtYXQocmVzdWx0LCB0aGlzLm1hc2spO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0VGlja3MgPSBmdW5jdGlvbiBnZXRUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRpY2tzID0gdGhpcy50aWNrcztcbiAgICB2YXIgcnN0ID0gW107XG4gICAgZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgIHZhciBvYmo7XG5cbiAgICAgIGlmIChpc09iamVjdCh0aWNrKSkge1xuICAgICAgICBvYmogPSB0aWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0ge1xuICAgICAgICAgIHRleHQ6IGlzU3RyaW5nKHRpY2spID8gdGljayA6IHNlbGYuZ2V0VGV4dCh0aWNrKSxcbiAgICAgICAgICB2YWx1ZTogc2VsZi5zY2FsZSh0aWNrKSxcbiAgICAgICAgICB0aWNrVmFsdWU6IHRpY2sgLy8g55So5LqO5Z2Q5qCH6L205LiK5paH5pys5Yqo55S75pe256Gu5a6a5YmN5ZCO5bin55qE5a+55bqU5YWz57O7XG5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcnN0LnB1c2gob2JqKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9OyAvLyDlsIbml7bpl7TovazmjaLkuLrml7bpl7TmiLNcblxuXG4gIF9wcm90by5fdG9UaW1lU3RhbXAgPSBmdW5jdGlvbiBfdG9UaW1lU3RhbXAodmFsdWUpIHtcbiAgICByZXR1cm4gVGltZVV0aWwudG9UaW1lU3RhbXAodmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lQ2F0ZWdvcnk7XG59KENhdGVnb3J5KTtcblxuQmFzZS5UaW1lQ2F0ID0gVGltZUNhdGVnb3J5O1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lQ2F0ZWdvcnk7XG5cbi8qKiovIH0pLFxuLyogMTc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cbi8qKlxuICogQGZpbGVPdmVydmlldyDkvb/nlKjluqbph4/vvIzov5vooYxsb2fovazmjaJcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG5cblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgTGluZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7IC8vIOiuoeeul2xvZ1xuXG5cbmZ1bmN0aW9uIGxvZyhhLCBiKSB7XG4gIGlmIChhID09PSAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gTWF0aC5sb2coYikgLyBNYXRoLmxvZyhhKTtcbn1cbi8qKlxuICog5bqm6YeP55qEbG9n6K6h566XXG4gKiBAY2xhc3MgU2NhbGUuTG9nXG4gKi9cblxuXG52YXIgTG9nID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTGluZWFyKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvZywgX0xpbmVhcik7XG5cbiAgZnVuY3Rpb24gTG9nKCkge1xuICAgIHJldHVybiBfTGluZWFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2cucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgX0xpbmVhci5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSAnbG9nJztcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBsb2cg55qE5Z2Q5qCH54K555qE5Liq5pWw5o6n5Yi25ZyoMTDkuKrku6XkuItcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy50aWNrQ291bnQgPSAxMDtcbiAgICAvKipcbiAgICAgKiDov5vooYxsb2forqHnrpfnmoTln7rmlbBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5iYXNlID0gMjsgLy8g5pyA5bCP55qEdGlja++8jOS7heWGhemDqOS9v+eUqFxuXG4gICAgdGhpcy5fbWluVGljayA9IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uY2FsY3VsYXRlVGlja3MgPSBmdW5jdGlvbiBjYWxjdWxhdGVUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJhc2UgPSBzZWxmLmJhc2U7XG4gICAgdmFyIG1pblRpY2s7XG5cbiAgICBpZiAoc2VsZi5taW4gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtaW5pbXVtIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8hJyk7XG4gICAgfVxuXG4gICAgdmFyIG1heFRpY2sgPSBsb2coYmFzZSwgc2VsZi5tYXgpO1xuXG4gICAgaWYgKHNlbGYubWluID4gMCkge1xuICAgICAgbWluVGljayA9IE1hdGguZmxvb3IobG9nKGJhc2UsIHNlbGYubWluKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBzZWxmLnZhbHVlcztcbiAgICAgIHZhciBwb3NpdGl2ZU1pbiA9IHNlbGYubWF4OyAvLyDmn6Xmib7lpKfkuo4w55qE56ys5LiA5Liq5YC8LCDlpoLmnpzpg73lsI/kuo4w77yM6buY6K6k5Li6MVxuXG4gICAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDAgJiYgdmFsdWUgPCBwb3NpdGl2ZU1pbikge1xuICAgICAgICAgIHBvc2l0aXZlTWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocG9zaXRpdmVNaW4gPT09IHNlbGYubWF4KSB7XG4gICAgICAgIHBvc2l0aXZlTWluID0gc2VsZi5tYXggLyBiYXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpdmVNaW4gPiAxKSB7XG4gICAgICAgIHBvc2l0aXZlTWluID0gMTtcbiAgICAgIH1cblxuICAgICAgbWluVGljayA9IE1hdGguZmxvb3IobG9nKGJhc2UsIHBvc2l0aXZlTWluKSk7XG4gICAgICBzZWxmLl9taW5UaWNrID0gbWluVGljaztcbiAgICAgIHNlbGYucG9zaXRpdmVNaW4gPSBwb3NpdGl2ZU1pbjtcbiAgICB9XG5cbiAgICB2YXIgY291bnQgPSBtYXhUaWNrIC0gbWluVGljaztcbiAgICB2YXIgdGlja0NvdW50ID0gc2VsZi50aWNrQ291bnQ7XG4gICAgdmFyIGF2ZyA9IE1hdGguY2VpbChjb3VudCAvIHRpY2tDb3VudCk7XG4gICAgdmFyIHRpY2tzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gbWluVGljazsgaSA8IG1heFRpY2sgKyBhdmc7IGkgPSBpICsgYXZnKSB7XG4gICAgICB0aWNrcy5wdXNoKE1hdGgucG93KGJhc2UsIGkpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5taW4gPT09IDApIHtcbiAgICAgIHRpY2tzLnVuc2hpZnQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9OyAvLyDojrflj5bluqbph4/orqHnrpfml7bvvIx2YWx1ZeWNoOeahOWumuS5ieWfn+eZvuWIhuavlFxuXG5cbiAgX3Byb3RvLl9nZXRTY2FsZVBlcmNlbnQgPSBmdW5jdGlvbiBfZ2V0U2NhbGVQZXJjZW50KHZhbHVlKSB7XG4gICAgdmFyIG1heCA9IHRoaXMubWF4O1xuICAgIHZhciBtaW4gPSB0aGlzLm1pbjtcblxuICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSAvLyDlpoLmnpzlgLzlsI/kuo7nrYnkuo4w77yM5YiZ5oyJ54WnMOWkhOeQhlxuXG5cbiAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdmFyIHBvc2l0aXZlTWluID0gdGhpcy5wb3NpdGl2ZU1pbjsgLy8g5aaC5p6cbWluID09IDAsIOWImeagueaNruavlDDlpKfnmoTmnIDlsI/lgLzvvIzorqHnrpfmr5TkvovlhbPns7vjgILov5nkuKrmnIDlsI/lgLzkvZzkuLrlnZDmoIfovbTkuIrnmoTnrKzkuozkuKp0aWNr77yM56ys5LiA5Liq5pivMOS9huaYr+S4jeaYvuekulxuXG4gICAgaWYgKHBvc2l0aXZlTWluKSB7XG4gICAgICBtaW4gPSBwb3NpdGl2ZU1pbiAqIDEgLyBiYXNlO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50OyAvLyDlpoLmnpzmlbDlgLzlsI/kuo7mrKHlsI/lgLzvvIzpgqPkuYjlsLHorqHnrpcgdmFsdWUgLyDmrKHlsI/lgLwg5Y2g5pW05L2T55qE5q+U5L6LXG5cbiAgICBpZiAodmFsdWUgPCBwb3NpdGl2ZU1pbikge1xuICAgICAgcGVyY2VudCA9IHZhbHVlIC8gcG9zaXRpdmVNaW4gLyAobG9nKGJhc2UsIG1heCkgLSBsb2coYmFzZSwgbWluKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmNlbnQgPSAobG9nKGJhc2UsIHZhbHVlKSAtIGxvZyhiYXNlLCBtaW4pKSAvIChsb2coYmFzZSwgbWF4KSAtIGxvZyhiYXNlLCBtaW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHBlcmNlbnQgPSB0aGlzLl9nZXRTY2FsZVBlcmNlbnQodmFsdWUpO1xuXG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICByZXR1cm4gcmFuZ2VNaW4gKyBwZXJjZW50ICogKHJhbmdlTWF4IC0gcmFuZ2VNaW4pO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCh2YWx1ZSkge1xuICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgIHZhciBtYXggPSBsb2coYmFzZSwgdGhpcy5tYXgpO1xuICAgIHZhciByYW5nZU1pbiA9IHRoaXMucmFuZ2VNaW4oKTtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlTWF4KCkgLSByYW5nZU1pbjtcbiAgICB2YXIgbWluO1xuICAgIHZhciBwb3NpdGl2ZU1pbiA9IHRoaXMucG9zaXRpdmVNaW47XG5cbiAgICBpZiAocG9zaXRpdmVNaW4pIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgbWluID0gbG9nKGJhc2UsIHBvc2l0aXZlTWluIC8gYmFzZSk7XG4gICAgICB2YXIgYXBwZW5kUGVyY2VudCA9IDEgLyAobWF4IC0gbWluKSAqIHJhbmdlOyAvLyAwIOWIsCBwb3NpdGl2ZU1pbueahOWNoOavlFxuXG4gICAgICBpZiAodmFsdWUgPCBhcHBlbmRQZXJjZW50KSB7XG4gICAgICAgIC8vIOiQveWIsCAwIC0gcG9zaXRpdmVNaW4g5LmL6Ze0XG4gICAgICAgIHJldHVybiB2YWx1ZSAvIGFwcGVuZFBlcmNlbnQgKiBwb3NpdGl2ZU1pbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluID0gbG9nKGJhc2UsIHRoaXMubWluKTtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9ICh2YWx1ZSAtIHJhbmdlTWluKSAvIHJhbmdlO1xuICAgIHZhciB0bXAgPSBwZXJjZW50ICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgcmV0dXJuIE1hdGgucG93KGJhc2UsIHRtcCk7XG4gIH07XG5cbiAgcmV0dXJuIExvZztcbn0oTGluZWFyKTtcblxuQmFzZS5Mb2cgPSBMb2c7XG5tb2R1bGUuZXhwb3J0cyA9IExvZztcblxuLyoqKi8gfSksXG4vKiAxODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOS9v+eUqHBvd+i/m+ihjOW6pumHj+iuoeeul1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cblxuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgTGluZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7IC8vIOaxguS7pWHkuLrmrKHluYLvvIznu5PmnpzkuLpi55qE5Z+65pWw77yM5aaCIHheXmEgPSBiO+axgnhcblxuXG5mdW5jdGlvbiBjYWxCYXNlKGEsIGIpIHtcbiAgdmFyIGUgPSBNYXRoLkU7XG4gIHZhciB2YWx1ZSA9IE1hdGgucG93KGUsIE1hdGgubG9nKGIpIC8gYSk7IC8vIOS9v+eUqOaNouW6leWFrOW8j+axguW6lVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICog5bqm6YeP55qEUG936K6h566XXG4gKiBAY2xhc3MgU2NhbGUuTG9nXG4gKi9cblxuXG52YXIgUG93ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTGluZWFyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvdywgX0xpbmVhcik7XG5cbiAgZnVuY3Rpb24gUG93KCkge1xuICAgIHJldHVybiBfTGluZWFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQb3cucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgX0xpbmVhci5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSAncG93JztcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBwb3cg55qE5Z2Q5qCH54K555qE5Liq5pWw5o6n5Yi25ZyoMTDkuKrku6XkuItcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy50aWNrQ291bnQgPSAxMDtcbiAgICAvKipcbiAgICAgKiDov5vooYxwb3forqHnrpfnmoTln7rmlbBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5leHBvbmVudCA9IDI7XG4gIH07XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uY2FsY3VsYXRlVGlja3MgPSBmdW5jdGlvbiBjYWxjdWxhdGVUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGV4cG9uZW50ID0gc2VsZi5leHBvbmVudDtcbiAgICB2YXIgbWluO1xuICAgIHZhciBtYXggPSBNYXRoLmNlaWwoY2FsQmFzZShleHBvbmVudCwgc2VsZi5tYXgpKTtcblxuICAgIGlmIChzZWxmLm1pbiA+PSAwKSB7XG4gICAgICBtaW4gPSBNYXRoLmZsb29yKGNhbEJhc2UoZXhwb25lbnQsIHNlbGYubWluKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgdmFyIHRtcCA9IG1heDtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IHRtcDtcbiAgICB9XG5cbiAgICB2YXIgY291bnQgPSBtYXggLSBtaW47XG4gICAgdmFyIHRpY2tDb3VudCA9IHNlbGYudGlja0NvdW50O1xuICAgIHZhciBhdmcgPSBNYXRoLmNlaWwoY291bnQgLyB0aWNrQ291bnQpO1xuICAgIHZhciB0aWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8IG1heCArIGF2ZzsgaSA9IGkgKyBhdmcpIHtcbiAgICAgIHRpY2tzLnB1c2goTWF0aC5wb3coaSwgZXhwb25lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH07IC8vIOiOt+WPluW6pumHj+iuoeeul+aXtu+8jHZhbHVl5Y2g55qE5a6a5LmJ5Z+f55m+5YiG5q+UXG5cblxuICBfcHJvdG8uX2dldFNjYWxlUGVyY2VudCA9IGZ1bmN0aW9uIF9nZXRTY2FsZVBlcmNlbnQodmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuICAgIHZhciBwZXJjZW50ID0gKGNhbEJhc2UoZXhwb25lbnQsIHZhbHVlKSAtIGNhbEJhc2UoZXhwb25lbnQsIG1pbikpIC8gKGNhbEJhc2UoZXhwb25lbnQsIG1heCkgLSBjYWxCYXNlKGV4cG9uZW50LCBtaW4pKTtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHBlcmNlbnQgPSB0aGlzLl9nZXRTY2FsZVBlcmNlbnQodmFsdWUpO1xuXG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICByZXR1cm4gcmFuZ2VNaW4gKyBwZXJjZW50ICogKHJhbmdlTWF4IC0gcmFuZ2VNaW4pO1xuICB9O1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCh2YWx1ZSkge1xuICAgIHZhciBwZXJjZW50ID0gKHZhbHVlIC0gdGhpcy5yYW5nZU1pbigpKSAvICh0aGlzLnJhbmdlTWF4KCkgLSB0aGlzLnJhbmdlTWluKCkpO1xuICAgIHZhciBleHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG4gICAgdmFyIG1heCA9IGNhbEJhc2UoZXhwb25lbnQsIHRoaXMubWF4KTtcbiAgICB2YXIgbWluID0gY2FsQmFzZShleHBvbmVudCwgdGhpcy5taW4pO1xuICAgIHZhciB0bXAgPSBwZXJjZW50ICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgcmV0dXJuIE1hdGgucG93KHRtcCwgZXhwb25lbnQpO1xuICB9O1xuXG4gIHJldHVybiBQb3c7XG59KExpbmVhcik7XG5cbkJhc2UuUG93ID0gUG93O1xubW9kdWxlLmV4cG9ydHMgPSBQb3c7XG5cbi8qKiovIH0pLFxuLyogMTgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xuXG52YXIgR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cbnZhciBUaW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkwKTtcblxudmFyIHJlbmRlcmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMjE1KTtcblxudmFyIENhbnZhcyA9IGZ1bmN0aW9uIENhbnZhcyhjZmcpIHtcbiAgQ2FudmFzLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBjZmcpO1xufTtcblxuQ2FudmFzLkNGRyA9IHtcbiAgZXZlbnRFbmFibGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIOWDj+e0oOWuveW6plxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgd2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIOWDj+e0oOmrmOW6plxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgaGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiDnlLvluIPlrr3luqZcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHdpZHRoQ2FudmFzOiBudWxsLFxuXG4gIC8qKlxuICAgKiDnlLvluIPpq5jluqZcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGhlaWdodENhbnZhczogbnVsbCxcblxuICAvKipcbiAgICogQ1NT5a69XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICB3aWR0aFN0eWxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBDU1Ppq5hcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGhlaWdodFN0eWxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiDlrrnlmahET01cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGNvbnRhaW5lckRPTTogbnVsbCxcblxuICAvKipcbiAgICog5b2T5YmNQ2FudmFz55qERE9NXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBjYW52YXNET006IG51bGwsXG5cbiAgLyoqXG4gICAqIOWxj+W5leWDj+e0oOavlFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgcGl4ZWxSYXRpbzogbnVsbCxcblxuICAvKipcbiAgICog5riy5p+T5Zmo77yM6buY6K6k5pivY2FudmFzXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICByZW5kZXJlcjogJ2NhbnZhcydcbn07XG5VdGlsLmV4dGVuZChDYW52YXMsIEdyb3VwKTtcblV0aWwuYXVnbWVudChDYW52YXMsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBDYW52YXMuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRHbG9iYWxQYXJhbSgpO1xuXG4gICAgdGhpcy5fc2V0Q29udGFpbmVyKCk7XG5cbiAgICB0aGlzLl9pbml0UGFpbnRlcigpO1xuXG4gICAgdGhpcy5fc2NhbGUoKTtcblxuICAgIGlmICh0aGlzLmdldCgnZXZlbnRFbmFibGUnKSkge1xuICAgICAgdGhpcy5fcmVnaXN0RXZlbnRzKCk7XG4gICAgfVxuICB9LFxuICBnZXRFbWl0dGVyOiBmdW5jdGlvbiBnZXRFbWl0dGVyKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChVdGlsLmlzRW1wdHkoZWxlbWVudC5fZ2V0RXZlbnRzKCkpKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LmdldCgncGFyZW50Jyk7XG5cbiAgICAgICAgaWYgKHBhcmVudCAmJiAhZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW1pdHRlcihwYXJlbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZ2V0RXZlbnRPYmo6IGZ1bmN0aW9uIF9nZXRFdmVudE9iaih0eXBlLCBlLCBwb2ludCwgdGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIGUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LnggPSBwb2ludC54O1xuICAgIGV2ZW50LnkgPSBwb2ludC55O1xuICAgIGV2ZW50LmNsaWVudFggPSBlLmNsaWVudFg7XG4gICAgZXZlbnQuY2xpZW50WSA9IGUuY2xpZW50WTtcbiAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG4gIF90cmlnZ2VyRXZlbnQ6IGZ1bmN0aW9uIF90cmlnZ2VyRXZlbnQodHlwZSwgZSkge1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnRCeUNsaWVudChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5nZXRTaGFwZShwb2ludC54LCBwb2ludC55LCBlKTtcbiAgICB2YXIgZWwgPSB0aGlzLmdldCgnZWwnKTtcbiAgICB2YXIgZW1pdE9iajtcblxuICAgIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgdmFyIHByZVNoYXBlID0gdGhpcy5nZXQoJ3ByZVNoYXBlJyk7XG5cbiAgICAgIGlmIChwcmVTaGFwZSAmJiBwcmVTaGFwZSAhPT0gc2hhcGUpIHtcbiAgICAgICAgdmFyIG1vdXNlbGVhdmUgPSB0aGlzLl9nZXRFdmVudE9iaignbW91c2VsZWF2ZScsIGUsIHBvaW50LCBwcmVTaGFwZSk7XG5cbiAgICAgICAgZW1pdE9iaiA9IHRoaXMuZ2V0RW1pdHRlcihwcmVTaGFwZSwgZSk7XG4gICAgICAgIGVtaXRPYmogJiYgZW1pdE9iai5lbWl0KCdtb3VzZWxlYXZlJywgbW91c2VsZWF2ZSk7XG4gICAgICAgIGVsLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgIH1cblxuICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgIHZhciBtb3VzZW1vdmUgPSB0aGlzLl9nZXRFdmVudE9iaignbW91c2Vtb3ZlJywgZSwgcG9pbnQsIHNoYXBlKTtcblxuICAgICAgICBlbWl0T2JqID0gdGhpcy5nZXRFbWl0dGVyKHNoYXBlLCBlKTtcbiAgICAgICAgZW1pdE9iaiAmJiBlbWl0T2JqLmVtaXQoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG5cbiAgICAgICAgaWYgKHByZVNoYXBlICE9PSBzaGFwZSkge1xuICAgICAgICAgIHZhciBtb3VzZWVudGVyID0gdGhpcy5fZ2V0RXZlbnRPYmooJ21vdXNlZW50ZXInLCBlLCBwb2ludCwgc2hhcGUpO1xuXG4gICAgICAgICAgZW1pdE9iaiAmJiBlbWl0T2JqLmVtaXQoJ21vdXNlZW50ZXInLCBtb3VzZWVudGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNhbnZhc21vdXNlbW92ZSA9IHRoaXMuX2dldEV2ZW50T2JqKCdtb3VzZW1vdmUnLCBlLCBwb2ludCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtb3VzZW1vdmUnLCBjYW52YXNtb3VzZW1vdmUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCgncHJlU2hhcGUnLCBzaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMuX2dldEV2ZW50T2JqKHR5cGUsIGUsIHBvaW50LCBzaGFwZSB8fCB0aGlzKTtcblxuICAgICAgZW1pdE9iaiA9IHRoaXMuZ2V0RW1pdHRlcihzaGFwZSwgZSk7XG5cbiAgICAgIGlmIChlbWl0T2JqICYmIGVtaXRPYmogIT09IHRoaXMpIHtcbiAgICAgICAgZW1pdE9iai5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcGUgJiYgIXNoYXBlLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIGVsLnN0eWxlLmN1cnNvciA9IHNoYXBlLmF0dHIoJ2N1cnNvcicpIHx8ICdkZWZhdWx0JztcbiAgICB9XG4gIH0sXG4gIF9yZWdpc3RFdmVudHM6IGZ1bmN0aW9uIF9yZWdpc3RFdmVudHMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHNlbGYuZ2V0KCdlbCcpO1xuICAgIHZhciBldmVudHMgPSBbJ21vdXNlb3V0JywgJ21vdXNlb3ZlcicsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNlbGVhdmUnLCAnbW91c2V1cCcsICdjbGljaycsICdkYmxjbGljayddO1xuICAgIFV0aWwuZWFjaChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5fdHJpZ2dlckV2ZW50KGV2ZW50LCBlKTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9KTsgLy8gc3BlY2lhbCBjYXNlc1xuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIVV0aWwuaXNFbXB0eShlLnRvdWNoZXMpKSB7XG4gICAgICAgIHNlbGYuX3RyaWdnZXJFdmVudCgndG91Y2hzdGFydCcsIGUudG91Y2hlc1swXSk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIVV0aWwuaXNFbXB0eShlLnRvdWNoZXMpKSB7XG4gICAgICAgIHNlbGYuX3RyaWdnZXJFdmVudCgndG91Y2htb3ZlJywgZS50b3VjaGVzWzBdKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFVdGlsLmlzRW1wdHkoZS5jaGFuZ2VkVG91Y2hlcykpIHtcbiAgICAgICAgc2VsZi5fdHJpZ2dlckV2ZW50KCd0b3VjaGVuZCcsIGUuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgfSxcbiAgX3NjYWxlOiBmdW5jdGlvbiBfc2NhbGUoKSB7XG4gICAgaWYgKHRoaXMuX2NmZy5yZW5kZXJUeXBlICE9PSAnc3ZnJykge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldCgncGl4ZWxSYXRpbycpO1xuICAgICAgdGhpcy5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICB9XG4gIH0sXG4gIF9zZXRHbG9iYWxQYXJhbTogZnVuY3Rpb24gX3NldEdsb2JhbFBhcmFtKCkge1xuICAgIHZhciByZW5kZXJUeXBlID0gdGhpcy5nZXQoJ3JlbmRlcmVyJykgfHwgJ2NhbnZhcyc7XG5cbiAgICBpZiAocmVuZGVyVHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgIHRoaXMuc2V0KCdwaXhlbFJhdGlvJywgMSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5nZXQoJ3BpeGVsUmF0aW8nKSkge1xuICAgICAgdGhpcy5zZXQoJ3BpeGVsUmF0aW8nLCBVdGlsLmdldFJhdGlvKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2NmZy5yZW5kZXJUeXBlID0gcmVuZGVyVHlwZTtcbiAgICB2YXIgcmVuZGVyZXIgPSByZW5kZXJlcnNbcmVuZGVyVHlwZV07XG4gICAgdGhpcy5fY2ZnLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fY2ZnLmNhbnZhcyA9IHRoaXM7XG4gICAgdmFyIHRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHRoaXMpO1xuICAgIHRoaXMuX2NmZy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICB9LFxuICBfc2V0Q29udGFpbmVyOiBmdW5jdGlvbiBfc2V0Q29udGFpbmVyKCkge1xuICAgIHZhciBjb250YWluZXJJZCA9IHRoaXMuZ2V0KCdjb250YWluZXJJZCcpO1xuICAgIHZhciBjb250YWluZXJET00gPSB0aGlzLmdldCgnY29udGFpbmVyRE9NJyk7XG5cbiAgICBpZiAoIWNvbnRhaW5lckRPTSkge1xuICAgICAgY29udGFpbmVyRE9NID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySWQpO1xuICAgICAgdGhpcy5zZXQoJ2NvbnRhaW5lckRPTScsIGNvbnRhaW5lckRPTSk7XG4gICAgfVxuXG4gICAgVXRpbC5tb2RpZnlDU1MoY29udGFpbmVyRE9NLCB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0pO1xuICB9LFxuICBfaW5pdFBhaW50ZXI6IGZ1bmN0aW9uIF9pbml0UGFpbnRlcigpIHtcbiAgICB2YXIgY29udGFpbmVyRE9NID0gdGhpcy5nZXQoJ2NvbnRhaW5lckRPTScpO1xuICAgIHZhciBwYWludGVyID0gbmV3IHRoaXMuX2NmZy5yZW5kZXJlci5wYWludGVyKGNvbnRhaW5lckRPTSk7XG4gICAgdGhpcy5fY2ZnLnBhaW50ZXIgPSBwYWludGVyO1xuICAgIHRoaXMuX2NmZy5jYW52YXNET00gPSB0aGlzLl9jZmcuZWwgPSBwYWludGVyLmNhbnZhcztcbiAgICB0aGlzLmNoYW5nZVNpemUodGhpcy5nZXQoJ3dpZHRoJyksIHRoaXMuZ2V0KCdoZWlnaHQnKSk7XG4gIH0sXG4gIF9yZXNpemU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgdmFyIGNhbnZhc0RPTSA9IHRoaXMuZ2V0KCdjYW52YXNET00nKTtcbiAgICB2YXIgd2lkdGhDYW52YXMgPSB0aGlzLmdldCgnd2lkdGhDYW52YXMnKTtcbiAgICB2YXIgaGVpZ2h0Q2FudmFzID0gdGhpcy5nZXQoJ2hlaWdodENhbnZhcycpO1xuICAgIHZhciB3aWR0aFN0eWxlID0gdGhpcy5nZXQoJ3dpZHRoU3R5bGUnKTtcbiAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldCgnaGVpZ2h0U3R5bGUnKTtcbiAgICBjYW52YXNET00uc3R5bGUud2lkdGggPSB3aWR0aFN0eWxlO1xuICAgIGNhbnZhc0RPTS5zdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHlsZTtcbiAgICBjYW52YXNET00uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoQ2FudmFzKTtcbiAgICBjYW52YXNET00uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHRDYW52YXMpO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldCgncGl4ZWxSYXRpbycpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHJldHVybiB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXQoJ3BpeGVsUmF0aW8nKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHJldHVybiBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB9LFxuICBjaGFuZ2VTaXplOiBmdW5jdGlvbiBjaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0KCdwaXhlbFJhdGlvJyk7XG4gICAgdmFyIHdpZHRoQ2FudmFzID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgIHZhciBoZWlnaHRDYW52YXMgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc2V0KCd3aWR0aENhbnZhcycsIHdpZHRoQ2FudmFzKTtcbiAgICB0aGlzLnNldCgnaGVpZ2h0Q2FudmFzJywgaGVpZ2h0Q2FudmFzKTtcbiAgICB0aGlzLnNldCgnd2lkdGhTdHlsZScsIHdpZHRoICsgJ3B4Jyk7XG4gICAgdGhpcy5zZXQoJ2hlaWdodFN0eWxlJywgaGVpZ2h0ICsgJ3B4Jyk7XG4gICAgdGhpcy5zZXQoJ3dpZHRoJywgd2lkdGgpO1xuICAgIHRoaXMuc2V0KCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgdGhpcy5fcmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWwhueql+WPo+WdkOagh+i9rOWPmOaIkCBjYW52YXMg5Z2Q5qCHXG4gICAqIEBwYXJhbSAge051bWJlcn0gY2xpZW50WCDnqpflj6N45Z2Q5qCHXG4gICAqIEBwYXJhbSAge051bWJlcn0gY2xpZW50WSDnqpflj6N55Z2Q5qCHXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2FudmFz5Z2Q5qCHXG4gICAqL1xuICBnZXRQb2ludEJ5Q2xpZW50OiBmdW5jdGlvbiBnZXRQb2ludEJ5Q2xpZW50KGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmdldCgnZWwnKTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0KCdwaXhlbFJhdGlvJykgfHwgMTtcbiAgICB2YXIgYmJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoY2xpZW50WCAtIGJib3gubGVmdCkgKiBwaXhlbFJhdGlvLFxuICAgICAgeTogKGNsaWVudFkgLSBiYm94LnRvcCkgKiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfSxcbiAgZ2V0Q2xpZW50QnlQb2ludDogZnVuY3Rpb24gZ2V0Q2xpZW50QnlQb2ludCh4LCB5KSB7XG4gICAgdmFyIGVsID0gdGhpcy5nZXQoJ2VsJyk7XG4gICAgdmFyIGJib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0KCdwaXhlbFJhdGlvJykgfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50WDogeCAvIHBpeGVsUmF0aW8gKyBiYm94LmxlZnQsXG4gICAgICBjbGllbnRZOiB5IC8gcGl4ZWxSYXRpbyArIGJib3gudG9wXG4gICAgfTtcbiAgfSxcbiAgZHJhdzogZnVuY3Rpb24gZHJhdygpIHtcbiAgICB0aGlzLl9jZmcucGFpbnRlci5kcmF3KHRoaXMpO1xuICB9LFxuICBnZXRTaGFwZTogZnVuY3Rpb24gZ2V0U2hhcGUoeCwgeSwgZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHRoaXMuX2NmZy5yZW5kZXJlci5nZXRTaGFwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NmZy5yZW5kZXJlci5nZXRTaGFwZS5jYWxsKHRoaXMsIHgsIHksIGUpO1xuICAgIH1cblxuICAgIHJldHVybiBDYW52YXMuc3VwZXJjbGFzcy5nZXRTaGFwZS5jYWxsKHRoaXMsIHgsIHkpO1xuICB9LFxuICBnZXRSZW5kZXJlcjogZnVuY3Rpb24gZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZy5yZW5kZXJUeXBlO1xuICB9LFxuICBfZHJhd1N5bmM6IGZ1bmN0aW9uIF9kcmF3U3luYygpIHtcbiAgICB0aGlzLl9jZmcucGFpbnRlci5kcmF3U3luYyh0aGlzKTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgY2ZnID0gdGhpcy5fY2ZnO1xuICAgIHZhciBjb250YWluZXJET00gPSBjZmcuY29udGFpbmVyRE9NO1xuICAgIHZhciBjYW52YXNET00gPSBjZmcuY2FudmFzRE9NO1xuXG4gICAgaWYgKGNhbnZhc0RPTSAmJiBjb250YWluZXJET00pIHtcbiAgICAgIGNvbnRhaW5lckRPTS5yZW1vdmVDaGlsZChjYW52YXNET00pO1xuICAgIH1cblxuICAgIGNmZy50aW1lbGluZS5zdG9wKCk7XG4gICAgQ2FudmFzLnN1cGVyY2xhc3MuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuXG4vKioqLyB9KSxcbi8qIDE4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5mcm9tTWF0NCA9IGZyb21NYXQ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLmZyb21NYXQyZCA9IGZyb21NYXQyZDtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMubm9ybWFsRnJvbU1hdDQgPSBub3JtYWxGcm9tTWF0NDtcbmV4cG9ydHMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuXG52YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29tbW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG59XG4vKipcbiAqIDN4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0M1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbNF07XG4gIG91dFs0XSA9IGFbNV07XG4gIG91dFs1XSA9IGFbNl07XG4gIG91dFs2XSA9IGFbOF07XG4gIG91dFs3XSA9IGFbOV07XG4gIG91dFs4XSA9IGFbMTBdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICBvdXRbMF0gPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XG4gIG91dFsxXSA9IGEwMiAqIGEyMSAtIGEwMSAqIGEyMjtcbiAgb3V0WzJdID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBvdXRbM10gPSBhMTIgKiBhMjAgLSBhMTAgKiBhMjI7XG4gIG91dFs0XSA9IGEwMCAqIGEyMiAtIGEwMiAqIGEyMDtcbiAgb3V0WzVdID0gYTAyICogYTEwIC0gYTAwICogYTEyO1xuICBvdXRbNl0gPSBhMTAgKiBhMjEgLSBhMTEgKiBhMjA7XG4gIG91dFs3XSA9IGEwMSAqIGEyMCAtIGEwMCAqIGEyMTtcbiAgb3V0WzhdID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuO1xuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IHZbMF07XG4gIG91dFs3XSA9IHZbMV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5cblxuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFszXSA9IHl4IC0gd3o7XG4gIG91dFs2XSA9IHp4ICsgd3k7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbN10gPSB6eSAtIHd4O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbNV0gPSB6eSArIHd4O1xuICBvdXRbOF0gPSAxIC0geHggLSB5eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cblxuXG5mdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn1cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpO1xufVxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddLFxuICAgICAgYTggPSBhWzhdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddLFxuICAgICAgYjggPSBiWzhdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cblxudmFyIG11bCA9IGV4cG9ydHMubXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbnZhciBzdWIgPSBleHBvcnRzLnN1YiA9IHN1YnRyYWN0O1xuXG4vKioqLyB9KSxcbi8qIDE4MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSBleHBvcnRzLmxlbiA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmNlaWwgPSBjZWlsO1xuZXhwb3J0cy5mbG9vciA9IGZsb29yO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0MiA9IHRyYW5zZm9ybU1hdDI7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDJkID0gdHJhbnNmb3JtTWF0MmQ7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDMgPSB0cmFuc2Zvcm1NYXQzO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQ0ID0gdHJhbnNmb3JtTWF0NDtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5hbmdsZSA9IGFuZ2xlO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcblxudmFyIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvbW1vbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxufVxuLyoqXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMyXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cblxuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgMkQgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCBjKSB7XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgdmFyIHAwID0gYVswXSAtIGJbMF0sXG4gICAgICBwMSA9IGFbMV0gLSBiWzFdLFxuICAgICAgc2luQyA9IE1hdGguc2luKGMpLFxuICAgICAgY29zQyA9IE1hdGguY29zKGMpOyAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB4MSA9IGFbMF0sXG4gICAgICB5MSA9IGFbMV0sXG4gICAgICB4MiA9IGJbMF0sXG4gICAgICB5MiA9IGJbMV07XG4gIHZhciBsZW4xID0geDEgKiB4MSArIHkxICogeTE7XG5cbiAgaWYgKGxlbjEgPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4xID0gMSAvIE1hdGguc3FydChsZW4xKTtcbiAgfVxuXG4gIHZhciBsZW4yID0geDIgKiB4MiArIHkyICogeTI7XG5cbiAgaWYgKGxlbjIgPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4yID0gMSAvIE1hdGguc3FydChsZW4yKTtcbiAgfVxuXG4gIHZhciBjb3NpbmUgPSAoeDEgKiB4MiArIHkxICogeTIpICogbGVuMSAqIGxlbjI7XG5cbiAgaWYgKGNvc2luZSA+IDEuMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGNvc2luZSA8IC0xLjApIHtcbiAgICByZXR1cm4gTWF0aC5QSTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cblxudmFyIGxlbiA9IGV4cG9ydHMubGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgc3ViID0gZXhwb3J0cy5zdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxudmFyIG11bCA9IGV4cG9ydHMubXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgZGl2ID0gZXhwb3J0cy5kaXYgPSBkaXZpZGU7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbnZhciBkaXN0ID0gZXhwb3J0cy5kaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgc3FyRGlzdCA9IGV4cG9ydHMuc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgc3FyTGVuID0gZXhwb3J0cy5zcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5cbnZhciBmb3JFYWNoID0gZXhwb3J0cy5mb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgIGwgPSB2b2lkIDA7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpO1xuXG4vKioqLyB9KSxcbi8qIDE4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMuc3FyRGlzdCA9IGV4cG9ydHMuZGlzdCA9IGV4cG9ydHMuZGl2ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnN1YiA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmhlcm1pdGUgPSBoZXJtaXRlO1xuZXhwb3J0cy5iZXppZXIgPSBiZXppZXI7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDMgPSB0cmFuc2Zvcm1NYXQzO1xuZXhwb3J0cy50cmFuc2Zvcm1RdWF0ID0gdHJhbnNmb3JtUXVhdDtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5cbnZhciBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb21tb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbn1cbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKGMpIC0gcFsyXSAqIE1hdGguc2luKGMpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKGMpICsgcFsyXSAqIE1hdGguY29zKGMpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYykge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMl0gKiBNYXRoLnNpbihjKSArIHBbMF0gKiBNYXRoLmNvcyhjKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MoYykgLSBwWzBdICogTWF0aC5zaW4oYyk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKGMpIC0gcFsxXSAqIE1hdGguc2luKGMpO1xuICByWzFdID0gcFswXSAqIE1hdGguc2luKGMpICsgcFsxXSAqIE1hdGguY29zKGMpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5cblxuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICB2YXIgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuICBub3JtYWxpemUodGVtcEEsIHRlbXBBKTtcbiAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gIHZhciBjb3NpbmUgPSBkb3QodGVtcEEsIHRlbXBCKTtcblxuICBpZiAoY29zaW5lID4gMS4wKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoY29zaW5lIDwgLTEuMCkge1xuICAgIHJldHVybiBNYXRoLlBJO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cblxudmFyIHN1YiA9IGV4cG9ydHMuc3ViID0gc3VidHJhY3Q7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbnZhciBtdWwgPSBleHBvcnRzLm11bCA9IG11bHRpcGx5O1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxudmFyIGRpdiA9IGV4cG9ydHMuZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgZGlzdCA9IGV4cG9ydHMuZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cblxudmFyIHNxckRpc3QgPSBleHBvcnRzLnNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgbGVuID0gZXhwb3J0cy5sZW4gPSBsZW5ndGg7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cblxudmFyIHNxckxlbiA9IGV4cG9ydHMuc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgZm9yRWFjaCA9IGV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICBsID0gdm9pZCAwO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7XG5cbi8qKiovIH0pLFxuLyogMTg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhbkZpbGw6IGZhbHNlLFxuICBjYW5TdHJva2U6IGZhbHNlLFxuICBpbml0QXR0cnM6IGZ1bmN0aW9uIGluaXRBdHRycyhhdHRycykge1xuICAgIHRoaXMuX2F0dHJzID0ge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIG1hdHJpeDogWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdXG4gICAgfTtcbiAgICB0aGlzLmF0dHIoVXRpbC5hc3NpZ24odGhpcy5nZXREZWZhdWx0QXR0cnMoKSwgYXR0cnMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZ2V0RGVmYXVsdEF0dHJzOiBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7miJbogIXorr7nva7lsZ7mgKfvvIzmnInku6XkuIsgNCDnp43mg4XlvaLvvJpcbiAgICogICAtIG5hbWUg5LiN5a2Y5ZyoLCDliJnov5Tlm57lsZ7mgKfpm4blkIhcbiAgICogICAtIG5hbWUg5Li65a2X56ym5Liy77yMdmFsdWUg5Li656m677yM6I635Y+W5bGe5oCn5YC8XG4gICAqICAgLSBuYW1lIOS4uuWtl+espuS4su+8jHZhbHVlIOS4jeS4uuepuu+8jOiuvue9ruWxnuaAp+WAvO+8jOi/lOWbniB0aGlzXG4gICAqICAgLSBuYW1lIOS4uumUruWAvOWvue+8jHZhbHVlIOS4uuepuu+8jOiuvue9ruWxnuaAp+WAvFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmcgfCBPYmplY3R9IG5hbWUgIOWxnuaAp+WQjVxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZSDlsZ7mgKflgLxcbiAgICogQHJldHVybiB7Kn0g5bGe5oCn5YC8XG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbiBhdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzZWxmLl9hdHRycztcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdChuYW1lKSkge1xuICAgICAgLy8gc2VsZi5fYXR0cnMgPSBVdGlsLmRlZXBNaXgoc2VsZi5fYXR0cnMsIG5hbWUpO1xuICAgICAgZm9yICh2YXIgayBpbiBuYW1lKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIoaywgbmFtZVtrXSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuY2xlYXJCQm94KCk7XG4gICAgICB0aGlzLl9jZmcuaGFzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKG5hbWUsIHZhbHVlKTtcblxuICAgICAgc2VsZi5jbGVhckJCb3goKTtcbiAgICAgIHRoaXMuX2NmZy5oYXNVcGRhdGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuX2F0dHJzW25hbWVdO1xuICB9LFxuICBfc2V0QXR0cjogZnVuY3Rpb24gX3NldEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIGlmIChuYW1lID09PSAnZmlsbCcgfHwgbmFtZSA9PT0gJ3N0cm9rZScpIHtcbiAgICAgIGF0dHJzW25hbWUgKyAnU3R5bGUnXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgIGF0dHJzLmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdjbGlwJyAmJiB2YWx1ZSkge1xuICAgICAgc2VsZi5fc2V0Q2xpcCh2YWx1ZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ3BhdGgnICYmIHNlbGYuX2FmdGVyU2V0QXR0clBhdGgpIHtcbiAgICAgIHNlbGYuX2FmdGVyU2V0QXR0clBhdGgodmFsdWUpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICBzZWxmLnRyYW5zZm9ybSh2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdyb3RhdGUnKSB7XG4gICAgICBzZWxmLnJvdGF0ZUF0U3RhcnQodmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgY2xlYXJCQm94OiBmdW5jdGlvbiBjbGVhckJCb3goKSB7XG4gICAgdGhpcy5zZXRTaWxlbnQoJ2JveCcsIG51bGwpO1xuICB9LFxuICBoYXNGaWxsOiBmdW5jdGlvbiBoYXNGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmNhbkZpbGwgJiYgdGhpcy5fYXR0cnMuZmlsbFN0eWxlO1xuICB9LFxuICBoYXNTdHJva2U6IGZ1bmN0aW9uIGhhc1N0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5TdHJva2UgJiYgdGhpcy5fYXR0cnMuc3Ryb2tlU3R5bGU7XG4gIH0sXG4gIF9zZXRDbGlwOiBmdW5jdGlvbiBfc2V0Q2xpcChpdGVtKSB7XG4gICAgaXRlbS5fY2ZnLnJlbmRlcmVyID0gdGhpcy5fY2ZnLnJlbmRlcmVyO1xuICAgIGl0ZW0uX2NmZy5jYW52YXMgPSB0aGlzLl9jZmcuY2FudmFzO1xuICAgIGl0ZW0uX2NmZy5wYXJlbnQgPSB0aGlzLl9jZmcucGFyZW50O1xuXG4gICAgaXRlbS5oYXNGaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpOyAvLyDmmK/lkKbmnKrmlLnlj5hcblxuXG5mdW5jdGlvbiBpc1VuY2hhbmdlZChtKSB7XG4gIHJldHVybiBtWzBdID09PSAxICYmIG1bMV0gPT09IDAgJiYgbVszXSA9PT0gMCAmJiBtWzRdID09PSAxICYmIG1bNl0gPT09IDAgJiYgbVs3XSA9PT0gMDtcbn0gLy8g5piv5ZCm5LuF5LuF5pivc2NhbGVcblxuXG5mdW5jdGlvbiBpc1NjYWxlKG0pIHtcbiAgcmV0dXJuIG1bMV0gPT09IDAgJiYgbVszXSA9PT0gMCAmJiBtWzZdID09PSAwICYmIG1bN10gPT09IDA7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlKG0xLCBtMikge1xuICBpZiAoIWlzVW5jaGFuZ2VkKG0yKSkge1xuICAgIGlmIChpc1NjYWxlKG0yKSkge1xuICAgICAgbTFbMF0gKj0gbTJbMF07XG4gICAgICBtMVs0XSAqPSBtMls0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbC5tYXQzLm11bHRpcGx5KG0xLCBtMSwgbTIpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdFRyYW5zZm9ybTogZnVuY3Rpb24gaW5pdFRyYW5zZm9ybSgpIHt9LFxuICByZXNldE1hdHJpeDogZnVuY3Rpb24gcmVzZXRNYXRyaXgoKSB7XG4gICAgdGhpcy5hdHRyKCdtYXRyaXgnLCBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSh0eCwgdHkpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMubWF0cml4O1xuICAgIFV0aWwubWF0My50cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFt0eCwgdHldKTtcbiAgICB0aGlzLmNsZWFyVG90YWxNYXRyaXgoKTtcbiAgICB0aGlzLmF0dHIoJ21hdHJpeCcsIG1hdHJpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKHJhZGlhbikge1xuICAgIHZhciBtYXRyaXggPSB0aGlzLl9hdHRycy5tYXRyaXg7XG4gICAgVXRpbC5tYXQzLnJvdGF0ZShtYXRyaXgsIG1hdHJpeCwgcmFkaWFuKTtcbiAgICB0aGlzLmNsZWFyVG90YWxNYXRyaXgoKTtcbiAgICB0aGlzLmF0dHIoJ21hdHJpeCcsIG1hdHJpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNjYWxlOiBmdW5jdGlvbiBzY2FsZShzMSwgczIpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMubWF0cml4O1xuICAgIFV0aWwubWF0My5zY2FsZShtYXRyaXgsIG1hdHJpeCwgW3MxLCBzMl0pO1xuICAgIHRoaXMuY2xlYXJUb3RhbE1hdHJpeCgpO1xuICAgIHRoaXMuYXR0cignbWF0cml4JywgbWF0cml4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcm90YXRlQXRTdGFydDogZnVuY3Rpb24gcm90YXRlQXRTdGFydChyb3RhdGUpIHtcbiAgICB2YXIgeCA9IHRoaXMuX2F0dHJzLnggfHwgdGhpcy5fY2ZnLmF0dHJzLng7XG4gICAgdmFyIHkgPSB0aGlzLl9hdHRycy55IHx8IHRoaXMuX2NmZy5hdHRycy55O1xuXG4gICAgaWYgKE1hdGguYWJzKHJvdGF0ZSkgPiBNYXRoLlBJICogMikge1xuICAgICAgcm90YXRlID0gcm90YXRlIC8gMTgwICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oW1sndCcsIC14LCAteV0sIFsncicsIHJvdGF0ZV0sIFsndCcsIHgsIHldXSk7XG4gIH0sXG4gIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgIHZhciBjeCA9IHRoaXMuZ2V0KCd4JykgfHwgMDsgLy8g5b2T5YmN55qEeFxuXG4gICAgdmFyIGN5ID0gdGhpcy5nZXQoJ3knKSB8fCAwOyAvLyDlvZPliY3nmoR5XG5cbiAgICB0aGlzLnRyYW5zbGF0ZSh4IC0gY3gsIHkgLSBjeSk7XG4gICAgdGhpcy5zZXQoJ3gnLCB4KTtcbiAgICB0aGlzLnNldCgneScsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybSh0cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMubWF0cml4O1xuICAgIFV0aWwuZWFjaCh0cywgZnVuY3Rpb24gKHQpIHtcbiAgICAgIHN3aXRjaCAodFswXSkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICBzZWxmLnRyYW5zbGF0ZSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBzZWxmLnNjYWxlKHRbMV0sIHRbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgIHNlbGYucm90YXRlKHRbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIHNlbGYuYXR0cignbWF0cml4JywgVXRpbC5tYXQzLm11bHRpcGx5KFtdLCBtYXRyaXgsIHRbMV0pKTtcbiAgICAgICAgICBzZWxmLmNsZWFyVG90YWxNYXRyaXgoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh0cykge1xuICAgIHRoaXMuYXR0cignbWF0cml4JywgWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odHMpO1xuICB9LFxuICBnZXRNYXRyaXg6IGZ1bmN0aW9uIGdldE1hdHJpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXRyaXgnKTtcbiAgfSxcbiAgc2V0TWF0cml4OiBmdW5jdGlvbiBzZXRNYXRyaXgobSkge1xuICAgIHRoaXMuYXR0cignbWF0cml4JywgbSk7XG4gICAgdGhpcy5jbGVhclRvdGFsTWF0cml4KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh2LCByb290KSB7XG4gICAgdmFyIG07XG5cbiAgICBpZiAocm9vdCkge1xuICAgICAgbSA9IHRoaXMuX2dldE1hdHJpeEJ5Um9vdChyb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHRoaXMuYXR0cignbWF0cml4Jyk7XG4gICAgfVxuXG4gICAgVXRpbC52ZWMzLnRyYW5zZm9ybU1hdDModiwgdiwgbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIOiOt+WPluWIsOi+vuaMh+WumuagueiKgueCueeahOefqemYtVxuICBfZ2V0TWF0cml4QnlSb290OiBmdW5jdGlvbiBfZ2V0TWF0cml4QnlSb290KHJvb3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcm9vdCA9IHJvb3QgfHwgc2VsZjtcbiAgICB2YXIgcGFyZW50ID0gc2VsZjtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgd2hpbGUgKHBhcmVudCAhPT0gcm9vdCkge1xuICAgICAgcGFyZW50cy51bnNoaWZ0KHBhcmVudCk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0KCdwYXJlbnQnKTtcbiAgICB9XG5cbiAgICBwYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcbiAgICB2YXIgbSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICBVdGlsLmVhY2gocGFyZW50cywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBVdGlsLm1hdDMubXVsdGlwbHkobSwgY2hpbGQuYXR0cignbWF0cml4JyksIG0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlupTnlKjliLDlvZPliY3lhYPntKDkuIrnmoTmgLvnmoTnn6npmLVcbiAgICogQHJldHVybiB7TWF0cml4fSDnn6npmLVcbiAgICovXG4gIGdldFRvdGFsTWF0cml4OiBmdW5jdGlvbiBnZXRUb3RhbE1hdHJpeCgpIHtcbiAgICB2YXIgbSA9IHRoaXMuX2NmZy50b3RhbE1hdHJpeDtcblxuICAgIGlmICghbSkge1xuICAgICAgbSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9jZmcucGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHZhciBwbSA9IHBhcmVudC5nZXRUb3RhbE1hdHJpeCgpO1xuICAgICAgICBtdWx0aXBsZShtLCBwbSk7XG4gICAgICB9XG5cbiAgICAgIG11bHRpcGxlKG0sIHRoaXMuYXR0cignbWF0cml4JykpO1xuICAgICAgdGhpcy5fY2ZnLnRvdGFsTWF0cml4ID0gbTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbiAgfSxcbiAgLy8g5riF6Zmk5b2T5YmN55qE55+p6Zi1XG4gIGNsZWFyVG90YWxNYXRyaXg6IGZ1bmN0aW9uIGNsZWFyVG90YWxNYXRyaXgoKSB7Ly8gdGhpcy5fY2ZnLnRvdGFsTWF0cml4ID0gbnVsbDtcbiAgfSxcbiAgaW52ZXJ0OiBmdW5jdGlvbiBpbnZlcnQodikge1xuICAgIHZhciBtID0gdGhpcy5nZXRUb3RhbE1hdHJpeCgpOyAvLyDljZXnsr7lsY/luZXkuIvlpKflpJrmlbDnn6npmLXmsqHlj5jljJZcblxuICAgIGlmIChpc1NjYWxlKG0pKSB7XG4gICAgICB2WzBdIC89IG1bMF07XG4gICAgICB2WzFdIC89IG1bNF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbm0gPSBVdGlsLm1hdDMuaW52ZXJ0KFtdLCBtKTtcblxuICAgICAgaWYgKGlubSkge1xuICAgICAgICBVdGlsLnZlYzMudHJhbnNmb3JtTWF0Myh2LCB2LCBpbm0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgIHZhciBtbyA9IHRoaXMuYXR0cignbWF0cml4Jyk7IC8vIOS4jeaUueWPmOaXtlxuXG4gICAgaWYgKCFpc1VuY2hhbmdlZChtbykpIHtcbiAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1vWzBdLCBtb1sxXSwgbW9bM10sIG1vWzRdLCBtb1s2XSwgbW9bN10pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgUmVzZXJ2ZWRQcm9wcyA9IHtcbiAgZGVsYXk6ICdkZWxheScsXG4gIHJvdGF0ZTogJ3JvdGF0ZSdcbn07XG52YXIgY29sb3JSYWxhcmVkUHJvcHMgPSB7XG4gIGZpbGw6ICdmaWxsJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgZmlsbFN0eWxlOiAnZmlsbFN0eWxlJyxcbiAgc3Ryb2tlU3R5bGU6ICdzdHJva2VTdHlsZSdcbn07XG5cbmZ1bmN0aW9uIGdldEZyb21BdHRycyh0b0F0dHJzLCBzaGFwZSkge1xuICB2YXIgcnN0ID0ge307XG4gIHZhciBhdHRycyA9IHNoYXBlLl9hdHRycztcblxuICBmb3IgKHZhciBrIGluIHRvQXR0cnMuYXR0cnMpIHtcbiAgICByc3Rba10gPSBhdHRyc1trXTtcbiAgfVxuXG4gIHJldHVybiByc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEZvcm1hdFByb3BzKHByb3BzLCBzaGFwZSkge1xuICB2YXIgcnN0ID0ge1xuICAgIG1hdHJpeDogbnVsbCxcbiAgICBhdHRyczoge31cbiAgfTtcbiAgdmFyIGF0dHJzID0gc2hhcGUuX2F0dHJzO1xuXG4gIGZvciAodmFyIGsgaW4gcHJvcHMpIHtcbiAgICBpZiAoayA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgIHJzdC5tYXRyaXggPSBVdGlsLnRyYW5zZm9ybShzaGFwZS5nZXRNYXRyaXgoKSwgcHJvcHNba10pO1xuICAgIH0gZWxzZSBpZiAoayA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgIHJzdC5tYXRyaXggPSBVdGlsLnRyYW5zZm9ybShzaGFwZS5nZXRNYXRyaXgoKSwgW1sncicsIHByb3BzW2tdXV0pO1xuICAgIH0gZWxzZSBpZiAoayA9PT0gJ21hdHJpeCcpIHtcbiAgICAgIHJzdC5tYXRyaXggPSBwcm9wc1trXTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yUmFsYXJlZFByb3BzW2tdICYmIC9eW3IsUixMLGxdezF9W1xcc10qXFwoLy50ZXN0KHByb3BzW2tdKSkge1xuICAgICAgLy8g5riQ5Y+Y6Imy5LiN5pSv5oyB5Yqo55S7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKCFSZXNlcnZlZFByb3BzW2tdICYmIGF0dHJzW2tdICE9PSBwcm9wc1trXSkge1xuICAgICAgcnN0LmF0dHJzW2tdID0gcHJvcHNba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdDtcbn1cblxuZnVuY3Rpb24gY2hlY2tFeGlzdGVkQXR0cnMoYW5pbWF0b3JzLCBhbmltYXRvcikge1xuICB2YXIgZGVsYXkgPSBhbmltYXRvci5kZWxheTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgVXRpbC5lYWNoKGFuaW1hdG9yLnRvQXR0cnMsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgVXRpbC5lYWNoKGFuaW1hdG9ycywgZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICBpZiAoZGVsYXkgPCBhbmltYXRvci5zdGFydFRpbWUgKyBhbmltYXRvci5kdXJhdGlvbikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhbmltYXRvci50b0F0dHJzLCBrKSkge1xuICAgICAgICAgIGRlbGV0ZSBhbmltYXRvci50b0F0dHJzW2tdO1xuICAgICAgICAgIGRlbGV0ZSBhbmltYXRvci5mcm9tQXR0cnNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKGFuaW1hdG9yLnRvTWF0cml4KSB7XG4gICAgVXRpbC5lYWNoKGFuaW1hdG9ycywgZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICBpZiAoZGVsYXkgPCBhbmltYXRvci5zdGFydFRpbWUgKyBhbmltYXRvci5kdXJhdGlvbiAmJiBhbmltYXRvci50b01hdHJpeCkge1xuICAgICAgICBkZWxldGUgYW5pbWF0b3IudG9NYXRyaXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0b3JzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIOaJp+ihjOWKqOeUu1xuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgdG9Qcm9wcyAg5Yqo55S75pyA57uI54q25oCBXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBkdXJhdGlvbiDliqjnlLvmiafooYzml7bpl7RcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIGVhc2luZyAgIOWKqOeUu+e8k+WKqOaViOaenFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sg5Yqo55S75omn6KGM5ZCO55qE5Zue6LCDXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBkZWxheSAgICDliqjnlLvlu7bov5/ml7bpl7RcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUodG9Qcm9wcywgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5zZXQoJ2FuaW1hdGluZycsIHRydWUpO1xuICAgIHZhciB0aW1lbGluZSA9IHNlbGYuZ2V0KCd0aW1lbGluZScpO1xuXG4gICAgaWYgKCF0aW1lbGluZSkge1xuICAgICAgdGltZWxpbmUgPSBzZWxmLmdldCgnY2FudmFzJykuZ2V0KCd0aW1lbGluZScpO1xuICAgICAgc2VsZi5zZXRTaWxlbnQoJ3RpbWVsaW5lJywgdGltZWxpbmUpO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRvcnMgPSBzZWxmLmdldCgnYW5pbWF0b3JzJykgfHwgW107IC8vIOWIneWni+WMlnRpY2tcblxuICAgIGlmICghdGltZWxpbmUuX3RpbWVyKSB7XG4gICAgICB0aW1lbGluZS5pbml0VGltZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgIGRlbGF5ID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgIGVhc2luZyA9ICdlYXNlTGluZWFyJztcbiAgICB9IGVsc2Uge1xuICAgICAgZWFzaW5nID0gZWFzaW5nID8gZWFzaW5nIDogJ2Vhc2VMaW5lYXInO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXRQcm9wcyA9IGdldEZvcm1hdFByb3BzKHRvUHJvcHMsIHNlbGYpOyAvLyDorrDlvZXliqjnlLvlsZ7mgKdcblxuICAgIHZhciBhbmltYXRvciA9IHtcbiAgICAgIGZyb21BdHRyczogZ2V0RnJvbUF0dHJzKGZvcm1hdFByb3BzLCBzZWxmKSxcbiAgICAgIHRvQXR0cnM6IGZvcm1hdFByb3BzLmF0dHJzLFxuICAgICAgZnJvbU1hdHJpeDogVXRpbC5jbG9uZShzZWxmLmdldE1hdHJpeCgpKSxcbiAgICAgIHRvTWF0cml4OiBmb3JtYXRQcm9wcy5tYXRyaXgsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBlYXNpbmc6IGVhc2luZyxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIHN0YXJ0VGltZTogdGltZWxpbmUuZ2V0VGltZSgpLFxuICAgICAgaWQ6IFV0aWwudW5pcXVlSWQoKVxuICAgIH07IC8vIOWmguaenOWKqOeUu+mYn+WIl+S4reW3sue7j+aciei/meS4quWbvuW9ouS6hlxuXG4gICAgaWYgKGFuaW1hdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyDlhYjmo4Dmn6XmmK/lkKbpnIDopoHlkIjlubblsZ7mgKfjgILoi6XmnInnm7jlkIznmoTliqjnlLvvvIzlsIbor6XlsZ7mgKfku47liY3kuIDkuKrliqjnlLvkuK3liKDpmaQs55u05o6l55So5ZCO5LiA5Liq5Yqo55S75LitXG4gICAgICBhbmltYXRvcnMgPSBjaGVja0V4aXN0ZWRBdHRycyhhbmltYXRvcnMsIGFuaW1hdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g5ZCm5YiZ5bCG5Zu+5b2i5re75Yqg5Yiw6Zif5YiXXG4gICAgICB0aW1lbGluZS5hZGRBbmltYXRvcihzZWxmKTtcbiAgICB9XG5cbiAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ2FuaW1hdG9ycycsIGFuaW1hdG9ycyk7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ3BhdXNlJywge1xuICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG4gIHN0b3BBbmltYXRlOiBmdW5jdGlvbiBzdG9wQW5pbWF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuZ2V0KCdhbmltYXRvcnMnKTsgLy8g5bCG5Yqo55S75omn6KGM5Yiw5pyA5ZCO5LiA5bin77yM5omn6KGM5Zue6LCDXG5cbiAgICBVdGlsLmVhY2goYW5pbWF0b3JzLCBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgIF90aGlzLmF0dHIoYW5pbWF0b3IudG9BdHRycyk7XG5cbiAgICAgIGlmIChhbmltYXRvci50b01hdHJpeCkge1xuICAgICAgICBfdGhpcy5hdHRyKCdtYXRyaXgnLCBhbmltYXRvci50b01hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRvci5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRvci5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0U2lsZW50KCdhbmltYXRpbmcnLCBmYWxzZSk7XG4gICAgdGhpcy5zZXRTaWxlbnQoJ2FuaW1hdG9ycycsIFtdKTtcbiAgfSxcbiAgcGF1c2VBbmltYXRlOiBmdW5jdGlvbiBwYXVzZUFuaW1hdGUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aW1lbGluZSA9IHNlbGYuZ2V0KCd0aW1lbGluZScpOyAvLyDorrDlvZXkuIvmmK/lnKjku4DkuYjml7blgJnmmoLlgZznmoRcblxuICAgIHNlbGYuc2V0U2lsZW50KCdwYXVzZScsIHtcbiAgICAgIGlzUGF1c2VkOiB0cnVlLFxuICAgICAgcGF1c2VUaW1lOiB0aW1lbGluZS5nZXRUaW1lKClcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgcmVzdW1lQW5pbWF0ZTogZnVuY3Rpb24gcmVzdW1lQW5pbWF0ZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRpbWVsaW5lID0gc2VsZi5nZXQoJ3RpbWVsaW5lJyk7XG4gICAgdmFyIGN1cnJlbnQgPSB0aW1lbGluZS5nZXRUaW1lKCk7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHNlbGYuZ2V0KCdhbmltYXRvcnMnKTtcbiAgICB2YXIgcGF1c2VUaW1lID0gc2VsZi5nZXQoJ3BhdXNlJykucGF1c2VUaW1lOyAvLyDkuYvlkI7mm7TmlrDlsZ7mgKfpnIDopoHorqHnrpfliqjnlLvlt7Lnu4/miafooYznmoTml7bplb/vvIzlpoLmnpzmmoLlgZzkuobvvIzlsLHmiorliJ3lp4vml7bpl7TosIPlkI5cblxuICAgIFV0aWwuZWFjaChhbmltYXRvcnMsIGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgYW5pbWF0b3Iuc3RhcnRUaW1lID0gYW5pbWF0b3Iuc3RhcnRUaW1lICsgKGN1cnJlbnQgLSBwYXVzZVRpbWUpO1xuICAgICAgYW5pbWF0b3IuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgYW5pbWF0b3IuX3BhdXNlVGltZSA9IG51bGw7XG4gICAgfSk7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ3BhdXNlJywge1xuICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ2FuaW1hdG9ycycsIGFuaW1hdG9ycyk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblNoYXBlLkFyYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblNoYXBlLkNpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblNoYXBlLkRvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3KTtcblNoYXBlLkVsbGlwc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG5TaGFwZS5GYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XG5TaGFwZS5JbWFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblNoYXBlLkxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XG5TaGFwZS5NYXJrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblNoYXBlLlBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG5TaGFwZS5Qb2x5Z29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTMpO1xuU2hhcGUuUG9seWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5TaGFwZS5SZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpO1xuU2hhcGUuVGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbi8qKiovIH0pLFxuLyogMTg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEluc2lkZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXG52YXIgbWF0aFV0bCA9IHtcbiAgYXJjOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxcbiAgZWxsaXBzZTogX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpLFxuICBsaW5lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxufTtcbnZhciBjYW52YXMgPSBVdGlsLmNyZWF0ZURvbSgnPGNhbnZhcyB3aWR0aD1cIjUwMFwiIGhlaWdodD1cIjUwMFwiPjwvY2FudmFzPicpO1xudmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuZnVuY3Rpb24gaXNQb2ludEluUGF0aEJ5Q29udGV4dCh4LCB5LCBjdHgpIHtcbiAgY3R4LmNyZWF0ZVBhdGgoY29udGV4dCk7XG4gIHJldHVybiBjb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSk7XG59XG5cbnZhciBhcmMgPSBmdW5jdGlvbiBhcmMoeCwgeSkge1xuICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgdmFyIGN4ID0gYXR0cnMueDtcbiAgdmFyIGN5ID0gYXR0cnMueTtcbiAgdmFyIHIgPSBhdHRycy5yLFxuICAgICAgc3RhcnRBbmdsZSA9IGF0dHJzLnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlLFxuICAgICAgY2xvY2t3aXNlID0gYXR0cnMuY2xvY2t3aXNlO1xuICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcblxuICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgIHJldHVybiBJbnNpZGUuYXJjbGluZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIGxpbmVXaWR0aCwgeCwgeSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgY2lyY2xlID0gZnVuY3Rpb24gY2lyY2xlKHgsIHkpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gIHZhciBjeCA9IGF0dHJzLng7XG4gIHZhciBjeSA9IGF0dHJzLnk7XG4gIHZhciByID0gYXR0cnMucjtcbiAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0SGl0TGluZVdpZHRoKCk7XG4gIHZhciBmaWxsID0gdGhpcy5oYXNGaWxsKCk7XG4gIHZhciBzdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpO1xuXG4gIGlmIChmaWxsICYmIHN0cm9rZSkge1xuICAgIHJldHVybiBJbnNpZGUuY2lyY2xlKGN4LCBjeSwgciwgeCwgeSkgfHwgSW5zaWRlLmFyY2xpbmUoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UsIGxpbmVXaWR0aCwgeCwgeSk7XG4gIH1cblxuICBpZiAoZmlsbCkge1xuICAgIHJldHVybiBJbnNpZGUuY2lyY2xlKGN4LCBjeSwgciwgeCwgeSk7XG4gIH1cblxuICBpZiAoc3Ryb2tlKSB7XG4gICAgcmV0dXJuIEluc2lkZS5hcmNsaW5lKGN4LCBjeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlLCBsaW5lV2lkdGgsIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGVsbGlwc2UgPSBmdW5jdGlvbiBlbGxpcHNlKHgsIHkpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnM7XG4gIHZhciBmaWxsID0gdGhpcy5oYXNGaWxsKCk7XG4gIHZhciBzdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpO1xuICB2YXIgY3ggPSBhdHRycy54O1xuICB2YXIgY3kgPSBhdHRycy55O1xuICB2YXIgcnggPSBhdHRycy5yeDtcbiAgdmFyIHJ5ID0gYXR0cnMucnk7XG4gIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuICB2YXIgcCA9IFt4LCB5LCAxXTtcbiAgdmFyIG0gPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG4gIFV0aWwubWF0My5zY2FsZShtLCBtLCBbc2NhbGVYLCBzY2FsZVldKTtcbiAgVXRpbC5tYXQzLnRyYW5zbGF0ZShtLCBtLCBbY3gsIGN5XSk7XG4gIHZhciBpbm0gPSBVdGlsLm1hdDMuaW52ZXJ0KFtdLCBtKTtcbiAgVXRpbC52ZWMzLnRyYW5zZm9ybU1hdDMocCwgcCwgaW5tKTtcblxuICBpZiAoZmlsbCAmJiBzdHJva2UpIHtcbiAgICByZXR1cm4gSW5zaWRlLmNpcmNsZSgwLCAwLCByLCBwWzBdLCBwWzFdKSB8fCBJbnNpZGUuYXJjbGluZSgwLCAwLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UsIGxpbmVXaWR0aCwgcFswXSwgcFsxXSk7XG4gIH1cblxuICBpZiAoZmlsbCkge1xuICAgIHJldHVybiBJbnNpZGUuY2lyY2xlKDAsIDAsIHIsIHBbMF0sIHBbMV0pO1xuICB9XG5cbiAgaWYgKHN0cm9rZSkge1xuICAgIHJldHVybiBJbnNpZGUuYXJjbGluZSgwLCAwLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UsIGxpbmVXaWR0aCwgcFswXSwgcFsxXSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZmFuID0gZnVuY3Rpb24gZmFuKHgsIHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZmlsbCA9IHNlbGYuaGFzRmlsbCgpO1xuICB2YXIgc3Ryb2tlID0gc2VsZi5oYXNTdHJva2UoKTtcbiAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gIHZhciBjeCA9IGF0dHJzLng7XG4gIHZhciBjeSA9IGF0dHJzLnk7XG4gIHZhciBycyA9IGF0dHJzLnJzO1xuICB2YXIgcmUgPSBhdHRycy5yZTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlO1xuICB2YXIgZW5kQW5nbGUgPSBhdHRycy5lbmRBbmdsZTtcbiAgdmFyIGNsb2Nrd2lzZSA9IGF0dHJzLmNsb2Nrd2lzZTtcbiAgdmFyIHYxID0gWzEsIDBdO1xuICB2YXIgc3VidiA9IFt4IC0gY3gsIHkgLSBjeV07XG4gIHZhciBhbmdsZSA9IFV0aWwudmVjMi5hbmdsZVRvKHYxLCBzdWJ2KTtcblxuICBmdW5jdGlvbiBfaXNQb2ludEluRmlsbCgpIHtcbiAgICB2YXIgYW5nbGUxID0gbWF0aFV0bC5hcmMubmVhckFuZ2xlKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlKTtcblxuICAgIGlmIChVdGlsLmlzTnVtYmVyRXF1YWwoYW5nbGUsIGFuZ2xlMSkpIHtcbiAgICAgIHZhciBscyA9IFV0aWwudmVjMi5zcXVhcmVkTGVuZ3RoKHN1YnYpO1xuXG4gICAgICBpZiAocnMgKiBycyA8PSBscyAmJiBscyA8PSByZSAqIHJlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc1BvaW50SW5TdHJva2UoKSB7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHNlbGYuZ2V0SGl0TGluZVdpZHRoKCk7XG4gICAgdmFyIHNzcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKHN0YXJ0QW5nbGUpICogcnMgKyBjeCxcbiAgICAgIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpICogcnMgKyBjeVxuICAgIH07XG4gICAgdmFyIHNlcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmUgKyBjeCxcbiAgICAgIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmUgKyBjeVxuICAgIH07XG4gICAgdmFyIGVzcCA9IHtcbiAgICAgIHg6IE1hdGguY29zKGVuZEFuZ2xlKSAqIHJzICsgY3gsXG4gICAgICB5OiBNYXRoLnNpbihlbmRBbmdsZSkgKiBycyArIGN5XG4gICAgfTtcbiAgICB2YXIgZWVwID0ge1xuICAgICAgeDogTWF0aC5jb3MoZW5kQW5nbGUpICogcmUgKyBjeCxcbiAgICAgIHk6IE1hdGguc2luKGVuZEFuZ2xlKSAqIHJlICsgY3lcbiAgICB9O1xuXG4gICAgaWYgKEluc2lkZS5saW5lKHNzcC54LCBzc3AueSwgc2VwLngsIHNlcC55LCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoSW5zaWRlLmxpbmUoZXNwLngsIGVzcC55LCBlZXAueCwgZWVwLnksIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChJbnNpZGUuYXJjbGluZShjeCwgY3ksIHJzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoSW5zaWRlLmFyY2xpbmUoY3gsIGN5LCByZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgJiYgc3Ryb2tlKSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5GaWxsKCkgfHwgX2lzUG9pbnRJblN0cm9rZSgpO1xuICB9XG5cbiAgaWYgKGZpbGwpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkZpbGwoKTtcbiAgfVxuXG4gIGlmIChzdHJva2UpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJblN0cm9rZSgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGltYWdlID0gZnVuY3Rpb24gaW1hZ2UoeCwgeSkge1xuICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcblxuICBpZiAodGhpcy5nZXQoJ3RvRHJhdycpIHx8ICFhdHRycy5pbWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXRoaXMuX2NmZy5hdHRycyB8fCB0aGlzLl9jZmcuYXR0cnMuaW1nICE9PSBhdHRycy5pbWcpIHtcbiAgICB0aGlzLl9zZXRBdHRySW1nKCk7XG4gIH1cblxuICB2YXIgcnggPSBhdHRycy54O1xuICB2YXIgcnkgPSBhdHRycy55O1xuICB2YXIgd2lkdGggPSBhdHRycy53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcbiAgcmV0dXJuIEluc2lkZS5yZWN0KHJ4LCByeSwgd2lkdGgsIGhlaWdodCwgeCwgeSk7XG59O1xuXG52YXIgbGluZSA9IGZ1bmN0aW9uIGxpbmUoeCwgeSkge1xuICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycztcbiAgdmFyIHgxID0gYXR0cnMueDEsXG4gICAgICB5MSA9IGF0dHJzLnkxLFxuICAgICAgeDIgPSBhdHRycy54MixcbiAgICAgIHkyID0gYXR0cnMueTI7XG4gIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldEhpdExpbmVXaWR0aCgpO1xuXG4gIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgcmV0dXJuIEluc2lkZS5saW5lKHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHBhdGggPSBmdW5jdGlvbiBwYXRoKHgsIHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VnbWVudHMgPSBzZWxmLmdldCgnc2VnbWVudHMnKTtcbiAgdmFyIGZpbGwgPSBzZWxmLmhhc0ZpbGwoKTtcbiAgdmFyIHN0cm9rZSA9IHNlbGYuaGFzU3Ryb2tlKCk7XG5cbiAgZnVuY3Rpb24gX2lzUG9pbnRJblN0cm9rZSgpIHtcbiAgICBpZiAoIVV0aWwuaXNFbXB0eShzZWdtZW50cykpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzZWxmLmdldEhpdExpbmVXaWR0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoc2VnbWVudHNbaV0uaXNJbnNpZGUoeCwgeSwgbGluZVdpZHRoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlsbCAmJiBzdHJva2UpIHtcbiAgICByZXR1cm4gaXNQb2ludEluUGF0aEJ5Q29udGV4dCh4LCB5LCBzZWxmKSB8fCBfaXNQb2ludEluU3Ryb2tlKCk7XG4gIH1cblxuICBpZiAoZmlsbCkge1xuICAgIHJldHVybiBpc1BvaW50SW5QYXRoQnlDb250ZXh0KHgsIHksIHNlbGYpO1xuICB9XG5cbiAgaWYgKHN0cm9rZSkge1xuICAgIHJldHVybiBfaXNQb2ludEluU3Ryb2tlKCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgcG9seWdvbiA9IGZ1bmN0aW9uIHBvbHlnb24oeCwgeSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBmaWxsID0gc2VsZi5oYXNGaWxsKCk7XG4gIHZhciBzdHJva2UgPSBzZWxmLmhhc1N0cm9rZSgpO1xuXG4gIGZ1bmN0aW9uIF9pc1BvaW50SW5TdHJva2UoKSB7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG4gICAgdmFyIHBvaW50cyA9IGF0dHJzLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaW5lV2lkdGggPSBzZWxmLmdldEhpdExpbmVXaWR0aCgpO1xuICAgIHZhciBvdXRQb2ludHMgPSBwb2ludHMuc2xpY2UoMCk7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBvdXRQb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBJbnNpZGUucG9seWxpbmUob3V0UG9pbnRzLCBsaW5lV2lkdGgsIHgsIHkpO1xuICB9XG5cbiAgaWYgKGZpbGwgJiYgc3Ryb2tlKSB7XG4gICAgcmV0dXJuIGlzUG9pbnRJblBhdGhCeUNvbnRleHQoeCwgeSwgc2VsZikgfHwgX2lzUG9pbnRJblN0cm9rZSgpO1xuICB9XG5cbiAgaWYgKGZpbGwpIHtcbiAgICByZXR1cm4gaXNQb2ludEluUGF0aEJ5Q29udGV4dCh4LCB5LCBzZWxmKTtcbiAgfVxuXG4gIGlmIChzdHJva2UpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJblN0cm9rZSgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIG1hcmtlciA9IGZ1bmN0aW9uIG1hcmtlcih4LCB5KSB7XG4gIHZhciBhdHRycyA9IHRoaXMuX2F0dHJzO1xuICB2YXIgY3ggPSBhdHRycy54O1xuICB2YXIgY3kgPSBhdHRycy55O1xuICB2YXIgciA9IGF0dHJzLnJhZGl1cyB8fCBhdHRycy5yO1xuICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRIaXRMaW5lV2lkdGgoKTtcbiAgcmV0dXJuIEluc2lkZS5jaXJjbGUoY3gsIGN5LCByICsgbGluZVdpZHRoIC8gMiwgeCwgeSk7XG59O1xuXG52YXIgcG9seWxpbmUgPSBmdW5jdGlvbiBwb2x5bGluZSh4LCB5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnM7XG5cbiAgaWYgKHNlbGYuaGFzU3Ryb2tlKCkpIHtcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVXaWR0aCA9IGF0dHJzLmxpbmVXaWR0aDtcbiAgICByZXR1cm4gSW5zaWRlLnBvbHlsaW5lKHBvaW50cywgbGluZVdpZHRoLCB4LCB5KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciByZWN0ID0gZnVuY3Rpb24gcmVjdCh4LCB5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGZpbGwgPSBzZWxmLmhhc0ZpbGwoKTtcbiAgdmFyIHN0cm9rZSA9IHNlbGYuaGFzU3Ryb2tlKCk7XG5cbiAgZnVuY3Rpb24gX2lzUG9pbnRJblN0cm9rZSgpIHtcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycztcbiAgICB2YXIgcnggPSBhdHRycy54O1xuICAgIHZhciByeSA9IGF0dHJzLnk7XG4gICAgdmFyIHdpZHRoID0gYXR0cnMud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcbiAgICB2YXIgcmFkaXVzID0gYXR0cnMucmFkaXVzO1xuICAgIHZhciBsaW5lV2lkdGggPSBzZWxmLmdldEhpdExpbmVXaWR0aCgpO1xuXG4gICAgaWYgKHJhZGl1cyA9PT0gMCkge1xuICAgICAgdmFyIGhhbGZXaWR0aCA9IGxpbmVXaWR0aCAvIDI7XG4gICAgICByZXR1cm4gSW5zaWRlLmxpbmUocnggLSBoYWxmV2lkdGgsIHJ5LCByeCArIHdpZHRoICsgaGFsZldpZHRoLCByeSwgbGluZVdpZHRoLCB4LCB5KSB8fCBJbnNpZGUubGluZShyeCArIHdpZHRoLCByeSAtIGhhbGZXaWR0aCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgKyBoYWxmV2lkdGgsIGxpbmVXaWR0aCwgeCwgeSkgfHwgSW5zaWRlLmxpbmUocnggKyB3aWR0aCArIGhhbGZXaWR0aCwgcnkgKyBoZWlnaHQsIHJ4IC0gaGFsZldpZHRoLCByeSArIGhlaWdodCwgbGluZVdpZHRoLCB4LCB5KSB8fCBJbnNpZGUubGluZShyeCwgcnkgKyBoZWlnaHQgKyBoYWxmV2lkdGgsIHJ4LCByeSAtIGhhbGZXaWR0aCwgbGluZVdpZHRoLCB4LCB5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW5zaWRlLmxpbmUocnggKyByYWRpdXMsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSwgbGluZVdpZHRoLCB4LCB5KSB8fCBJbnNpZGUubGluZShyeCArIHdpZHRoLCByeSArIHJhZGl1cywgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMsIGxpbmVXaWR0aCwgeCwgeSkgfHwgSW5zaWRlLmxpbmUocnggKyB3aWR0aCAtIHJhZGl1cywgcnkgKyBoZWlnaHQsIHJ4ICsgcmFkaXVzLCByeSArIGhlaWdodCwgbGluZVdpZHRoLCB4LCB5KSB8fCBJbnNpZGUubGluZShyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMsIHJ4LCByeSArIHJhZGl1cywgbGluZVdpZHRoLCB4LCB5KSB8fCBJbnNpZGUuYXJjbGluZShyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIHJhZGl1cywgcmFkaXVzLCAxLjUgKiBNYXRoLlBJLCAyICogTWF0aC5QSSwgZmFsc2UsIGxpbmVXaWR0aCwgeCwgeSkgfHwgSW5zaWRlLmFyY2xpbmUocnggKyB3aWR0aCAtIHJhZGl1cywgcnkgKyBoZWlnaHQgLSByYWRpdXMsIHJhZGl1cywgMCwgMC41ICogTWF0aC5QSSwgZmFsc2UsIGxpbmVXaWR0aCwgeCwgeSkgfHwgSW5zaWRlLmFyY2xpbmUocnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzLCByYWRpdXMsIDAuNSAqIE1hdGguUEksIE1hdGguUEksIGZhbHNlLCBsaW5lV2lkdGgsIHgsIHkpIHx8IEluc2lkZS5hcmNsaW5lKHJ4ICsgcmFkaXVzLCByeSArIHJhZGl1cywgcmFkaXVzLCBNYXRoLlBJLCAxLjUgKiBNYXRoLlBJLCBmYWxzZSwgbGluZVdpZHRoLCB4LCB5KTtcbiAgfVxuXG4gIGlmIChmaWxsICYmIHN0cm9rZSkge1xuICAgIHJldHVybiBpc1BvaW50SW5QYXRoQnlDb250ZXh0KHgsIHksIHNlbGYpIHx8IF9pc1BvaW50SW5TdHJva2UoKTtcbiAgfVxuXG4gIGlmIChmaWxsKSB7XG4gICAgcmV0dXJuIGlzUG9pbnRJblBhdGhCeUNvbnRleHQoeCwgeSwgc2VsZik7XG4gIH1cblxuICBpZiAoc3Ryb2tlKSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5TdHJva2UoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dCh4LCB5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJveCA9IHNlbGYuZ2V0QkJveCgpO1xuXG4gIGlmIChzZWxmLmhhc0ZpbGwoKSB8fCBzZWxmLmhhc1N0cm9rZSgpKSB7XG4gICAgcmV0dXJuIEluc2lkZS5ib3goYm94Lm1pblgsIGJveC5tYXhYLCBib3gubWluWSwgYm94Lm1heFksIHgsIHkpO1xuICB9XG59O1xuXG52YXIgZG9tID0gZnVuY3Rpb24gZG9tKHgsIHkpIHtcbiAgaWYgKCF0aGlzLl9jZmcuZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYm94ID0gdGhpcy5fY2ZnLmVsLmdldEJCb3goKTtcblxuICByZXR1cm4gSW5zaWRlLmJveChib3gueCwgYm94LnggKyBib3gud2lkdGgsIGJveC55LCBib3gueSArIGJveC5oZWlnaHQsIHgsIHkpO1xufTtcblxudmFyIHNoYXBlcyA9IHtcbiAgYXJjOiBhcmMsXG4gIGNpcmNsZTogY2lyY2xlLFxuICBkb206IGRvbSxcbiAgZWxsaXBzZTogZWxsaXBzZSxcbiAgZmFuOiBmYW4sXG4gIGltYWdlOiBpbWFnZSxcbiAgbGluZTogbGluZSxcbiAgcGF0aDogcGF0aCxcbiAgbWFya2VyOiBtYXJrZXIsXG4gIHBvbHlnb246IHBvbHlnb24sXG4gIHBvbHlsaW5lOiBwb2x5bGluZSxcbiAgcmVjdDogcmVjdCxcbiAgdGV4dDogdGV4dFxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1BvaW50SW5QYXRoOiBmdW5jdGlvbiBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICB2YXIgc2hhcGUgPSBzaGFwZXNbdGhpcy50eXBlXTtcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmNhbGwodGhpcywgeCwgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBQYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG52YXIgZDNUaW1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcwKTtcblxudmFyIGQzRWFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTczKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpLFxuICAgIGludGVycG9sYXRlID0gX3JlcXVpcmUuaW50ZXJwb2xhdGUsXG4gICAgaW50ZXJwb2xhdGVBcnJheSA9IF9yZXF1aXJlLmludGVycG9sYXRlQXJyYXk7IC8vIOebruWJjeaVtOS9k+WKqOeUu+WPqumcgOimgeaVsOWAvOWSjOaVsOe7hOeahOW3ruWAvOiuoeeul1xuXG5cbnZhciBUaW1lbGluZSA9IGZ1bmN0aW9uIFRpbWVsaW5lKGNhbnZhcykge1xuICAvLyDlvoXmiafooYzliqjnlLvnmoTpmJ/liJdcbiAgdGhpcy5fYW5pbWF0b3JzID0gW107IC8vIOW9k+WJjeaXtumXtFxuXG4gIHRoaXMuX2N1cnJlbnQgPSAwOyAvLyDorqHml7blmajlrp7kvotcblxuICB0aGlzLl90aW1lciA9IG51bGw7IC8vIOeUu+W4g1xuXG4gIHRoaXMuY2FudmFzID0gY2FudmFzO1xufTtcblxuZnVuY3Rpb24gX3VwZGF0ZShzZWxmLCBhbmltYXRvciwgcmF0aW8pIHtcbiAgdmFyIGNQcm9wcyA9IHt9OyAvLyDmraTliLvlsZ7mgKdcblxuICB2YXIgdG9BdHRycyA9IGFuaW1hdG9yLnRvQXR0cnM7XG4gIHZhciBmcm9tQXR0cnMgPSBhbmltYXRvci5mcm9tQXR0cnM7XG4gIHZhciB0b01hdHJpeCA9IGFuaW1hdG9yLnRvTWF0cml4O1xuXG4gIGlmIChzZWxmLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW50ZXJmOyAvLyAg5beu5YC85Ye95pWwXG5cbiAgZm9yICh2YXIgayBpbiB0b0F0dHJzKSB7XG4gICAgaWYgKCFVdGlsLmlzRXF1YWwoZnJvbUF0dHJzW2tdLCB0b0F0dHJzW2tdKSkge1xuICAgICAgaWYgKGsgPT09ICdwYXRoJykge1xuICAgICAgICB2YXIgdG9QYXRoID0gdG9BdHRyc1trXTtcbiAgICAgICAgdmFyIGZyb21QYXRoID0gZnJvbUF0dHJzW2tdO1xuXG4gICAgICAgIGlmICh0b1BhdGgubGVuZ3RoID4gZnJvbVBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgdG9QYXRoID0gUGF0aFV0aWwucGFyc2VQYXRoU3RyaW5nKHRvQXR0cnNba10pOyAvLyDnu4jngrnnirbmgIFcblxuICAgICAgICAgIGZyb21QYXRoID0gUGF0aFV0aWwucGFyc2VQYXRoU3RyaW5nKGZyb21BdHRyc1trXSk7IC8vIOi1t+Wni+eKtuaAgVxuXG4gICAgICAgICAgZnJvbVBhdGggPSBQYXRoVXRpbC5maWxsUGF0aEJ5RGlmZihmcm9tUGF0aCwgdG9QYXRoKTtcbiAgICAgICAgICBmcm9tUGF0aCA9IFBhdGhVdGlsLmZvcm1hdFBhdGgoZnJvbVBhdGgsIHRvUGF0aCk7XG4gICAgICAgICAgYW5pbWF0b3IuZnJvbUF0dHJzLnBhdGggPSBmcm9tUGF0aDtcbiAgICAgICAgICBhbmltYXRvci50b0F0dHJzLnBhdGggPSB0b1BhdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFuaW1hdG9yLnBhdGhGb3JtYXR0ZWQpIHtcbiAgICAgICAgICB0b1BhdGggPSBQYXRoVXRpbC5wYXJzZVBhdGhTdHJpbmcodG9BdHRyc1trXSk7XG4gICAgICAgICAgZnJvbVBhdGggPSBQYXRoVXRpbC5wYXJzZVBhdGhTdHJpbmcoZnJvbUF0dHJzW2tdKTtcbiAgICAgICAgICBmcm9tUGF0aCA9IFBhdGhVdGlsLmZvcm1hdFBhdGgoZnJvbVBhdGgsIHRvUGF0aCk7XG4gICAgICAgICAgYW5pbWF0b3IuZnJvbUF0dHJzLnBhdGggPSBmcm9tUGF0aDtcbiAgICAgICAgICBhbmltYXRvci50b0F0dHJzLnBhdGggPSB0b1BhdGg7XG4gICAgICAgICAgYW5pbWF0b3IucGF0aEZvcm1hdHRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjUHJvcHNba10gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0b1BhdGhQb2ludCA9IHRvUGF0aFtpXTtcbiAgICAgICAgICB2YXIgZnJvbVBhdGhQb2ludCA9IGZyb21QYXRoW2ldO1xuICAgICAgICAgIHZhciBjUGF0aFBvaW50ID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRvUGF0aFBvaW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc051bWJlcih0b1BhdGhQb2ludFtqXSkgJiYgZnJvbVBhdGhQb2ludCAmJiBVdGlsLmlzTnVtYmVyKGZyb21QYXRoUG9pbnRbal0pKSB7XG4gICAgICAgICAgICAgIGludGVyZiA9IGludGVycG9sYXRlKGZyb21QYXRoUG9pbnRbal0sIHRvUGF0aFBvaW50W2pdKTtcbiAgICAgICAgICAgICAgY1BhdGhQb2ludC5wdXNoKGludGVyZihyYXRpbykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY1BhdGhQb2ludC5wdXNoKHRvUGF0aFBvaW50W2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjUHJvcHNba10ucHVzaChjUGF0aFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJmID0gaW50ZXJwb2xhdGUoZnJvbUF0dHJzW2tdLCB0b0F0dHJzW2tdKTtcbiAgICAgICAgY1Byb3BzW2tdID0gaW50ZXJmKHJhdGlvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodG9NYXRyaXgpIHtcbiAgICB2YXIgbWYgPSBpbnRlcnBvbGF0ZUFycmF5KGFuaW1hdG9yLmZyb21NYXRyaXgsIHRvTWF0cml4KTtcbiAgICB2YXIgY00gPSBtZihyYXRpbyk7XG4gICAgc2VsZi5zZXRNYXRyaXgoY00pO1xuICB9XG5cbiAgc2VsZi5hdHRyKGNQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZShzaGFwZSwgYW5pbWF0b3IsIGVsYXBzZWQpIHtcbiAgdmFyIHN0YXJ0VGltZSA9IGFuaW1hdG9yLnN0YXJ0VGltZTsgLy8g5aaC5p6c6L+Y5rKh5pyJ5byA5aeL5omn6KGM5oiW5pqC5YGc77yM5YWI5LiN5pu05pawXG5cbiAgaWYgKGVsYXBzZWQgPCBzdGFydFRpbWUgKyBhbmltYXRvci5kZWxheSB8fCBhbmltYXRvci5pc1BhdXNlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByYXRpbztcbiAgdmFyIGR1cmF0aW9uID0gYW5pbWF0b3IuZHVyYXRpb247XG4gIHZhciBlYXNpbmcgPSBhbmltYXRvci5lYXNpbmc7IC8vIOW3suaJp+ihjOaXtumXtFxuXG4gIGVsYXBzZWQgPSBlbGFwc2VkIC0gc3RhcnRUaW1lIC0gYW5pbWF0b3IuZGVsYXk7XG5cbiAgaWYgKGFuaW1hdG9yLnRvQXR0cnMucmVwZWF0KSB7XG4gICAgcmF0aW8gPSBlbGFwc2VkICUgZHVyYXRpb24gLyBkdXJhdGlvbjtcbiAgICByYXRpbyA9IGQzRWFzZVtlYXNpbmddKHJhdGlvKTtcbiAgfSBlbHNlIHtcbiAgICByYXRpbyA9IGVsYXBzZWQgLyBkdXJhdGlvbjtcblxuICAgIGlmIChyYXRpbyA8IDEpIHtcbiAgICAgIHJhdGlvID0gZDNFYXNlW2Vhc2luZ10ocmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZS5hdHRyKGFuaW1hdG9yLnRvQXR0cnMpO1xuXG4gICAgICBpZiAoYW5pbWF0b3IudG9NYXRyaXgpIHtcbiAgICAgICAgc2hhcGUuc2V0TWF0cml4KGFuaW1hdG9yLnRvTWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZShzaGFwZSwgYW5pbWF0b3IsIHJhdGlvKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cblV0aWwuYXVnbWVudChUaW1lbGluZSwge1xuICBpbml0VGltZXI6IGZ1bmN0aW9uIGluaXRUaW1lcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdmFyIHNoYXBlLCBhbmltYXRvcnMsIGFuaW1hdG9yO1xuICAgIHNlbGYuX3RpbWVyID0gZDNUaW1lci50aW1lcihmdW5jdGlvbiAoZWxhcHNlZCkge1xuICAgICAgc2VsZi5fY3VycmVudCA9IGVsYXBzZWQ7XG5cbiAgICAgIGlmIChfdGhpcy5fYW5pbWF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IF90aGlzLl9hbmltYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBzaGFwZSA9IF90aGlzLl9hbmltYXRvcnNbaV07XG5cbiAgICAgICAgICBpZiAoc2hhcGUuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5bey57uP6KKr6ZSA5q+B77yM55u05o6l56e75Ye66Zif5YiXXG4gICAgICAgICAgICBzZWxmLnJlbW92ZUFuaW1hdG9yKGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzaGFwZS5nZXQoJ3BhdXNlJykuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIGFuaW1hdG9ycyA9IHNoYXBlLmdldCgnYW5pbWF0b3JzJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBhbmltYXRvcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgYW5pbWF0b3IgPSBhbmltYXRvcnNbal07XG4gICAgICAgICAgICAgIGlzRmluaXNoZWQgPSB1cGRhdGUoc2hhcGUsIGFuaW1hdG9yLCBlbGFwc2VkKTtcblxuICAgICAgICAgICAgICBpZiAoaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ycy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBhbmltYXRvci5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUFuaW1hdG9yKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbnZhcy5kcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiBhZGRBbmltYXRvcihzaGFwZSkge1xuICAgIHRoaXMuX2FuaW1hdG9ycy5wdXNoKHNoYXBlKTtcbiAgfSxcbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIHJlbW92ZUFuaW1hdG9yKGluZGV4KSB7XG4gICAgdGhpcy5fYW5pbWF0b3JzLnNwbGljZShpbmRleCwgMSk7XG4gIH0sXG4gIGlzQW5pbWF0aW5nOiBmdW5jdGlvbiBpc0FuaW1hdGluZygpIHtcbiAgICByZXR1cm4gISF0aGlzLl9hbmltYXRvcnMubGVuZ3RoO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgdGhpcy5fdGltZXIuc3RvcCgpO1xuICAgIH1cbiAgfSxcbiAgc3RvcEFsbEFuaW1hdGlvbnM6IGZ1bmN0aW9uIHN0b3BBbGxBbmltYXRpb25zKCkge1xuICAgIHRoaXMuX2FuaW1hdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgYW5pbWF0b3Iuc3RvcEFuaW1hdGUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2FuaW1hdG9ycyA9IFtdO1xuICAgIHRoaXMuY2FudmFzLmRyYXcoKTtcbiAgfSxcbiAgZ2V0VGltZTogZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lO1xuXG4vKioqLyB9KSxcbi8qIDE5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RpbWVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdGltZXJfX1tcImFcIiAvKiBUaW1lciAqL10oKTtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIChlbGFwc2VkKSB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RpbWVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdGltZXJfX1tcImFcIiAvKiBUaW1lciAqL10oKSxcbiAgICAgIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdGltZXJfX1tcImJcIiAvKiBub3cgKi9dKSgpIDogK3RpbWU7XG4gIHQucmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgIHQucmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGxpbmVhcjtcbmZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiArdDtcbn1cblxuLyoqKi8gfSksXG4vKiAxOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHF1YWRJbjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gcXVhZE91dDtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJiXCJdID0gcXVhZEluT3V0O1xuZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gIHJldHVybiB0ICogKDIgLSB0KTtcbn1cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cblxuLyoqKi8gfSksXG4vKiAxOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGN1YmljSW47XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY1wiXSA9IGN1YmljT3V0O1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBjdWJpY0luT3V0O1xuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5mdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn1cblxuLyoqKi8gfSksXG4vKiAxOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBvbHlJbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBvbHlPdXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwb2x5SW5PdXQ7IH0pO1xudmFyIGV4cG9uZW50ID0gMztcbnZhciBwb2x5SW4gPSBmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gIH1cblxuICBwb2x5SW4uZXhwb25lbnQgPSBjdXN0b207XG4gIHJldHVybiBwb2x5SW47XG59KGV4cG9uZW50KTtcbnZhciBwb2x5T3V0ID0gZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlPdXQodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIGUpO1xuICB9XG5cbiAgcG9seU91dC5leHBvbmVudCA9IGN1c3RvbTtcbiAgcmV0dXJuIHBvbHlPdXQ7XG59KGV4cG9uZW50KTtcbnZhciBwb2x5SW5PdXQgPSBmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdyh0LCBlKSA6IDIgLSBNYXRoLnBvdygyIC0gdCwgZSkpIC8gMjtcbiAgfVxuXG4gIHBvbHlJbk91dC5leHBvbmVudCA9IGN1c3RvbTtcbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0oZXhwb25lbnQpO1xuXG4vKioqLyB9KSxcbi8qIDE5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gc2luSW47XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY1wiXSA9IHNpbk91dDtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJiXCJdID0gc2luSW5PdXQ7XG52YXIgcGkgPSBNYXRoLlBJLFxuICAgIGhhbGZQaSA9IHBpIC8gMjtcbmZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cbmZ1bmN0aW9uIHNpbk91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNpbih0ICogaGFsZlBpKTtcbn1cbmZ1bmN0aW9uIHNpbkluT3V0KHQpIHtcbiAgcmV0dXJuICgxIC0gTWF0aC5jb3MocGkgKiB0KSkgLyAyO1xufVxuXG4vKioqLyB9KSxcbi8qIDE5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gZXhwSW47XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY1wiXSA9IGV4cE91dDtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJiXCJdID0gZXhwSW5PdXQ7XG5mdW5jdGlvbiBleHBJbih0KSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCk7XG59XG5mdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xufVxuZnVuY3Rpb24gZXhwSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCkgOiAyIC0gTWF0aC5wb3coMiwgMTAgLSAxMCAqIHQpKSAvIDI7XG59XG5cbi8qKiovIH0pLFxuLyogMTk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBjaXJjbGVJbjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gY2lyY2xlT3V0O1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBjaXJjbGVJbk91dDtcbmZ1bmN0aW9uIGNpcmNsZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNsZU91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG5cbi8qKiovIH0pLFxuLyogMjAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBib3VuY2VJbjtcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gYm91bmNlT3V0O1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBib3VuY2VJbk91dDtcbnZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XG59XG5mdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICByZXR1cm4gKHQgPSArdCkgPCBiMSA/IGIwICogdCAqIHQgOiB0IDwgYjMgPyBiMCAqICh0IC09IGIyKSAqIHQgKyBiNCA6IHQgPCBiNiA/IGIwICogKHQgLT0gYjUpICogdCArIGI3IDogYjAgKiAodCAtPSBiOCkgKiB0ICsgYjk7XG59XG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhY2tJbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhY2tPdXQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYWNrSW5PdXQ7IH0pO1xudmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG52YXIgYmFja0luID0gZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuICByZXR1cm4gYmFja0luO1xufShvdmVyc2hvb3QpO1xudmFyIGJhY2tPdXQgPSBmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcbiAgcmV0dXJuIGJhY2tPdXQ7XG59KG92ZXJzaG9vdCk7XG52YXIgYmFja0luT3V0ID0gZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuICByZXR1cm4gYmFja0luT3V0O1xufShvdmVyc2hvb3QpO1xuXG4vKioqLyB9KSxcbi8qIDIwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWxhc3RpY0luOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWxhc3RpY091dDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVsYXN0aWNJbk91dDsgfSk7XG52YXIgdGF1ID0gMiAqIE1hdGguUEksXG4gICAgYW1wbGl0dWRlID0gMSxcbiAgICBwZXJpb2QgPSAwLjM7XG52YXIgZWxhc3RpY0luID0gZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7XG4gIH07XG5cbiAgZWxhc3RpY0luLnBlcmlvZCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIGN1c3RvbShhLCBwKTtcbiAgfTtcblxuICByZXR1cm4gZWxhc3RpY0luO1xufShhbXBsaXR1ZGUsIHBlcmlvZCk7XG52YXIgZWxhc3RpY091dCA9IGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAxIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0ID0gK3QpKSAqIE1hdGguc2luKCh0ICsgcykgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNPdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpO1xuICB9O1xuXG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gY3VzdG9tKGEsIHApO1xuICB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufShhbXBsaXR1ZGUsIHBlcmlvZCk7XG52YXIgZWxhc3RpY0luT3V0ID0gZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ID0gdCAqIDIgLSAxKSA8IDAgPyBhICogTWF0aC5wb3coMiwgMTAgKiB0KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKSA6IDIgLSBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigocyArIHQpIC8gcCkpIC8gMjtcbiAgfVxuXG4gIGVsYXN0aWNJbk91dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7XG4gIH07XG5cbiAgZWxhc3RpY0luT3V0LnBlcmlvZCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIGN1c3RvbShhLCBwKTtcbiAgfTtcblxuICByZXR1cm4gZWxhc3RpY0luT3V0O1xufShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbi8qKiovIH0pLFxuLyogMjAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBsYWI7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgTGFiICovXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYlwiXSA9IGhjbDtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBIY2wgKi9cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19tYXRoX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cblxuXG52YXIgS24gPSAxOCxcbiAgICBYbiA9IDAuOTUwNDcwLFxuICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuWW4gPSAxLFxuICAgIFpuID0gMS4wODg4MzAsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuXG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgdmFyIGggPSBvLmggKiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21hdGhfX1tcImFcIiAvKiBkZWcycmFkICovXTtcbiAgICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbiAgfVxuXG4gIGlmICghKG8gaW5zdGFuY2VvZiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJiXCIgLyogUmdiICovXSkpIG8gPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiaFwiIC8qIHJnYkNvbnZlcnQgKi9dKShvKTtcbiAgdmFyIGIgPSByZ2IyeHl6KG8uciksXG4gICAgICBhID0gcmdiMnh5eihvLmcpLFxuICAgICAgbCA9IHJnYjJ4eXooby5iKSxcbiAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiBiICsgMC4zNTc1NzYxICogYSArIDAuMTgwNDM3NSAqIGwpIC8gWG4pLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIGIgKyAwLjcxNTE1MjIgKiBhICsgMC4wNzIxNzUwICogbCkgLyBZbiksXG4gICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogYiArIDAuMTE5MTkyMCAqIGEgKyAwLjk1MDMwNDEgKiBsKSAvIFpuKTtcbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cbmZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGVmaW5lX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKExhYiwgbGFiLCBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWZpbmVfX1tcImJcIiAvKiBleHRlbmQgKi9dKShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogQ29sb3IgKi9dLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJiXCIgLyogUmdiICovXSh4eXoycmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIC8vIEQ2NSAtPiBzUkdCXG4gICAgeHl6MnJnYigtMC45NjkyNjYwICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NjAgKiB6KSwgeHl6MnJnYigwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopLCB0aGlzLm9wYWNpdHkpO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24geHl6MnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19tYXRoX19bXCJiXCIgLyogcmFkMmRlZyAqL107XG4gIHJldHVybiBuZXcgSGNsKGggPCAwID8gaCArIDM2MCA6IGgsIE1hdGguc3FydChvLmEgKiBvLmEgKyBvLmIgKiBvLmIpLCBvLmwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5PYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWZpbmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoSGNsLCBoY2wsIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fW1wiYlwiIC8qIGV4dGVuZCAqL10pKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBDb2xvciAqL10sIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsYWJDb252ZXJ0KHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBjdWJlaGVsaXg7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgQ3ViZWhlbGl4ICovXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWZpbmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fbWF0aF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTgpO1xuXG5cblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYlwiIC8qIFJnYiAqL10pKSBvID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImhcIiAvKiByZ2JDb252ZXJ0ICovXSkobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSxcbiAgICAgIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21hdGhfX1tcImJcIiAvKiByYWQyZGVnICovXSAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5mdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cbk9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlZmluZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGVmaW5lX19bXCJiXCIgLyogZXh0ZW5kICovXSkoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIENvbG9yICovXSwge1xuICBicmlnaHRlcjogZnVuY3Rpb24gKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiY1wiIC8qIGJyaWdodGVyICovXSA6IE1hdGgucG93KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImNcIiAvKiBicmlnaHRlciAqL10sIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImRcIiAvKiBkYXJrZXIgKi9dIDogTWF0aC5wb3coX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiZFwiIC8qIGRhcmtlciAqL10sIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21hdGhfX1tcImFcIiAvKiBkZWcycmFkICovXSxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImJcIiAvKiBSZ2IgKi9dKDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLCB0aGlzLm9wYWNpdHkpO1xuICB9XG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcbiAgfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19udW1iZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcGFyc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3KTtcblxuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX251bWJlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh4YSwgeGIpXG4gICAgICB9LCB7XG4gICAgICAgIGk6IGkgLSAyLFxuICAgICAgICB4OiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19udW1iZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoeWEsIHliKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwO2Vsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuXG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsXG4gICAgICAgIHg6IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX251bWJlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShhLCBiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsXG4gICAgICAgIHg6IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX251bWJlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShhLCBiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IGkgLSA0LFxuICAgICAgICB4OiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19udW1iZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoeGEsIHhiKVxuICAgICAgfSwge1xuICAgICAgICBpOiBpIC0gMixcbiAgICAgICAgeDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbnVtYmVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHlhLCB5YilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBzID0gW10sXG4gICAgICAgIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgbiA9IHEubGVuZ3RoLFxuICAgICAgICAgIG87XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG5cbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19wYXJzZV9fW1wiYVwiIC8qIHBhcnNlQ3NzICovXSwgXCJweCwgXCIsIFwicHgpXCIsIFwiZGVnKVwiKTtcbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcGFyc2VfX1tcImJcIiAvKiBwYXJzZVN2ZyAqL10sIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcblxuLyoqKi8gfSksXG4vKiAyMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHBhcnNlQ3NzO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSBwYXJzZVN2Zztcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlY29tcG9zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDgpO1xuXG52YXIgY3NzTm9kZSwgY3NzUm9vdCwgY3NzVmlldywgc3ZnTm9kZTtcbmZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJub25lXCIpIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2RlY29tcG9zZV9fW1wiYlwiIC8qIGlkZW50aXR5ICovXTtcbiAgaWYgKCFjc3NOb2RlKSBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgY3NzUm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY3NzVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjc3NOb2RlLnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlO1xuICB2YWx1ZSA9IGNzc1ZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjc3NSb290LmFwcGVuZENoaWxkKGNzc05vZGUpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpO1xuICBjc3NSb290LnJlbW92ZUNoaWxkKGNzc05vZGUpO1xuICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDcsIC0xKS5zcGxpdChcIixcIik7XG4gIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWNvbXBvc2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoK3ZhbHVlWzBdLCArdmFsdWVbMV0sICt2YWx1ZVsyXSwgK3ZhbHVlWzNdLCArdmFsdWVbNF0sICt2YWx1ZVs1XSk7XG59XG5mdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGVjb21wb3NlX19bXCJiXCIgLyogaWRlbnRpdHkgKi9dO1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19kZWNvbXBvc2VfX1tcImJcIiAvKiBpZGVudGl0eSAqL107XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fZGVjb21wb3NlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuXG4vKioqLyB9KSxcbi8qIDIwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaWRlbnRpdHk7IH0pO1xudmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xudmFyIGlkZW50aXR5ID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMjA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIHJobyA9IE1hdGguU1FSVDIsXG4gICAgcmhvMiA9IDIsXG4gICAgcmhvNCA9IDQsXG4gICAgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn0gLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHAwLCBwMSkge1xuICB2YXIgdXgwID0gcDBbMF0sXG4gICAgICB1eTAgPSBwMFsxXSxcbiAgICAgIHcwID0gcDBbMl0sXG4gICAgICB1eDEgPSBwMVswXSxcbiAgICAgIHV5MSA9IHAxWzFdLFxuICAgICAgdzEgPSBwMVsyXSxcbiAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgaSxcbiAgICAgIFM7IC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuXG4gICAgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gW3V4MCArIHQgKiBkeCwgdXkwICsgdCAqIGR5LCB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKV07XG4gICAgfTtcbiAgfSAvLyBHZW5lcmFsIGNhc2UuXG4gIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcblxuICAgICAgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFt1eDAgKyB1ICogZHgsIHV5MCArIHUgKiBkeSwgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMCldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwO1xuICByZXR1cm4gaTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaHNsTG9uZzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuXG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fW1wiZFwiIC8qIGhzbCAqL10pKHN0YXJ0KSkuaCwgKGVuZCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImRcIiAvKiBoc2wgKi9dKShlbmQpKS5oKSxcbiAgICAgICAgcyA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGhzbChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJjXCIgLyogaHVlICovXSkpO1xudmFyIGhzbExvbmcgPSBoc2woX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuLyoqKi8gfSksXG4vKiAyMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGxhYjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5cbmZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoKHN0YXJ0ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fW1wiZVwiIC8qIGxhYiAqL10pKHN0YXJ0KSkubCwgKGVuZCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImVcIiAvKiBsYWIgKi9dKShlbmQpKS5sKSxcbiAgICAgIGEgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhjbExvbmc7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cblxuXG5mdW5jdGlvbiBoY2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImNcIiAvKiBoY2wgKi9dKShzdGFydCkpLmgsIChlbmQgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX19bXCJjXCIgLyogaGNsICovXSkoZW5kKSkuaCksXG4gICAgICAgIGMgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdGFydC5jLCBlbmQuYyksXG4gICAgICAgIGwgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChoY2woX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiY1wiIC8qIGh1ZSAqL10pKTtcbnZhciBoY2xMb25nID0gaGNsKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cbi8qKiovIH0pLFxuLyogMjEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdWJlaGVsaXhMb25nOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5cblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2NvbG9yX19bXCJiXCIgLyogY3ViZWhlbGl4ICovXSkoc3RhcnQpKS5oLCAoZW5kID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fW1wiYlwiIC8qIGN1YmVoZWxpeCAqL10pKGVuZCkpLmgpLFxuICAgICAgICAgIHMgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzdGFydC5zLCBlbmQucyksXG4gICAgICAgICAgbCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2NvbG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgICBvcGFjaXR5ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSgxKTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYlwiXSA9IChjdWJlaGVsaXgoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19jb2xvcl9fW1wiY1wiIC8qIGh1ZSAqL10pKTtcbnZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29sb3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cbi8qKiovIH0pLFxuLyogMjE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcblxuICByZXR1cm4gc2FtcGxlcztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2FudmFzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNiksXG4gIHN2ZzogX193ZWJwYWNrX3JlcXVpcmVfXygyMTkpXG59O1xuXG4vKioqLyB9KSxcbi8qIDIxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFpbnRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygyMTcpXG59O1xuXG4vKioqLyB9KSxcbi8qIDIxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciByZW5kZXJVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTgpO1xuXG52YXIgU0hBUEVfQVRUUlMgPSBbJ2ZpbGxTdHlsZScsICdmb250JywgJ2dsb2JhbEFscGhhJywgJ2xpbmVDYXAnLCAnbGluZVdpZHRoJywgJ2xpbmVKb2luJywgJ21pdGVyTGltaXQnLCAnc2hhZG93Qmx1cicsICdzaGFkb3dDb2xvcicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknLCAnc3Ryb2tlU3R5bGUnLCAndGV4dEFsaWduJywgJ3RleHRCYXNlbGluZScsICdsaW5lRGFzaCcsICdsaW5lRGFzaE9mZnNldCddO1xuXG52YXIgUGFpbnRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhaW50ZXIoZG9tKSB7XG4gICAgaWYgKCFkb20pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjYW52YXNJZCA9IFV0aWwudW5pcXVlSWQoJ2NhbnZhc18nKTtcbiAgICB2YXIgY2FudmFzRG9tID0gVXRpbC5jcmVhdGVEb20oJzxjYW52YXMgaWQ9XCInICsgY2FudmFzSWQgKyAnXCI+PC9jYW52YXM+Jyk7XG4gICAgZG9tLmFwcGVuZENoaWxkKGNhbnZhc0RvbSk7XG4gICAgdGhpcy50eXBlID0gJ2NhbnZhcyc7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXNEb207XG4gICAgdGhpcy5jb250ZXh0ID0gY2FudmFzRG9tLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy50b0RyYXcgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYWludGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYmVmb3JlRHJhdyA9IGZ1bmN0aW9uIGJlZm9yZURyYXcoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5jYW52YXM7XG4gICAgdGhpcy5jb250ZXh0ICYmIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgZWwud2lkdGgsIGVsLmhlaWdodCk7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KG1vZGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZHJhd0lubmVyKCkge1xuICAgICAgc2VsZi5hbmltYXRlSGFuZGxlciA9IFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hbmltYXRlSGFuZGxlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2VsZi50b0RyYXcpIHtcbiAgICAgICAgICBkcmF3SW5uZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLmJlZm9yZURyYXcoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5fZHJhd0dyb3VwKG1vZGVsKTtcbiAgICAgIH0gY2F0Y2ggKGV2KSB7XG4gICAgICAgIC8vIOe7mOWItuaXtuW8guW4uO+8jOS4reaWremHjee7mFxuICAgICAgICBjb25zb2xlLndhcm4oJ2Vycm9yIGluIGRyYXcgY2FudmFzLCBkZXRhaWwgYXM6Jyk7XG4gICAgICAgIGNvbnNvbGUud2Fybihldik7XG4gICAgICAgIHNlbGYudG9EcmF3ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGYudG9EcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuYW5pbWF0ZUhhbmRsZXIpIHtcbiAgICAgIHNlbGYudG9EcmF3ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd0lubmVyKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kcmF3U3luYyA9IGZ1bmN0aW9uIGRyYXdTeW5jKG1vZGVsKSB7XG4gICAgdGhpcy5iZWZvcmVEcmF3KCk7XG5cbiAgICB0aGlzLl9kcmF3R3JvdXAobW9kZWwpO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd0dyb3VwID0gZnVuY3Rpb24gX2RyYXdHcm91cChncm91cCkge1xuICAgIGlmIChncm91cC5fY2ZnLnJlbW92ZWQgfHwgZ3JvdXAuX2NmZy5kZXN0cm95ZWQgfHwgIWdyb3VwLl9jZmcudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGRyZW4gPSBncm91cC5fY2ZnLmNoaWxkcmVuO1xuICAgIHZhciBjaGlsZCA9IG51bGw7XG4gICAgdGhpcy5zZXRDb250ZXh0KGdyb3VwKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZHJlbltpXS5pc0dyb3VwKSB7XG4gICAgICAgIHNlbGYuX2RyYXdHcm91cChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9kcmF3U2hhcGUoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZUNvbnRleHQoZ3JvdXApO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd1NoYXBlID0gZnVuY3Rpb24gX2RyYXdTaGFwZShzaGFwZSkge1xuICAgIGlmIChzaGFwZS5fY2ZnLnJlbW92ZWQgfHwgc2hhcGUuX2NmZy5kZXN0cm95ZWQgfHwgIXNoYXBlLl9jZmcudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0Q29udGV4dChzaGFwZSk7XG4gICAgc2hhcGUuZHJhd0lubmVyKHRoaXMuY29udGV4dCk7XG4gICAgdGhpcy5yZXN0b3JlQ29udGV4dChzaGFwZSk7XG4gICAgc2hhcGUuX2NmZy5hdHRycyA9IHNoYXBlLl9hdHRycztcbiAgICBzaGFwZS5fY2ZnLmhhc1VwZGF0ZSA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5zZXRDb250ZXh0ID0gZnVuY3Rpb24gc2V0Q29udGV4dChzaGFwZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciBjbGlwID0gc2hhcGUuX2F0dHJzLmNsaXA7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgLy8gY29udGV4dC5zYXZlKCk7XG4gICAgICBjbGlwLnJlc2V0VHJhbnNmb3JtKGNvbnRleHQpO1xuICAgICAgY2xpcC5jcmVhdGVQYXRoKGNvbnRleHQpO1xuICAgICAgY29udGV4dC5jbGlwKCk7IC8vIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRDb250ZXh0KHNoYXBlKTtcbiAgICBzaGFwZS5yZXNldFRyYW5zZm9ybShjb250ZXh0KTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdG9yZUNvbnRleHQgPSBmdW5jdGlvbiByZXN0b3JlQ29udGV4dCgpIHtcbiAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldENvbnRleHQgPSBmdW5jdGlvbiByZXNldENvbnRleHQoc2hhcGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB2YXIgZWxBdHRycyA9IHNoYXBlLl9hdHRyczsgLy8gdmFyIGNhbnZhcyA9IHRoaXMuZ2V0KCdjYW52YXMnKTtcblxuICAgIGlmICghc2hhcGUuaXNHcm91cCkge1xuICAgICAgZm9yICh2YXIgayBpbiBlbEF0dHJzKSB7XG4gICAgICAgIGlmIChTSEFQRV9BVFRSUy5pbmRleE9mKGspID4gLTEpIHtcbiAgICAgICAgICAvLyDpnZ5jYW52YXPlsZ7mgKfkuI3pmYTliqBcbiAgICAgICAgICB2YXIgdiA9IGVsQXR0cnNba107XG5cbiAgICAgICAgICBpZiAoayA9PT0gJ2ZpbGxTdHlsZScpIHtcbiAgICAgICAgICAgIHYgPSByZW5kZXJVdGlsLnBhcnNlU3R5bGUodiwgc2hhcGUsIGNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrID09PSAnc3Ryb2tlU3R5bGUnKSB7XG4gICAgICAgICAgICB2ID0gcmVuZGVyVXRpbC5wYXJzZVN0eWxlKHYsIHNoYXBlLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoayA9PT0gJ2xpbmVEYXNoJyAmJiBjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAoVXRpbC5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2godik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWwuaXNTdHJpbmcodikpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCh2LnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0W2tdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBhaW50ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcblxuLyoqKi8gfSksXG4vKiAyMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgcmVnZXhUYWdzID0gL1tNTEhWUVRDU0FaXShbXk1MSFZRVENTQVpdKikvaWc7XG52YXIgcmVnZXhEb3QgPSAvW15cXHNcXCxdKy9pZztcbnZhciByZWdleExHID0gL15sXFxzKlxcKFxccyooW1xcZC5dKylcXHMqXFwpXFxzKiguKikvaTtcbnZhciByZWdleFJHID0gL15yXFxzKlxcKFxccyooW1xcZC5dKylcXHMqLFxccyooW1xcZC5dKylcXHMqLFxccyooW1xcZC5dKylcXHMqXFwpXFxzKiguKikvaTtcbnZhciByZWdleFBSID0gL15wXFxzKlxcKFxccyooW2F4eW5dKVxccypcXClcXHMqKC4qKS9pO1xudmFyIHJlZ2V4Q29sb3JTdG9wID0gL1tcXGQuXSs6KCNbXlxcc10rfFteXFwpXStcXCkpL2lnOyAvLyBjb25zdCBudW1Db2xvckNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGFkZFN0b3Aoc3RlcHMsIGdyYWRpZW50KSB7XG4gIHZhciBhcnIgPSBzdGVwcy5tYXRjaChyZWdleENvbG9yU3RvcCk7XG4gIFV0aWwuZWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaXRlbSA9IGl0ZW0uc3BsaXQoJzonKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoaXRlbVswXSwgaXRlbVsxXSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbmVHcmFkaWVudChjb2xvciwgc2VsZiwgY29udGV4dCkge1xuICB2YXIgYXJyID0gcmVnZXhMRy5leGVjKGNvbG9yKTtcbiAgdmFyIGFuZ2xlID0gVXRpbC5tb2QoVXRpbC50b1JhZGlhbihwYXJzZUZsb2F0KGFyclsxXSkpLCBNYXRoLlBJICogMik7XG4gIHZhciBzdGVwcyA9IGFyclsyXTtcbiAgdmFyIGJveCA9IHNlbGYuZ2V0QkJveCgpO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBlbmQ7XG5cbiAgaWYgKGFuZ2xlID49IDAgJiYgYW5nbGUgPCAwLjUgKiBNYXRoLlBJKSB7XG4gICAgc3RhcnQgPSB7XG4gICAgICB4OiBib3gubWluWCxcbiAgICAgIHk6IGJveC5taW5ZXG4gICAgfTtcbiAgICBlbmQgPSB7XG4gICAgICB4OiBib3gubWF4WCxcbiAgICAgIHk6IGJveC5tYXhZXG4gICAgfTtcbiAgfSBlbHNlIGlmICgwLjUgKiBNYXRoLlBJIDw9IGFuZ2xlICYmIGFuZ2xlIDwgTWF0aC5QSSkge1xuICAgIHN0YXJ0ID0ge1xuICAgICAgeDogYm94Lm1heFgsXG4gICAgICB5OiBib3gubWluWVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogYm94Lm1pblgsXG4gICAgICB5OiBib3gubWF4WVxuICAgIH07XG4gIH0gZWxzZSBpZiAoTWF0aC5QSSA8PSBhbmdsZSAmJiBhbmdsZSA8IDEuNSAqIE1hdGguUEkpIHtcbiAgICBzdGFydCA9IHtcbiAgICAgIHg6IGJveC5tYXhYLFxuICAgICAgeTogYm94Lm1heFlcbiAgICB9O1xuICAgIGVuZCA9IHtcbiAgICAgIHg6IGJveC5taW5YLFxuICAgICAgeTogYm94Lm1pbllcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0ge1xuICAgICAgeDogYm94Lm1pblgsXG4gICAgICB5OiBib3gubWF4WVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogYm94Lm1heFgsXG4gICAgICB5OiBib3gubWluWVxuICAgIH07XG4gIH1cblxuICB2YXIgdGFuVGhldGEgPSBNYXRoLnRhbihhbmdsZSk7XG4gIHZhciB0YW5UaGV0YTIgPSB0YW5UaGV0YSAqIHRhblRoZXRhO1xuICB2YXIgeCA9IChlbmQueCAtIHN0YXJ0LnggKyB0YW5UaGV0YSAqIChlbmQueSAtIHN0YXJ0LnkpKSAvICh0YW5UaGV0YTIgKyAxKSArIHN0YXJ0Lng7XG4gIHZhciB5ID0gdGFuVGhldGEgKiAoZW5kLnggLSBzdGFydC54ICsgdGFuVGhldGEgKiAoZW5kLnkgLSBzdGFydC55KSkgLyAodGFuVGhldGEyICsgMSkgKyBzdGFydC55O1xuICB2YXIgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIHgsIHkpO1xuICBhZGRTdG9wKHN0ZXBzLCBncmFkaWVudCk7XG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZnVuY3Rpb24gcGFyc2VSYWRpYWxHcmFkaWVudChjb2xvciwgc2VsZiwgY29udGV4dCkge1xuICB2YXIgYXJyID0gcmVnZXhSRy5leGVjKGNvbG9yKTtcbiAgdmFyIGZ4ID0gcGFyc2VGbG9hdChhcnJbMV0pO1xuICB2YXIgZnkgPSBwYXJzZUZsb2F0KGFyclsyXSk7XG4gIHZhciBmciA9IHBhcnNlRmxvYXQoYXJyWzNdKTtcbiAgdmFyIHN0ZXBzID0gYXJyWzRdOyAvLyDnjq/ljYrlvoTkuLow5pe277yM6buY6K6k5peg5riQ5Y+Y77yM5Y+W5riQ5Y+Y5bqP5YiX55qE5pyA5ZCO5LiA5Liq6aKc6ImyXG5cbiAgaWYgKGZyID09PSAwKSB7XG4gICAgdmFyIGNvbG9ycyA9IHN0ZXBzLm1hdGNoKHJlZ2V4Q29sb3JTdG9wKTtcbiAgICByZXR1cm4gY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXS5zcGxpdCgnOicpWzFdO1xuICB9XG5cbiAgdmFyIGJveCA9IHNlbGYuZ2V0QkJveCgpO1xuICB2YXIgd2lkdGggPSBib3gubWF4WCAtIGJveC5taW5YO1xuICB2YXIgaGVpZ2h0ID0gYm94Lm1heFkgLSBib3gubWluWTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyO1xuICB2YXIgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGJveC5taW5YICsgd2lkdGggKiBmeCwgYm94Lm1pblkgKyBoZWlnaHQgKiBmeSwgZnIgKiByLCBib3gubWluWCArIHdpZHRoIC8gMiwgYm94Lm1pblkgKyBoZWlnaHQgLyAyLCByKTtcbiAgYWRkU3RvcChzdGVwcywgZ3JhZGllbnQpO1xuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0dGVybihjb2xvciwgc2VsZiwgY29udGV4dCkge1xuICBpZiAoc2VsZi5nZXQoJ3BhdHRlcm5Tb3VyY2UnKSAmJiBzZWxmLmdldCgncGF0dGVyblNvdXJjZScpID09PSBjb2xvcikge1xuICAgIHJldHVybiBzZWxmLmdldCgncGF0dGVybicpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm47XG4gIHZhciBpbWc7XG4gIHZhciBhcnIgPSByZWdleFBSLmV4ZWMoY29sb3IpO1xuICB2YXIgcmVwZWF0ID0gYXJyWzFdO1xuICB2YXIgc291cmNlID0gYXJyWzJdOyAvLyBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBwYXR0ZXJuIGxvYWRzXG5cbiAgZnVuY3Rpb24gb25sb2FkKCkge1xuICAgIC8vIENyZWF0ZSBwYXR0ZXJuXG4gICAgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgc2VsZi5zZXRTaWxlbnQoJ3BhdHRlcm4nLCBwYXR0ZXJuKTsgLy8gYmUgYSBjYWNoZVxuXG4gICAgc2VsZi5zZXRTaWxlbnQoJ3BhdHRlcm5Tb3VyY2UnLCBjb2xvcik7XG4gIH1cblxuICBzd2l0Y2ggKHJlcGVhdCkge1xuICAgIGNhc2UgJ2EnOlxuICAgICAgcmVwZWF0ID0gJ3JlcGVhdCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3gnOlxuICAgICAgcmVwZWF0ID0gJ3JlcGVhdC14JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAneSc6XG4gICAgICByZXBlYXQgPSAncmVwZWF0LXknO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICduJzpcbiAgICAgIHJlcGVhdCA9ICduby1yZXBlYXQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmVwZWF0ID0gJ25vLXJlcGVhdCc7XG4gIH1cblxuICBpbWcgPSBuZXcgSW1hZ2UoKTsgLy8gSWYgc291cmNlIFVSTCBpcyBub3QgYSBkYXRhIFVSTFxuXG4gIGlmICghc291cmNlLm1hdGNoKC9eZGF0YTovaSkpIHtcbiAgICAvLyBTZXQgY3Jvc3NPcmlnaW4gZm9yIHRoaXMgaW1hZ2VcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgfVxuXG4gIGltZy5zcmMgPSBzb3VyY2U7XG5cbiAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgIG9ubG9hZCgpO1xuICB9IGVsc2Uge1xuICAgIGltZy5vbmxvYWQgPSBvbmxvYWQ7IC8vIEZpeCBvbmxvYWQoKSBidWcgaW4gSUU5XG5cbiAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VQYXRoOiBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIHBhdGggPSBwYXRoIHx8IFtdO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheShwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgIHBhdGggPSBwYXRoLm1hdGNoKHJlZ2V4VGFncyk7XG4gICAgICBVdGlsLmVhY2gocGF0aCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtLm1hdGNoKHJlZ2V4RG90KTtcblxuICAgICAgICBpZiAoaXRlbVswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IGl0ZW1bMF0uY2hhckF0KDApO1xuICAgICAgICAgIGl0ZW0uc3BsaWNlKDEsIDAsIGl0ZW1bMF0uc3Vic3RyKDEpKTtcbiAgICAgICAgICBpdGVtWzBdID0gdGFnO1xuICAgICAgICB9XG5cbiAgICAgICAgVXRpbC5lYWNoKGl0ZW0sIGZ1bmN0aW9uIChzdWIsIGkpIHtcbiAgICAgICAgICBpZiAoIWlzTmFOKHN1YikpIHtcbiAgICAgICAgICAgIGl0ZW1baV0gPSArc3ViO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGhbaW5kZXhdID0gaXRlbTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9LFxuICBwYXJzZVN0eWxlOiBmdW5jdGlvbiBwYXJzZVN0eWxlKGNvbG9yLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgaWYgKFV0aWwuaXNTdHJpbmcoY29sb3IpKSB7XG4gICAgICBpZiAoY29sb3JbMV0gPT09ICcoJyB8fCBjb2xvclsyXSA9PT0gJygnKSB7XG4gICAgICAgIGlmIChjb2xvclswXSA9PT0gJ2wnKSB7XG4gICAgICAgICAgLy8gcmVnZXhMRy50ZXN0KGNvbG9yKVxuICAgICAgICAgIHJldHVybiBwYXJzZUxpbmVHcmFkaWVudChjb2xvciwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JbMF0gPT09ICdyJykge1xuICAgICAgICAgIC8vIHJlZ2V4UkcudGVzdChjb2xvcilcbiAgICAgICAgICByZXR1cm4gcGFyc2VSYWRpYWxHcmFkaWVudChjb2xvciwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JbMF0gPT09ICdwJykge1xuICAgICAgICAgIC8vIHJlZ2V4UFIudGVzdChjb2xvcilcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXR0ZXJuKGNvbG9yLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICB9XG4gIC8qICxcbiAgbnVtYmVyVG9Db2xvcihudW0pIHtcbiAgICAvLyDlop7liqDnvJPlrZhcbiAgICBsZXQgY29sb3IgPSBudW1Db2xvckNhY2hlW251bV07XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgbGV0IHN0ciA9IG51bS50b1N0cmluZygxNik7XG4gICAgICBmb3IgKGxldCBpID0gc3RyLmxlbmd0aDsgaSA8IDY7IGkrKykge1xuICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgICB9XG4gICAgICBjb2xvciA9ICcjJyArIHN0cjtcbiAgICAgIG51bUNvbG9yQ2FjaGVbbnVtXSA9IGNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH0qL1xuXG59O1xuXG4vKioqLyB9KSxcbi8qIDIxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFpbnRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygyMjApLFxuICBnZXRTaGFwZTogX193ZWJwYWNrX3JlcXVpcmVfXygyMjcpXG59O1xuXG4vKioqLyB9KSxcbi8qIDIyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpLFxuICAgIHBhcnNlUmFkaXVzID0gX3JlcXVpcmUucGFyc2VSYWRpdXM7XG5cbnZhciBNYXJrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIERlZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMSk7XG5cbnZhciBTSEFQRV9UT19UQUdTID0ge1xuICByZWN0OiAncGF0aCcsXG4gIGNpcmNsZTogJ2NpcmNsZScsXG4gIGxpbmU6ICdsaW5lJyxcbiAgcGF0aDogJ3BhdGgnLFxuICBtYXJrZXI6ICdwYXRoJyxcbiAgdGV4dDogJ3RleHQnLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIGltYWdlOiAnaW1hZ2UnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGRvbTogJ2ZvcmVpZ25PYmplY3QnLFxuICBmYW46ICdwYXRoJyxcbiAgZ3JvdXA6ICdnJ1xufTtcbnZhciBMRVRURVJfU1BBQ0lORyA9IDAuMztcbnZhciBTVkdfQVRUUl9NQVAgPSB7XG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgZmlsbFN0eWxlOiAnZmlsbCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgc3Ryb2tlU3R5bGU6ICdzdHJva2UnLFxuICB4OiAneCcsXG4gIHk6ICd5JyxcbiAgcjogJ3InLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIGxpbmVDYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIGxpbmVKb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgbGluZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgbGluZURhc2g6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgbGluZURhc2hPZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIG1pdGVyTGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIGZvbnQ6ICdmb250JyxcbiAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBzdGFydEFycm93OiAnbWFya2VyLXN0YXJ0JyxcbiAgZW5kQXJyb3c6ICdtYXJrZXItZW5kJyxcbiAgcGF0aDogJ2QnLFxuICBjbGFzczogJ2NsYXNzJyxcbiAgaWQ6ICdpZCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbydcbn07XG52YXIgQkFTRUxJTkVfTUFQID0ge1xuICB0b3A6ICdiZWZvcmUtZWRnZScsXG4gIG1pZGRsZTogJ2NlbnRyYWwnLFxuICBib3R0b206ICdhZnRlci1lZGdlJyxcbiAgYWxwaGFiZXRpYzogJ2Jhc2VsaW5lJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnXG59O1xudmFyIEFOQ0hPUl9NQVAgPSB7XG4gIGxlZnQ6ICdsZWZ0JyxcbiAgc3RhcnQ6ICdsZWZ0JyxcbiAgY2VudGVyOiAnbWlkZGxlJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBlbmQ6ICdlbmQnXG59O1xuXG52YXIgUGFpbnRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhaW50ZXIoZG9tKSB7XG4gICAgaWYgKCFkb20pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdmdJZCA9IFV0aWwudW5pcXVlSWQoJ2NhbnZhc18nKTtcbiAgICB2YXIgY2FudmFzRG9tID0gVXRpbC5jcmVhdGVEb20oXCI8c3ZnIGlkPVxcXCJcIiArIHN2Z0lkICsgXCJcXFwiPjwvc3ZnPlwiKTtcbiAgICBkb20uYXBwZW5kQ2hpbGQoY2FudmFzRG9tKTtcbiAgICB0aGlzLnR5cGUgPSAnc3ZnJztcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc0RvbTtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgRGVmcyhjYW52YXNEb20pO1xuICAgIHRoaXMudG9EcmF3ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFpbnRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KG1vZGVsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZHJhd0lubmVyKCkge1xuICAgICAgc2VsZi5hbmltYXRlSGFuZGxlciA9IFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hbmltYXRlSGFuZGxlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoc2VsZi50b0RyYXcpIHtcbiAgICAgICAgICBkcmF3SW5uZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuX2RyYXdDaGlsZHJlbihtb2RlbCk7XG4gICAgICB9IGNhdGNoIChldikge1xuICAgICAgICAvLyDnu5jliLbml7blvILluLjvvIzkuK3mlq3ph43nu5hcbiAgICAgICAgY29uc29sZS53YXJuKCdlcnJvciBpbiBkcmF3IGNhbnZhcywgZGV0YWlsIGFzOicpO1xuICAgICAgICBjb25zb2xlLndhcm4oZXYpO1xuICAgICAgICBzZWxmLnRvRHJhdyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnRvRHJhdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmFuaW1hdGVIYW5kbGVyKSB7XG4gICAgICBzZWxmLnRvRHJhdyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdJbm5lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZHJhd1N5bmMgPSBmdW5jdGlvbiBkcmF3U3luYyhtb2RlbCkge1xuICAgIHRoaXMuX2RyYXdDaGlsZHJlbihtb2RlbCk7XG4gIH07XG5cbiAgX3Byb3RvLl9kcmF3R3JvdXAgPSBmdW5jdGlvbiBfZHJhd0dyb3VwKG1vZGVsLCBpbmRleCkge1xuICAgIHZhciBjZmcgPSBtb2RlbC5fY2ZnO1xuXG4gICAgaWYgKGNmZy5yZW1vdmVkIHx8IGNmZy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLnRvYmVSZW1vdmVkKSB7XG4gICAgICBVdGlsLmVhY2goY2ZnLnRvYmVSZW1vdmVkLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNmZy50b2JlUmVtb3ZlZCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdTaGFwZShtb2RlbCwgaW5kZXgpO1xuXG4gICAgaWYgKGNmZy5jaGlsZHJlbiAmJiBjZmcuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKG1vZGVsKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9kcmF3Q2hpbGRyZW4gPSBmdW5jdGlvbiBfZHJhd0NoaWxkcmVuKHBhcmVudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NmZy5jaGlsZHJlbjtcbiAgICB2YXIgc2hhcGU7IC8vIOmYsuatouWcqOeUu2NoaWxkcmVu55qE5pe25YCZ77yM54i2Z3JvdXDlt7Lnu4/ooqtkZXN0cm95XG5cbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc2hhcGUgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKHNoYXBlLmlzR3JvdXApIHtcbiAgICAgICAgc2VsZi5fZHJhd0dyb3VwKHNoYXBlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX2RyYXdTaGFwZShzaGFwZSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fZHJhd1NoYXBlID0gZnVuY3Rpb24gX2RyYXdTaGFwZShtb2RlbCwgaW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gbW9kZWwuX2F0dHJzO1xuICAgIHZhciBjZmcgPSBtb2RlbC5fY2ZnO1xuICAgIHZhciBlbCA9IGNmZy5lbDsgLy8g5Yig6ZmkXG5cbiAgICBpZiAoY2ZnLnJlbW92ZWQgfHwgY2ZnLmRlc3Ryb3llZCkge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2ZnLmVsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8g5paw5aKe6IqC54K5XG5cblxuICAgIGlmICghZWwgJiYgY2ZnLnBhcmVudCkge1xuICAgICAgc2VsZi5fY3JlYXRlRG9tKG1vZGVsLCBpbmRleCk7XG5cbiAgICAgIHNlbGYuX3VwZGF0ZVNoYXBlKG1vZGVsKTtcbiAgICB9XG5cbiAgICBlbCA9IGNmZy5lbDtcblxuICAgIGlmIChjZmcudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLnZpc2libGUgJiYgZWwuaGFzQXR0cmlidXRlKCd2aXNpYmlsaXR5JykpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndmlzaWJpbGl0eScpO1xuICAgIH0gLy8g5pu05pawXG5cblxuICAgIGlmIChjZmcuaGFzVXBkYXRlKSB7XG4gICAgICBzZWxmLl91cGRhdGVTaGFwZShtb2RlbCk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJzLmNsaXAgJiYgYXR0cnMuY2xpcC5fY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgc2VsZi5fdXBkYXRlU2hhcGUoYXR0cnMuY2xpcCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fdXBkYXRlU2hhcGUgPSBmdW5jdGlvbiBfdXBkYXRlU2hhcGUobW9kZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gbW9kZWwuX2F0dHJzO1xuICAgIHZhciBmb3JtZXJBdHRycyA9IG1vZGVsLl9jZmcuYXR0cnM7XG5cbiAgICBpZiAoIWZvcm1lckF0dHJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbC5fY2ZnLmVsKSB7XG4gICAgICBzZWxmLl9jcmVhdGVEb20obW9kZWwpO1xuICAgIH1cblxuICAgIGlmICgnY2xpcCcgaW4gYXR0cnMpIHtcbiAgICAgIHRoaXMuX3NldENsaXAobW9kZWwsIGF0dHJzLmNsaXApO1xuICAgIH1cblxuICAgIGlmICgnc2hhZG93T2Zmc2V0WCcgaW4gYXR0cnMgfHwgJ3NoYWRvd09mZnNldFknIGluIGF0dHJzIHx8ICdzaGFkb3dCbHVyJyBpbiBhdHRycyB8fCAnc2hhZG93Q29sb3InIGluIGF0dHJzKSB7XG4gICAgICB0aGlzLl9zZXRTaGFkb3cobW9kZWwpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHNlbGYuX3VwZGF0ZVRleHQobW9kZWwpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLnR5cGUgPT09ICdmYW4nKSB7XG4gICAgICBzZWxmLl91cGRhdGVGYW4obW9kZWwpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC50eXBlID09PSAnbWFya2VyJykge1xuICAgICAgbW9kZWwuX2NmZy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCBzZWxmLl9hc3NlbWJsZU1hcmtlcihhdHRycykpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC50eXBlID09PSAncmVjdCcpIHtcbiAgICAgIG1vZGVsLl9jZmcuZWwuc2V0QXR0cmlidXRlKCdkJywgc2VsZi5fYXNzZW1ibGVSZWN0KGF0dHJzKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gZm9ybWVyQXR0cnNba2V5XSkge1xuICAgICAgICBzZWxmLl9zZXRBdHRyaWJ1dGUobW9kZWwsIGtleSwgYXR0cnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWwuX2NmZy5hdHRycyA9IFV0aWwuZGVlcE1peCh7fSwgbW9kZWwuX2F0dHJzKTtcbiAgICBtb2RlbC5fY2ZnLmhhc1VwZGF0ZSA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5fc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gX3NldEF0dHJpYnV0ZShtb2RlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IG1vZGVsLnR5cGU7XG4gICAgdmFyIGF0dHJzID0gbW9kZWwuX2F0dHJzO1xuICAgIHZhciBlbCA9IG1vZGVsLl9jZmcuZWw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmNvbnRleHQ7IC8vIOiuoeeul21hcmtlcui3r+W+hFxuXG4gICAgaWYgKCh0eXBlID09PSAnbWFya2VyJyB8fCB0eXBlID09PSAncmVjdCcpICYmIH5bJ3gnLCAneScsICdyYWRpdXMnLCAnciddLmluZGV4T2YobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIOWchuWSjOakreWchuS4jeaYr3gsIHnvvIwg5pivY3gsIGN544CCIG1hcmtlcueahHgseSDnlKjkuo7orqHnrpdtYXJrZXLnmoTot6/lvoTvvIzkuI3pnIDopoHlhpnliLBkb21cblxuXG4gICAgaWYgKH5bJ2NpcmNsZScsICdlbGxpcHNlJ10uaW5kZXhPZih0eXBlKSAmJiB+Wyd4JywgJ3knXS5pbmRleE9mKG5hbWUpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2MnICsgbmFtZSwgcGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlpJrovrnlvaJcblxuXG4gICAgaWYgKHR5cGUgPT09ICdwb2x5Z29uJyAmJiBuYW1lID09PSAncG9pbnRzJykge1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgcmV0dXJuIHBvaW50WzBdICsgJywnICsgcG9pbnRbMV07XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdwb2ludHMnLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDorr7nva5wYXRoXG5cblxuICAgIGlmIChuYW1lID09PSAncGF0aCcgJiYgVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkJywgdGhpcy5fZm9ybWF0UGF0aCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8g6K6+572u5Zu+54mHXG5cblxuICAgIGlmIChuYW1lID09PSAnaW1nJykge1xuICAgICAgdGhpcy5fc2V0SW1hZ2UobW9kZWwsIHZhbHVlKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShtb2RlbCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRUcmFuc2Zvcm0obW9kZWwpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdtYXRyaXgnKSB7XG4gICAgICB0aGlzLl9zZXRUcmFuc2Zvcm0obW9kZWwpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdmaWxsU3R5bGUnIHx8IG5hbWUgPT09ICdzdHJva2VTdHlsZScpIHtcbiAgICAgIHRoaXMuX3NldENvbG9yKG1vZGVsLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2NsaXAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKH5uYW1lLmluZGV4T2YoJ0Fycm93JykpIHtcbiAgICAgIG5hbWUgPSBTVkdfQVRUUl9NQVBbbmFtZV07XG5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgbW9kZWwuX2NmZ1tuYW1lXSA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgaWQgPSBkZWZzLmdldERlZmF1bHRBcnJvdyhhdHRycywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSBkZWZzLmFkZEFycm93KGF0dHJzLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCBcInVybCgjXCIgKyBpZCArIFwiKVwiKTtcbiAgICAgICAgbW9kZWwuX2NmZ1tuYW1lXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmb3JlaWduT2JqZWN0XG5cblxuICAgIGlmIChuYW1lID09PSAnaHRtbCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoU1ZHX0FUVFJfTUFQW25hbWVdKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoU1ZHX0FUVFJfTUFQW25hbWVdLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fY3JlYXRlRG9tID0gZnVuY3Rpb24gX2NyZWF0ZURvbShtb2RlbCwgaW5kZXgpIHtcbiAgICB2YXIgdHlwZSA9IFNIQVBFX1RPX1RBR1NbbW9kZWwudHlwZV07XG4gICAgdmFyIGF0dHJzID0gbW9kZWwuX2F0dHJzO1xuICAgIHZhciBwYXJlbnQgPSBtb2RlbC5fY2ZnLnBhcmVudDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudC5fY2ZnLmVsO1xuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSB0eXBlJyArIG1vZGVsLnR5cGUgKyAnaXMgbm90IHN1cHBvcnRlZCBieSBzdmcnKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdHlwZSk7XG4gICAgbW9kZWwuX2NmZy5lbCA9IHNoYXBlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHBhcmVudC5fY2ZnLmVsLmNoaWxkTm9kZXM7IC8vIHN2Z+S4i+WkqeeEtuaciWRlZnPkvZzkuLrlrZDoioLngrnvvIxzdmfkuIvlrZDlhYPntKBpbmRleOmcgOimgSsxXG5cbiAgICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzaGFwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2hhcGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLl9jZmcuYXR0cnMgPSB7fTtcblxuICAgIGlmIChtb2RlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgncGFpbnQtb3JkZXInLCAnc3Ryb2tlJyk7XG4gICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3N0cm9rZS1saW5lY2FwOmJ1dHQ7IHN0cm9rZS1saW5lam9pbjptaXRlcjsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFhdHRycy5zdHJva2UgJiYgIWF0dHJzLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdHRycy5maWxsICYmICFhdHRycy5maWxsU3R5bGUpIHtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgX3Byb3RvLl9hc3NlbWJsZU1hcmtlciA9IGZ1bmN0aW9uIF9hc3NlbWJsZU1hcmtlcihhdHRycykge1xuICAgIHZhciByID0gYXR0cnMucjtcblxuICAgIGlmICh0eXBlb2YgYXR0cnMuciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHIgPSBhdHRycy5yYWRpdXM7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKE51bWJlcihhdHRycy54KSkgfHwgaXNOYU4oTnVtYmVyKGF0dHJzLnkpKSB8fCBpc05hTihOdW1iZXIocikpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcblxuICAgIGlmICh0eXBlb2YgYXR0cnMuc3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkID0gYXR0cnMuc3ltYm9sKGF0dHJzLngsIGF0dHJzLnksIHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gTWFya2VyLlN5bWJvbHNbYXR0cnMuc3ltYm9sIHx8ICdjaXJjbGUnXShhdHRycy54LCBhdHRycy55LCByKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KGQpKSB7XG4gICAgICBkID0gZC5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbignICcpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgX3Byb3RvLl9hc3NlbWJsZVJlY3QgPSBmdW5jdGlvbiBfYXNzZW1ibGVSZWN0KGF0dHJzKSB7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICAgIHZhciBoID0gYXR0cnMuaGVpZ2h0O1xuICAgIHZhciByYWRpdXMgPSBhdHRycy5yYWRpdXM7XG5cbiAgICBpZiAoIXJhZGl1cykge1xuICAgICAgcmV0dXJuIFwiTSBcIiArIHggKyBcIixcIiArIHkgKyBcIiBsIFwiICsgdyArIFwiLDAgbCAwLFwiICsgaCArIFwiIGxcIiArIC13ICsgXCIgMCB6XCI7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBwYXJzZVJhZGl1cyhyYWRpdXMpO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheShyYWRpdXMpKSB7XG4gICAgICBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByLnIxID0gci5yMiA9IHIucjMgPSByLnI0ID0gcmFkaXVzWzBdO1xuICAgICAgfSBlbHNlIGlmIChyYWRpdXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHIucjEgPSByLnIzID0gcmFkaXVzWzBdO1xuICAgICAgICByLnIyID0gci5yNCA9IHJhZGl1c1sxXTtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByLnIxID0gcmFkaXVzWzBdO1xuICAgICAgICByLnIyID0gci5yNCA9IHJhZGl1c1sxXTtcbiAgICAgICAgci5yMyA9IHJhZGl1c1syXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIucjEgPSByYWRpdXNbMF07XG4gICAgICAgIHIucjIgPSByYWRpdXNbMV07XG4gICAgICAgIHIucjMgPSByYWRpdXNbMl07XG4gICAgICAgIHIucjQgPSByYWRpdXNbM107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucjEgPSByLnIyID0gci5yMyA9IHIucjQgPSByYWRpdXM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBbW1wiTSBcIiArICh4ICsgci5yMSkgKyBcIixcIiArIHldLCBbXCJsIFwiICsgKHcgLSByLnIxIC0gci5yMikgKyBcIiwwXCJdLCBbXCJhIFwiICsgci5yMiArIFwiLFwiICsgci5yMiArIFwiLDAsMCwxLFwiICsgci5yMiArIFwiLFwiICsgci5yMl0sIFtcImwgMCxcIiArIChoIC0gci5yMiAtIHIucjMpXSwgW1wiYSBcIiArIHIucjMgKyBcIixcIiArIHIucjMgKyBcIiwwLDAsMSxcIiArIC1yLnIzICsgXCIsXCIgKyByLnIzXSwgW1wibCBcIiArIChyLnIzICsgci5yNCAtIHcpICsgXCIsMFwiXSwgW1wiYSBcIiArIHIucjQgKyBcIixcIiArIHIucjQgKyBcIiwwLDAsMSxcIiArIC1yLnI0ICsgXCIsXCIgKyAtci5yNF0sIFtcImwgMCxcIiArIChyLnI0ICsgci5yMSAtIGgpXSwgW1wiYSBcIiArIHIucjEgKyBcIixcIiArIHIucjEgKyBcIiwwLDAsMSxcIiArIHIucjEgKyBcIixcIiArIC1yLnIxXSwgWyd6J11dO1xuICAgIHJldHVybiBkLmpvaW4oJyAnKTtcbiAgfTtcblxuICBfcHJvdG8uX2Zvcm1hdFBhdGggPSBmdW5jdGlvbiBfZm9ybWF0UGF0aCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKCcgJyk7XG4gICAgfSkuam9pbignJyk7XG5cbiAgICBpZiAofnZhbHVlLmluZGV4T2YoJ05hTicpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5fc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldFRyYW5zZm9ybShtb2RlbCkge1xuICAgIHZhciBtYXRyaXggPSBtb2RlbC5fYXR0cnMubWF0cml4O1xuICAgIHZhciBlbCA9IG1vZGVsLl9jZmcuZWw7XG4gICAgdmFyIHRyYW5zZm9ybSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA5OyBpICs9IDMpIHtcbiAgICAgIHRyYW5zZm9ybS5wdXNoKG1hdHJpeFtpXSArICcsJyArIG1hdHJpeFtpICsgMV0pO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5qb2luKCcsJyk7XG5cbiAgICBpZiAodHJhbnNmb3JtLmluZGV4T2YoJ05hTicpID09PSAtMSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcIm1hdHJpeChcIiArIHRyYW5zZm9ybSArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdpbnZhbGlkIG1hdHJpeDonLCBtYXRyaXgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3NldEltYWdlID0gZnVuY3Rpb24gX3NldEltYWdlKG1vZGVsLCBpbWcpIHtcbiAgICB2YXIgYXR0cnMgPSBtb2RlbC5fYXR0cnM7XG4gICAgdmFyIGVsID0gbW9kZWwuX2NmZy5lbDtcblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKGltZykpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaHJlZicsIGltZyk7XG4gICAgfSBlbHNlIGlmIChpbWcgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgICAgaWYgKCFhdHRycy53aWR0aCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaW1nLndpZHRoKTtcbiAgICAgICAgbW9kZWwuX2F0dHJzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dHJzLmhlaWdodCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGltZy5oZWlnaHQpO1xuICAgICAgICBtb2RlbC5fYXR0cnMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgZWwuc2V0QXR0cmlidXRlKCdocmVmJywgaW1nLnNyYyk7XG4gICAgfSBlbHNlIGlmIChpbWcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBVdGlsLmlzU3RyaW5nKGltZy5ub2RlTmFtZSkgJiYgaW1nLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBpbWcudG9EYXRhVVJMKCkpO1xuICAgIH0gZWxzZSBpZiAoaW1nIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGltZy53aWR0aCk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBpbWcuaGVpZ2h0KTtcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuXG4gICAgICBpZiAoIWF0dHJzLndpZHRoKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBpbWcud2lkdGgpO1xuICAgICAgICBtb2RlbC5fYXR0cnMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXR0cnMuaGVpZ2h0KSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaW1nLmhlaWdodCk7XG4gICAgICAgIG1vZGVsLl9hdHRycy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBjYW52YXMudG9EYXRhVVJMKCkpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3VwZGF0ZUZhbiA9IGZ1bmN0aW9uIF91cGRhdGVGYW4obW9kZWwpIHtcbiAgICBmdW5jdGlvbiBnZXRQb2ludChhbmdsZSwgcmFkaXVzLCBjZW50ZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSArIGNlbnRlci54LFxuICAgICAgICB5OiByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyBjZW50ZXIueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSBtb2RlbC5fYXR0cnM7XG4gICAgdmFyIGNmZyA9IG1vZGVsLl9jZmc7XG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGF0dHJzLngsXG4gICAgICB5OiBhdHRycy55XG4gICAgfTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBzdGFydEFuZ2xlID0gYXR0cnMuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBhdHRycy5lbmRBbmdsZTtcblxuICAgIGlmIChVdGlsLmlzTnVtYmVyRXF1YWwoZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCBNYXRoLlBJICogMikpIHtcbiAgICAgIGVuZEFuZ2xlIC09IDAuMDAwMDE7XG4gICAgfVxuXG4gICAgdmFyIG91dGVyU3RhcnQgPSBnZXRQb2ludChzdGFydEFuZ2xlLCBhdHRycy5yZSwgY2VudGVyKTtcbiAgICB2YXIgb3V0ZXJFbmQgPSBnZXRQb2ludChlbmRBbmdsZSwgYXR0cnMucmUsIGNlbnRlcik7XG4gICAgdmFyIGZhID0gZW5kQW5nbGUgPiBzdGFydEFuZ2xlID8gMSA6IDA7XG4gICAgdmFyIGZzID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IE1hdGguUEkgPyAxIDogMDtcbiAgICB2YXIgcnMgPSBhdHRycy5ycztcbiAgICB2YXIgcmUgPSBhdHRycy5yZTtcbiAgICB2YXIgaW5uZXJTdGFydCA9IGdldFBvaW50KHN0YXJ0QW5nbGUsIGF0dHJzLnJzLCBjZW50ZXIpO1xuICAgIHZhciBpbm5lckVuZCA9IGdldFBvaW50KGVuZEFuZ2xlLCBhdHRycy5ycywgY2VudGVyKTtcblxuICAgIGlmIChhdHRycy5ycyA+IDApIHtcbiAgICAgIGQucHVzaChcIk0gXCIgKyBvdXRlckVuZC54ICsgXCIsXCIgKyBvdXRlckVuZC55KTtcbiAgICAgIGQucHVzaChcIkwgXCIgKyBpbm5lckVuZC54ICsgXCIsXCIgKyBpbm5lckVuZC55KTtcbiAgICAgIGQucHVzaChcIkEgXCIgKyBycyArIFwiLFwiICsgcnMgKyBcIiwwLFwiICsgZnMgKyBcIixcIiArIChmYSA9PT0gMSA/IDAgOiAxKSArIFwiLFwiICsgaW5uZXJTdGFydC54ICsgXCIsXCIgKyBpbm5lclN0YXJ0LnkpO1xuICAgICAgZC5wdXNoKFwiTCBcIiArIG91dGVyU3RhcnQueCArIFwiIFwiICsgb3V0ZXJTdGFydC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZC5wdXNoKFwiTSBcIiArIGNlbnRlci54ICsgXCIsXCIgKyBjZW50ZXIueSk7XG4gICAgICBkLnB1c2goXCJMIFwiICsgb3V0ZXJTdGFydC54ICsgXCIsXCIgKyBvdXRlclN0YXJ0LnkpO1xuICAgIH1cblxuICAgIGQucHVzaChcIkEgXCIgKyByZSArIFwiLFwiICsgcmUgKyBcIiwwLFwiICsgZnMgKyBcIixcIiArIGZhICsgXCIsXCIgKyBvdXRlckVuZC54ICsgXCIsXCIgKyBvdXRlckVuZC55KTtcblxuICAgIGlmIChhdHRycy5ycyA+IDApIHtcbiAgICAgIGQucHVzaChcIkwgXCIgKyBpbm5lckVuZC54ICsgXCIsXCIgKyBpbm5lckVuZC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZC5wdXNoKCdaJyk7XG4gICAgfVxuXG4gICAgY2ZnLmVsLnNldEF0dHJpYnV0ZSgnZCcsIGQuam9pbignICcpKTtcbiAgfTtcblxuICBfcHJvdG8uX3VwZGF0ZVRleHQgPSBmdW5jdGlvbiBfdXBkYXRlVGV4dChtb2RlbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBtb2RlbC5fYXR0cnM7XG4gICAgdmFyIGZvcm1lckF0dHJzID0gbW9kZWwuX2NmZy5hdHRycztcbiAgICB2YXIgZWwgPSBtb2RlbC5fY2ZnLmVsO1xuXG4gICAgdGhpcy5fc2V0Rm9udChtb2RlbCk7XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnNbYXR0cl0gIT09IGZvcm1lckF0dHJzW2F0dHJdKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAndGV4dCcpIHtcbiAgICAgICAgICBzZWxmLl9zZXRUZXh0KG1vZGVsLCBcIlwiICsgYXR0cnNbYXR0cl0pO1xuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ciA9PT0gJ2ZpbGxTdHlsZScgfHwgYXR0ciA9PT0gJ3N0cm9rZVN0eWxlJykge1xuICAgICAgICAgIHRoaXMuX3NldENvbG9yKG1vZGVsLCBhdHRyLCBhdHRyc1thdHRyXSk7XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyID09PSAnbWF0cml4Jykge1xuICAgICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShtb2RlbCk7XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTVkdfQVRUUl9NQVBbYXR0cl0pIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoU1ZHX0FUVFJfTUFQW2F0dHJdLCBhdHRyc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2RlbC5fY2ZnLmF0dHJzID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kZWwuX2F0dHJzKTtcbiAgICBtb2RlbC5fY2ZnLmhhc1VwZGF0ZSA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5fc2V0Rm9udCA9IGZ1bmN0aW9uIF9zZXRGb250KG1vZGVsKSB7XG4gICAgdmFyIGVsID0gbW9kZWwuZ2V0KCdlbCcpO1xuICAgIHZhciBhdHRycyA9IG1vZGVsLl9hdHRycztcbiAgICB2YXIgZm9udFNpemUgPSBhdHRycy5mb250U2l6ZTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FsaWdubWVudC1iYXNlbGluZScsIEJBU0VMSU5FX01BUFthdHRycy50ZXh0QmFzZWxpbmVdIHx8ICdiYXNlbGluZScpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCBBTkNIT1JfTUFQW2F0dHJzLnRleHRBbGlnbl0gfHwgJ2xlZnQnKTtcblxuICAgIGlmIChmb250U2l6ZSAmJiArZm9udFNpemUgPCAxMikge1xuICAgICAgLy8g5bCP5LqOIDEyIOWDj+e0oOeahOaWh+acrOi/m+ihjCBzY2FsZSDlpITnkIZcbiAgICAgIGF0dHJzLm1hdHJpeCA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXTtcbiAgICAgIG1vZGVsLnRyYW5zZm9ybShbWyd0JywgLWF0dHJzLngsIC1hdHRycy55XSwgWydzJywgK2ZvbnRTaXplIC8gMTIsICtmb250U2l6ZSAvIDEyXSwgWyd0JywgYXR0cnMueCwgYXR0cnMueV1dKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRUZXh0ID0gZnVuY3Rpb24gX3NldFRleHQobW9kZWwsIHRleHQpIHtcbiAgICB2YXIgZWwgPSBtb2RlbC5fY2ZnLmVsO1xuICAgIHZhciBiYXNlbGluZSA9IG1vZGVsLl9hdHRycy50ZXh0QmFzZWxpbmUgfHwgJ2JvdHRvbSc7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgIH0gZWxzZSBpZiAofnRleHQuaW5kZXhPZignXFxuJykpIHtcbiAgICAgIHZhciB4ID0gbW9kZWwuX2F0dHJzLng7XG4gICAgICB2YXIgdGV4dEFyciA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHRleHRMZW4gPSB0ZXh0QXJyLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYXJyID0gJyc7XG4gICAgICBVdGlsLmVhY2godGV4dEFyciwgZnVuY3Rpb24gKHNlZ21lbnQsIGkpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBpZiAoYmFzZWxpbmUgPT09ICdhbHBoYWJldGljJykge1xuICAgICAgICAgICAgYXJyICs9IFwiPHRzcGFuIHg9XFxcIlwiICsgeCArIFwiXFxcIiBkeT1cXFwiXCIgKyAtdGV4dExlbiArIFwiZW1cXFwiPlwiICsgc2VnbWVudCArIFwiPC90c3Bhbj5cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJhc2VsaW5lID09PSAndG9wJykge1xuICAgICAgICAgICAgYXJyICs9IFwiPHRzcGFuIHg9XFxcIlwiICsgeCArIFwiXFxcIiBkeT1cXFwiMC45ZW1cXFwiPlwiICsgc2VnbWVudCArIFwiPC90c3Bhbj5cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJhc2VsaW5lID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgYXJyICs9IFwiPHRzcGFuIHg9XFxcIlwiICsgeCArIFwiXFxcIiBkeT1cXFwiXCIgKyAtKHRleHRMZW4gLSAxKSAvIDIgKyBcImVtXFxcIj5cIiArIHNlZ21lbnQgKyBcIjwvdHNwYW4+XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChiYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGFyciArPSBcIjx0c3BhbiB4PVxcXCJcIiArIHggKyBcIlxcXCIgZHk9XFxcIi1cIiArICh0ZXh0TGVuICsgTEVUVEVSX1NQQUNJTkcpICsgXCJlbVxcXCI+XCIgKyBzZWdtZW50ICsgXCI8L3RzcGFuPlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmFzZWxpbmUgPT09ICdoYW5naW5nJykge1xuICAgICAgICAgICAgYXJyICs9IFwiPHRzcGFuIHg9XFxcIlwiICsgeCArIFwiXFxcIiBkeT1cXFwiXCIgKyAoLSh0ZXh0TGVuIC0gMSkgLSBMRVRURVJfU1BBQ0lORykgKyBcImVtXFxcIj5cIiArIHNlZ21lbnQgKyBcIjwvdHNwYW4+XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyciArPSBcIjx0c3BhbiB4PVxcXCJcIiArIHggKyBcIlxcXCIgZHk9XFxcIjFlbVxcXCI+XCIgKyBzZWdtZW50ICsgXCI8L3RzcGFuPlwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVsLmlubmVySFRNTCA9IGFycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuaW5uZXJIVE1MID0gdGV4dDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRDbGlwID0gZnVuY3Rpb24gX3NldENsaXAobW9kZWwsIHZhbHVlKSB7XG4gICAgdmFyIGVsID0gbW9kZWwuX2NmZy5lbDtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xpcC1wYXRoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpKSB7XG4gICAgICB0aGlzLl9jcmVhdGVEb20odmFsdWUpO1xuXG4gICAgICB0aGlzLl91cGRhdGVTaGFwZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBpZCA9IHRoaXMuY29udGV4dC5hZGRDbGlwKHZhbHVlKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgXCJ1cmwoI1wiICsgaWQgKyBcIilcIik7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5fY2ZnLmhhc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlU2hhcGUodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3NldENvbG9yID0gZnVuY3Rpb24gX3NldENvbG9yKG1vZGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBlbCA9IG1vZGVsLl9jZmcuZWw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoU1ZHX0FUVFJfTUFQW25hbWVdLCAnbm9uZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG4gICAgaWYgKC9eW3IsUixMLGxdezF9W1xcc10qXFwoLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFyIGlkID0gZGVmcy5maW5kKCdncmFkaWVudCcsIHZhbHVlKTtcblxuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBpZCA9IGRlZnMuYWRkR3JhZGllbnQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoU1ZHX0FUVFJfTUFQW25hbWVdLCBcInVybCgjXCIgKyBpZCArIFwiKVwiKTtcbiAgICB9IGVsc2UgaWYgKC9eW3AsUF17MX1bXFxzXSpcXCgvLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YXIgX2lkID0gZGVmcy5maW5kKCdwYXR0ZXJuJywgdmFsdWUpO1xuXG4gICAgICBpZiAoIV9pZCkge1xuICAgICAgICBfaWQgPSBkZWZzLmFkZFBhdHRlcm4odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoU1ZHX0FUVFJfTUFQW25hbWVdLCBcInVybCgjXCIgKyBfaWQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShTVkdfQVRUUl9NQVBbbmFtZV0sIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRTaGFkb3cgPSBmdW5jdGlvbiBfc2V0U2hhZG93KG1vZGVsKSB7XG4gICAgdmFyIGVsID0gbW9kZWwuX2NmZy5lbDtcbiAgICB2YXIgYXR0cnMgPSBtb2RlbC5fYXR0cnM7XG4gICAgdmFyIGNmZyA9IHtcbiAgICAgIGR4OiBhdHRycy5zaGFkb3dPZmZzZXRYLFxuICAgICAgZHk6IGF0dHJzLnNoYWRvd09mZnNldFksXG4gICAgICBibHVyOiBhdHRycy5zaGFkb3dCbHVyLFxuICAgICAgY29sb3I6IGF0dHJzLnNoYWRvd0NvbG9yXG4gICAgfTtcblxuICAgIGlmICghY2ZnLmR4ICYmICFjZmcuZHkgJiYgIWNmZy5ibHVyICYmICFjZmcuY29sb3IpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuY29udGV4dC5maW5kKCdmaWx0ZXInLCBjZmcpO1xuXG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlkID0gdGhpcy5jb250ZXh0LmFkZFNoYWRvdyhjZmcsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsIFwidXJsKCNcIiArIGlkICsgXCIpXCIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGFpbnRlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWludGVyO1xuXG4vKioqLyB9KSxcbi8qIDIyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgRWxhaW5lIG9uIDIwMTgvNS85LlxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBHcmFkaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIyKTtcblxudmFyIFNoYWRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIzKTtcblxudmFyIEFycm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQpO1xuXG52YXIgQ2xpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjI1KTtcblxudmFyIFBhdHRlcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNik7XG5cbnZhciBEZWZzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmcyhjYW52YXMpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2RlZnMnKTtcbiAgICB2YXIgaWQgPSBVdGlsLnVuaXF1ZUlkKCdkZWZzXycpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgY2FudmFzLmFwcGVuZENoaWxkKGVsKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5kZWZhdWx0QXJyb3cgPSB7fTtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGVmcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZpbmQgPSBmdW5jdGlvbiBmaW5kKHR5cGUsIGF0dHIpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLm1hdGNoKHR5cGUsIGF0dHIpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNoaWxkcmVuW2ldLmlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5maW5kQnlJZCA9IGZ1bmN0aW9uIGZpbmRCeUlkKGlkKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgZmxhZyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0uaWQgPT09IGlkKSB7XG4gICAgICAgIGZsYWcgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYWc7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChpdGVtKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgIGl0ZW0uY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgaXRlbS5wYXJlbnQgPSB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWZhdWx0QXJyb3cgPSBmdW5jdGlvbiBnZXREZWZhdWx0QXJyb3coYXR0cnMsIG5hbWUpIHtcbiAgICB2YXIgc3Ryb2tlID0gYXR0cnMuc3Ryb2tlIHx8IGF0dHJzLnN0cm9rZVN0eWxlO1xuXG4gICAgaWYgKHRoaXMuZGVmYXVsdEFycm93W3N0cm9rZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBcnJvd1tzdHJva2VdLmlkO1xuICAgIH1cblxuICAgIHZhciBhcnJvdyA9IG5ldyBBcnJvdyhhdHRycywgbmFtZSk7XG4gICAgdGhpcy5kZWZhdWx0QXJyb3dbc3Ryb2tlXSA9IGFycm93O1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoYXJyb3cuZWwpO1xuICAgIHJldHVybiBhcnJvdy5pZDtcbiAgfTtcblxuICBfcHJvdG8uYWRkR3JhZGllbnQgPSBmdW5jdGlvbiBhZGRHcmFkaWVudChjZmcpIHtcbiAgICB2YXIgZ3JhZGllbnQgPSBuZXcgR3JhZGllbnQoY2ZnKTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGdyYWRpZW50LmVsKTtcbiAgICB0aGlzLmFkZChncmFkaWVudCk7XG4gICAgcmV0dXJuIGdyYWRpZW50LmlkO1xuICB9O1xuXG4gIF9wcm90by5hZGRBcnJvdyA9IGZ1bmN0aW9uIGFkZEFycm93KGF0dHJzLCBuYW1lKSB7XG4gICAgdmFyIGFycm93ID0gbmV3IEFycm93KGF0dHJzLCBuYW1lKTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGFycm93LmVsKTtcbiAgICByZXR1cm4gYXJyb3cuaWQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZFNoYWRvdyA9IGZ1bmN0aW9uIGFkZFNoYWRvdyhjZmcpIHtcbiAgICB2YXIgc2hhZG93ID0gbmV3IFNoYWRvdyhjZmcpO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoc2hhZG93LmVsKTtcbiAgICB0aGlzLmFkZChzaGFkb3cpO1xuICAgIHJldHVybiBzaGFkb3cuaWQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZFBhdHRlcm4gPSBmdW5jdGlvbiBhZGRQYXR0ZXJuKGNmZykge1xuICAgIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oY2ZnKTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHBhdHRlcm4uZWwpO1xuICAgIHRoaXMuYWRkKHBhdHRlcm4pO1xuICAgIHJldHVybiBwYXR0ZXJuLmlkO1xuICB9O1xuXG4gIF9wcm90by5hZGRDbGlwID0gZnVuY3Rpb24gYWRkQ2xpcChjZmcpIHtcbiAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKGNmZyk7XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZChjbGlwLmVsKTtcbiAgICB0aGlzLmFkZChjbGlwKTtcbiAgICByZXR1cm4gY2xpcC5pZDtcbiAgfTtcblxuICByZXR1cm4gRGVmcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZzO1xuXG4vKioqLyB9KSxcbi8qIDIyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgRWxhaW5lIG9uIDIwMTgvNS85LlxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciByZWdleExHID0gL15sXFxzKlxcKFxccyooW1xcZC5dKylcXHMqXFwpXFxzKiguKikvaTtcbnZhciByZWdleFJHID0gL15yXFxzKlxcKFxccyooW1xcZC5dKylcXHMqLFxccyooW1xcZC5dKylcXHMqLFxccyooW1xcZC5dKylcXHMqXFwpXFxzKiguKikvaTtcbnZhciByZWdleENvbG9yU3RvcCA9IC9bXFxkLl0rOigjW15cXHNdK3xbXlxcKV0rXFwpKS9pZztcblxuZnVuY3Rpb24gYWRkU3RvcChzdGVwcykge1xuICB2YXIgYXJyID0gc3RlcHMubWF0Y2gocmVnZXhDb2xvclN0b3ApO1xuXG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHN0b3BzID0gJyc7XG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgYSA9IGEuc3BsaXQoJzonKTtcbiAgICBiID0gYi5zcGxpdCgnOicpO1xuICAgIHJldHVybiBOdW1iZXIoYVswXSkgLSBOdW1iZXIoYlswXSk7XG4gIH0pO1xuICBVdGlsLmVhY2goYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGl0ZW0gPSBpdGVtLnNwbGl0KCc6Jyk7XG4gICAgc3RvcHMgKz0gXCI8c3RvcCBvZmZzZXQ9XFxcIlwiICsgaXRlbVswXSArIFwiXFxcIiBzdG9wLWNvbG9yPVxcXCJcIiArIGl0ZW1bMV0gKyBcIlxcXCI+PC9zdG9wPlwiO1xuICB9KTtcbiAgcmV0dXJuIHN0b3BzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbmVHcmFkaWVudChjb2xvciwgZWwpIHtcbiAgdmFyIGFyciA9IHJlZ2V4TEcuZXhlYyhjb2xvcik7XG4gIHZhciBhbmdsZSA9IFV0aWwubW9kKFV0aWwudG9SYWRpYW4ocGFyc2VGbG9hdChhcnJbMV0pKSwgTWF0aC5QSSAqIDIpO1xuICB2YXIgc3RlcHMgPSBhcnJbMl07XG4gIHZhciBzdGFydDtcbiAgdmFyIGVuZDtcblxuICBpZiAoYW5nbGUgPj0gMCAmJiBhbmdsZSA8IDAuNSAqIE1hdGguUEkpIHtcbiAgICBzdGFydCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBlbmQgPSB7XG4gICAgICB4OiAxLFxuICAgICAgeTogMVxuICAgIH07XG4gIH0gZWxzZSBpZiAoMC41ICogTWF0aC5QSSA8PSBhbmdsZSAmJiBhbmdsZSA8IE1hdGguUEkpIHtcbiAgICBzdGFydCA9IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICBlbmQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMVxuICAgIH07XG4gIH0gZWxzZSBpZiAoTWF0aC5QSSA8PSBhbmdsZSAmJiBhbmdsZSA8IDEuNSAqIE1hdGguUEkpIHtcbiAgICBzdGFydCA9IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfTtcbiAgICBlbmQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogMSxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIHRhblRoZXRhID0gTWF0aC50YW4oYW5nbGUpO1xuICB2YXIgdGFuVGhldGEyID0gdGFuVGhldGEgKiB0YW5UaGV0YTtcbiAgdmFyIHggPSAoZW5kLnggLSBzdGFydC54ICsgdGFuVGhldGEgKiAoZW5kLnkgLSBzdGFydC55KSkgLyAodGFuVGhldGEyICsgMSkgKyBzdGFydC54O1xuICB2YXIgeSA9IHRhblRoZXRhICogKGVuZC54IC0gc3RhcnQueCArIHRhblRoZXRhICogKGVuZC55IC0gc3RhcnQueSkpIC8gKHRhblRoZXRhMiArIDEpICsgc3RhcnQueTtcbiAgZWwuc2V0QXR0cmlidXRlKCd4MScsIHN0YXJ0LngpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3kxJywgc3RhcnQueSk7XG4gIGVsLnNldEF0dHJpYnV0ZSgneDInLCB4KTtcbiAgZWwuc2V0QXR0cmlidXRlKCd5MicsIHkpO1xuICBlbC5pbm5lckhUTUwgPSBhZGRTdG9wKHN0ZXBzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VSYWRpYWxHcmFkaWVudChjb2xvciwgc2VsZikge1xuICB2YXIgYXJyID0gcmVnZXhSRy5leGVjKGNvbG9yKTtcbiAgdmFyIGN4ID0gcGFyc2VGbG9hdChhcnJbMV0pO1xuICB2YXIgY3kgPSBwYXJzZUZsb2F0KGFyclsyXSk7XG4gIHZhciByID0gcGFyc2VGbG9hdChhcnJbM10pO1xuICB2YXIgc3RlcHMgPSBhcnJbNF07XG4gIHNlbGYuc2V0QXR0cmlidXRlKCdjeCcsIGN4KTtcbiAgc2VsZi5zZXRBdHRyaWJ1dGUoJ2N5JywgY3kpO1xuICBzZWxmLnNldEF0dHJpYnV0ZSgncicsIHIpO1xuICBzZWxmLmlubmVySFRNTCA9IGFkZFN0b3Aoc3RlcHMpO1xufVxuXG52YXIgR3JhZGllbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHcmFkaWVudChjZmcpIHtcbiAgICB2YXIgZWwgPSBudWxsO1xuICAgIHZhciBpZCA9IFV0aWwudW5pcXVlSWQoJ2dyYWRpZW50XycpO1xuXG4gICAgaWYgKGNmZy50b0xvd2VyQ2FzZSgpWzBdID09PSAnbCcpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdsaW5lYXJHcmFkaWVudCcpO1xuICAgICAgcGFyc2VMaW5lR3JhZGllbnQoY2ZnLCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdyYWRpYWxHcmFkaWVudCcpO1xuICAgICAgcGFyc2VSYWRpYWxHcmFkaWVudChjZmcsIGVsKTtcbiAgICB9XG5cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jZmcgPSBjZmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gR3JhZGllbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHR5cGUsIGF0dHIpIHtcbiAgICByZXR1cm4gdGhpcy5jZmcgPT09IGF0dHI7XG4gIH07XG5cbiAgcmV0dXJuIEdyYWRpZW50O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50O1xuXG4vKioqLyB9KSxcbi8qIDIyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgRWxhaW5lIG9uIDIwMTgvNS8xMC5cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQVRUUl9NQVAgPSB7XG4gIHNoYWRvd0NvbG9yOiAnY29sb3InLFxuICBzaGFkb3dPcGFjaXR5OiAnb3BhY2l0eScsXG4gIHNoYWRvd0JsdXI6ICdibHVyJyxcbiAgc2hhZG93T2Zmc2V0WDogJ2R4JyxcbiAgc2hhZG93T2Zmc2V0WTogJ2R5J1xufTtcbnZhciBTSEFET1dfRElNRU5TSU9OID0ge1xuICB4OiAnLTQwJScsXG4gIHk6ICctNDAlJyxcbiAgd2lkdGg6ICcyMDAlJyxcbiAgaGVpZ2h0OiAnMjAwJSdcbn07XG5cbnZhciBTaGFkb3cgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGFkb3coY2ZnKSB7XG4gICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdmaWx0ZXInKTsgLy8gZXhwYW5kIHRoZSBmaWx0ZXIgcmVnaW9uIHRvIGZpbGwgaW4gc2hhZG93c1xuXG4gICAgVXRpbC5lYWNoKFNIQURPV19ESU1FTlNJT04sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoaywgdik7XG4gICAgfSk7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuaWQgPSBVdGlsLnVuaXF1ZUlkKCdmaWx0ZXJfJyk7XG4gICAgdGhpcy5lbC5pZCA9IHRoaXMuaWQ7XG4gICAgdGhpcy5jZmcgPSBjZmc7XG5cbiAgICB0aGlzLl9wYXJzZVNoYWRvdyhjZmcsIGVsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoYWRvdy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godHlwZSwgY2ZnKSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jZmc7XG4gICAgVXRpbC5lYWNoKE9iamVjdC5rZXlzKGNvbmZpZyksIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICBpZiAoY29uZmlnW2F0dHJdICE9PSBjZmdbYXR0cl0pIHtcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZsYWc7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNmZztcbiAgICBjb25maWdbQVRUUl9NQVBbbmFtZV1dID0gdmFsdWU7XG5cbiAgICB0aGlzLl9wYXJzZVNoYWRvdyhjb25maWcsIHRoaXMuZWwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVNoYWRvdyA9IGZ1bmN0aW9uIF9wYXJzZVNoYWRvdyhjb25maWcsIGVsKSB7XG4gICAgdmFyIGNoaWxkID0gXCI8ZmVEcm9wU2hhZG93IFxcbiAgICAgIGR4PVxcXCJcIiArIChjb25maWcuZHggfHwgMCkgKyBcIlxcXCIgXFxuICAgICAgZHk9XFxcIlwiICsgKGNvbmZpZy5keSB8fCAwKSArIFwiXFxcIiBcXG4gICAgICBzdGREZXZpYXRpb249XFxcIlwiICsgKGNvbmZpZy5ibHVyID8gY29uZmlnLmJsdXIgLyAxMCA6IDApICsgXCJcXFwiXFxuICAgICAgZmxvb2QtY29sb3I9XFxcIlwiICsgKGNvbmZpZy5jb2xvciA/IGNvbmZpZy5jb2xvciA6ICcjMDAwJykgKyBcIlxcXCJcXG4gICAgICBmbG9vZC1vcGFjaXR5PVxcXCJcIiArIChjb25maWcub3BhY2l0eSA/IGNvbmZpZy5vcGFjaXR5IDogMSkgKyBcIlxcXCJcXG4gICAgICAvPlwiO1xuICAgIGVsLmlubmVySFRNTCA9IGNoaWxkO1xuICB9O1xuXG4gIHJldHVybiBTaGFkb3c7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZG93O1xuXG4vKioqLyB9KSxcbi8qIDIyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgRWxhaW5lIG9uIDIwMTgvNS8xMS5cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQXJyb3cgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBcnJvdyhhdHRycywgdHlwZSkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnbWFya2VyJyk7XG4gICAgdmFyIGlkID0gVXRpbC51bmlxdWVJZCgnbWFya2VyXycpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgdmFyIHNoYXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG4gICAgc2hhcGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGF0dHJzLnN0cm9rZSB8fCAnIzAwMCcpO1xuICAgIGVsLmFwcGVuZENoaWxkKHNoYXBlKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ29yaWVudCcsICdhdXRvLXN0YXJ0LXJldmVyc2UnKTtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jaGlsZCA9IHNoYXBlO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNmZyA9IGF0dHJzW3R5cGUgPT09ICdtYXJrZXItc3RhcnQnID8gJ3N0YXJ0QXJyb3cnIDogJ2VuZEFycm93J107XG4gICAgdGhpcy5zdHJva2UgPSBhdHRycy5zdHJva2UgfHwgJyMwMDAnO1xuXG4gICAgaWYgKHRoaXMuY2ZnID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UGF0aCh0eXBlLCBzaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldE1hcmtlcihhdHRycy5saW5lV2lkdGgsIHNoYXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBcnJvdy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5fc2V0RGVmYXVsdFBhdGggPSBmdW5jdGlvbiBfc2V0RGVmYXVsdFBhdGgodHlwZSwgZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5lbDtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAsMCBMNiwzIEwwLDYgTDMsM1onKTtcbiAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCdyZWZYJywgMyk7XG4gICAgcGFyZW50LnNldEF0dHJpYnV0ZSgncmVmWScsIDMpO1xuICB9O1xuXG4gIF9wcm90by5fc2V0TWFya2VyID0gZnVuY3Rpb24gX3NldE1hcmtlcihyLCBlbCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmVsO1xuICAgIHZhciBwYXRoID0gdGhpcy5jZmcucGF0aDtcbiAgICB2YXIgZCA9IHRoaXMuY2ZnLmQ7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHBhdGgpKSB7XG4gICAgICBwYXRoID0gcGF0aC5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQuam9pbignICcpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuXG4gICAgZWwuc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsKTtcblxuICAgIGlmIChkKSB7XG4gICAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCdyZWZYJywgZCAvIHIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGZpbGwpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkLmF0dHIpIHtcbiAgICAgIGNoaWxkLmF0dHIoJ2ZpbGwnLCBmaWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdmaWxsJywgZmlsbCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBBcnJvdztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJvdztcblxuLyoqKi8gfSksXG4vKiAyMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IEVsYWluZSBvbiAyMDE4LzUvMTQuXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIENsaXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDbGlwKGNmZykge1xuICAgIHRoaXMudHlwZSA9ICdjbGlwJztcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2NsaXBQYXRoJyk7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuaWQgPSBVdGlsLnVuaXF1ZUlkKCdjbGlwXycpO1xuICAgIGVsLmlkID0gdGhpcy5pZDtcbiAgICB2YXIgc2hhcGVFbCA9IGNmZy5fY2ZnLmVsOyAvLyBqdXN0IGluIGNhc2UgdGhlIGNsaXAgc2hhcGUgaXMgYWxzbyBhIHNoYXBlIG5lZWRzIHRvIGJlIGRyYXduXG5cbiAgICBlbC5hcHBlbmRDaGlsZChzaGFwZUVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgdGhpcy5jZmcgPSBjZmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2xpcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfTtcblxuICByZXR1cm4gQ2xpcDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGlwO1xuXG4vKioqLyB9KSxcbi8qIDIyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENyZWF0ZWQgYnkgRWxhaW5lIG9uIDIwMTgvNS85LlxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciByZWdleFBSID0gL15wXFxzKlxcKFxccyooW2F4eW5dKVxccypcXClcXHMqKC4qKS9pO1xuXG52YXIgUGF0dGVybiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhdHRlcm4oY2ZnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXR0ZXJuJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdwYXR0ZXJuVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB2YXIgY2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2ltYWdlJyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHZhciBpZCA9IFV0aWwudW5pcXVlSWQoJ3BhdHRlcm5fJyk7XG4gICAgZWwuaWQgPSBpZDtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2ZnID0gY2ZnO1xuICAgIHZhciBhcnIgPSByZWdleFBSLmV4ZWMoY2ZnKTtcbiAgICB2YXIgc291cmNlID0gYXJyWzJdO1xuICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnaHJlZicsIHNvdXJjZSk7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaWYgKCFzb3VyY2UubWF0Y2goL15kYXRhOi9pKSkge1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgfVxuXG4gICAgaW1nLnNyYyA9IHNvdXJjZTtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaW1nLndpZHRoKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaW1nLmhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgb25sb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltZy5vbmxvYWQgPSBvbmxvYWQ7IC8vIEZpeCBvbmxvYWQoKSBidWcgaW4gSUU5XG5cbiAgICAgIGltZy5zcmMgPSBpbWcuc3JjO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBhdHRlcm4ucHJvdG90eXBlO1xuXG4gIF9wcm90by5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHR5cGUsIGF0dHIpIHtcbiAgICByZXR1cm4gdGhpcy5jZmcgPT09IGF0dHI7XG4gIH07XG5cbiAgcmV0dXJuIFBhdHRlcm47XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0dGVybjtcblxuLyoqKi8gfSksXG4vKiAyMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIFRBR19NQVAgPSB7XG4gIHN2ZzogJ3N2ZycsXG4gIGNpcmNsZTogJ2NpcmNsZScsXG4gIHJlY3Q6ICdyZWN0JyxcbiAgdGV4dDogJ3RleHQnLFxuICBwYXRoOiAncGF0aCcsXG4gIGZvcmVpZ25PYmplY3Q6ICdmb3JlaWduT2JqZWN0JyxcbiAgcG9seWdvbjogJ3BvbHlnb24nLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGltYWdlOiAnaW1hZ2UnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNoYXBlKHgsIHksIGUpIHtcbiAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuICBpZiAoIVRBR19NQVBbdGFyZ2V0LnRhZ05hbWVdKSB7XG4gICAgdmFyIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhVEFHX01BUFtwYXJlbnQudGFnTmFtZV0pIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHBhcmVudDtcbiAgfVxuXG4gIGlmICh0aGlzLl9jZmcuZWwgPT09IHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLl9jZmcgJiYgaXRlbS5fY2ZnLmVsID09PSB0YXJnZXQ7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZEV2ZW50TGlzdGVuZXI6IF9fd2VicGFja19yZXF1aXJlX18oMjI5KSxcbiAgY3JlYXRlRG9tOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KSxcbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMCksXG4gIGdldEhlaWdodDogX193ZWJwYWNrX3JlcXVpcmVfXygyMzEpLFxuICBnZXRPdXRlckhlaWdodDogX193ZWJwYWNrX3JlcXVpcmVfXygyMzIpLFxuICBnZXRPdXRlcldpZHRoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMyksXG4gIGdldFJhdGlvOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNCksXG4gIGdldFN0eWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNSksXG4gIGdldFdpZHRoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNiksXG4gIG1vZGlmeUNTUzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NSksXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZTogX193ZWJwYWNrX3JlcXVpcmVfXyg5Nilcbn07XG5cbi8qKiovIH0pLFxuLyogMjI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICog5re75Yqg5LqL5Lu255uR5ZCs5ZmoXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldCBET03lr7nosaFcbiAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnRUeXBlIOS6i+S7tuWQjVxuICogQHBhcmFtICB7RnVudGlvbn0gY2FsbGJhY2sg5Zue6LCD5Ye95pWwXG4gKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuWvueixoVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChub2RlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKG5vZGUgJiYgbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3A7XG4gICAgdmFyIGxlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50TGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiByZWN0LnRvcCAtIHRvcCxcbiAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLSB0b3AsXG4gICAgICBsZWZ0OiByZWN0LmxlZnQgLSBsZWZ0LFxuICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBsZWZ0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKiovIH0pLFxuLyogMjMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICog6I635Y+W6auY5bqmXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgZG9t6IqC54K5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZmF1bHRWYWx1ZSDpu5jorqTlgLxcbiAqIEByZXR1cm4ge051bWJlcn0g6auY5bqmXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoZWwsICdoZWlnaHQnLCBkZWZhdWx0VmFsdWUpO1xuXG4gIGlmIChoZWlnaHQgPT09ICdhdXRvJykge1xuICAgIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZsb2F0KGhlaWdodCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIOiOt+WPluWkluWxgumrmOW6plxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsIGRvbeiKgueCuVxuICogQHBhcmFtICB7TnVtYmVyfSBkZWZhdWx0VmFsdWUg6buY6K6k5YC8XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IOmrmOW6plxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE91dGVySGVpZ2h0KGVsLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KGVsLCBkZWZhdWx0VmFsdWUpO1xuICB2YXIgYlRvcCA9IHBhcnNlRmxvYXQodGhpcy5nZXRTdHlsZShlbCwgJ2JvcmRlclRvcFdpZHRoJykpIHx8IDA7XG4gIHZhciBwVG9wID0gcGFyc2VGbG9hdCh0aGlzLmdldFN0eWxlKGVsLCAncGFkZGluZ1RvcCcpKSB8fCAwO1xuICB2YXIgcEJvdHRvbSA9IHBhcnNlRmxvYXQodGhpcy5nZXRTdHlsZShlbCwgJ3BhZGRpbmdCb3R0b20nKSkgfHwgMDtcbiAgdmFyIGJCb3R0b20gPSBwYXJzZUZsb2F0KHRoaXMuZ2V0U3R5bGUoZWwsICdib3JkZXJCb3R0b21XaWR0aCcpKSB8fCAwO1xuICByZXR1cm4gaGVpZ2h0ICsgYlRvcCArIGJCb3R0b20gKyBwVG9wICsgcEJvdHRvbTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICog6I635Y+W5aSW5bGC5a695bqmXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgZG9t6IqC54K5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZmF1bHRWYWx1ZSDpu5jorqTlgLxcbiAqIEByZXR1cm4ge051bWJlcn0g5a695bqmXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3V0ZXJXaWR0aChlbCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoZWwsIGRlZmF1bHRWYWx1ZSk7XG4gIHZhciBiTGVmdCA9IHBhcnNlRmxvYXQodGhpcy5nZXRTdHlsZShlbCwgJ2JvcmRlckxlZnRXaWR0aCcpKSB8fCAwO1xuICB2YXIgcExlZnQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0U3R5bGUoZWwsICdwYWRkaW5nTGVmdCcpKSB8fCAwO1xuICB2YXIgcFJpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmdldFN0eWxlKGVsLCAncGFkZGluZ1JpZ2h0JykpIHx8IDA7XG4gIHZhciBiUmlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0U3R5bGUoZWwsICdib3JkZXJSaWdodFdpZHRoJykpIHx8IDA7XG4gIHJldHVybiB3aWR0aCArIGJMZWZ0ICsgYlJpZ2h0ICsgcExlZnQgKyBwUmlnaHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFJhdGlvKCkge1xuICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDI7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyoqXG4gKiDojrflj5bmoLflvI9cbiAqIEBwYXJhbSAge09iamVjdH0gZG9tIERPTeiKgueCuVxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIOagt+W8j+WQjVxuICogQHBhcmFtICB7QW55fSBkZWZhdWx0VmFsdWUg6buY6K6k5YC8XG4gKiBAcmV0dXJuIHtTdHJpbmd9IOWxnuaAp+WAvFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTdHlsZShkb20sIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB0cnkge1xuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSwgbnVsbClbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbS5jdXJyZW50U3R5bGVbbmFtZV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWlzTmlsKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICog6I635Y+W5a695bqmXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgIGRvbeiKgueCuVxuICogQHBhcmFtICB7TnVtYmVyfSBkZWZhdWx0VmFsdWUg6buY6K6k5YC8XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IOWuveW6plxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFdpZHRoKGVsLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZShlbCwgJ3dpZHRoJywgZGVmYXVsdFZhbHVlKTtcblxuICBpZiAod2lkdGggPT09ICdhdXRvJykge1xuICAgIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gIH1cblxuICByZXR1cm4gcGFyc2VGbG9hdCh3aWR0aCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGFpbnM6IF9fd2VicGFja19yZXF1aXJlX18oNDEpLFxuICBkaWZmZXJlbmNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOCksXG4gIGZpbmQ6IF9fd2VicGFja19yZXF1aXJlX18oMjM5KSxcbiAgZmlyc3RWYWx1ZTogX193ZWJwYWNrX3JlcXVpcmVfXygyNDApLFxuICBmbGF0dGVuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0MSksXG4gIGZsYXR0ZW5EZWVwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0MiksXG4gIGdldFJhbmdlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0MyksXG4gIG1lcmdlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSxcbiAgcHVsbDogX193ZWJwYWNrX3JlcXVpcmVfXyg5MCksXG4gIHB1bGxBdDogX193ZWJwYWNrX3JlcXVpcmVfXygxMzApLFxuICByZWR1Y2U6IF9fd2VicGFja19yZXF1aXJlX18oMjQ0KSxcbiAgcmVtb3ZlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NSksXG4gIHNvcnRCeTogX193ZWJwYWNrX3JlcXVpcmVfXygyNDYpLFxuICB1bmlvbjogX193ZWJwYWNrX3JlcXVpcmVfXygyNDcpLFxuICB1bmlxOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMSksXG4gIHZhbHVlc09mS2V5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KVxufTtcblxuLyoqKi8gfSksXG4vKiAyMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXG52YXIgY29udGFpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKiBkaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTsgIC8vID0+IFsxXVxuICovXG5cblxudmFyIGRpZmZlcmVuY2UgPSBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycikge1xuICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIGZpbHRlcihhcnIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhY29udGFpbnModmFsdWVzLCB2YWx1ZSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuXG4vKioqLyB9KSxcbi8qIDIzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgaXNNYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4KTtcblxuZnVuY3Rpb24gZmluZChhcnIsIHByZWRpY2F0ZSkge1xuICB2YXIgX3ByZWRpY2F0ZSA9IHZvaWQgMDtcblxuICBpZiAoaXNGdW5jdGlvbihwcmVkaWNhdGUpKSB7XG4gICAgX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgfVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHByZWRpY2F0ZSkpIHtcbiAgICBfcHJlZGljYXRlID0gZnVuY3Rpb24gX3ByZWRpY2F0ZShhKSB7XG4gICAgICByZXR1cm4gaXNNYXRjaChhLCBwcmVkaWNhdGUpO1xuICAgIH07XG4gIH1cblxuICBpZiAoX3ByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoX3ByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgIHJldHVybiBhcnJbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcblxuLyoqKi8gfSksXG4vKiAyNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzTmlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgZmlyc3RWYWx1ZSA9IGZ1bmN0aW9uIGZpcnN0VmFsdWUoZGF0YSwgbmFtZSkge1xuICB2YXIgcnN0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqID0gZGF0YVtpXTtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAoIWlzTmlsKHZhbHVlKSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJzdCA9IHZhbHVlWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnN0ID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpcnN0VmFsdWU7XG5cbi8qKiovIH0pLFxuLyogMjQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTsgIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuXG5cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBlYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXNBcnJheShpdGVtKSkge1xuICAgICAgZWFjaChpdGVtLCBmdW5jdGlvbiAoc3ViSXRlbSkge1xuICAgICAgICByZXN1bHQucHVzaChzdWJJdGVtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG4vKioqLyB9KSxcbi8qIDI0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIGFycmF5IHRvIHJldHVybi5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pOyAgLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gKi9cblxuXG52YXIgZmxhdHRlbkRlZXAgPSBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnIpIHtcbiAgdmFyIHJlc3VsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgaWYgKCFpc0FycmF5KGFycikpIHtcbiAgICByZXN1bHQucHVzaChhcnIpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBmbGF0dGVuRGVlcChhcnJbaV0sIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkRlZXA7XG5cbi8qKiovIH0pLFxuLyogMjQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgZ2V0UmFuZ2UgPSBmdW5jdGlvbiBnZXRSYW5nZSh2YWx1ZXMpIHtcbiAgLy8g5a2Y5ZyoIE5hTiDml7bvvIxtaW4sbWF4IOWIpOWumuS8muWHuumXrumimFxuICB2YWx1ZXMgPSBmaWx0ZXIodmFsdWVzLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAhaXNOYU4odik7XG4gIH0pO1xuXG4gIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgIC8vIOWmguaenOayoeacieaVsOWAvOWImeebtOaOpei/lOWbnjBcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAwXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICB2YXIgdG1wID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG1wID0gdG1wLmNvbmNhdCh2YWx1ZXNbaV0pO1xuICAgIH1cblxuICAgIHZhbHVlcyA9IHRtcDtcbiAgfVxuXG4gIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB2YWx1ZXMpO1xuICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYW5nZTtcblxuLyoqKi8gfSksXG4vKiAyNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciByZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoYXJyLCBmbiwgaW5pdCkge1xuICBpZiAoIWlzQXJyYXkoYXJyKSAmJiAhaXNQbGFpbk9iamVjdChhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBpbml0O1xuICBlYWNoKGFyciwgZnVuY3Rpb24gKGRhdGEsIGkpIHtcbiAgICByZXN1bHQgPSBmbihyZXN1bHQsIGRhdGEsIGkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlO1xuXG4vKioqLyB9KSxcbi8qIDI0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIHB1bGxBdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMwKTtcblxudmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhcnIsIHByZWRpY2F0ZSkge1xuICAvKipcbiAgICogY29uc3QgYXJyID0gWzEsIDIsIDMsIDRdXG4gICAqIGNvbnN0IGV2ZW5zID0gcmVtb3ZlKGFyciwgbiA9PiBuICUgMiA9PSAwKVxuICAgKiBjb25zb2xlLmxvZyhhcnIpIC8vID0+IFsxLCAzXVxuICAgKiBjb25zb2xlLmxvZyhldmVucykgLy8gPT4gWzIsIDRdXG4gICAqL1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFpc0FycmF5TGlrZShhcnIpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBpbmRleGVzID0gW107XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJbaV07XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpLCBhcnIpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICB9XG5cbiAgcHVsbEF0KGFyciwgaW5kZXhlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbW92ZTtcblxuLyoqKi8gfSksXG4vKiAyNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gc29ydEJ5KGFyciwga2V5KSB7XG4gIHZhciBjb21wYXJlciA9IHZvaWQgMDtcblxuICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgY29tcGFyZXIgPSBmdW5jdGlvbiBjb21wYXJlcihhLCBiKSB7XG4gICAgICByZXR1cm4ga2V5KGEpIC0ga2V5KGIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGlmIChpc1N0cmluZyhrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoa2V5KSkge1xuICAgICAga2V5cyA9IGtleTtcbiAgICB9XG5cbiAgICBjb21wYXJlciA9IGZ1bmN0aW9uIGNvbXBhcmVyKGEsIGIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGFbcHJvcF0gPiBiW3Byb3BdKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYVtwcm9wXSA8IGJbcHJvcF0pIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgfVxuXG4gIGFyci5zb3J0KGNvbXBhcmVyKTtcbiAgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG5cbi8qKiovIH0pLFxuLyogMjQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIHRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyIHVuaXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMSk7XG5cbnZhciB1bmlvbiA9IGZ1bmN0aW9uIHVuaW9uKCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBzb3VyY2VzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBlYWNoKHNvdXJjZXMsIGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGFycik7XG4gIH0pO1xuICByZXR1cm4gdW5pcShyZXN1bHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcblxuLyoqKi8gfSksXG4vKiAyNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFdyYXBCZWhhdmlvcjogX193ZWJwYWNrX3JlcXVpcmVfXygyNDkpLFxuICB3cmFwQmVoYXZpb3I6IF9fd2VicGFja19yZXF1aXJlX18oMjUwKVxufTtcblxuLyoqKi8gfSksXG4vKiAyNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiDojrflj5blsIHoo4XnmoTkuovku7ZcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAg5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiDkuovku7blkI3np7BcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAg6L+U5Zue5LqL5Lu25aSE55CG5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBCZWhhdmlvcihvYmosIGFjdGlvbikge1xuICByZXR1cm4gb2JqWydfd3JhcF8nICsgYWN0aW9uXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRXcmFwQmVoYXZpb3I7XG5cbi8qKiovIH0pLFxuLyogMjUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICog5bCB6KOF5LqL5Lu277yM5L6/5LqO5L2/55So5LiK5LiL5paHdGhpcyzlkozkvr/kuo7op6PpmaTkuovku7bml7bkvb/nlKhcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAg5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiDkuovku7blkI3np7BcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAg6L+U5Zue5LqL5Lu25aSE55CG5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIHdyYXBCZWhhdmlvcihvYmosIGFjdGlvbikge1xuICBpZiAob2JqWydfd3JhcF8nICsgYWN0aW9uXSkge1xuICAgIHJldHVybiBvYmpbJ193cmFwXycgKyBhY3Rpb25dO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uIG1ldGhvZChlKSB7XG4gICAgb2JqW2FjdGlvbl0oZSk7XG4gIH07XG5cbiAgb2JqWydfd3JhcF8nICsgYWN0aW9uXSA9IG1ldGhvZDtcbiAgcmV0dXJuIG1ldGhvZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwQmVoYXZpb3I7XG5cbi8qKiovIH0pLFxuLyogMjUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBudW1iZXIyY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1Mik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBudW1iZXIyY29sb3I6IG51bWJlcjJjb2xvcixcbiAgbnVtYmVyVG9Db2xvcjogbnVtYmVyMmNvbG9yLFxuICBwYXJzZVBhdGg6IF9fd2VicGFja19yZXF1aXJlX18oMjUzKSxcbiAgcGFyc2VSYWRpdXM6IF9fd2VicGFja19yZXF1aXJlX18oMjU0KVxufTtcblxuLyoqKi8gfSksXG4vKiAyNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIG51bUNvbG9yQ2FjaGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBudW1iZXJUb0NvbG9yKG51bSkge1xuICAvLyDlop7liqDnvJPlrZhcbiAgdmFyIGNvbG9yID0gbnVtQ29sb3JDYWNoZVtudW1dO1xuXG4gIGlmICghY29sb3IpIHtcbiAgICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcblxuICAgIGZvciAodmFyIGkgPSBzdHIubGVuZ3RoOyBpIDwgNjsgaSsrKSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuXG4gICAgY29sb3IgPSAnIycgKyBzdHI7XG4gICAgbnVtQ29sb3JDYWNoZVtudW1dID0gY29sb3I7XG4gIH1cblxuICByZXR1cm4gY29sb3I7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciByZWdleFRhZ3MgPSAvW01MSFZRVENTQVpdKFteTUxIVlFUQ1NBWl0qKS9pZztcbnZhciByZWdleERvdCA9IC9bXlxcc1xcLF0rL2lnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHBhdGggPSBwYXRoIHx8IFtdO1xuXG4gIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcocGF0aCkpIHtcbiAgICBwYXRoID0gcGF0aC5tYXRjaChyZWdleFRhZ3MpO1xuICAgIGVhY2gocGF0aCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBpdGVtID0gaXRlbS5tYXRjaChyZWdleERvdCk7XG5cbiAgICAgIGlmIChpdGVtWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IGl0ZW1bMF0uY2hhckF0KDApO1xuICAgICAgICBpdGVtLnNwbGljZSgxLCAwLCBpdGVtWzBdLnN1YnN0cigxKSk7XG4gICAgICAgIGl0ZW1bMF0gPSB0YWc7XG4gICAgICB9XG5cbiAgICAgIGVhY2goaXRlbSwgZnVuY3Rpb24gKHN1YiwgaSkge1xuICAgICAgICBpZiAoIWlzTmFOKHN1YikpIHtcbiAgICAgICAgICBpdGVtW2ldID0gK3N1YjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRoW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVJhZGl1cyhyYWRpdXMpIHtcbiAgdmFyIHIxID0gMCxcbiAgICAgIHIyID0gMCxcbiAgICAgIHIzID0gMCxcbiAgICAgIHI0ID0gMDtcblxuICBpZiAoaXNBcnJheShyYWRpdXMpKSB7XG4gICAgaWYgKHJhZGl1cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcmFkaXVzWzBdO1xuICAgIH0gZWxzZSBpZiAocmFkaXVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJhZGl1c1swXTtcbiAgICAgIHIyID0gcjQgPSByYWRpdXNbMV07XG4gICAgfSBlbHNlIGlmIChyYWRpdXMubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJhZGl1c1swXTtcbiAgICAgIHIyID0gcjQgPSByYWRpdXNbMV07XG4gICAgICByMyA9IHJhZGl1c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByYWRpdXNbMF07XG4gICAgICByMiA9IHJhZGl1c1sxXTtcbiAgICAgIHIzID0gcmFkaXVzWzJdO1xuICAgICAgcjQgPSByYWRpdXNbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcmFkaXVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByMTogcjEsXG4gICAgcjI6IHIyLFxuICAgIHIzOiByMyxcbiAgICByNDogcjRcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc051bWJlckVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGFtcDogX193ZWJwYWNrX3JlcXVpcmVfXyg1MCksXG4gIGZpeGVkQmFzZTogX193ZWJwYWNrX3JlcXVpcmVfXygyNTYpLFxuICBpc0RlY2ltYWw6IF9fd2VicGFja19yZXF1aXJlX18oMjU3KSxcbiAgaXNFdmVuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1OCksXG4gIGlzSW50ZWdlcjogX193ZWJwYWNrX3JlcXVpcmVfXygyNTkpLFxuICBpc05lZ2F0aXZlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCksXG4gIGlzTnVtYmVyRXF1YWw6IGlzTnVtYmVyRXF1YWwsXG4gIGlzT2RkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MSksXG4gIGlzUG9zaXRpdmU6IF9fd2VicGFja19yZXF1aXJlX18oMjYyKSxcbiAgbWF4Qnk6IF9fd2VicGFja19yZXF1aXJlX18oMTMyKSxcbiAgbWluQnk6IF9fd2VicGFja19yZXF1aXJlX18oMjYzKSxcbiAgbW9kOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKSxcbiAgc25hcEVxdWFsOiBpc051bWJlckVxdWFsLFxuICB0b0RlZ3JlZTogX193ZWJwYWNrX3JlcXVpcmVfXyg5MiksXG4gIHRvSW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyksXG4gIHRvSW50ZWdlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxMzMpLFxuICB0b1JhZGlhbjogX193ZWJwYWNrX3JlcXVpcmVfXyg5MSlcbn07XG5cbi8qKiovIH0pLFxuLyogMjU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBmaXhlZEJhc2UgPSBmdW5jdGlvbiBmaXhlZEJhc2UodiwgYmFzZSkge1xuICB2YXIgc3RyID0gYmFzZS50b1N0cmluZygpO1xuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2KTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzdHIuc3Vic3RyKGluZGV4ICsgMSkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPiAyMCkge1xuICAgIGxlbmd0aCA9IDIwO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQodi50b0ZpeGVkKGxlbmd0aCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaXhlZEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMjU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBpc0RlY2ltYWwgPSBmdW5jdGlvbiBpc0RlY2ltYWwobnVtKSB7XG4gIHJldHVybiBpc051bWJlcihudW0pICYmIG51bSAlIDEgIT09IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGVjaW1hbDtcblxuLyoqKi8gfSksXG4vKiAyNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIGlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbihudW0pIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG51bSkgJiYgbnVtICUgMiA9PT0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVuO1xuXG4vKioqLyB9KSxcbi8qIDI1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNOdW1iZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciA/IE51bWJlci5pc0ludGVnZXIgOiBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBpc051bWJlcihudW0pICYmIG51bSAlIDEgPT09IDA7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBpc0ludGVnZXI7XG5cbi8qKiovIH0pLFxuLyogMjYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBpc05hZ2F0aXZlID0gZnVuY3Rpb24gaXNOYWdhdGl2ZShudW0pIHtcbiAgcmV0dXJuIGlzTnVtYmVyKG51bSkgJiYgbnVtIDwgMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOYWdhdGl2ZTtcblxuLyoqKi8gfSksXG4vKiAyNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIGlzT2RkID0gZnVuY3Rpb24gaXNPZGQobnVtKSB7XG4gIHJldHVybiBpc051bWJlcihudW0pICYmIG51bSAlIDIgIT09IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2RkO1xuXG4vKioqLyB9KSxcbi8qIDI2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNOdW1iZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUobnVtKSB7XG4gIHJldHVybiBpc051bWJlcihudW0pICYmIG51bSA+IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUG9zaXRpdmU7XG5cbi8qKiovIH0pLFxuLyogMjYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBtaW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDEgfVxuICpcbiAqIG1pbkJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKi9cblxuXG52YXIgbWluQnkgPSBmdW5jdGlvbiBtaW5CeShhcnIsIGZuKSB7XG4gIGlmICghaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBtaW4gPSBhcnJbMF07XG4gIHZhciBtaW5EYXRhID0gdm9pZCAwO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgIG1pbkRhdGEgPSBmbihhcnJbMF0pO1xuICB9IGVsc2Uge1xuICAgIG1pbkRhdGEgPSBhcnJbMF1bZm5dO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB2b2lkIDA7XG4gIGVhY2goYXJyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICBkYXRhID0gZm4odmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHZhbFtmbl07XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPCBtaW5EYXRhKSB7XG4gICAgICBtaW4gPSB2YWw7XG4gICAgICBtaW5EYXRhID0gZGF0YTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW5CeTtcblxuLyoqKi8gfSksXG4vKiAyNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZvckluOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NSksXG4gIGhhczogX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpLFxuICBoYXNLZXk6IF9fd2VicGFja19yZXF1aXJlX18oMjY2KSxcbiAgaGFzVmFsdWU6IF9fd2VicGFja19yZXF1aXJlX18oMjY3KSxcbiAga2V5czogX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpLFxuICBpc01hdGNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOCksXG4gIHZhbHVlczogX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpXG59O1xuXG4vKioqLyB9KSxcbi8qIDI2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKiovIH0pLFxuLyogMjY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpO1xuXG4vKioqLyB9KSxcbi8qIDI2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29udGFpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIHZhbHVlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICByZXR1cm4gY29udGFpbnModmFsdWVzKG9iaiksIHZhbHVlKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXRoSW50ZXJzZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjkpO1xuXG52YXIgcGF0aDJhYnNvbHV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTM5KTtcblxudmFyIHBhdGgyY3VydmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG5cbnZhciBjYXRtdWxsUm9tMkJlemllciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQxKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhdG11bGxSb20yQmV6aWVyOiBjYXRtdWxsUm9tMkJlemllcixcbiAgY2F0bXVsbFJvbVRvQmV6aWVyOiBjYXRtdWxsUm9tMkJlemllcixcbiAgZmlsbFBhdGg6IF9fd2VicGFja19yZXF1aXJlX18oMjcwKSxcbiAgZmlsbFBhdGhCeURpZmY6IF9fd2VicGFja19yZXF1aXJlX18oMjcxKSxcbiAgZm9ybWF0UGF0aDogX193ZWJwYWNrX3JlcXVpcmVfXygyNzMpLFxuICBpbnRlcnNlY3Rpb246IHBhdGhJbnRlcnNlY3Rpb24sXG4gIHBhdGhJbnRlcnNlY3Rpb246IHBhdGhJbnRlcnNlY3Rpb24sXG4gIHBhcnNlUGF0aEFycmF5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNyksXG4gIHBhcnNlUGF0aFN0cmluZzogX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLFxuICBwYXRoVG9BYnNvbHV0ZTogcGF0aDJhYnNvbHV0ZSxcbiAgcGF0aDJhYnNvbHV0ZTogcGF0aDJhYnNvbHV0ZSxcbiAgcGF0aFRvY3VydmU6IHBhdGgyY3VydmUsXG4gIHBhdGgyY3VydmU6IHBhdGgyY3VydmUsXG4gIHJlY3RQYXRoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNilcbn07XG5cbi8qKiovIH0pLFxuLyogMjY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIHJlY3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xuXG52YXIgcGF0aFRvY3VydmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG5cbnZhciBiYXNlMyA9IGZ1bmN0aW9uIGJhc2UzKHQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciB0MSA9IC0zICogcDEgKyA5ICogcDIgLSA5ICogcDMgKyAzICogcDQ7XG4gIHZhciB0MiA9IHQgKiB0MSArIDYgKiBwMSAtIDEyICogcDIgKyA2ICogcDM7XG4gIHJldHVybiB0ICogdDIgLSAzICogcDEgKyAzICogcDI7XG59O1xuXG52YXIgYmV6bGVuID0gZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICBpZiAoeiA9PT0gbnVsbCkge1xuICAgIHogPSAxO1xuICB9XG5cbiAgeiA9IHogPiAxID8gMSA6IHogPCAwID8gMCA6IHo7XG4gIHZhciB6MiA9IHogLyAyO1xuICB2YXIgbiA9IDEyO1xuICB2YXIgVHZhbHVlcyA9IFstMC4xMjUyLCAwLjEyNTIsIC0wLjM2NzgsIDAuMzY3OCwgLTAuNTg3MywgMC41ODczLCAtMC43Njk5LCAwLjc2OTksIC0wLjkwNDEsIDAuOTA0MSwgLTAuOTgxNiwgMC45ODE2XTtcbiAgdmFyIEN2YWx1ZXMgPSBbMC4yNDkxLCAwLjI0OTEsIDAuMjMzNSwgMC4yMzM1LCAwLjIwMzIsIDAuMjAzMiwgMC4xNjAxLCAwLjE2MDEsIDAuMTA2OSwgMC4xMDY5LCAwLjA0NzIsIDAuMDQ3Ml07XG4gIHZhciBzdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGN0ID0gejIgKiBUdmFsdWVzW2ldICsgejI7XG4gICAgdmFyIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KTtcbiAgICB2YXIgeWJhc2UgPSBiYXNlMyhjdCwgeTEsIHkyLCB5MywgeTQpO1xuICAgIHZhciBjb21iID0geGJhc2UgKiB4YmFzZSArIHliYXNlICogeWJhc2U7XG4gICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBNYXRoLnNxcnQoY29tYik7XG4gIH1cblxuICByZXR1cm4gejIgKiBzdW07XG59O1xuXG52YXIgY3VydmVEaW0gPSBmdW5jdGlvbiBjdXJ2ZURpbSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHR2YWx1ZXMgPSBbXTtcbiAgdmFyIGJvdW5kcyA9IFtbXSwgW11dO1xuICB2YXIgYSA9IHZvaWQgMDtcbiAgdmFyIGIgPSB2b2lkIDA7XG4gIHZhciBjID0gdm9pZCAwO1xuICB2YXIgdCA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0ID0gLWMgLyBiO1xuXG4gICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgIHZhciBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcblxuICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcblxuICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSB7XG4gICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgIH1cblxuICAgIHZhciB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG5cbiAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaiA9IHR2YWx1ZXMubGVuZ3RoO1xuICB2YXIgamxlbiA9IGo7XG4gIHZhciBtdCA9IHZvaWQgMDtcblxuICB3aGlsZSAoai0tKSB7XG4gICAgdCA9IHR2YWx1ZXNbal07XG4gICAgbXQgPSAxIC0gdDtcbiAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MCArIDMgKiBtdCAqIG10ICogdCAqIHgxICsgMyAqIG10ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkwICsgMyAqIG10ICogbXQgKiB0ICogeTEgKyAzICogbXQgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gIH1cblxuICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuICByZXR1cm4ge1xuICAgIG1pbjoge1xuICAgICAgeDogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzBdKSxcbiAgICAgIHk6IE1hdGgubWluLmFwcGx5KDAsIGJvdW5kc1sxXSlcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgeDogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzBdKSxcbiAgICAgIHk6IE1hdGgubWF4LmFwcGx5KDAsIGJvdW5kc1sxXSlcbiAgICB9XG4gIH07XG59O1xuXG52YXIgaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuICBpZiAoTWF0aC5tYXgoeDEsIHgyKSA8IE1hdGgubWluKHgzLCB4NCkgfHwgTWF0aC5taW4oeDEsIHgyKSA+IE1hdGgubWF4KHgzLCB4NCkgfHwgTWF0aC5tYXgoeTEsIHkyKSA8IE1hdGgubWluKHkzLCB5NCkgfHwgTWF0aC5taW4oeTEsIHkyKSA+IE1hdGgubWF4KHkzLCB5NCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KTtcbiAgdmFyIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCk7XG4gIHZhciBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcjtcbiAgdmFyIHB5ID0gbnkgLyBkZW5vbWluYXRvcjtcbiAgdmFyIHB4MiA9ICtweC50b0ZpeGVkKDIpO1xuICB2YXIgcHkyID0gK3B5LnRvRml4ZWQoMik7XG5cbiAgaWYgKHB4MiA8ICtNYXRoLm1pbih4MSwgeDIpLnRvRml4ZWQoMikgfHwgcHgyID4gK01hdGgubWF4KHgxLCB4MikudG9GaXhlZCgyKSB8fCBweDIgPCArTWF0aC5taW4oeDMsIHg0KS50b0ZpeGVkKDIpIHx8IHB4MiA+ICtNYXRoLm1heCh4MywgeDQpLnRvRml4ZWQoMikgfHwgcHkyIDwgK01hdGgubWluKHkxLCB5MikudG9GaXhlZCgyKSB8fCBweTIgPiArTWF0aC5tYXgoeTEsIHkyKS50b0ZpeGVkKDIpIHx8IHB5MiA8ICtNYXRoLm1pbih5MywgeTQpLnRvRml4ZWQoMikgfHwgcHkyID4gK01hdGgubWF4KHkzLCB5NCkudG9GaXhlZCgyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcHgsXG4gICAgeTogcHlcbiAgfTtcbn07XG5cbnZhciBpc1BvaW50SW5zaWRlQkJveCA9IGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgcmV0dXJuIHggPj0gYmJveC54ICYmIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJiB5ID49IGJib3gueSAmJiB5IDw9IGJib3gueSArIGJib3guaGVpZ2h0O1xufTtcblxudmFyIGJveCA9IGZ1bmN0aW9uIGJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gIH1cblxuICBpZiAoeSA9PT0gbnVsbCkge1xuICAgIHkgPSB4Lnk7XG4gICAgd2lkdGggPSB4LndpZHRoO1xuICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgIHggPSB4Lng7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgdzogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgaDogaGVpZ2h0LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG4gICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgY3k6IHkgKyBoZWlnaHQgLyAyLFxuICAgIHIxOiBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIsXG4gICAgcjI6IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICByMDogTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpIC8gMixcbiAgICBwYXRoOiByZWN0UGF0aCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSxcbiAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oJyAnKVxuICB9O1xufTtcblxudmFyIGlzQkJveEludGVyc2VjdCA9IGZ1bmN0aW9uIGlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpIHtcbiAgYmJveDEgPSBib3goYmJveDEpO1xuICBiYm94MiA9IGJveChiYm94Mik7XG4gIHJldHVybiBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueSkgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KSB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MiwgYmJveDEueCwgYmJveDEueTIpIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54MiwgYmJveDEueTIpIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KSB8fCBpc1BvaW50SW5zaWRlQkJveChiYm94MSwgYmJveDIueDIsIGJib3gyLnkpIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55MikgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MikgfHwgKGJib3gxLnggPCBiYm94Mi54MiAmJiBiYm94MS54ID4gYmJveDIueCB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpICYmIChiYm94MS55IDwgYmJveDIueTIgJiYgYmJveDEueSA+IGJib3gyLnkgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbn07XG5cbnZhciBiZXppZXJCQm94ID0gZnVuY3Rpb24gYmV6aWVyQkJveChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSkge1xuICBpZiAoIWlzQXJyYXkocDF4KSkge1xuICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gIH1cblxuICB2YXIgYmJveCA9IGN1cnZlRGltLmFwcGx5KG51bGwsIHAxeCk7XG4gIHJldHVybiBib3goYmJveC5taW4ueCwgYmJveC5taW4ueSwgYmJveC5tYXgueCAtIGJib3gubWluLngsIGJib3gubWF4LnkgLSBiYm94Lm1pbi55KTtcbn07XG5cbnZhciBmaW5kRG90c0F0U2VnbWVudCA9IGZ1bmN0aW9uIGZpbmREb3RzQXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gIHZhciB0MSA9IDEgLSB0O1xuICB2YXIgdDEzID0gTWF0aC5wb3codDEsIDMpO1xuICB2YXIgdDEyID0gTWF0aC5wb3codDEsIDIpO1xuICB2YXIgdDIgPSB0ICogdDtcbiAgdmFyIHQzID0gdDIgKiB0O1xuICB2YXIgeCA9IHQxMyAqIHAxeCArIHQxMiAqIDMgKiB0ICogYzF4ICsgdDEgKiAzICogdCAqIHQgKiBjMnggKyB0MyAqIHAyeDtcbiAgdmFyIHkgPSB0MTMgKiBwMXkgKyB0MTIgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgdDMgKiBwMnk7XG4gIHZhciBteCA9IHAxeCArIDIgKiB0ICogKGMxeCAtIHAxeCkgKyB0MiAqIChjMnggLSAyICogYzF4ICsgcDF4KTtcbiAgdmFyIG15ID0gcDF5ICsgMiAqIHQgKiAoYzF5IC0gcDF5KSArIHQyICogKGMyeSAtIDIgKiBjMXkgKyBwMXkpO1xuICB2YXIgbnggPSBjMXggKyAyICogdCAqIChjMnggLSBjMXgpICsgdDIgKiAocDJ4IC0gMiAqIGMyeCArIGMxeCk7XG4gIHZhciBueSA9IGMxeSArIDIgKiB0ICogKGMyeSAtIGMxeSkgKyB0MiAqIChwMnkgLSAyICogYzJ5ICsgYzF5KTtcbiAgdmFyIGF4ID0gdDEgKiBwMXggKyB0ICogYzF4O1xuICB2YXIgYXkgPSB0MSAqIHAxeSArIHQgKiBjMXk7XG4gIHZhciBjeCA9IHQxICogYzJ4ICsgdCAqIHAyeDtcbiAgdmFyIGN5ID0gdDEgKiBjMnkgKyB0ICogcDJ5O1xuICB2YXIgYWxwaGEgPSA5MCAtIE1hdGguYXRhbjIobXggLSBueCwgbXkgLSBueSkgKiAxODAgLyBNYXRoLlBJOyAvLyAobXggPiBueCB8fCBteSA8IG55KSAmJiAoYWxwaGEgKz0gMTgwKTtcblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICBtOiB7XG4gICAgICB4OiBteCxcbiAgICAgIHk6IG15XG4gICAgfSxcbiAgICBuOiB7XG4gICAgICB4OiBueCxcbiAgICAgIHk6IG55XG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgeDogYXgsXG4gICAgICB5OiBheVxuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICB4OiBjeCxcbiAgICAgIHk6IGN5XG4gICAgfSxcbiAgICBhbHBoYTogYWxwaGFcbiAgfTtcbn07XG5cbnZhciBpbnRlckhlbHBlciA9IGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpO1xuICB2YXIgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuXG4gIGlmICghaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94MikpIHtcbiAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICB9XG5cbiAgdmFyIGwxID0gYmV6bGVuLmFwcGx5KDAsIGJlejEpO1xuICB2YXIgbDIgPSBiZXpsZW4uYXBwbHkoMCwgYmV6Mik7XG4gIHZhciBuMSA9IH5+KGwxIC8gOCk7XG4gIHZhciBuMiA9IH5+KGwyIC8gOCk7XG4gIHZhciBkb3RzMSA9IFtdO1xuICB2YXIgZG90czIgPSBbXTtcbiAgdmFyIHh5ID0ge307XG4gIHZhciByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMSArIDE7IGkrKykge1xuICAgIHZhciBkID0gZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoMCwgYmV6MS5jb25jYXQoaSAvIG4xKSk7XG4gICAgZG90czEucHVzaCh7XG4gICAgICB4OiBkLngsXG4gICAgICB5OiBkLnksXG4gICAgICB0OiBpIC8gbjFcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMiArIDE7IF9pKyspIHtcbiAgICB2YXIgX2QgPSBmaW5kRG90c0F0U2VnbWVudC5hcHBseSgwLCBiZXoyLmNvbmNhdChfaSAvIG4yKSk7XG5cbiAgICBkb3RzMi5wdXNoKHtcbiAgICAgIHg6IF9kLngsXG4gICAgICB5OiBfZC55LFxuICAgICAgdDogX2kgLyBuMlxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjE7IF9pMisrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuMjsgaisrKSB7XG4gICAgICB2YXIgZGkgPSBkb3RzMVtfaTJdO1xuICAgICAgdmFyIGRpMSA9IGRvdHMxW19pMiArIDFdO1xuICAgICAgdmFyIGRqID0gZG90czJbal07XG4gICAgICB2YXIgZGoxID0gZG90czJbaiArIDFdO1xuICAgICAgdmFyIGNpID0gTWF0aC5hYnMoZGkxLnggLSBkaS54KSA8IDAuMDAxID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGNqID0gTWF0aC5hYnMoZGoxLnggLSBkai54KSA8IDAuMDAxID8gJ3knIDogJ3gnO1xuICAgICAgdmFyIGlzID0gaW50ZXJzZWN0KGRpLngsIGRpLnksIGRpMS54LCBkaTEueSwgZGoueCwgZGoueSwgZGoxLngsIGRqMS55KTtcblxuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09PSBpcy55LnRvRml4ZWQoNCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHh5W2lzLngudG9GaXhlZCg0KV0gPSBpcy55LnRvRml4ZWQoNCk7XG4gICAgICAgIHZhciB0MSA9IGRpLnQgKyBNYXRoLmFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KTtcbiAgICAgICAgdmFyIHQyID0gZGoudCArIE1hdGguYWJzKChpc1tjal0gLSBkaltjal0pIC8gKGRqMVtjal0gLSBkaltjal0pKSAqIChkajEudCAtIGRqLnQpO1xuXG4gICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEgJiYgdDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgaWYgKGp1c3RDb3VudCkge1xuICAgICAgICAgICAgcmVzKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgeDogaXMueCxcbiAgICAgICAgICAgICAgeTogaXMueSxcbiAgICAgICAgICAgICAgdDE6IHQxLFxuICAgICAgICAgICAgICB0MjogdDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgaW50ZXJQYXRoSGVscGVyID0gZnVuY3Rpb24gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMiwganVzdENvdW50KSB7XG4gIHBhdGgxID0gcGF0aFRvY3VydmUocGF0aDEpO1xuICBwYXRoMiA9IHBhdGhUb2N1cnZlKHBhdGgyKTtcbiAgdmFyIHgxID0gdm9pZCAwO1xuICB2YXIgeTEgPSB2b2lkIDA7XG4gIHZhciB4MiA9IHZvaWQgMDtcbiAgdmFyIHkyID0gdm9pZCAwO1xuICB2YXIgeDFtID0gdm9pZCAwO1xuICB2YXIgeTFtID0gdm9pZCAwO1xuICB2YXIgeDJtID0gdm9pZCAwO1xuICB2YXIgeTJtID0gdm9pZCAwO1xuICB2YXIgYmV6MSA9IHZvaWQgMDtcbiAgdmFyIGJlejIgPSB2b2lkIDA7XG4gIHZhciByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aDEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuXG4gICAgaWYgKHBpWzBdID09PSAnTScpIHtcbiAgICAgIHgxID0geDFtID0gcGlbMV07XG4gICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGlbMF0gPT09ICdDJykge1xuICAgICAgICBiZXoxID0gW3gxLCB5MV0uY29uY2F0KHBpLnNsaWNlKDEpKTtcbiAgICAgICAgeDEgPSBiZXoxWzZdO1xuICAgICAgICB5MSA9IGJlejFbN107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXoxID0gW3gxLCB5MSwgeDEsIHkxLCB4MW0sIHkxbSwgeDFtLCB5MW1dO1xuICAgICAgICB4MSA9IHgxbTtcbiAgICAgICAgeTEgPSB5MW07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHBhdGgyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgdmFyIHBqID0gcGF0aDJbal07XG5cbiAgICAgICAgaWYgKHBqWzBdID09PSAnTScpIHtcbiAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgIHkyID0geTJtID0gcGpbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBqWzBdID09PSAnQycpIHtcbiAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgeDIgPSBiZXoyWzZdO1xuICAgICAgICAgICAgeTIgPSBiZXoyWzddO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXoyID0gW3gyLCB5MiwgeDIsIHkyLCB4Mm0sIHkybSwgeDJtLCB5Mm1dO1xuICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICB5MiA9IHkybTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG5cbiAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICByZXMgKz0gaW50cjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGtrID0gaW50ci5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgIGludHJba10uc2VnbWVudDEgPSBpO1xuICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQyID0gajtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoxID0gYmV6MTtcbiAgICAgICAgICAgICAgaW50cltrXS5iZXoyID0gYmV6MjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChpbnRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXRoSW50ZXJzZWN0aW9uKHBhdGgxLCBwYXRoMikge1xuICByZXR1cm4gaW50ZXJQYXRoSGVscGVyKHBhdGgxLCBwYXRoMik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBkZWNhc3RlbGphdShwb2ludHMsIHQpIHtcbiAgdmFyIGxlZnQgPSBbXTtcbiAgdmFyIHJpZ2h0ID0gW107XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShwb2ludHMsIHQpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGVmdC5wdXNoKHBvaW50c1swXSk7XG4gICAgICByaWdodC5wdXNoKHBvaW50c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaWRkbGVQb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbGVmdC5wdXNoKHBvaW50c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICByaWdodC5wdXNoKHBvaW50c1tpICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWlkZGxlUG9pbnRzW2ldID0gWygxIC0gdCkgKiBwb2ludHNbaV1bMF0gKyB0ICogcG9pbnRzW2kgKyAxXVswXSwgKDEgLSB0KSAqIHBvaW50c1tpXVsxXSArIHQgKiBwb2ludHNbaSArIDFdWzFdXTtcbiAgICAgIH1cblxuICAgICAgcmVjdXJzZShtaWRkbGVQb2ludHMsIHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgcmVjdXJzZShwb2ludHMsIHQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodC5yZXZlcnNlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3BsaXRDdXJ2ZShzdGFydCwgZW5kLCBjb3VudCkge1xuICB2YXIgcG9pbnRzID0gW1tzdGFydFsxXSwgc3RhcnRbMl1dXTtcbiAgY291bnQgPSBjb3VudCB8fCAyO1xuICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICBpZiAoZW5kWzBdID09PSAnQScpIHtcbiAgICBwb2ludHMucHVzaChlbmRbNl0pO1xuICAgIHBvaW50cy5wdXNoKGVuZFs3XSk7XG4gIH0gZWxzZSBpZiAoZW5kWzBdID09PSAnQycpIHtcbiAgICBwb2ludHMucHVzaChbZW5kWzFdLCBlbmRbMl1dKTtcbiAgICBwb2ludHMucHVzaChbZW5kWzNdLCBlbmRbNF1dKTtcbiAgICBwb2ludHMucHVzaChbZW5kWzVdLCBlbmRbNl1dKTtcbiAgfSBlbHNlIGlmIChlbmRbMF0gPT09ICdTJyB8fCBlbmRbMF0gPT09ICdRJykge1xuICAgIHBvaW50cy5wdXNoKFtlbmRbMV0sIGVuZFsyXV0pO1xuICAgIHBvaW50cy5wdXNoKFtlbmRbM10sIGVuZFs0XV0pO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cy5wdXNoKFtlbmRbMV0sIGVuZFsyXV0pO1xuICB9XG5cbiAgdmFyIGxlZnRTZWdtZW50cyA9IHBvaW50cztcbiAgdmFyIHQgPSAxIC8gY291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAtIDE7IGkrKykge1xuICAgIHZhciBydCA9IHQgLyAoMSAtIHQgKiBpKTtcbiAgICB2YXIgc3BsaXQgPSBkZWNhc3RlbGphdShsZWZ0U2VnbWVudHMsIHJ0KTtcbiAgICBzZWdtZW50cy5wdXNoKHNwbGl0LmxlZnQpO1xuICAgIGxlZnRTZWdtZW50cyA9IHNwbGl0LnJpZ2h0O1xuICB9XG5cbiAgc2VnbWVudHMucHVzaChsZWZ0U2VnbWVudHMpO1xuICB2YXIgcmVzdWx0ID0gc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgdmFyIGNtZCA9IFtdO1xuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSA0KSB7XG4gICAgICBjbWQucHVzaCgnQycpO1xuICAgICAgY21kID0gY21kLmNvbmNhdChzZWdtZW50WzJdKTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPj0gMykge1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNtZC5wdXNoKCdRJyk7XG4gICAgICB9XG5cbiAgICAgIGNtZCA9IGNtZC5jb25jYXQoc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjbWQucHVzaCgnTCcpO1xuICAgIH1cblxuICAgIGNtZCA9IGNtZC5jb25jYXQoc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdKTtcbiAgICByZXR1cm4gY21kO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3BsaXRTZWdtZW50KHN0YXJ0LCBlbmQsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHJldHVybiBbW10uY29uY2F0KHN0YXJ0KV07XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICBpZiAoZW5kWzBdID09PSAnTCcgfHwgZW5kWzBdID09PSAnQycgfHwgZW5kWzBdID09PSAnUScpIHtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmNvbmNhdChzcGxpdEN1cnZlKHN0YXJ0LCBlbmQsIGNvdW50KSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRlbXAgPSBbXS5jb25jYXQoc3RhcnQpO1xuXG4gICAgaWYgKHRlbXBbMF0gPT09ICdNJykge1xuICAgICAgdGVtcFswXSA9ICdMJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudCAtIDE7IGkrKykge1xuICAgICAgc2VnbWVudHMucHVzaCh0ZW1wKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbFBhdGgoc291cmNlLCB0YXJnZXQpIHtcbiAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIHNvdXJjZUxlbiA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gIHZhciByYXRpbyA9IHNvdXJjZUxlbiAvIHRhcmdldExlbjtcbiAgdmFyIHNlZ21lbnRzVG9GaWxsID0gW107XG5cbiAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDEgJiYgc291cmNlWzBdWzBdID09PSAnTScpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldExlbiAtIHNvdXJjZUxlbjsgaSsrKSB7XG4gICAgICBzb3VyY2UucHVzaChzb3VyY2VbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGFyZ2V0TGVuOyBfaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihyYXRpbyAqIF9pKTtcbiAgICBzZWdtZW50c1RvRmlsbFtpbmRleF0gPSAoc2VnbWVudHNUb0ZpbGxbaW5kZXhdIHx8IDApICsgMTtcbiAgfVxuXG4gIHZhciBmaWxsZWQgPSBzZWdtZW50c1RvRmlsbC5yZWR1Y2UoZnVuY3Rpb24gKGZpbGxlZCwgY291bnQsIGkpIHtcbiAgICBpZiAoaSA9PT0gc291cmNlTGVuKSB7XG4gICAgICByZXR1cm4gZmlsbGVkLmNvbmNhdChzb3VyY2Vbc291cmNlTGVuXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGxlZC5jb25jYXQoc3BsaXRTZWdtZW50KHNvdXJjZVtpXSwgc291cmNlW2kgKyAxXSwgY291bnQpKTtcbiAgfSwgW10pO1xuICBmaWxsZWQudW5zaGlmdChzb3VyY2VbMF0pO1xuXG4gIGlmICh0YXJnZXRbdGFyZ2V0TGVuXSA9PT0gJ1onIHx8IHRhcmdldFt0YXJnZXRMZW5dID09PSAneicpIHtcbiAgICBmaWxsZWQucHVzaCgnWicpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGxlZDtcbn07XG5cbi8qKiovIH0pLFxuLyogMjcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0VxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzIpO1xuXG5mdW5jdGlvbiBnZXRNaW5EaWZmKGRlbCwgYWRkLCBtb2RpZnkpIHtcbiAgdmFyIHR5cGUgPSBudWxsO1xuICB2YXIgbWluID0gbW9kaWZ5O1xuXG4gIGlmIChhZGQgPCBtaW4pIHtcbiAgICBtaW4gPSBhZGQ7XG4gICAgdHlwZSA9ICdhZGQnO1xuICB9XG5cbiAgaWYgKGRlbCA8IG1pbikge1xuICAgIG1pbiA9IGRlbDtcbiAgICB0eXBlID0gJ2RlbCc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgbWluOiBtaW5cbiAgfTtcbn1cbi8qXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbnNodGVpbl9kaXN0YW5jZVxuICog6K6h566X5Lik5p2hcGF0aOeahOe8lui+kei3neemu1xuICovXG5cblxudmFyIGxldmVuc2h0ZWluRGlzdGFuY2UgPSBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHZhciBzb3VyY2VMZW4gPSBzb3VyY2UubGVuZ3RoO1xuICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgdmFyIHNvdXJjZVNlZ21lbnQgPSB2b2lkIDAsXG4gICAgICB0YXJnZXRTZWdtZW50ID0gdm9pZCAwO1xuICB2YXIgdGVtcCA9IDA7XG5cbiAgaWYgKHNvdXJjZUxlbiA9PT0gMCB8fCB0YXJnZXRMZW4gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc291cmNlTGVuOyBpKyspIHtcbiAgICBkaXN0W2ldID0gW107XG4gICAgZGlzdFtpXVswXSA9IHtcbiAgICAgIG1pbjogaVxuICAgIH07XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8PSB0YXJnZXRMZW47IGorKykge1xuICAgIGRpc3RbMF1bal0gPSB7XG4gICAgICBtaW46IGpcbiAgICB9O1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8PSBzb3VyY2VMZW47IF9pKyspIHtcbiAgICBzb3VyY2VTZWdtZW50ID0gc291cmNlW19pIC0gMV07XG5cbiAgICBmb3IgKHZhciBfaiA9IDE7IF9qIDw9IHRhcmdldExlbjsgX2orKykge1xuICAgICAgdGFyZ2V0U2VnbWVudCA9IHRhcmdldFtfaiAtIDFdO1xuXG4gICAgICBpZiAoaXNFcXVhbChzb3VyY2VTZWdtZW50LCB0YXJnZXRTZWdtZW50KSkge1xuICAgICAgICB0ZW1wID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXAgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsID0gZGlzdFtfaSAtIDFdW19qXS5taW4gKyAxO1xuICAgICAgdmFyIGFkZCA9IGRpc3RbX2ldW19qIC0gMV0ubWluICsgMTtcbiAgICAgIHZhciBtb2RpZnkgPSBkaXN0W19pIC0gMV1bX2ogLSAxXS5taW4gKyB0ZW1wO1xuICAgICAgZGlzdFtfaV1bX2pdID0gZ2V0TWluRGlmZihkZWwsIGFkZCwgbW9kaWZ5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbFBhdGhCeURpZmYoc291cmNlLCB0YXJnZXQpIHtcbiAgdmFyIGRpZmZNYXRyaXggPSBsZXZlbnNodGVpbkRpc3RhbmNlKHNvdXJjZSwgdGFyZ2V0KTtcbiAgdmFyIHNvdXJjZUxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gIHZhciB0YXJnZXRMZW4gPSB0YXJnZXQubGVuZ3RoO1xuICB2YXIgY2hhbmdlcyA9IFtdO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgbWluUG9zID0gMTsgLy8g5aaC5p6cc291cmNl5ZKMdGFyZ2V05LiN5piv5a6M5YWo5LiN55u4562JXG5cbiAgaWYgKGRpZmZNYXRyaXhbc291cmNlTGVuXVt0YXJnZXRMZW5dICE9PSBzb3VyY2VMZW4pIHtcbiAgICAvLyDojrflj5bku45zb3VyY2XliLB0YXJnZXTmiYDpnIDmlLnliqhcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzb3VyY2VMZW47IGkrKykge1xuICAgICAgdmFyIG1pbiA9IGRpZmZNYXRyaXhbaV1baV0ubWluO1xuICAgICAgbWluUG9zID0gaTtcblxuICAgICAgZm9yICh2YXIgaiA9IGluZGV4OyBqIDw9IHRhcmdldExlbjsgaisrKSB7XG4gICAgICAgIGlmIChkaWZmTWF0cml4W2ldW2pdLm1pbiA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGRpZmZNYXRyaXhbaV1bal0ubWluO1xuICAgICAgICAgIG1pblBvcyA9IGo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBtaW5Qb3M7XG5cbiAgICAgIGlmIChkaWZmTWF0cml4W2ldW2luZGV4XS50eXBlKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgaW5kZXg6IGkgLSAxLFxuICAgICAgICAgIHR5cGU6IGRpZmZNYXRyaXhbaV1baW5kZXhdLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyDlr7lzb3VyY2Xov5vooYzlop7liKBwYXRoXG5cblxuICAgIGZvciAodmFyIF9pMiA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgX2kyID49IDA7IF9pMi0tKSB7XG4gICAgICBpbmRleCA9IGNoYW5nZXNbX2kyXS5pbmRleDtcblxuICAgICAgaWYgKGNoYW5nZXNbX2kyXS50eXBlID09PSAnYWRkJykge1xuICAgICAgICBzb3VyY2Uuc3BsaWNlKGluZGV4LCAwLCBbXS5jb25jYXQoc291cmNlW2luZGV4XSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHNvdXJjZeWwvumDqOihpem9kFxuXG5cbiAgc291cmNlTGVuID0gc291cmNlLmxlbmd0aDtcblxuICBpZiAoc291cmNlTGVuIDwgdGFyZ2V0TGVuKSB7XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgdGFyZ2V0TGVuIC0gc291cmNlTGVuOyBfaTMrKykge1xuICAgICAgaWYgKHNvdXJjZVtzb3VyY2VMZW4gLSAxXVswXSA9PT0gJ3onIHx8IHNvdXJjZVtzb3VyY2VMZW4gLSAxXVswXSA9PT0gJ1onKSB7XG4gICAgICAgIHNvdXJjZS5zcGxpY2Uoc291cmNlTGVuIC0gMiwgMCwgc291cmNlW3NvdXJjZUxlbiAtIDJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZS5wdXNoKHNvdXJjZVtzb3VyY2VMZW4gLSAxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBlYWNoKG9iajEsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKGl0ZW0gIT09IG9iajJbaV0pIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxuICog5oq95Y+WcGF0aFNlZ21lbnTkuK3nmoTlhbPplK7ngrlcbiAqIE0sTCxBLFEsSCxW5LiA5Liq56uv54K5XG4gKiBRLCBT5oq95Y+W5LiA5Liq56uv54K577yM5LiA5Liq5o6n5Yi254K5XG4gKiBD5oq95Y+W5LiA5Liq56uv54K577yM5Lik5Liq5o6n5Yi254K5XG4gKi9cbmZ1bmN0aW9uIF9nZXRTZWdtZW50UG9pbnRzKHNlZ21lbnQpIHtcbiAgdmFyIHBvaW50cyA9IFtdO1xuXG4gIHN3aXRjaCAoc2VnbWVudFswXSkge1xuICAgIGNhc2UgJ00nOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTCc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsyXV0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdBJzpcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzZdLCBzZWdtZW50WzddXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1EnOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbM10sIHNlZ21lbnRbNF1dKTtcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzFdLCBzZWdtZW50WzJdXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1QnOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnQyc6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFs1XSwgc2VnbWVudFs2XV0pO1xuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMl1dKTtcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzNdLCBzZWdtZW50WzRdXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1MnOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbM10sIHNlZ21lbnRbNF1dKTtcbiAgICAgIHBvaW50cy5wdXNoKFtzZWdtZW50WzFdLCBzZWdtZW50WzJdXSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0gnOlxuICAgICAgcG9pbnRzLnB1c2goW3NlZ21lbnRbMV0sIHNlZ21lbnRbMV1dKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnVic6XG4gICAgICBwb2ludHMucHVzaChbc2VnbWVudFsxXSwgc2VnbWVudFsxXV0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn0gLy8g5bCG5Lik5Liq54K55Z2H5YiG5oiQY291bnTkuKrngrlcblxuXG5mdW5jdGlvbiBfc3BsaXRQb2ludHMocG9pbnRzLCBmb3JtZXIsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSBbXS5jb25jYXQocG9pbnRzKTtcbiAgdmFyIGluZGV4ID0gdm9pZCAwO1xuICB2YXIgdCA9IDEgLyAoY291bnQgKyAxKTtcblxuICB2YXIgZm9ybWVyRW5kID0gX2dldFNlZ21lbnRQb2ludHMoZm9ybWVyKVswXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBjb3VudDsgaSsrKSB7XG4gICAgdCAqPSBpO1xuICAgIGluZGV4ID0gTWF0aC5mbG9vcihwb2ludHMubGVuZ3RoICogdCk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJlc3VsdC51bnNoaWZ0KFtmb3JtZXJFbmRbMF0gKiB0ICsgcG9pbnRzW2luZGV4XVswXSAqICgxIC0gdCksIGZvcm1lckVuZFsxXSAqIHQgKyBwb2ludHNbaW5kZXhdWzFdICogKDEgLSB0KV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc3BsaWNlKGluZGV4LCAwLCBbZm9ybWVyRW5kWzBdICogdCArIHBvaW50c1tpbmRleF1bMF0gKiAoMSAtIHQpLCBmb3JtZXJFbmRbMV0gKiB0ICsgcG9pbnRzW2luZGV4XVsxXSAqICgxIC0gdCldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgoZnJvbVBhdGgsIHRvUGF0aCkge1xuICBpZiAoZnJvbVBhdGgubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gZnJvbVBhdGg7XG4gIH1cblxuICB2YXIgcG9pbnRzID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9QYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXRoW2ldWzBdICE9PSB0b1BhdGhbaV1bMF0pIHtcbiAgICAgIC8vIOiOt+WPlmZyb21QYXRo55qEcGF0aFNlZ21lbnTnmoTnq6/ngrnvvIzmoLnmja50b1BhdGjnmoTmjIfku6Tlr7nlhbbmlLnpgKBcbiAgICAgIHBvaW50cyA9IF9nZXRTZWdtZW50UG9pbnRzKGZyb21QYXRoW2ldKTtcblxuICAgICAgc3dpdGNoICh0b1BhdGhbaV1bMF0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgZnJvbVBhdGhbaV0gPSBbJ00nXS5jb25jYXQocG9pbnRzWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBmcm9tUGF0aFtpXSA9IFsnTCddLmNvbmNhdChwb2ludHNbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGZyb21QYXRoW2ldID0gW10uY29uY2F0KHRvUGF0aFtpXSk7XG4gICAgICAgICAgZnJvbVBhdGhbaV1bNl0gPSBwb2ludHNbMF1bMF07XG4gICAgICAgICAgZnJvbVBhdGhbaV1bN10gPSBwb2ludHNbMF1bMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgcG9pbnRzID0gX3NwbGl0UG9pbnRzKHBvaW50cywgZnJvbVBhdGhbaSAtIDFdLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyb21QYXRoW2ldID0gdG9QYXRoW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmcm9tUGF0aFtpXSA9IFsnUSddLmNvbmNhdChwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KGkpO1xuICAgICAgICAgIH0sIFtdKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgZnJvbVBhdGhbaV0gPSBbJ1QnXS5jb25jYXQocG9pbnRzWzBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBwb2ludHMgPSBfc3BsaXRQb2ludHMocG9pbnRzLCBmcm9tUGF0aFtpIC0gMV0sIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhdGhbaV0gPSB0b1BhdGhbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyb21QYXRoW2ldID0gWydDJ10uY29uY2F0KHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoaSk7XG4gICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBwb2ludHMgPSBfc3BsaXRQb2ludHMocG9pbnRzLCBmcm9tUGF0aFtpIC0gMV0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbVBhdGhbaV0gPSB0b1BhdGhbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyb21QYXRoW2ldID0gWydTJ10uY29uY2F0KHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoaSk7XG4gICAgICAgICAgfSwgW10pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZyb21QYXRoW2ldID0gdG9QYXRoW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcm9tUGF0aDtcbn07XG5cbi8qKiovIH0pLFxuLyogMjc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzdHJVdGlsID0ge1xuICBsYzogX193ZWJwYWNrX3JlcXVpcmVfXygyNzUpLFxuICBsb3dlckNhc2U6IF9fd2VicGFja19yZXF1aXJlX18oMTQyKSxcbiAgbG93ZXJGaXJzdDogX193ZWJwYWNrX3JlcXVpcmVfXyg3NSksXG4gIHN1YnN0aXR1dGU6IF9fd2VicGFja19yZXF1aXJlX18oMjc2KSxcbiAgdWM6IF9fd2VicGFja19yZXF1aXJlX18oMjc3KSxcbiAgdXBwZXJDYXNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MyksXG4gIHVwcGVyRmlyc3Q6IF9fd2VicGFja19yZXF1aXJlX18oODcpXG59O1xubW9kdWxlLmV4cG9ydHMgPSBzdHJVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDI3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQyKTtcblxuLyoqKi8gfSksXG4vKiAyNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHN1YnN0aXR1dGUgPSBmdW5jdGlvbiBzdWJzdGl0dXRlKHN0ciwgbykge1xuICBpZiAoIXN0ciB8fCAhbykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFw/XFx7KFtee31dKylcXH0vZywgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgaWYgKG1hdGNoLmNoYXJBdCgwKSA9PT0gJ1xcXFwnKSB7XG4gICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9bbmFtZV0gPT09IHVuZGVmaW5lZCA/ICcnIDogb1tuYW1lXTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnN0aXR1dGU7XG5cbi8qKiovIH0pLFxuLyogMjc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDMpO1xuXG4vKioqLyB9KSxcbi8qIDI3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBjaGVja1R5cGUgPSB7XG4gIGdldFR5cGU6IF9fd2VicGFja19yZXF1aXJlX18oODQpLFxuICBpc0FycmF5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLFxuICBpc0FycmF5TGlrZTogX193ZWJwYWNrX3JlcXVpcmVfXygxMyksXG4gIGlzQm9vbGVhbjogX193ZWJwYWNrX3JlcXVpcmVfXyg4MiksXG4gIGlzRnVuY3Rpb246IF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuICBpc05pbDogX193ZWJwYWNrX3JlcXVpcmVfXyg1KSxcbiAgaXNOdWxsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3OSksXG4gIGlzTnVtYmVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLFxuICBpc09iamVjdDogX193ZWJwYWNrX3JlcXVpcmVfXygyNCksXG4gIGlzT2JqZWN0TGlrZTogX193ZWJwYWNrX3JlcXVpcmVfXyg0OCksXG4gIGlzUGxhaW5PYmplY3Q6IF9fd2VicGFja19yZXF1aXJlX18oMjYpLFxuICBpc1Byb3RvdHlwZTogX193ZWJwYWNrX3JlcXVpcmVfXyg4NSksXG4gIGlzVHlwZTogaXNUeXBlLFxuICBpc1VuZGVmaW5lZDogX193ZWJwYWNrX3JlcXVpcmVfXygyODApLFxuICBpc1N0cmluZzogX193ZWJwYWNrX3JlcXVpcmVfXygxMCksXG4gIGlzUmVnRXhwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MSksXG4gIGlzRGF0ZTogX193ZWJwYWNrX3JlcXVpcmVfXyg4MCksXG4gIGlzQXJndW1lbnRzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MiksXG4gIGlzRXJyb3I6IF9fd2VicGFja19yZXF1aXJlX18oMjgzKVxufTtcbm1vZHVsZS5leHBvcnRzID0gY2hlY2tUeXBlO1xuXG4vKioqLyB9KSxcbi8qIDI3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuXG4vKioqLyB9KSxcbi8qIDI4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG5cbi8qKiovIH0pLFxuLyogMjgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIGlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBpc1R5cGUoc3RyLCAnUmVnRXhwJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUmVnRXhwO1xuXG4vKioqLyB9KSxcbi8qIDI4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIOaYr+WQpuaYr+WPguaVsOexu+Wei1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSDmtYvor5XnmoTlgLxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIGlzQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ0FyZ3VtZW50cycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuLyoqKi8gfSksXG4vKiAyODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiDmmK/lkKbmmK/lj4LmlbDnsbvlnotcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUg5rWL6K+V55qE5YC8XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBpc0Vycm9yID0gZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnRXJyb3InKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcnJvcjtcblxuLyoqKi8gfSksXG4vKiAyODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG5cbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cbi8qKiovIH0pLFxuLyogMjg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoYXJyLCBvYmopIHtcbiAgaWYgKCFpc0FycmF5TGlrZShhcnIpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIG0gPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcblxuICBpZiAobSkge1xuICAgIHJldHVybiBtLmNhbGwoYXJyLCBvYmopO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZjtcblxuLyoqKi8gfSksXG4vKiAyODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIGlzRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIHRydWU7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICpcbiAqIGlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7ICAvLyA9PiB0cnVlXG4gKi9cblxuXG52YXIgaXNFcXVhbFdpdGggPSBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGZuKSB7XG4gIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICByZXR1cm4gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICB9XG5cbiAgcmV0dXJuICEhZm4odmFsdWUsIG90aGVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbFdpdGg7XG5cbi8qKiovIH0pLFxuLyogMjg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBtYXAgPSBmdW5jdGlvbiBtYXAoYXJyLCBmdW5jKSB7XG4gIGlmICghaXNBcnJheUxpa2UoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGVhY2goYXJyLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgcmVzdWx0LnB1c2goZnVuYyh2YWx1ZSwgaW5kZXgpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDtcblxuLyoqKi8gfSksXG4vKiAyODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaXNQbGFpbmVPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKiBwaWNrKG9iamVjdCwgWydhJywgJ2MnXSk7ICAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuXG52YXIgcGljayA9IGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBrZXlzKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwgfHwgIWlzUGxhaW5lT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG4gIGVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG4vKioqLyB9KSxcbi8qIDI4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0ID0gdm9pZCAwLFxuICAgICAgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgIGFyZ3MgPSB2b2lkIDAsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG4gIHZhciBwcmV2aW91cyA9IDA7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdGhyb3R0bGVkLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgcHJldmlvdXMgPSAwO1xuICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcblxuLyoqKi8gfSksXG4vKiAyOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IERlZmF1bHQgYW5pbWF0aW9uIGZ1bmNpdG9uXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgUGF0aFV0aWwgPSBVdGlsLlBhdGhVdGlsO1xuXG5mdW5jdGlvbiBnZXRDbGlwKGNvb3JkKSB7XG4gIHZhciBzdGFydCA9IGNvb3JkLnN0YXJ0O1xuICB2YXIgZW5kID0gY29vcmQuZW5kO1xuICB2YXIgd2lkdGggPSBjb29yZC5nZXRXaWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gY29vcmQuZ2V0SGVpZ2h0KCk7XG4gIHZhciBtYXJnaW4gPSAyMDA7XG4gIHZhciBzdGFydEFuZ2xlO1xuICB2YXIgZW5kQW5nbGU7XG4gIHZhciBjZW50ZXI7XG4gIHZhciByYWRpdXM7XG4gIHZhciBjbGlwO1xuXG4gIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgcmFkaXVzID0gY29vcmQuZ2V0UmFkaXVzKCk7XG4gICAgY2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gICAgc3RhcnRBbmdsZSA9IGNvb3JkLnN0YXJ0QW5nbGU7XG4gICAgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcbiAgICBjbGlwID0gbmV3IEcuRmFuKHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICB5OiBjZW50ZXIueSxcbiAgICAgICAgcnM6IDAsXG4gICAgICAgIHJlOiByYWRpdXMgKyBtYXJnaW4sXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gICAgY2xpcC5lbmRTdGF0ZSA9IHtcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY2xpcCA9IG5ldyBHLlJlY3Qoe1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgeDogc3RhcnQueCAtIG1hcmdpbixcbiAgICAgICAgeTogZW5kLnkgLSBtYXJnaW4sXG4gICAgICAgIHdpZHRoOiBjb29yZC5pc1RyYW5zcG9zZWQgPyB3aWR0aCArIG1hcmdpbiAqIDIgOiAwLFxuICAgICAgICBoZWlnaHQ6IGNvb3JkLmlzVHJhbnNwb3NlZCA/IDAgOiBoZWlnaHQgKyBtYXJnaW4gKiAyXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICBjbGlwLmVuZFN0YXRlID0ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIG1hcmdpbiAqIDJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXAuZW5kU3RhdGUgPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCArIG1hcmdpbiAqIDJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY2xpcC5pc0NsaXAgPSB0cnVlO1xuICByZXR1cm4gY2xpcDtcbn0gLy8g6I635Y+W5Zu+5b2i55qE5YyF5Zu055uSXG5cblxuZnVuY3Rpb24gZ2V0UG9pbnRzQm94KHBvaW50cykge1xuICBpZiAoVXRpbC5pc0VtcHR5KHBvaW50cykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtaW5YID0gcG9pbnRzWzBdLng7XG4gIHZhciBtYXhYID0gcG9pbnRzWzBdLng7XG4gIHZhciBtaW5ZID0gcG9pbnRzWzBdLnk7XG4gIHZhciBtYXhZID0gcG9pbnRzWzBdLnk7XG4gIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIG1pblggPSBtaW5YID4gcG9pbnQueCA/IHBvaW50LnggOiBtaW5YO1xuICAgIG1heFggPSBtYXhYIDwgcG9pbnQueCA/IHBvaW50LnggOiBtYXhYO1xuICAgIG1pblkgPSBtaW5ZID4gcG9pbnQueSA/IHBvaW50LnkgOiBtaW5ZO1xuICAgIG1heFkgPSBtYXhZIDwgcG9pbnQueSA/IHBvaW50LnkgOiBtYXhZO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtaW5YOiBtaW5YLFxuICAgIG1heFg6IG1heFgsXG4gICAgbWluWTogbWluWSxcbiAgICBtYXhZOiBtYXhZLFxuICAgIGNlbnRlclg6IChtaW5YICsgbWF4WCkgLyAyLFxuICAgIGNlbnRlclk6IChtaW5ZICsgbWF4WSkgLyAyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFuZ2xlKHNoYXBlLCBjb29yZCkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzIHx8IHNoYXBlLmdldCgnb3JpZ2luJykucG9pbnRzO1xuICB2YXIgYm94ID0gZ2V0UG9pbnRzQm94KHBvaW50cyk7XG4gIHZhciBlbmRBbmdsZTtcbiAgdmFyIHN0YXJ0QW5nbGU7XG4gIHZhciBjb29yZFN0YXJ0QW5nbGUgPSBjb29yZC5zdGFydEFuZ2xlO1xuICB2YXIgY29vcmRFbmRBbmdsZSA9IGNvb3JkLmVuZEFuZ2xlO1xuICB2YXIgZGlmZkFuZ2xlID0gY29vcmRFbmRBbmdsZSAtIGNvb3JkU3RhcnRBbmdsZTtcblxuICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgZW5kQW5nbGUgPSBib3gubWF4WSAqIGRpZmZBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gYm94Lm1pblkgKiBkaWZmQW5nbGU7XG4gIH0gZWxzZSB7XG4gICAgZW5kQW5nbGUgPSBib3gubWF4WCAqIGRpZmZBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gYm94Lm1pblggKiBkaWZmQW5nbGU7XG4gIH1cblxuICBlbmRBbmdsZSArPSBjb29yZFN0YXJ0QW5nbGU7XG4gIHN0YXJ0QW5nbGUgKz0gY29vcmRTdGFydEFuZ2xlO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGVuZEFuZ2xlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGVQYXJhbShhbmltYXRlQ2ZnLCBpbmRleCwgaWQpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChhbmltYXRlQ2ZnLmRlbGF5KSB7XG4gICAgcmVzdWx0LmRlbGF5ID0gVXRpbC5pc0Z1bmN0aW9uKGFuaW1hdGVDZmcuZGVsYXkpID8gYW5pbWF0ZUNmZy5kZWxheShpbmRleCwgaWQpIDogYW5pbWF0ZUNmZy5kZWxheTtcbiAgfVxuXG4gIHJlc3VsdC5lYXNpbmcgPSBVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZUNmZy5lYXNpbmcpID8gYW5pbWF0ZUNmZy5lYXNpbmcoaW5kZXgsIGlkKSA6IGFuaW1hdGVDZmcuZWFzaW5nO1xuICByZXN1bHQuZHVyYXRpb24gPSBVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZUNmZy5kdXJhdGlvbikgPyBhbmltYXRlQ2ZnLmR1cmF0aW9uKGluZGV4LCBpZCkgOiBhbmltYXRlQ2ZnLmR1cmF0aW9uO1xuICByZXN1bHQuY2FsbGJhY2sgPSBhbmltYXRlQ2ZnLmNhbGxiYWNrO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzY2FsZUluWShzaGFwZSwgYW5pbWF0ZUNmZykge1xuICB2YXIgaWQgPSBzaGFwZS5faWQ7XG4gIHZhciBpbmRleCA9IHNoYXBlLmdldCgnaW5kZXgnKTtcbiAgdmFyIGJveCA9IHNoYXBlLmdldEJCb3goKTtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLmdldCgnb3JpZ2luJykucG9pbnRzO1xuICB2YXIgeCA9IChib3gubWluWCArIGJveC5tYXhYKSAvIDI7XG4gIHZhciB5O1xuXG4gIGlmIChwb2ludHNbMF0ueSAtIHBvaW50c1sxXS55IDw9IDApIHtcbiAgICAvLyDlvZPpobbngrnlnKjpm7bngrnkuYvkuItcbiAgICB5ID0gYm94Lm1heFk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IGJveC5taW5ZO1xuICB9XG5cbiAgdmFyIHYgPSBbeCwgeSwgMV07XG4gIHNoYXBlLmFwcGx5KHYpO1xuICBzaGFwZS5hdHRyKCd0cmFuc2Zvcm0nLCBbWyd0JywgLXgsIC15XSwgWydzJywgMSwgMC4wMV0sIFsndCcsIHgsIHldXSk7XG4gIHZhciBlbmRTdGF0ZSA9IHtcbiAgICB0cmFuc2Zvcm06IFtbJ3QnLCAteCwgLXldLCBbJ3MnLCAxLCAxMDBdLCBbJ3QnLCB4LCB5XV1cbiAgfTtcbiAgdmFyIGFuaW1hdGVQYXJhbSA9IGdldEFuaW1hdGVQYXJhbShhbmltYXRlQ2ZnLCBpbmRleCwgaWQsIGVuZFN0YXRlKTtcbiAgc2hhcGUuYW5pbWF0ZShlbmRTdGF0ZSwgYW5pbWF0ZVBhcmFtLmR1cmF0aW9uLCBhbmltYXRlUGFyYW0uZWFzaW5nLCBhbmltYXRlUGFyYW0uY2FsbGJhY2ssIGFuaW1hdGVQYXJhbS5kZWxheSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlSW5YKHNoYXBlLCBhbmltYXRlQ2ZnKSB7XG4gIHZhciBpZCA9IHNoYXBlLl9pZDtcbiAgdmFyIGluZGV4ID0gc2hhcGUuZ2V0KCdpbmRleCcpO1xuICB2YXIgYm94ID0gc2hhcGUuZ2V0QkJveCgpO1xuICB2YXIgcG9pbnRzID0gc2hhcGUuZ2V0KCdvcmlnaW4nKS5wb2ludHM7XG4gIHZhciB4O1xuICB2YXIgeSA9IChib3gubWluWSArIGJveC5tYXhZKSAvIDI7XG5cbiAgaWYgKHBvaW50c1swXS55IC0gcG9pbnRzWzFdLnkgPiAwKSB7XG4gICAgLy8g5b2T6aG254K55Zyo6Zu254K55LmL5LiLXG4gICAgeCA9IGJveC5tYXhYO1xuICB9IGVsc2Uge1xuICAgIHggPSBib3gubWluWDtcbiAgfVxuXG4gIHZhciB2ID0gW3gsIHksIDFdO1xuICBzaGFwZS5hcHBseSh2KTtcbiAgc2hhcGUuYXR0cih7XG4gICAgdHJhbnNmb3JtOiBbWyd0JywgLXgsIC15XSwgWydzJywgMC4wMSwgMV0sIFsndCcsIHgsIHldXVxuICB9KTtcbiAgdmFyIGVuZFN0YXRlID0ge1xuICAgIHRyYW5zZm9ybTogW1sndCcsIC14LCAteV0sIFsncycsIDEwMCwgMV0sIFsndCcsIHgsIHldXVxuICB9O1xuICB2YXIgYW5pbWF0ZVBhcmFtID0gZ2V0QW5pbWF0ZVBhcmFtKGFuaW1hdGVDZmcsIGluZGV4LCBpZCwgZW5kU3RhdGUpO1xuICBzaGFwZS5hbmltYXRlKGVuZFN0YXRlLCBhbmltYXRlUGFyYW0uZHVyYXRpb24sIGFuaW1hdGVQYXJhbS5lYXNpbmcsIGFuaW1hdGVQYXJhbS5jYWxsYmFjaywgYW5pbWF0ZVBhcmFtLmRlbGF5KTtcbn1cblxuZnVuY3Rpb24gbGluZVdpZHRoT3V0KHNoYXBlLCBhbmltYXRlQ2ZnKSB7XG4gIHZhciBlbmRTdGF0ZSA9IHtcbiAgICBsaW5lV2lkdGg6IDAsXG4gICAgb3BhY2l0eTogMFxuICB9O1xuICB2YXIgaWQgPSBzaGFwZS5faWQ7XG4gIHZhciBpbmRleCA9IHNoYXBlLmdldCgnaW5kZXgnKTtcbiAgdmFyIGFuaW1hdGVQYXJhbSA9IGdldEFuaW1hdGVQYXJhbShhbmltYXRlQ2ZnLCBpbmRleCwgaWQsIGVuZFN0YXRlKTtcbiAgc2hhcGUuYW5pbWF0ZShlbmRTdGF0ZSwgYW5pbWF0ZVBhcmFtLmR1cmF0aW9uLCBhbmltYXRlUGFyYW0uZWFzaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2hhcGUucmVtb3ZlKCk7XG4gIH0sIGFuaW1hdGVQYXJhbS5kZWxheSk7XG59XG5cbmZ1bmN0aW9uIHpvb21JbihzaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpIHtcbiAgdmFyIGlkID0gc2hhcGUuX2lkO1xuICB2YXIgaW5kZXggPSBzaGFwZS5nZXQoJ2luZGV4Jyk7XG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiAoY29vcmQuaXNQb2xhciAmJiBzaGFwZS5uYW1lICE9PSAncG9pbnQnKSB7XG4gICAgeCA9IGNvb3JkLmdldENlbnRlcigpLng7XG4gICAgeSA9IGNvb3JkLmdldENlbnRlcigpLnk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJveCA9IHNoYXBlLmdldEJCb3goKTtcbiAgICB4ID0gKGJveC5taW5YICsgYm94Lm1heFgpIC8gMjtcbiAgICB5ID0gKGJveC5taW5ZICsgYm94Lm1heFkpIC8gMjtcbiAgfVxuXG4gIHZhciB2ID0gW3gsIHksIDFdO1xuICBzaGFwZS5hcHBseSh2KTtcbiAgc2hhcGUuYXR0cih7XG4gICAgdHJhbnNmb3JtOiBbWyd0JywgLXgsIC15XSwgWydzJywgMC4wMSwgMC4wMV0sIFsndCcsIHgsIHldXVxuICB9KTtcbiAgdmFyIGVuZFN0YXRlID0ge1xuICAgIHRyYW5zZm9ybTogW1sndCcsIC14LCAteV0sIFsncycsIDEwMCwgMTAwXSwgWyd0JywgeCwgeV1dXG4gIH07XG4gIHZhciBhbmltYXRlUGFyYW0gPSBnZXRBbmltYXRlUGFyYW0oYW5pbWF0ZUNmZywgaW5kZXgsIGlkLCBlbmRTdGF0ZSk7XG4gIHNoYXBlLmFuaW1hdGUoZW5kU3RhdGUsIGFuaW1hdGVQYXJhbS5kdXJhdGlvbiwgYW5pbWF0ZVBhcmFtLmVhc2luZywgYW5pbWF0ZVBhcmFtLmNhbGxiYWNrLCBhbmltYXRlUGFyYW0uZGVsYXkpO1xufVxuXG5mdW5jdGlvbiB6b29tT3V0KHNoYXBlLCBhbmltYXRlQ2ZnLCBjb29yZCkge1xuICB2YXIgaWQgPSBzaGFwZS5faWQ7XG4gIHZhciBpbmRleCA9IHNoYXBlLmdldCgnaW5kZXgnKTtcbiAgdmFyIHg7XG4gIHZhciB5O1xuXG4gIGlmIChjb29yZC5pc1BvbGFyICYmIHNoYXBlLm5hbWUgIT09ICdwb2ludCcpIHtcbiAgICB4ID0gY29vcmQuZ2V0Q2VudGVyKCkueDtcbiAgICB5ID0gY29vcmQuZ2V0Q2VudGVyKCkueTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYm94ID0gc2hhcGUuZ2V0QkJveCgpO1xuICAgIHggPSAoYm94Lm1pblggKyBib3gubWF4WCkgLyAyO1xuICAgIHkgPSAoYm94Lm1pblkgKyBib3gubWF4WSkgLyAyO1xuICB9XG5cbiAgdmFyIHYgPSBbeCwgeSwgMV07XG4gIHNoYXBlLmFwcGx5KHYpO1xuICB2YXIgZW5kU3RhdGUgPSB7XG4gICAgdHJhbnNmb3JtOiBbWyd0JywgLXgsIC15XSwgWydzJywgMC4wMSwgMC4wMV0sIFsndCcsIHgsIHldXVxuICB9O1xuICB2YXIgYW5pbWF0ZVBhcmFtID0gZ2V0QW5pbWF0ZVBhcmFtKGFuaW1hdGVDZmcsIGluZGV4LCBpZCwgZW5kU3RhdGUpO1xuICBzaGFwZS5hbmltYXRlKGVuZFN0YXRlLCBhbmltYXRlUGFyYW0uZHVyYXRpb24sIGFuaW1hdGVQYXJhbS5lYXNpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICBzaGFwZS5yZW1vdmUoKTtcbiAgfSwgYW5pbWF0ZVBhcmFtLmRlbGF5KTtcbn1cblxuZnVuY3Rpb24gcGF0aEluKHNoYXBlLCBhbmltYXRlQ2ZnKSB7XG4gIGlmIChzaGFwZS5nZXQoJ3R5cGUnKSAhPT0gJ3BhdGgnKSByZXR1cm47XG4gIHZhciBpZCA9IHNoYXBlLl9pZDtcbiAgdmFyIGluZGV4ID0gc2hhcGUuZ2V0KCdpbmRleCcpO1xuICB2YXIgcGF0aCA9IFBhdGhVdGlsLnBhdGhUb0Fic29sdXRlKHNoYXBlLmF0dHIoJ3BhdGgnKSk7XG4gIHNoYXBlLmF0dHIoJ3BhdGgnLCBbcGF0aFswXV0pO1xuICB2YXIgZW5kU3RhdGUgPSB7XG4gICAgcGF0aDogcGF0aFxuICB9O1xuICB2YXIgYW5pbWF0ZVBhcmFtID0gZ2V0QW5pbWF0ZVBhcmFtKGFuaW1hdGVDZmcsIGluZGV4LCBpZCwgZW5kU3RhdGUpO1xuICBzaGFwZS5hbmltYXRlKGVuZFN0YXRlLCBhbmltYXRlUGFyYW0uZHVyYXRpb24sIGFuaW1hdGVQYXJhbS5lYXNpbmcsIGFuaW1hdGVQYXJhbS5jYWxsYmFjaywgYW5pbWF0ZVBhcmFtLmRlbGF5KTtcbn1cblxuZnVuY3Rpb24gcGF0aE91dChzaGFwZSwgYW5pbWF0ZUNmZykge1xuICBpZiAoc2hhcGUuZ2V0KCd0eXBlJykgIT09ICdwYXRoJykgcmV0dXJuO1xuICB2YXIgaWQgPSBzaGFwZS5faWQ7XG4gIHZhciBpbmRleCA9IHNoYXBlLmdldCgnaW5kZXgnKTtcbiAgdmFyIHBhdGggPSBQYXRoVXRpbC5wYXRoVG9BYnNvbHV0ZShzaGFwZS5hdHRyKCdwYXRoJykpO1xuICB2YXIgZW5kU3RhdGUgPSB7XG4gICAgcGF0aDogW3BhdGhbMF1dXG4gIH07XG4gIHZhciBhbmltYXRlUGFyYW0gPSBnZXRBbmltYXRlUGFyYW0oYW5pbWF0ZUNmZywgaW5kZXgsIGlkLCBlbmRTdGF0ZSk7XG4gIHNoYXBlLmFuaW1hdGUoZW5kU3RhdGUsIGFuaW1hdGVQYXJhbS5kdXJhdGlvbiwgYW5pbWF0ZVBhcmFtLmVhc2luZywgZnVuY3Rpb24gKCkge1xuICAgIHNoYXBlLnJlbW92ZSgpO1xuICB9LCBhbmltYXRlUGFyYW0uZGVsYXkpO1xufVxuXG5mdW5jdGlvbiBjbGlwSW4oc2hhcGUsIGFuaW1hdGVDZmcsIGNvb3JkLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICB2YXIgY2xpcCA9IGdldENsaXAoY29vcmQpO1xuICB2YXIgY2FudmFzID0gc2hhcGUuZ2V0KCdjYW52YXMnKTtcbiAgdmFyIGlkID0gc2hhcGUuX2lkO1xuICB2YXIgaW5kZXggPSBzaGFwZS5nZXQoJ2luZGV4Jyk7XG4gIHZhciBlbmRTdGF0ZTtcblxuICBpZiAoc3RhcnRBbmdsZSkge1xuICAgIGNsaXAuYXR0cignc3RhcnRBbmdsZScsIHN0YXJ0QW5nbGUpO1xuICAgIGNsaXAuYXR0cignZW5kQW5nbGUnLCBzdGFydEFuZ2xlKTtcbiAgICBlbmRTdGF0ZSA9IHtcbiAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZW5kU3RhdGUgPSBjbGlwLmVuZFN0YXRlO1xuICB9XG5cbiAgY2xpcC5zZXQoJ2NhbnZhcycsIGNhbnZhcyk7XG4gIHNoYXBlLmF0dHIoJ2NsaXAnLCBjbGlwKTtcbiAgc2hhcGUuc2V0U2lsZW50KCdhbmltYXRpbmcnLCB0cnVlKTtcbiAgdmFyIGFuaW1hdGVQYXJhbSA9IGdldEFuaW1hdGVQYXJhbShhbmltYXRlQ2ZnLCBpbmRleCwgaWQsIGVuZFN0YXRlKTtcbiAgY2xpcC5hbmltYXRlKGVuZFN0YXRlLCBhbmltYXRlUGFyYW0uZHVyYXRpb24sIGFuaW1hdGVQYXJhbS5lYXNpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hhcGUgJiYgIXNoYXBlLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIHNoYXBlLmF0dHIoJ2NsaXAnLCBudWxsKTtcbiAgICAgIHNoYXBlLnNldFNpbGVudCgnY2FjaGVTaGFwZScsIG51bGwpO1xuICAgICAgc2hhcGUuc2V0U2lsZW50KCdhbmltYXRpbmcnLCBmYWxzZSk7XG4gICAgICBjbGlwLnJlbW92ZSgpO1xuICAgIH1cbiAgfSwgYW5pbWF0ZVBhcmFtLmRlbGF5KTtcbn1cblxuZnVuY3Rpb24gZmFkZUluKHNoYXBlLCBhbmltYXRlQ2ZnKSB7XG4gIHZhciBpZCA9IHNoYXBlLl9pZDtcbiAgdmFyIGluZGV4ID0gc2hhcGUuZ2V0KCdpbmRleCcpO1xuICB2YXIgZmlsbE9wYWNpdHkgPSBVdGlsLmlzTmlsKHNoYXBlLmF0dHIoJ2ZpbGxPcGFjaXR5JykpID8gMSA6IHNoYXBlLmF0dHIoJ2ZpbGxPcGFjaXR5Jyk7XG4gIHZhciBzdHJva2VPcGFjaXR5ID0gVXRpbC5pc05pbChzaGFwZS5hdHRyKCdzdHJva2VPcGFjaXR5JykpID8gMSA6IHNoYXBlLmF0dHIoJ3N0cm9rZU9wYWNpdHknKTtcbiAgc2hhcGUuYXR0cignZmlsbE9wYWNpdHknLCAwKTtcbiAgc2hhcGUuYXR0cignc3Ryb2tlT3BhY2l0eScsIDApO1xuICB2YXIgZW5kU3RhdGUgPSB7XG4gICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHlcbiAgfTtcbiAgdmFyIGFuaW1hdGVQYXJhbSA9IGdldEFuaW1hdGVQYXJhbShhbmltYXRlQ2ZnLCBpbmRleCwgaWQsIGVuZFN0YXRlKTtcbiAgc2hhcGUuYW5pbWF0ZShlbmRTdGF0ZSwgYW5pbWF0ZVBhcmFtLmR1cmF0aW9uLCBhbmltYXRlUGFyYW0uZWFzaW5nLCBhbmltYXRlUGFyYW0uY2FsbGJhY2ssIGFuaW1hdGVQYXJhbS5kZWxheSk7XG59XG5cbmZ1bmN0aW9uIGZhZGVPdXQoc2hhcGUsIGFuaW1hdGVDZmcpIHtcbiAgdmFyIGlkID0gc2hhcGUuX2lkO1xuICB2YXIgaW5kZXggPSBzaGFwZS5nZXQoJ2luZGV4Jyk7XG4gIHZhciBlbmRTdGF0ZSA9IHtcbiAgICBmaWxsT3BhY2l0eTogMCxcbiAgICBzdHJva2VPcGFjaXR5OiAwXG4gIH07XG4gIHZhciBhbmltYXRlUGFyYW0gPSBnZXRBbmltYXRlUGFyYW0oYW5pbWF0ZUNmZywgaW5kZXgsIGlkLCBlbmRTdGF0ZSk7XG4gIHNoYXBlLmFuaW1hdGUoZW5kU3RhdGUsIGFuaW1hdGVQYXJhbS5kdXJhdGlvbiwgYW5pbWF0ZVBhcmFtLmVhc2luZywgZnVuY3Rpb24gKCkge1xuICAgIHNoYXBlLnJlbW92ZSgpO1xuICB9LCBhbmltYXRlUGFyYW0uZGVsYXkpO1xufVxuXG5mdW5jdGlvbiBmYW5JbihzaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpIHtcbiAgdmFyIGFuZ2xlID0gZ2V0QW5nbGUoc2hhcGUsIGNvb3JkKTtcbiAgdmFyIGVuZEFuZ2xlID0gYW5nbGUuZW5kQW5nbGU7XG4gIHZhciBzdGFydEFuZ2xlID0gYW5nbGUuc3RhcnRBbmdsZTtcbiAgY2xpcEluKHNoYXBlLCBhbmltYXRlQ2ZnLCBjb29yZCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xufSAvLyDpu5jorqTliqjnlLvlupNcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW50ZXI6IHtcbiAgICBjbGlwSW46IGNsaXBJbixcbiAgICB6b29tSW46IHpvb21JbixcbiAgICBwYXRoSW46IHBhdGhJbixcbiAgICBzY2FsZUluWTogc2NhbGVJblksXG4gICAgc2NhbGVJblg6IHNjYWxlSW5YLFxuICAgIGZhbkluOiBmYW5JbixcbiAgICBmYWRlSW46IGZhZGVJblxuICB9LFxuICBsZWF2ZToge1xuICAgIGxpbmVXaWR0aE91dDogbGluZVdpZHRoT3V0LFxuICAgIHpvb21PdXQ6IHpvb21PdXQsXG4gICAgcGF0aE91dDogcGF0aE91dCxcbiAgICBmYWRlT3V0OiBmYWRlT3V0XG4gIH0sXG4gIGFwcGVhcjoge1xuICAgIGNsaXBJbjogY2xpcEluLFxuICAgIHpvb21Jbjogem9vbUluLFxuICAgIHBhdGhJbjogcGF0aEluLFxuICAgIHNjYWxlSW5ZOiBzY2FsZUluWSxcbiAgICBzY2FsZUluWDogc2NhbGVJblgsXG4gICAgZmFuSW46IGZhbkluLFxuICAgIGZhZGVJbjogZmFkZUluXG4gIH0sXG4gIHVwZGF0ZToge1xuICAgIGZhZGVJbjogZmFkZUluLFxuICAgIGZhbkluOiBmYW5JblxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyB2aWV3XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OCk7XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NSk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgVGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MSk7XG5cbnZhciBGSUVMRF9PUklHSU4gPSAnX29yaWdpbic7XG5cbnZhciBBbmltYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTUpO1xuXG5mdW5jdGlvbiBpc0Z1bGxDaXJjbGUoY29vcmQpIHtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBjb29yZC5zdGFydEFuZ2xlO1xuICB2YXIgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcblxuICBpZiAoIVV0aWwuaXNOaWwoc3RhcnRBbmdsZSkgJiYgIVV0aWwuaXNOaWwoZW5kQW5nbGUpICYmIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA8IE1hdGguUEkgKiAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wID0gKHZhbHVlIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbiAgcmV0dXJuIHRtcCA+PSAwICYmIHRtcCA8PSAxO1xufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5Db29yZChjb29yZCwgcG9pbnQpIHtcbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gIGlmIChjb29yZCkge1xuICAgIHZhciB0eXBlID0gY29vcmQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSAndGhldGEnKSB7XG4gICAgICB2YXIgc3RhcnQgPSBjb29yZC5zdGFydDtcbiAgICAgIHZhciBlbmQgPSBjb29yZC5lbmQ7XG4gICAgICByZXN1bHQgPSBpc0JldHdlZW4ocG9pbnQueCwgc3RhcnQueCwgZW5kLngpICYmIGlzQmV0d2Vlbihwb2ludC55LCBzdGFydC55LCBlbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbnZlcnRQb2ludCA9IGNvb3JkLmludmVydChwb2ludCk7XG4gICAgICByZXN1bHQgPSBpbnZlcnRQb2ludC54ID49IDAgJiYgaW52ZXJ0UG9pbnQueSA+PSAwICYmIGludmVydFBvaW50LnggPD0gMSAmJiBpbnZlcnRQb2ludC55IDw9IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFZpZXdHZW9tcyA9IHt9O1xuVXRpbC5lYWNoKEdlb20sIGZ1bmN0aW9uIChnZW9tQ29uc3RydWN0b3IsIGNsYXNzTmFtZSkge1xuICB2YXIgbWV0aG9kTmFtZSA9IFV0aWwubG93ZXJGaXJzdChjbGFzc05hbWUpO1xuXG4gIFZpZXdHZW9tc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICB2YXIgZ2VvbSA9IG5ldyBnZW9tQ29uc3RydWN0b3IoY2ZnKTtcbiAgICB0aGlzLmFkZEdlb20oZ2VvbSk7XG4gICAgcmV0dXJuIGdlb207XG4gIH07XG59KTtcbi8qKlxuICog5Zu+6KGo5Lit55qE6KeG5Zu+XG4gKiBAY2xhc3MgVmlld1xuICovXG5cbnZhciBWaWV3ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShWaWV3LCBfQmFzZSk7XG5cbiAgdmFyIF9wcm90byA9IFZpZXcucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3Q29udGFpbmVyOiBudWxsLFxuICAgICAgY29vcmQ6IG51bGwsXG4gICAgICBzdGFydDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDFcbiAgICAgIH0sXG4gICAgICBnZW9tczogW10sXG4gICAgICBzY2FsZXM6IHt9LFxuICAgICAgb3B0aW9uczoge30sXG4gICAgICBzY2FsZUNvbnRyb2xsZXI6IG51bGwsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgdGhlbWU6IG51bGwsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICB0b29sdGlwRW5hYmxlOiB0cnVlLFxuICAgICAgLy8g5piv5ZCm5bGV56S6IHRvb2x0aXBcbiAgICAgIGFuaW1hdGU6IEdsb2JhbC5hbmltYXRlLFxuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gVmlldyhjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHNlbGYuX3NldFRoZW1lKCk7XG5cbiAgICBVdGlsLmVhY2goR2VvbSwgZnVuY3Rpb24gKEdlb21Db25zdHJ1Y3RvciwgY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IFV0aWwubG93ZXJGaXJzdChjbGFzc05hbWUpO1xuXG4gICAgICBzZWxmW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKGNmZykge1xuICAgICAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjZmcgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNmZy52aWV3VGhlbWUgPSBzZWxmLmdldCgndmlld1RoZW1lJyk7XG4gICAgICAgIHZhciBnZW9tID0gbmV3IEdlb21Db25zdHJ1Y3RvcihjZmcpO1xuICAgICAgICBzZWxmLmFkZEdlb20oZ2VvbSk7XG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgICAgfTtcbiAgICB9KTsgLy8gVXRpbC5taXgodGhpcywgVmlld0dlb21zKTtcblxuICAgIHNlbGYuaW5pdCgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9wcm90by5fc2V0VGhlbWUgPSBmdW5jdGlvbiBfc2V0VGhlbWUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aGVtZSA9IHNlbGYuZ2V0KCd0aGVtZScpO1xuICAgIHZhciB2aWV3VGhlbWUgPSB7fTtcbiAgICB2YXIgbmV3VGhlbWUgPSB7fTtcblxuICAgIGlmIChVdGlsLmlzT2JqZWN0KHRoZW1lKSkge1xuICAgICAgbmV3VGhlbWUgPSB0aGVtZTtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaW5kZXhPZihPYmplY3Qua2V5cyhUaGVtZSksIHRoZW1lKSAhPT0gLTEpIHtcbiAgICAgIG5ld1RoZW1lID0gVGhlbWVbdGhlbWVdO1xuICAgIH1cblxuICAgIFV0aWwuZGVlcE1peCh2aWV3VGhlbWUsIEdsb2JhbCwgbmV3VGhlbWUpO1xuICAgIHNlbGYuc2V0KCd2aWV3VGhlbWUnLCB2aWV3VGhlbWUpO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDliJ3lp4vljJZcbiAgICovXG5cblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5faW5pdFZpZXdQbG90KCk7IC8vIOWFiOWIm+W7uuWuueWZqFxuXG5cbiAgICBpZiAodGhpcy5nZXQoJ2RhdGEnKSkge1xuICAgICAgdGhpcy5faW5pdERhdGEodGhpcy5nZXQoJ2RhdGEnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdE9wdGlvbnMoKTtcblxuICAgIHRoaXMuX2luaXRDb250cm9sbGVycygpO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9OyAvLyDliJ3lp4vljJbphY3nva7poblcblxuXG4gIF9wcm90by5faW5pdE9wdGlvbnMgPSBmdW5jdGlvbiBfaW5pdE9wdGlvbnMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gVXRpbC5taXgoe30sIHNlbGYuZ2V0KCdvcHRpb25zJykpOyAvLyDpmLLmraLkv67mlLnljp/lp4vlgLxcblxuICAgIGlmICghb3B0aW9ucy5zY2FsZXMpIHtcbiAgICAgIG9wdGlvbnMuc2NhbGVzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmNvb3JkKSB7XG4gICAgICBvcHRpb25zLmNvb3JkID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc2V0KCdhbmltYXRlJywgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRvb2x0aXAgPT09IGZhbHNlIHx8IFV0aWwuaXNOdWxsKG9wdGlvbnMudG9vbHRpcCkpIHtcbiAgICAgIC8vIOmFjee9rumhueaWueW8j+WFs+mXrSB0b29sdGlwXG4gICAgICB0aGlzLnNldCgndG9vbHRpcEVuYWJsZScsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5nZW9tcyAmJiBvcHRpb25zLmdlb21zLmxlbmd0aCkge1xuICAgICAgVXRpbC5lYWNoKG9wdGlvbnMuZ2VvbXMsIGZ1bmN0aW9uIChnZW9tT3B0aW9uKSB7XG4gICAgICAgIHNlbGYuX2NyZWF0ZUdlb20oZ2VvbU9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVDb250cm9sbGVyID0gc2VsZi5nZXQoJ3NjYWxlQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKHNjYWxlQ29udHJvbGxlcikge1xuICAgICAgc2NhbGVDb250cm9sbGVyLmRlZnMgPSBvcHRpb25zLnNjYWxlcztcbiAgICB9XG5cbiAgICB2YXIgY29vcmRDb250cm9sbGVyID0gc2VsZi5nZXQoJ2Nvb3JkQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKGNvb3JkQ29udHJvbGxlcikge1xuICAgICAgY29vcmRDb250cm9sbGVyLnJlc2V0KG9wdGlvbnMuY29vcmQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdvcHRpb25zJywgb3B0aW9ucyk7XG4gIH07XG5cbiAgX3Byb3RvLl9jcmVhdGVHZW9tID0gZnVuY3Rpb24gX2NyZWF0ZUdlb20oY2ZnKSB7XG4gICAgdmFyIHR5cGUgPSBjZmcudHlwZTtcbiAgICB2YXIgZ2VvbTtcblxuICAgIGlmICh0aGlzW3R5cGVdKSB7XG4gICAgICBnZW9tID0gdGhpc1t0eXBlXSgpO1xuICAgICAgVXRpbC5lYWNoKGNmZywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgaWYgKGdlb21ba10pIHtcbiAgICAgICAgICBpZiAoVXRpbC5pc09iamVjdCh2KSAmJiB2LmZpZWxkKSB7XG4gICAgICAgICAgICAvLyDphY3nva7pobnkvKDlhaVcbiAgICAgICAgICAgIGlmICh2ID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgIGdlb21ba10odi5maWVsZCwgdi5jYWxsYmFjaywgdi5jZmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jZmc7XG5cbiAgICAgICAgICAgICAgVXRpbC5lYWNoKHYsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2ZpZWxkJykge1xuICAgICAgICAgICAgICAgICAgX2NmZyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdlb21ba10odi5maWVsZCwgX2NmZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlb21ba10odik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIOWIneWni+WMluaJgOacieeahOaOp+WItuWZqFxuXG5cbiAgX3Byb3RvLl9pbml0Q29udHJvbGxlcnMgPSBmdW5jdGlvbiBfaW5pdENvbnRyb2xsZXJzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHNlbGYuZ2V0KCdvcHRpb25zJyk7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYuZ2V0KCd2aWV3VGhlbWUnKTtcbiAgICB2YXIgY2FudmFzID0gc2VsZi5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBzY2FsZUNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlci5TY2FsZSh7XG4gICAgICB2aWV3VGhlbWU6IHZpZXdUaGVtZSxcbiAgICAgIGRlZnM6IG9wdGlvbnMuc2NhbGVzXG4gICAgfSk7XG4gICAgdmFyIGNvb3JkQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyLkNvb3JkKG9wdGlvbnMuY29vcmQpO1xuICAgIHRoaXMuc2V0KCdzY2FsZUNvbnRyb2xsZXInLCBzY2FsZUNvbnRyb2xsZXIpO1xuICAgIHRoaXMuc2V0KCdjb29yZENvbnRyb2xsZXInLCBjb29yZENvbnRyb2xsZXIpO1xuICAgIHZhciBheGlzQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyLkF4aXMoe1xuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICB2aWV3VGhlbWU6IHZpZXdUaGVtZVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdheGlzQ29udHJvbGxlcicsIGF4aXNDb250cm9sbGVyKTtcbiAgICB2YXIgZ3VpZGVDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIuR3VpZGUoe1xuICAgICAgdmlld1RoZW1lOiB2aWV3VGhlbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLmd1aWRlcyB8fCBbXVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdndWlkZUNvbnRyb2xsZXInLCBndWlkZUNvbnRyb2xsZXIpO1xuICB9O1xuXG4gIF9wcm90by5faW5pdFZpZXdQbG90ID0gZnVuY3Rpb24gX2luaXRWaWV3UGxvdCgpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KCd2aWV3Q29udGFpbmVyJykpIHtcbiAgICAgIC8vIOeUqOS6jiBnZW9tIOeahOe7mOWItlxuICAgICAgdGhpcy5zZXQoJ3ZpZXdDb250YWluZXInLCB0aGlzLmdldCgnbWlkZGxlUGxvdCcpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0R2VvbXMgPSBmdW5jdGlvbiBfaW5pdEdlb21zKCkge1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldCgnZmlsdGVyZWREYXRhJyk7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHZpZXdJZCA9IHRoaXMuZ2V0KCdfaWQnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBnZW9tID0gZ2VvbXNbaV07XG4gICAgICBnZW9tLnNldCgnZGF0YScsIGZpbHRlcmVkRGF0YSk7XG4gICAgICBnZW9tLnNldCgnY29vcmQnLCBjb29yZCk7XG4gICAgICBnZW9tLnNldCgnX2lkJywgdmlld0lkICsgJy1nZW9tJyArIGkpO1xuICAgICAgZ2VvbS5zZXQoJ2tleUZpZWxkcycsIHRoaXMuZ2V0KCdrZXlGaWVsZHMnKSk7XG4gICAgICBnZW9tLmluaXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jbGVhckdlb21zID0gZnVuY3Rpb24gX2NsZWFyR2VvbXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnZW9tcyA9IHNlbGYuZ2V0KCdnZW9tcycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcbiAgICAgIGdlb20uY2xlYXIoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZW1vdmVHZW9tcyA9IGZ1bmN0aW9uIF9yZW1vdmVHZW9tcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGdlb21zID0gc2VsZi5nZXQoJ2dlb21zJyk7XG5cbiAgICB3aGlsZSAoZ2VvbXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGdlb20gPSBnZW9tcy5zaGlmdCgpO1xuICAgICAgZ2VvbS5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fZHJhd0dlb21zID0gZnVuY3Rpb24gX2RyYXdHZW9tcygpIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZWRyYXdnZW9tcycpO1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcbiAgICAgIGdlb20uc2V0Q29vcmQoY29vcmQpO1xuICAgICAgZ2VvbS5wYWludCgpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYWZ0ZXJkcmF3Z2VvbXMnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTaGFwZUluVmlldyA9IGZ1bmN0aW9uIGlzU2hhcGVJblZpZXcoc2hhcGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmdldCgnX2lkJyk7XG4gICAgdmFyIHNoYXBlSWQgPSBzaGFwZS5faWQ7XG5cbiAgICBpZiAoIXNoYXBlSWQpIHtcbiAgICAgIHJldHVybiBzaGFwZS5nZXQoJ3BhcmVudCcpLmdldCgndmlld0lkJykgPT09IGlkO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZUlkLnNwbGl0KCctJylbMF0gPT09IGlkO1xuICB9O1xuICAvKipcbiAgICogVmlldyDmiYDlnKjnmoTojIPlm7RcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFZpZXcg5omA5Zyo55qE6IyD5Zu0XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldFZpZXdSZWdpb24gPSBmdW5jdGlvbiBnZXRWaWV3UmVnaW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcGFyZW50ID0gc2VsZi5nZXQoJ3BhcmVudCcpO1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgZW5kO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIHJlZ2lvbiA9IHBhcmVudC5nZXRWaWV3UmVnaW9uKCk7XG5cbiAgICAgIHZhciB2aWV3UmVnaW9uID0gc2VsZi5fZ2V0Vmlld1JlZ2lvbihyZWdpb24uc3RhcnQsIHJlZ2lvbi5lbmQpO1xuXG4gICAgICBzdGFydCA9IHZpZXdSZWdpb24uc3RhcnQ7XG4gICAgICBlbmQgPSB2aWV3UmVnaW9uLmVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBzZWxmLmdldCgnc3RhcnQnKTtcbiAgICAgIGVuZCA9IHNlbGYuZ2V0KCdlbmQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICB9OyAvLyDojrflj5YgcmFuZ2Ug5omA5Zyo55qE6IyD5Zu0XG5cblxuICBfcHJvdG8uX2dldFZpZXdSZWdpb24gPSBmdW5jdGlvbiBfZ2V0Vmlld1JlZ2lvbihwbG90U3RhcnQsIHBsb3RFbmQpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmdldCgnc3RhcnQnKTtcbiAgICB2YXIgZW5kID0gdGhpcy5nZXQoJ2VuZCcpO1xuICAgIHZhciBzdGFydFggPSBzdGFydC54O1xuICAgIHZhciBzdGFydFkgPSAxIC0gZW5kLnk7XG4gICAgdmFyIGVuZFggPSBlbmQueDtcbiAgICB2YXIgZW5kWSA9IDEgLSBzdGFydC55O1xuICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXQoJ3BhZGRpbmcnKTsgLy8g6L2s5o2i5oiQIOS4iuOAgeWPs+OAgeS4i+OAgeW3pueahOaooeW8j1xuXG4gICAgdmFyIGFsbFBhZGRpbmcgPSBVdGlsLnRvQWxsUGFkZGluZyhwYWRkaW5nKTtcbiAgICB2YXIgdG9wID0gYWxsUGFkZGluZ1swXTtcbiAgICB2YXIgcmlnaHQgPSBhbGxQYWRkaW5nWzFdO1xuICAgIHZhciBib3R0b20gPSBhbGxQYWRkaW5nWzJdO1xuICAgIHZhciBsZWZ0ID0gYWxsUGFkZGluZ1szXTtcbiAgICB2YXIgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0WCAqIChwbG90RW5kLnggLSBwbG90U3RhcnQueCkgKyBwbG90U3RhcnQueCArIGxlZnQsXG4gICAgICB5OiBzdGFydFkgKiAocGxvdEVuZC55IC0gcGxvdFN0YXJ0LnkpICsgcGxvdFN0YXJ0LnkgLSBib3R0b21cbiAgICB9O1xuICAgIHZhciBlbmRQb2ludCA9IHtcbiAgICAgIHg6IGVuZFggKiAocGxvdEVuZC54IC0gcGxvdFN0YXJ0LngpICsgcGxvdFN0YXJ0LnggLSByaWdodCxcbiAgICAgIHk6IGVuZFkgKiAocGxvdEVuZC55IC0gcGxvdFN0YXJ0LnkpICsgcGxvdFN0YXJ0LnkgKyB0b3BcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogc3RhcnRQb2ludCxcbiAgICAgIGVuZDogZW5kUG9pbnRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fY3JlYXRlQ29vcmQgPSBmdW5jdGlvbiBfY3JlYXRlQ29vcmQoKSB7XG4gICAgdmFyIGNvb3JkQ29udHJvbGxlciA9IHRoaXMuZ2V0KCdjb29yZENvbnRyb2xsZXInKTtcbiAgICB2YXIgcmVnaW9uID0gdGhpcy5nZXRWaWV3UmVnaW9uKCk7XG4gICAgdmFyIGNvb3JkID0gY29vcmRDb250cm9sbGVyLmNyZWF0ZUNvb3JkKHJlZ2lvbi5zdGFydCwgcmVnaW9uLmVuZCk7XG4gICAgdGhpcy5zZXQoJ2Nvb3JkJywgY29vcmQpO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyQXhlcyA9IGZ1bmN0aW9uIF9yZW5kZXJBeGVzKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXQoJ29wdGlvbnMnKTtcbiAgICB2YXIgYXhlc09wdGlvbnMgPSBvcHRpb25zLmF4ZXM7XG5cbiAgICBpZiAoYXhlc09wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAvLyDkuI3muLLmn5PlnZDmoIfovbRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0NvbnRyb2xsZXIgPSB0aGlzLmdldCgnYXhpc0NvbnRyb2xsZXInKTtcbiAgICBheGlzQ29udHJvbGxlci5jb250YWluZXIgPSB0aGlzLmdldCgnYmFja1Bsb3QnKTtcbiAgICBheGlzQ29udHJvbGxlci5jb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgIGF4aXNDb250cm9sbGVyLm9wdGlvbnMgPSBheGVzT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlcyA9IHRoaXMuZ2V0WVNjYWxlcygpO1xuICAgIHZhciB2aWV3SWQgPSB0aGlzLmdldCgnX2lkJyk7XG4gICAgYXhpc0NvbnRyb2xsZXIuY3JlYXRlQXhpcyh4U2NhbGUsIHlTY2FsZXMsIHZpZXdJZCk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJHdWlkZXMgPSBmdW5jdGlvbiBfcmVuZGVyR3VpZGVzKCkge1xuICAgIHZhciBndWlkZUNvbnRyb2xsZXIgPSB0aGlzLmdldCgnZ3VpZGVDb250cm9sbGVyJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNFbXB0eShndWlkZUNvbnRyb2xsZXIub3B0aW9ucykpIHtcbiAgICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgICAgZ3VpZGVDb250cm9sbGVyLnZpZXcgPSB0aGlzO1xuICAgICAgZ3VpZGVDb250cm9sbGVyLmJhY2tDb250YWluZXIgPSB0aGlzLmdldCgnYmFja1Bsb3QnKTtcbiAgICAgIGd1aWRlQ29udHJvbGxlci5mcm9udENvbnRhaW5lciA9IHRoaXMuZ2V0KCdmcm9udFBsb3QnKTtcbiAgICAgIGd1aWRlQ29udHJvbGxlci54U2NhbGVzID0gdGhpcy5fZ2V0U2NhbGVzKCd4Jyk7XG4gICAgICBndWlkZUNvbnRyb2xsZXIueVNjYWxlcyA9IHRoaXMuX2dldFNjYWxlcygneScpO1xuICAgICAgZ3VpZGVDb250cm9sbGVyLnJlbmRlcihjb29yZCk7XG4gICAgfVxuICB9OyAvLyDms6jlhozkuovku7ZcblxuXG4gIF9wcm90by5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgIHZhciBldmVudENvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlci5FdmVudCh7XG4gICAgICB2aWV3OiB0aGlzLFxuICAgICAgY2FudmFzOiB0aGlzLmdldCgnY2FudmFzJylcbiAgICB9KTtcbiAgICBldmVudENvbnRyb2xsZXIuYmluZEV2ZW50cygpO1xuICAgIHRoaXMuc2V0KCdldmVudENvbnRyb2xsZXInLCBldmVudENvbnRyb2xsZXIpO1xuICB9OyAvLyDmuIXnkIbml7bpl7RcblxuXG4gIF9wcm90by5fY2xlYXJFdmVudHMgPSBmdW5jdGlvbiBfY2xlYXJFdmVudHMoKSB7XG4gICAgdmFyIGV2ZW50Q29udHJvbGxlciA9IHRoaXMuZ2V0KCdldmVudENvbnRyb2xsZXInKTtcbiAgICBldmVudENvbnRyb2xsZXIgJiYgZXZlbnRDb250cm9sbGVyLmNsZWFyRXZlbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRTY2FsZXMgPSBmdW5jdGlvbiBfZ2V0U2NhbGVzKGRpbVR5cGUpIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbSA9IGdlb21zW2ldO1xuICAgICAgdmFyIHNjYWxlID0gZGltVHlwZSA9PT0gJ3gnID8gZ2VvbS5nZXRYU2NhbGUoKSA6IGdlb20uZ2V0WVNjYWxlKCk7XG5cbiAgICAgIGlmIChzY2FsZSAmJiAhcmVzdWx0W3NjYWxlLmZpZWxkXSkge1xuICAgICAgICByZXN1bHRbc2NhbGUuZmllbGRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uX2FkanVzdFNjYWxlID0gZnVuY3Rpb24gX2FkanVzdFNjYWxlKCkge1xuICAgIHRoaXMuX3NldENhdFNjYWxlc1JhbmdlKCk7XG5cbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgc2NhbGVDb250cm9sbGVyID0gdGhpcy5nZXQoJ3NjYWxlQ29udHJvbGxlcicpO1xuICAgIHZhciBjb2xEZWZzID0gc2NhbGVDb250cm9sbGVyLmRlZnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbSA9IGdlb21zW2ldO1xuXG4gICAgICBpZiAoZ2VvbS5nZXQoJ3R5cGUnKSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICB2YXIgeVNjYWxlID0gZ2VvbS5nZXRZU2NhbGUoKTtcbiAgICAgICAgdmFyIGZpZWxkID0geVNjYWxlLmZpZWxkLFxuICAgICAgICAgICAgbWluID0geVNjYWxlLm1pbixcbiAgICAgICAgICAgIG1heCA9IHlTY2FsZS5tYXgsXG4gICAgICAgICAgICB0eXBlID0geVNjYWxlLnR5cGU7XG5cbiAgICAgICAgaWYgKCEoY29sRGVmc1tmaWVsZF0gJiYgY29sRGVmc1tmaWVsZF0ubWluKSAmJiB0eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgeVNjYWxlLmNoYW5nZSh7XG4gICAgICAgICAgICAgIG1pbjogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXggPD0gMCkge1xuICAgICAgICAgICAgLy8g5b2T5p+x54q25Zu+5YWo5Li66LSf5YC85pe25Lmf6ZyA6KaB5LuOIDAg5byA5aeL55Sf6ZW/XG4gICAgICAgICAgICB5U2NhbGUuY2hhbmdlKHtcbiAgICAgICAgICAgICAgbWF4OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRDYXRTY2FsZXNSYW5nZSA9IGZ1bmN0aW9uIF9zZXRDYXRTY2FsZXNSYW5nZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYuZ2V0KCd2aWV3VGhlbWUnKTtcbiAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlcyA9IHNlbGYuZ2V0WVNjYWxlcygpO1xuICAgIHZhciBzY2FsZXMgPSBbXTtcbiAgICB4U2NhbGUgJiYgc2NhbGVzLnB1c2goeFNjYWxlKTtcbiAgICBzY2FsZXMgPSBzY2FsZXMuY29uY2F0KHlTY2FsZXMpO1xuICAgIHZhciBpbkZ1bGxDaXJjbGUgPSBjb29yZC5pc1BvbGFyICYmIGlzRnVsbENpcmNsZShjb29yZCk7XG4gICAgdmFyIHNjYWxlQ29udHJvbGxlciA9IHNlbGYuZ2V0KCdzY2FsZUNvbnRyb2xsZXInKTtcbiAgICB2YXIgY29sRGVmcyA9IHNjYWxlQ29udHJvbGxlci5kZWZzO1xuICAgIFV0aWwuZWFjaChzY2FsZXMsIGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgaWYgKChzY2FsZS5pc0NhdGVnb3J5IHx8IHNjYWxlLmlzSWRlbnRpdHkpICYmIHNjYWxlLnZhbHVlcyAmJiAhKGNvbERlZnNbc2NhbGUuZmllbGRdICYmIGNvbERlZnNbc2NhbGUuZmllbGRdLnJhbmdlKSkge1xuICAgICAgICB2YXIgY291bnQgPSBzY2FsZS52YWx1ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmFuZ2U7XG5cbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmFuZ2UgPSBbMC41LCAxXTsgLy8g5Y+q5pyJ5LiA5Liq5YiG57G75pe2LOmYsuatouiuoeeul+WHuueOsCBbMC41LDAuNV3nmoTnirbmgIFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IDE7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICBpZiAoaW5GdWxsQ2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAoIWNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgICAgICAgICByYW5nZSA9IFswLCAxIC0gMSAvIGNvdW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoUmF0aW8gPSB2aWV3VGhlbWUud2lkdGhSYXRpby5tdWx0aXBsZVBpZTtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gMSAvIGNvdW50ICogd2lkdGhSYXRpbztcbiAgICAgICAgICAgICAgcmFuZ2UgPSBbb2Zmc2V0IC8gMiwgMSAtIG9mZnNldCAvIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAxIC8gY291bnQgKiAxIC8gMjsgLy8g5Lik6L6555WZ5LiL5YiG57G756m66Ze055qE5LiA5Y2KXG5cbiAgICAgICAgICAgIHJhbmdlID0gW29mZnNldCwgMSAtIG9mZnNldF07IC8vIOWdkOagh+i9tOacgOWJjemdouWSjOacgOWQjumdoueVmeS4i+epuueZvemYsuatoue7mOWItuafseeKtuWbvuaXtlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnJhbmdlID0gcmFuZ2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFhTY2FsZSA9IGZ1bmN0aW9uIGdldFhTY2FsZSgpIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTsgLy8g5aaC5p6c6L+b6KGM6L+H5ruk77yM6YKj5LmIIGdlb20g6buY6K6k6ZqQ6JeP5pe25Lya5Ye6546w5LiN5LiA6Ie0XG4gICAgLy8g6buY6K6k6ZqQ6JeP5pe25Z2Q5qCH6L205LiN57uY5Yi277yM5L2G5piv6LCD55So5LqGIGdlb20uc2hvdygpIOWQju+8jOWImeWbvuW9ouaYvuekuuS6hu+8jOWdkOagh+i9tOS+neeEtuS4jeingVxuXG4gICAgLyogLmZpbHRlcihmdW5jdGlvbihnZW9tKSB7XG4gICAgICByZXR1cm4gZ2VvbS5nZXQoJ3Zpc2libGUnKTtcbiAgICB9KTsgKi9cblxuICAgIHZhciB4U2NhbGUgPSBudWxsO1xuXG4gICAgaWYgKCFVdGlsLmlzRW1wdHkoZ2VvbXMpKSB7XG4gICAgICB4U2NhbGUgPSBnZW9tc1swXS5nZXRYU2NhbGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4geFNjYWxlO1xuICB9O1xuXG4gIF9wcm90by5nZXRZU2NhbGVzID0gZnVuY3Rpb24gZ2V0WVNjYWxlcygpIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICAvKiAuZmlsdGVyKGZ1bmN0aW9uKGdlb20pIHtcbiAgICAgIHJldHVybiBnZW9tLmdldCgndmlzaWJsZScpO1xuICAgIH0pOyAqL1xuXG4gICAgdmFyIHJzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcbiAgICAgIHZhciB5U2NhbGUgPSBnZW9tLmdldFlTY2FsZSgpO1xuXG4gICAgICBpZiAoeVNjYWxlICYmIFV0aWwuaW5kZXhPZihyc3QsIHlTY2FsZSkgPT09IC0xKSB7XG4gICAgICAgIHJzdC5wdXNoKHlTY2FsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcbiAgLyoqXG4gICAqIOiOt+WPluaVsOaNruWvueW6lOWcqOeUu+W4g+epuumXtOeahOWdkOagh1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGl0ZW0g5Y6f5aeL5pWw5o2uXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICDov5Tlm57lr7nlupTnmoTnlLvluIPkuIrnmoTlnZDmoIfngrlcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0WFkgPSBmdW5jdGlvbiBnZXRYWShpdGVtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuXG4gICAgdmFyIHhTY2FsZXMgPSBzZWxmLl9nZXRTY2FsZXMoJ3gnKTtcblxuICAgIHZhciB5U2NhbGVzID0gc2VsZi5fZ2V0U2NhbGVzKCd5Jyk7XG5cbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcblxuICAgIGZvciAodmFyIGZpZWxkIGluIGl0ZW0pIHtcbiAgICAgIGlmICh4U2NhbGVzW2ZpZWxkXSkge1xuICAgICAgICB4ID0geFNjYWxlc1tmaWVsZF0uc2NhbGUoaXRlbVtmaWVsZF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoeVNjYWxlc1tmaWVsZF0pIHtcbiAgICAgICAgeSA9IHlTY2FsZXNbZmllbGRdLnNjYWxlKGl0ZW1bZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIVV0aWwuaXNOaWwoeCkgJiYgIVV0aWwuaXNOaWwoeSkpIHtcbiAgICAgIHJldHVybiBjb29yZC5jb252ZXJ0KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiDojrflj5bpgLzov5HnmoTngrnnmoTmlbDmja7pm4blkIhcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDnlLvluIPkuIrnmoTlg4/ntKDngrlcbiAgICogQHJldHVybiB7QXJyYXl9IOaVsOaNrlxuICAgKi9cblxuXG4gIF9wcm90by5nZXRTbmFwUmVjb3JkcyA9IGZ1bmN0aW9uIGdldFNuYXBSZWNvcmRzKHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnZW9tcyA9IHNlbGYuZ2V0KCdnZW9tcycpO1xuICAgIHZhciByc3QgPSBbXTtcbiAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICB2YXIgZGF0YUFycmF5ID0gZ2VvbS5nZXQoJ2RhdGFBcnJheScpO1xuICAgICAgdmFyIHJlY29yZDtcbiAgICAgIFV0aWwuZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJlY29yZCA9IGdlb20uZmluZFBvaW50KHBvaW50LCBkYXRhKTtcbiAgICAgICAgcmVjb3JkICYmIHJzdC5wdXNoKHJlY29yZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDmt7vliqDlh6DkvZXmoIforrBcbiAgICogQHBhcmFtIHtHZW9tfSBnZW9tIOWHoOS9leagh+iusFxuICAgKi9cblxuXG4gIF9wcm90by5hZGRHZW9tID0gZnVuY3Rpb24gYWRkR2VvbShnZW9tKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnZW9tcyA9IHNlbGYuZ2V0KCdnZW9tcycpO1xuICAgIGdlb21zLnB1c2goZ2VvbSk7XG4gICAgZ2VvbS5zZXQoJ3ZpZXcnLCBzZWxmKTtcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ3ZpZXdDb250YWluZXInKTtcbiAgICBnZW9tLnNldCgnY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICBnZW9tLnNldCgnYW5pbWF0ZScsIHNlbGYuZ2V0KCdhbmltYXRlJykpO1xuICAgIGdlb20uYmluZEV2ZW50cygpO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDnp7vpmaTlh6DkvZXmoIforrBcbiAgICogQHBhcmFtIHtHZW9tfSBnZW9tIOWHoOS9leagh+iusFxuICAgKi9cblxuXG4gIF9wcm90by5yZW1vdmVHZW9tID0gZnVuY3Rpb24gcmVtb3ZlR2VvbShnZW9tKSB7XG4gICAgdmFyIGdlb21zID0gdGhpcy5nZXQoJ2dlb21zJyk7XG4gICAgVXRpbC5BcnJheS5yZW1vdmUoZ2VvbXMsIGdlb20pO1xuICAgIGdlb20uZGVzdHJveSgpO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVTY2FsZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlKGZpZWxkLCBkYXRhKSB7XG4gICAgdmFyIHNjYWxlcyA9IHRoaXMuZ2V0KCdzY2FsZXMnKTtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXQoJ3BhcmVudCcpO1xuICAgIHZhciBzY2FsZSA9IHNjYWxlc1tmaWVsZF07IC8vIGNvbnN0IGZpbHRlcnMgPSB0aGlzLl9nZXRGaWx0ZXJzKCk7XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldCgnZmlsdGVyZWREYXRhJyk7XG5cbiAgICAgIHZhciBsZWdlbmRGaWVsZHMgPSB0aGlzLl9nZXRGaWVsZHNGb3JMZWdlbmQoKTsgLy8g6L+H5ruk5a+86Ie05pWw5o2u5Li656m65pe277yM6ZyA6KaB5L2/55So5YWo5bGA5pWw5o2uXG4gICAgICAvLyDlj4LkuI7ov4fmu6TnmoTlrZfmrrXnmoTluqbph4/kuZ/moLnmja7lhajlsYDmlbDmja7mnaXnlJ/miJBcblxuXG4gICAgICBpZiAoZmlsdGVyZWREYXRhLmxlbmd0aCAmJiBsZWdlbmRGaWVsZHMuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICAgIGRhdGEgPSBmaWx0ZXJlZERhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gdGhpcy5nZXQoJ2RhdGEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2NhbGVDb250cm9sbGVyID0gdGhpcy5nZXQoJ3NjYWxlQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFzY2FsZSkge1xuICAgICAgc2NhbGUgPSBzY2FsZUNvbnRyb2xsZXIuY3JlYXRlU2NhbGUoZmllbGQsIGRhdGEpO1xuXG4gICAgICBpZiAoc2NhbGUuc3luYyAmJiBwYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudFNjYWxlID0gcGFyZW50LmNyZWF0ZVNjYWxlKGZpZWxkLCBkYXRhKTtcbiAgICAgICAgc2NhbGUgPSB0aGlzLl9nZXRTeW5jU2NhbGUocGFyZW50U2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgc2NhbGVzW2ZpZWxkXSA9IHNjYWxlO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUuc3luYykge1xuICAgICAgLy8g6Ziy5q2iIHZpZXcg5YaF6YOo5Yib5bu655qEc2NhbGXvvIxDaGFydCDkuIrnmoRzY2FsZSDojIPlm7Tmm7TlpKdcbiAgICAgIHZhciBuZXdTY2FsZSA9IHNjYWxlQ29udHJvbGxlci5jcmVhdGVTY2FsZShmaWVsZCwgZGF0YSk7XG5cbiAgICAgIHRoaXMuX3N5bmNTY2FsZShzY2FsZSwgbmV3U2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldEZpZWxkc0ZvckxlZ2VuZCA9IGZ1bmN0aW9uIF9nZXRGaWVsZHNGb3JMZWdlbmQoKSB7XG4gICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgIHZhciBnZW9tRmllbGRzID0gZ2VvbS5nZXRGaWVsZHNGb3JMZWdlbmQoKTtcbiAgICAgIGZpZWxkcyA9IGZpZWxkcy5jb25jYXQoZ2VvbUZpZWxkcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFV0aWwudW5pcShmaWVsZHMpO1xuICB9OyAvLyDlpoLmnpzpnIDopoHlkIzmraXluqbph4/vvIzliJnkvb/lvpcgdmFsdWVzLG1pbixtYXjnmoTojIPlm7TmnIDlpKdcblxuXG4gIF9wcm90by5fZ2V0U3luY1NjYWxlID0gZnVuY3Rpb24gX2dldFN5bmNTY2FsZShwYXJlbnRTY2FsZSwgc2NhbGUpIHtcbiAgICBpZiAocGFyZW50U2NhbGUudHlwZSAhPT0gc2NhbGUudHlwZSkge1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIHRoaXMuX3N5bmNTY2FsZShwYXJlbnRTY2FsZSwgc2NhbGUpO1xuXG4gICAgcmV0dXJuIHBhcmVudFNjYWxlO1xuICB9O1xuXG4gIF9wcm90by5fc3luY1NjYWxlID0gZnVuY3Rpb24gX3N5bmNTY2FsZShkaXN0U2NhbGUsIHNvdXJjZVNjYWxlKSB7XG4gICAgdmFyIG1lcmdlVmFsdWVzID0gVXRpbC51bmlvbihkaXN0U2NhbGUudmFsdWVzLCBzb3VyY2VTY2FsZS52YWx1ZXMpO1xuXG4gICAgaWYgKHNvdXJjZVNjYWxlLmlzTGluZWFyKSB7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoZGlzdFNjYWxlLm1heCwgc291cmNlU2NhbGUubWF4KTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihkaXN0U2NhbGUubWluLCBzb3VyY2VTY2FsZS5taW4pO1xuXG4gICAgICBpZiAoZGlzdFNjYWxlLm1heCAhPT0gbWF4IHx8IGRpc3RTY2FsZS5taW4gIT09IG1pbikge1xuICAgICAgICBkaXN0U2NhbGUuY2hhbmdlKHtcbiAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICB2YWx1ZXM6IG1lcmdlVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXJnZVZhbHVlcy5sZW5ndGggIT09IGRpc3RTY2FsZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBkaXN0U2NhbGUuY2hhbmdlKHtcbiAgICAgICAgdmFsdWVzOiBtZXJnZVZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDojrflj5bov4fmu6TlkI7nmoTlgLzvvIjpnIDopoHmmL7npLrnmoTlgLzvvIlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIOW6pumHj1xuICAgKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0g5ruk5ZCO55qE5YC8XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldEZpbHRlcmVkVmFsdWVzID0gZnVuY3Rpb24gZ2V0RmlsdGVyZWRWYWx1ZXMoZmllbGQpIHtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldCgnc2NhbGVzJylbZmllbGRdO1xuICAgIHZhciB2YWx1ZXMgPSBzY2FsZS52YWx1ZXM7XG5cbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuX2dldEZpbHRlcnMoKTtcblxuICAgIHZhciByc3Q7XG5cbiAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzW2ZpZWxkXSkge1xuICAgICAgcnN0ID0gdmFsdWVzLmZpbHRlcihmaWx0ZXJzW2ZpZWxkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdCA9IHZhbHVlcy5zbGljZSgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDojrflj5booqvov4fmu6TnmoTlgLzvvIjkuI3pnIDmmL7npLrnmoTlgLzvvIlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIOW6pumHj1xuICAgKiBAcmV0dXJuIHtBcnJheS48U3RyaW5nPn0g5ruk5Ye655qE5YC8XG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldEZpbHRlcmVkT3V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0RmlsdGVyZWRPdXRWYWx1ZXMoZmllbGQpIHtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldCgnc2NhbGVzJylbZmllbGRdO1xuICAgIHZhciB2YWx1ZXMgPSBzY2FsZS52YWx1ZXM7XG5cbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuX2dldEZpbHRlcnMoKTtcblxuICAgIHZhciByc3Q7XG5cbiAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzW2ZpZWxkXSkge1xuICAgICAgcnN0ID0gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gIWZpbHRlcnNbZmllbGRdKHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdCA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihmaWVsZCwgY29uZGl0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldCgnb3B0aW9ucycpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZpbHRlcnMpIHtcbiAgICAgIG9wdGlvbnMuZmlsdGVycyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMuZmlsdGVyc1tmaWVsZF0gPSBjb25kaXRpb247XG4gICAgdGhpcy5nZXQoJ3NjYWxlQ29udHJvbGxlcicpLmZpbHRlcnMgPSBvcHRpb25zLmZpbHRlcnM7XG4gIH07IC8vIOiOt+WPliBmaWx0ZXJzXG5cblxuICBfcHJvdG8uX2dldEZpbHRlcnMgPSBmdW5jdGlvbiBfZ2V0RmlsdGVycygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdvcHRpb25zJyk7XG4gICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVycztcbiAgfTsgLy8g5omn6KGMIGZpbHRlciDmlbDmja5cblxuXG4gIF9wcm90by5leGVjRmlsdGVyID0gZnVuY3Rpb24gZXhlY0ZpbHRlcihkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGZpbHRlcnMgPSBzZWxmLl9nZXRGaWx0ZXJzKCk7XG5cbiAgICBpZiAoZmlsdGVycykge1xuICAgICAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHJzdCA9IHRydWU7XG4gICAgICAgIFV0aWwuZWFjaChmaWx0ZXJzLCBmdW5jdGlvbiAoZm4sIGspIHtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHJzdCA9IGZuKG9ialtrXSwgb2JqKTtcblxuICAgICAgICAgICAgaWYgKCFyc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByc3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBfcHJvdG8uYXhpcyA9IGZ1bmN0aW9uIGF4aXMoZmllbGQsIGNmZykge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXQoJ29wdGlvbnMnKTtcblxuICAgIGlmIChmaWVsZCA9PT0gZmFsc2UpIHtcbiAgICAgIG9wdGlvbnMuYXhlcyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYXhlcykge1xuICAgICAgICBvcHRpb25zLmF4ZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNPcHRpb25zID0gb3B0aW9ucy5heGVzO1xuICAgICAgYXhpc09wdGlvbnNbZmllbGRdID0gY2ZnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5ndWlkZSA9IGZ1bmN0aW9uIGd1aWRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnZ3VpZGVDb250cm9sbGVyJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRLZXlGaWVsZHMgPSBmdW5jdGlvbiBfZ2V0S2V5RmllbGRzKHNjYWxlRGVmcykge1xuICAgIHZhciBrZXlGaWVsZHMgPSBbXTtcbiAgICBVdGlsLmVhY2goc2NhbGVEZWZzLCBmdW5jdGlvbiAoZGVmLCBmaWVsZCkge1xuICAgICAgaWYgKGRlZi5rZXkpIHtcbiAgICAgICAga2V5RmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdrZXlGaWVsZHMnLCBrZXlGaWVsZHMpO1xuICB9O1xuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGZpZWxkLCBjZmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdvcHRpb25zJyk7XG4gICAgdmFyIHNjYWxlRGVmcyA9IG9wdGlvbnMuc2NhbGVzO1xuXG4gICAgaWYgKFV0aWwuaXNPYmplY3QoZmllbGQpKSB7XG4gICAgICBVdGlsLm1peChzY2FsZURlZnMsIGZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVEZWZzW2ZpZWxkXSA9IGNmZztcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRLZXlGaWVsZHMoc2NhbGVEZWZzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50b29sdGlwID0gZnVuY3Rpb24gdG9vbHRpcCh2aXNpYmxlKSB7XG4gICAgdGhpcy5zZXQoJ3Rvb2x0aXBFbmFibGUnLCB2aXNpYmxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUoZW5hYmxlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldCgnb3B0aW9ucycpO1xuICAgIG9wdGlvbnMuYW5pbWF0ZSA9IGVuYWJsZTtcbiAgICB0aGlzLnNldCgnYW5pbWF0ZScsIGVuYWJsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNoYW5nZU9wdGlvbnMgPSBmdW5jdGlvbiBjaGFuZ2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldCgnb3B0aW9ucycsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCDmn6Xmib7ljIXlkKvmjIflrprngrnnmoTop4blm75cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDngrnnmoTkvY3nva5cbiAgICogQHJldHVybiB7QXJyYXl9IOWkmuS4quinhuWbvlxuICAgKi9cblxuXG4gIF9wcm90by5nZXRWaWV3c0J5UG9pbnQgPSBmdW5jdGlvbiBnZXRWaWV3c0J5UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXQoJ3ZpZXdzJyk7XG5cbiAgICBpZiAoaXNQb2ludEluQ29vcmQodGhpcy5nZXQoJ2Nvb3JkJyksIHBvaW50KSkge1xuICAgICAgcnN0LnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgaWYgKHZpZXcuZ2V0KCd2aXNpYmxlJykgJiYgaXNQb2ludEluQ29vcmQodmlldy5nZXQoJ2Nvb3JkJyksIHBvaW50KSkge1xuICAgICAgICByc3QucHVzaCh2aWV3KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICog6YGN5Y6G5omA5pyJ55qEIHNoYXBlIO+8jOeUqOaIt+abtOaUuSBzaGFwZSDlkI7ov5vooYzliLfmlrBcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuIOWbnuiwg+WHveaVsOWMheWQq+WPguaVsO+8mnJlY29yZCxzaGFwZSxnZW9tLHZpZXdcbiAgICogQHJldHVybiB7Vmlld30g5b2T5YmN6KeG5Zu+XG4gICAqL1xuXG5cbiAgX3Byb3RvLmVhY2hTaGFwZSA9IGZ1bmN0aW9uIGVhY2hTaGFwZShmbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmlld3MgPSBzZWxmLmdldCgndmlld3MnKTtcbiAgICB2YXIgY2FudmFzID0gc2VsZi5nZXQoJ2NhbnZhcycpO1xuICAgIFV0aWwuZWFjaCh2aWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZpZXcuZWFjaFNoYXBlKGZuKTtcbiAgICB9KTtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICB2YXIgc2hhcGVzID0gZ2VvbS5nZXRTaGFwZXMoKTtcbiAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gc2hhcGUuZ2V0KCdvcmlnaW4nKTtcblxuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgICB2YXIgYXJyID0gb3JpZ2luLm1hcChmdW5jdGlvbiAoc3ViT3JpZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViT3JpZ2luW0ZJRUxEX09SSUdJTl07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm4oYXJyLCBzaGFwZSwgZ2VvbSwgc2VsZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9yaWdpbltGSUVMRF9PUklHSU5dO1xuICAgICAgICAgIGZuKG9iaiwgc2hhcGUsIGdlb20sIHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjYW52YXMuZHJhdygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog6YGN5Y6G5omA5pyJ55qEIHNoYXBlIO+8jOWbnuiwg+WHveaVsOS4rSB0cnVlIC8gZmFsc2Ug5o6n5Yi25Zu+5b2i5piv5ZCm5pi+56S6XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiDlm57osIPlh73mlbDljIXlkKvlj4LmlbDvvJpyZWNvcmQsc2hhcGUsZ2VvbSx2aWV3XG4gICAqIEByZXR1cm4ge1ZpZXd9IOW9k+WJjeinhuWbvlxuICAgKi9cblxuXG4gIF9wcm90by5maWx0ZXJTaGFwZSA9IGZ1bmN0aW9uIGZpbHRlclNoYXBlKGZuKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2socmVjb3JkLCBzaGFwZSwgZ2VvbSwgdmlldykge1xuICAgICAgaWYgKCFmbihyZWNvcmQsIHNoYXBlLCBnZW9tLCB2aWV3KSkge1xuICAgICAgICBzaGFwZS5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZWFjaFNoYXBlKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJJbm5lciA9IGZ1bmN0aW9uIGNsZWFySW5uZXIoKSB7XG4gICAgdGhpcy5zZXQoJ3NjYWxlcycsIHt9KTtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZWNsZWFyaW5uZXInKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdvcHRpb25zJyk7XG4gICAgb3B0aW9ucy5nZW9tcyA9IG51bGw7XG5cbiAgICB0aGlzLl9jbGVhckdlb21zKCk7IC8vIHJlc2V0IGd1aWRlXG5cblxuICAgIHRoaXMuZ2V0KCdndWlkZUNvbnRyb2xsZXInKSAmJiB0aGlzLmdldCgnZ3VpZGVDb250cm9sbGVyJykucmVzZXQoKTsgLy8gY2xlYXIgYXhpc1xuXG4gICAgdGhpcy5nZXQoJ2F4aXNDb250cm9sbGVyJykgJiYgdGhpcy5nZXQoJ2F4aXNDb250cm9sbGVyJykuY2xlYXIoKTtcbiAgICB0aGlzLmVtaXQoJ2FmdGVyY2xlYXJpbm5lcicpO1xuICB9O1xuICAvKipcbiAgICog5riF6Zmk6KeG5Zu+5YaF5a6577yM5YyF5ousIGdlb21zXG4gICAqIEByZXR1cm4ge1ZpZXd9IOW9k+WJjeinhuWbvlxuICAgKi9cblxuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXQoJ29wdGlvbnMnKTtcbiAgICBvcHRpb25zLmZpbHRlcnMgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVtb3ZlR2VvbXMoKTsgLy8gY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXQoJ3ZpZXdDb250YWluZXInKTtcbiAgICAvLyBjb250YWluZXIuY2xlYXIoKTtcblxuXG4gICAgdGhpcy5jbGVhcklubmVyKCk7XG4gICAgdGhpcy5nZXQoJ2d1aWRlQ29udHJvbGxlcicpICYmIHRoaXMuZ2V0KCdndWlkZUNvbnRyb2xsZXInKS5jbGVhcigpO1xuICAgIHRoaXMuc2V0KCdpc1VwZGF0ZScsIGZhbHNlKTtcbiAgICB0aGlzLnNldCgna2V5RmllbGRzJywgW10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog6K6+572u5Z2Q5qCH57O75L+h5oGvXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSDnsbvlnotcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgIOmFjee9rumhuVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNvb3JkQ29udHJvbGxlciDlnZDmoIfns7vnmoTnrqHnkIblmahcbiAgICovXG5cblxuICBfcHJvdG8uY29vcmQgPSBmdW5jdGlvbiBjb29yZCh0eXBlLCBjZmcpIHtcbiAgICB2YXIgY29vcmRDb250cm9sbGVyID0gdGhpcy5nZXQoJ2Nvb3JkQ29udHJvbGxlcicpO1xuICAgIGNvb3JkQ29udHJvbGxlci5yZXNldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgY2ZnOiBjZmdcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRDb250cm9sbGVyO1xuICB9O1xuICAvKipcbiAgICog5b2T54i25YWD57Sg6L655qGG5Y+R55Sf5pS55Y+Y5pe25Z2Q5qCH57O76ZyA6KaB6YeN5paw6LCD5pW0XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBfcHJvdG8ucmVzZXRDb29yZCA9IGZ1bmN0aW9uIHJlc2V0Q29vcmQoKSB7XG4gICAgdGhpcy5fY3JlYXRlQ29vcmQoKTtcbiAgfTtcblxuICBfcHJvdG8uc291cmNlID0gZnVuY3Rpb24gc291cmNlKGRhdGEsIHNjYWxlcykge1xuICAgIHRoaXMuX2luaXREYXRhKGRhdGEpO1xuXG4gICAgaWYgKHNjYWxlcykge1xuICAgICAgdGhpcy5zY2FsZShzY2FsZXMpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnc2V0ZGF0YScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jaGFuZ2VEYXRhID0gZnVuY3Rpb24gY2hhbmdlRGF0YShkYXRhKSB7XG4gICAgdGhpcy5lbWl0KCdiZWZvcmVjaGFuZ2VkYXRhJyk7XG5cbiAgICB0aGlzLl9pbml0RGF0YShkYXRhKTtcblxuICAgIHRoaXMuZW1pdCgnYWZ0ZXJjaGFuZ2VkYXRhJyk7XG4gICAgdGhpcy5yZXBhaW50KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0RGF0YSA9IGZ1bmN0aW9uIF9pbml0RGF0YShkYXRhKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5nZXQoJ2RhdGFWaWV3Jyk7XG5cbiAgICBpZiAoZGF0YVZpZXcpIHtcbiAgICAgIGRhdGFWaWV3Lm9mZignY2hhbmdlJywgVXRpbC5nZXRXcmFwQmVoYXZpb3IodGhpcywgJ19vblZpZXdDaGFuZ2UnKSk7XG4gICAgICB0aGlzLnNldCgnZGF0YVZpZXcnLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmlzRGF0YVZpZXcpIHtcbiAgICAgIGRhdGEub24oJ2NoYW5nZScsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdfb25WaWV3Q2hhbmdlJykpO1xuICAgICAgdGhpcy5zZXQoJ2RhdGFWaWV3JywgZGF0YSk7XG4gICAgICBkYXRhID0gZGF0YS5yb3dzO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdkYXRhJywgZGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLl9vblZpZXdDaGFuZ2UgPSBmdW5jdGlvbiBfb25WaWV3Q2hhbmdlKCkge1xuICAgIHRoaXMuZW1pdCgnYmVmb3JlY2hhbmdlZGF0YScpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZ2V0KCdkYXRhVmlldycpO1xuICAgIHZhciByb3dzID0gZGF0YVZpZXcucm93cztcbiAgICB0aGlzLnNldCgnZGF0YScsIHJvd3MpO1xuICAgIHRoaXMuZW1pdCgnYWZ0ZXJjaGFuZ2VkYXRhJyk7XG4gICAgdGhpcy5yZXBhaW50KCk7XG4gIH07IC8vIOWIneWni+WMluWQhOS4qiB2aWV3IOWSjOe7mOWItui+heWKqeWFg+e0oFxuXG5cbiAgX3Byb3RvLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlcigpIHtcbiAgICB2YXIgdmlld3MgPSB0aGlzLmdldCgndmlld3MnKTsgLy8g5aaC5p6c5a2Y5ZyoIHZpZXdzIOWImeWIneWni+WMluWtkCB2aWV3IOeahOaWueazlVxuXG4gICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgdmlldy5iZWZvcmVSZW5kZXIoKTtcbiAgICB9KTtcbiAgICB0aGlzLmluaXRWaWV3KCk7XG4gIH07IC8vIOe7mOWItuWdkOagh+i9tOOAgeWbvuS+i+OAgei+heWKqeWFg+e0oOetieWbvuihqOe7hOS7tlxuXG5cbiAgX3Byb3RvLmRyYXdDb21wb25lbnRzID0gZnVuY3Rpb24gZHJhd0NvbXBvbmVudHMoKSB7XG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXQoJ3ZpZXdzJyk7IC8vIOWmguaenOWtmOWcqCB2aWV3cyDliJnliJ3lp4vljJblrZAgdmlldyDnmoTmlrnms5VcblxuICAgIFV0aWwuZWFjaCh2aWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZpZXcuZHJhd0NvbXBvbmVudHMoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlbmRlckF4ZXMoKTtcblxuICAgIHRoaXMuX3JlbmRlckd1aWRlcygpO1xuICB9OyAvLyDnu5jliLblm77lvaJcblxuXG4gIF9wcm90by5kcmF3Q2FudmFzID0gZnVuY3Rpb24gZHJhd0NhbnZhcyhzdG9wRHJhdykge1xuICAgIGlmICghc3RvcERyYXcpIHtcbiAgICAgIHZhciB2aWV3cyA9IHRoaXMuZ2V0KCd2aWV3cycpO1xuICAgICAgdmFyIGJhY2tQbG90ID0gdGhpcy5nZXQoJ2JhY2tQbG90Jyk7XG4gICAgICBiYWNrUGxvdC5zb3J0KCk7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgICAgdmFyIGFuaW1hdGUgPSB0aGlzLmdldCgnYW5pbWF0ZScpO1xuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICB2YXIgaXNVcGRhdGUgPSB0aGlzLmdldCgnaXNVcGRhdGUnKTtcbiAgICAgICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgIEFuaW1hdGUuZXhlY0FuaW1hdGlvbih2aWV3LCBpc1VwZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBBbmltYXRlLmV4ZWNBbmltYXRpb24odGhpcywgaXNVcGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzdG9wRHJhdykge1xuICAgIHRoaXMuY2xlYXJJbm5lcigpO1xuICAgIHRoaXMuZW1pdCgnYmVmb3JlcmVuZGVyJyk7XG4gICAgdGhpcy5iZWZvcmVSZW5kZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZXBhaW50Jyk7XG4gICAgdGhpcy5kcmF3Q29tcG9uZW50cygpO1xuICAgIHRoaXMucGFpbnQoKTtcbiAgICB0aGlzLmVtaXQoJ2FmdGVycGFpbnQnKTtcbiAgICB0aGlzLmRyYXdDYW52YXMoc3RvcERyYXcpO1xuICAgIHRoaXMuZW1pdCgnYWZ0ZXJyZW5kZXInKTtcbiAgICB0aGlzLnNldCgncmVuZGVyZWQnLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaW5pdFZpZXcgPSBmdW5jdGlvbiBpbml0VmlldygpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0KCdkYXRhJykgfHwgW107XG4gICAgdmFyIGZpbHRlcmVkRGF0YSA9IHRoaXMuZXhlY0ZpbHRlcihkYXRhKTtcbiAgICB0aGlzLnNldCgnZmlsdGVyZWREYXRhJywgZmlsdGVyZWREYXRhKTsgLy8gaWYgKCFVdGlsLmlzRW1wdHkoZGF0YSkpIHtcblxuICAgIHRoaXMuX2NyZWF0ZUNvb3JkKCk7IC8vIGRyYXcgZ2VvbWV0cnkg5YmN57uY5Yi25Yy65Z+f5Y+v6IO95Lya5Y+R55Sf5pS55Y+YXG5cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlaW5pdGdlb21zJyk7XG5cbiAgICB0aGlzLl9pbml0R2VvbXMoKTtcblxuICAgIHRoaXMuX2FkanVzdFNjYWxlKCk7IC8vIH1cblxuICB9O1xuXG4gIF9wcm90by5wYWludCA9IGZ1bmN0aW9uIHBhaW50KCkge1xuICAgIHZhciB2aWV3cyA9IHRoaXMuZ2V0KCd2aWV3cycpOyAvLyDnu5jliLZcblxuICAgIFV0aWwuZWFjaCh2aWV3cywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIHZpZXcucGFpbnQoKTtcbiAgICB9KTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0KCdkYXRhJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNFbXB0eShkYXRhKSkge1xuICAgICAgdGhpcy5fZHJhd0dlb21zKCk7XG4gICAgfSAvLyDlpoLmnpwgdmlldyDpmpDol4/kuobvvIzpmpDol4/miYDmnInnmoTlm77lvaLlkozlnZDmoIfovbRcblxuXG4gICAgaWYgKCF0aGlzLmdldCgndmlzaWJsZScpKSB7XG4gICAgICB0aGlzLmNoYW5nZVZpc2libGUoZmFsc2UsIHRydWUpOyAvLyDpmpDol4/miYDmnInnmoTlm77lvaLvvIzkvYbmmK/kuI3nu5jliLZcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNoYW5nZVZpc2libGUgPSBmdW5jdGlvbiBjaGFuZ2VWaXNpYmxlKHZpc2libGUsIHN0b3BEcmF3KSB7XG4gICAgdmFyIGdlb21zID0gdGhpcy5nZXQoJ2dlb21zJyk7XG4gICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgLy8gaWYgKGdlb20uZ2V0KCd2aXNpYmxlJykpIHsgLy8gZ2VvbSDpmpDol4/ml7bkuI3lj5dcbiAgICAgIGdlb20uY2hhbmdlVmlzaWJsZSh2aXNpYmxlLCB0cnVlKTsgLy8gfVxuICAgIH0pO1xuICAgIHRoaXMuZ2V0KCdheGlzQ29udHJvbGxlcicpICYmIHRoaXMuZ2V0KCdheGlzQ29udHJvbGxlcicpLmNoYW5nZVZpc2libGUodmlzaWJsZSk7XG4gICAgdGhpcy5nZXQoJ2d1aWRlQ29udHJvbGxlcicpICYmIHRoaXMuZ2V0KCdndWlkZUNvbnRyb2xsZXInKS5jaGFuZ2VWaXNpYmxlKHZpc2libGUpO1xuXG4gICAgaWYgKCFzdG9wRHJhdykge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy5kcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXBhaW50ID0gZnVuY3Rpb24gcmVwYWludCgpIHtcbiAgICB0aGlzLnNldCgnaXNVcGRhdGUnLCB0cnVlKTtcbiAgICB0aGlzLmNsZWFySW5uZXIoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGVhckV2ZW50cygpO1xuXG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5nZXQoJ2RhdGFWaWV3Jyk7XG4gICAgZGF0YVZpZXcgJiYgZGF0YVZpZXcub2ZmKCdjaGFuZ2UnLCBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnX29uVmlld0NoYW5nZScpKTtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICBfQmFzZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBWaWV3O1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuXG4vKioqLyB9KSxcbi8qIDI5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG52YXIgUG9zaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvc2l0aW9uLCBfQmFzZSk7XG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZS5jYWxsKHRoaXMsIGNmZykgfHwgdGhpcztcbiAgICBfdGhpcy5uYW1lcyA9IFsneCcsICd5J107XG4gICAgX3RoaXMudHlwZSA9ICdwb3NpdGlvbic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubWFwcGluZyA9IGZ1bmN0aW9uIG1hcHBpbmcoeCwgeSkge1xuICAgIHZhciBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICB2YXIgY29vcmQgPSB0aGlzLmNvb3JkO1xuICAgIHZhciBzY2FsZVggPSBzY2FsZXNbMF07XG4gICAgdmFyIHNjYWxlWSA9IHNjYWxlc1sxXTtcbiAgICB2YXIgcnN0WDtcbiAgICB2YXIgcnN0WTtcbiAgICB2YXIgb2JqO1xuXG4gICAgaWYgKGlzTmlsKHgpIHx8IGlzTmlsKHkpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoeSkgJiYgaXNBcnJheSh4KSkge1xuICAgICAgcnN0WCA9IFtdO1xuICAgICAgcnN0WSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDAsIHhMZW4gPSB4Lmxlbmd0aCwgeUxlbiA9IHkubGVuZ3RoOyBpIDwgeExlbiAmJiBqIDwgeUxlbjsgaSsrLCBqKyspIHtcbiAgICAgICAgb2JqID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgICAgICB4OiBzY2FsZVguc2NhbGUoeFtpXSksXG4gICAgICAgICAgeTogc2NhbGVZLnNjYWxlKHlbal0pXG4gICAgICAgIH0pO1xuICAgICAgICByc3RYLnB1c2gob2JqLngpO1xuICAgICAgICByc3RZLnB1c2gob2JqLnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh5KSkge1xuICAgICAgeCA9IHNjYWxlWC5zY2FsZSh4KTtcbiAgICAgIHJzdFkgPSBbXTtcbiAgICAgIGVhY2goeSwgZnVuY3Rpb24gKHlWYWwpIHtcbiAgICAgICAgeVZhbCA9IHNjYWxlWS5zY2FsZSh5VmFsKTtcbiAgICAgICAgb2JqID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlWYWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJzdFggJiYgcnN0WCAhPT0gb2JqLngpIHtcbiAgICAgICAgICBpZiAoIWlzQXJyYXkocnN0WCkpIHtcbiAgICAgICAgICAgIHJzdFggPSBbcnN0WF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcnN0WC5wdXNoKG9iai54KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByc3RYID0gb2JqLng7XG4gICAgICAgIH1cblxuICAgICAgICByc3RZLnB1c2gob2JqLnkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICB5ID0gc2NhbGVZLnNjYWxlKHkpO1xuICAgICAgcnN0WCA9IFtdO1xuICAgICAgZWFjaCh4LCBmdW5jdGlvbiAoeFZhbCkge1xuICAgICAgICB4VmFsID0gc2NhbGVYLnNjYWxlKHhWYWwpO1xuICAgICAgICBvYmogPSBjb29yZC5jb252ZXJ0UG9pbnQoe1xuICAgICAgICAgIHg6IHhWYWwsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocnN0WSAmJiByc3RZICE9PSBvYmoueSkge1xuICAgICAgICAgIGlmICghaXNBcnJheShyc3RZKSkge1xuICAgICAgICAgICAgcnN0WSA9IFtyc3RZXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByc3RZLnB1c2gob2JqLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzdFkgPSBvYmoueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJzdFgucHVzaChvYmoueCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHNjYWxlWC5zY2FsZSh4KTtcbiAgICAgIHkgPSBzY2FsZVkuc2NhbGUoeSk7XG4gICAgICB2YXIgcG9pbnQgPSBjb29yZC5jb252ZXJ0UG9pbnQoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHJzdFggPSBwb2ludC54O1xuICAgICAgcnN0WSA9IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyc3RYLCByc3RZXTtcbiAgfTtcblxuICByZXR1cm4gUG9zaXRpb247XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDI5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgQ29sb3JVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDkpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG52YXIgQ29sb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbG9yLCBfQmFzZSk7XG5cbiAgZnVuY3Rpb24gQ29sb3IoY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZS5jYWxsKHRoaXMsIGNmZykgfHwgdGhpcztcbiAgICBfdGhpcy5uYW1lcyA9IFsnY29sb3InXTtcbiAgICBfdGhpcy50eXBlID0gJ2NvbG9yJztcbiAgICBfdGhpcy5ncmFkaWVudCA9IG51bGw7XG5cbiAgICBpZiAoaXNTdHJpbmcoX3RoaXMudmFsdWVzKSkge1xuICAgICAgX3RoaXMubGluZWFyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBDb2xvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldExpbmVhclZhbHVlID0gZnVuY3Rpb24gZ2V0TGluZWFyVmFsdWUocGVyY2VudCkge1xuICAgIHZhciBncmFkaWVudCA9IHRoaXMuZ3JhZGllbnQ7XG5cbiAgICBpZiAoIWdyYWRpZW50KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICBncmFkaWVudCA9IENvbG9yVXRpbC5ncmFkaWVudCh2YWx1ZXMpO1xuICAgICAgdGhpcy5ncmFkaWVudCA9IGdyYWRpZW50O1xuICAgIH1cblxuICAgIHJldHVybiBncmFkaWVudChwZXJjZW50KTtcbiAgfTtcblxuICByZXR1cm4gQ29sb3I7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuXG4vKioqLyB9KSxcbi8qIDI5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBTaGFwZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2hhcGUsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBTaGFwZShjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIF90aGlzLm5hbWVzID0gWydzaGFwZSddO1xuICAgIF90aGlzLnR5cGUgPSAnc2hhcGUnO1xuICAgIF90aGlzLmdyYWRpZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTaGFwZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldExpbmVhclZhbHVlID0gZnVuY3Rpb24gZ2V0TGluZWFyVmFsdWUocGVyY2VudCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwZXJjZW50KTtcbiAgICByZXR1cm4gdmFsdWVzW2luZGV4XTtcbiAgfTtcblxuICByZXR1cm4gU2hhcGU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuXG4vKioqLyB9KSxcbi8qIDI5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBTaXplID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShTaXplLCBfQmFzZSk7XG5cbiAgZnVuY3Rpb24gU2l6ZShjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIF90aGlzLm5hbWVzID0gWydzaXplJ107XG4gICAgX3RoaXMudHlwZSA9ICdzaXplJztcbiAgICBfdGhpcy5ncmFkaWVudCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNpemU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpemU7XG5cbi8qKiovIH0pLFxuLyogMjk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxudmFyIE9wYWNpdHkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKE9wYWNpdHksIF9CYXNlKTtcblxuICBmdW5jdGlvbiBPcGFjaXR5KGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgX3RoaXMubmFtZXMgPSBbJ29wYWNpdHknXTtcbiAgICBfdGhpcy50eXBlID0gJ29wYWNpdHknO1xuICAgIF90aGlzLmdyYWRpZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gT3BhY2l0eTtcbn0oQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3BhY2l0eTtcblxuLyoqKi8gfSksXG4vKiAyOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8g5a6M5pW054mI5LiL5L2/55So5pSv5oyB5oyJ54Wn5p+Q5Liq5a2X5q616L+b6KGM5YiG57uE55qEIGRvZGdlXG52YXIgbWl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEFkanVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuXG52YXIgRG9kZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5OCk7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oMjk5KTtcblxudmFyIEFkanVzdE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTApO1xuXG52YXIgRG9kZ2VNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzAwKTtcblxudmFyIFN0YWNrTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMSk7XG5cbm1peChBZGp1c3QucHJvdG90eXBlLCBBZGp1c3RNaXhpbik7XG5taXgoRG9kZ2UucHJvdG90eXBlLCBBZGp1c3RNaXhpbiwgRG9kZ2VNaXhpbik7XG5taXgoU3RhY2sucHJvdG90eXBlLCBTdGFja01peGluKTtcbkFkanVzdC5KaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMik7XG5BZGp1c3QuU3ltbWV0cmljID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDMpO1xuQWRqdXN0LkRvZGdlID0gRG9kZ2U7XG5BZGp1c3QuU3RhY2sgPSBTdGFjaztcbm1vZHVsZS5leHBvcnRzID0gQWRqdXN0O1xuXG4vKioqLyB9KSxcbi8qIDI5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBBZGp1c3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgTUFSR0lOX1JBVElPID0gMSAvIDI7XG52YXIgRE9ER0VfUkFUSU8gPSAxIC8gMjtcblxudmFyIERvZGdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQWRqdXN0KSB7XG4gIF9pbmhlcml0c0xvb3NlKERvZGdlLCBfQWRqdXN0KTtcblxuICBmdW5jdGlvbiBEb2RnZSgpIHtcbiAgICByZXR1cm4gX0FkanVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRG9kZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgLyoqXG4gICAgICog6LCD5pW06L+H56iL5LitLDLkuKrmlbDmja7nmoTpl7Tot51cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWFyZ2luUmF0aW8gPSBNQVJHSU5fUkFUSU87XG4gICAgLyoqXG4gICAgICog6LCD5pW05Y2g5Y2V5L2N5a695bqm55qE5q+U5L6LLOS+i+Wmgu+8muWNoDLkuKrliIbnsbvpl7Tot53nmoQgMS8yXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZG9kZ2VSYXRpbyA9IERPREdFX1JBVElPO1xuICAgIHRoaXMuYWRqdXN0TmFtZXMgPSBbJ3gnLCAneSddOyAvLyDosIPmlbTnmoTnu7TluqbvvIzpu5jorqQseCx56YO95YGa6LCD5pW0XG4gIH07XG5cbiAgX3Byb3RvLmdldERvZGdlT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RG9kZ2VPZmZzZXQocmFuZ2UsIGluZGV4LCBjb3VudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJlID0gcmFuZ2UucHJlO1xuICAgIHZhciBuZXh0ID0gcmFuZ2UubmV4dDtcbiAgICB2YXIgdGlja0xlbmd0aCA9IG5leHQgLSBwcmU7XG4gICAgdmFyIHdpZHRoID0gdGlja0xlbmd0aCAqIHNlbGYuZG9kZ2VSYXRpbyAvIGNvdW50O1xuICAgIHZhciBtYXJnaW4gPSBzZWxmLm1hcmdpblJhdGlvICogd2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IDEgLyAyICogKHRpY2tMZW5ndGggLSBjb3VudCAqIHdpZHRoIC0gKGNvdW50IC0gMSkgKiBtYXJnaW4pICsgKChpbmRleCArIDEpICogd2lkdGggKyBpbmRleCAqIG1hcmdpbikgLSAxIC8gMiAqIHdpZHRoIC0gMSAvIDIgKiB0aWNrTGVuZ3RoO1xuICAgIHJldHVybiAocHJlICsgbmV4dCkgLyAyICsgb2Zmc2V0O1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzQWRqdXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0FkanVzdChkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvdW50ID0gZGF0YUFycmF5Lmxlbmd0aDtcbiAgICB2YXIgeEZpZWxkID0gc2VsZi54RmllbGQ7XG4gICAgZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialt4RmllbGRdO1xuICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgcHJlOiB2YWx1ZSAtIDAuNSxcbiAgICAgICAgICBuZXh0OiB2YWx1ZSArIDAuNVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZG9kZ2VWYWx1ZSA9IHNlbGYuZ2V0RG9kZ2VPZmZzZXQocmFuZ2UsIGluZGV4LCBjb3VudCk7XG4gICAgICAgIG9ialt4RmllbGRdID0gZG9kZ2VWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRG9kZ2U7XG59KEFkanVzdCk7XG5cbkFkanVzdC5Eb2RnZSA9IERvZGdlO1xubW9kdWxlLmV4cG9ydHMgPSBEb2RnZTtcblxuLyoqKi8gfSksXG4vKiAyOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBBZGp1c3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxudmFyIFN0YWNrID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQWRqdXN0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0YWNrLCBfQWRqdXN0KTtcblxuICBmdW5jdGlvbiBTdGFjaygpIHtcbiAgICByZXR1cm4gX0FkanVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RhY2sucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy54RmllbGQgPSBudWxsOyAvLyDosIPmlbTlr7nlupTnmoQgeCDmlrnlkJHlr7nlupTnmoTlrZfmrrXlkI3np7BcblxuICAgIHRoaXMueUZpZWxkID0gbnVsbDsgLy8g6LCD5pW05a+55bqU55qEIHkg5pa55ZCR5a+55bqU55qE5a2X5q615ZCN56ewXG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3NBZGp1c3QgPSBmdW5jdGlvbiBwcm9jZXNzQWRqdXN0KGRhdGFBcnJheSkge1xuICAgIHRoaXMucHJvY2Vzc1N0YWNrKGRhdGFBcnJheSk7XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3NTdGFjayA9IGZ1bmN0aW9uIHByb2Nlc3NTdGFjayhkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHhGaWVsZCA9IHNlbGYueEZpZWxkO1xuICAgIHZhciB5RmllbGQgPSBzZWxmLnlGaWVsZDtcbiAgICB2YXIgY291bnQgPSBkYXRhQXJyYXkubGVuZ3RoO1xuICAgIHZhciBzdGFja0NhY2hlID0ge1xuICAgICAgcG9zaXRpdmU6IHt9LFxuICAgICAgbmVnYXRpdmU6IHt9XG4gICAgfTsgLy8g5bGC5Y+g6aG65bqP57+76L2sXG5cbiAgICBpZiAoc2VsZi5yZXZlcnNlT3JkZXIpIHtcbiAgICAgIGRhdGFBcnJheSA9IGRhdGFBcnJheS5zbGljZSgwKS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFBcnJheVtpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBkYXRhW2pdO1xuICAgICAgICB2YXIgeCA9IGl0ZW1beEZpZWxkXSB8fCAwO1xuICAgICAgICB2YXIgeSA9IGl0ZW1beUZpZWxkXTtcbiAgICAgICAgdmFyIHhrZXkgPSB4LnRvU3RyaW5nKCk7XG4gICAgICAgIHkgPSBpc0FycmF5KHkpID8geVsxXSA6IHk7XG5cbiAgICAgICAgaWYgKCFpc05pbCh5KSkge1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB5ID49IDAgPyAncG9zaXRpdmUnIDogJ25lZ2F0aXZlJztcblxuICAgICAgICAgIGlmICghc3RhY2tDYWNoZVtkaXJlY3Rpb25dW3hrZXldKSB7XG4gICAgICAgICAgICBzdGFja0NhY2hlW2RpcmVjdGlvbl1beGtleV0gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZW1beUZpZWxkXSA9IFtzdGFja0NhY2hlW2RpcmVjdGlvbl1beGtleV0sIHkgKyBzdGFja0NhY2hlW2RpcmVjdGlvbl1beGtleV1dO1xuICAgICAgICAgIHN0YWNrQ2FjaGVbZGlyZWN0aW9uXVt4a2V5XSArPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdGFjaztcbn0oQWRqdXN0KTtcblxuQWRqdXN0LlN0YWNrID0gU3RhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG4vKioqLyB9KSxcbi8qIDMwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgQXJyYXlVdGlsID0ge1xuICBtZXJnZTogX193ZWJwYWNrX3JlcXVpcmVfXyg0MiksXG4gIHZhbHVlczogX193ZWJwYWNrX3JlcXVpcmVfXyg2NClcbn07XG5cbnZhciBncm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0KTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBwcm9jZXNzQWRqdXN0OiBmdW5jdGlvbiBwcm9jZXNzQWRqdXN0KGRhdGFBcnJheSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWVyZ2VEYXRhID0gQXJyYXlVdGlsLm1lcmdlKGRhdGFBcnJheSk7XG4gICAgdmFyIGRvZGdlRGltID0gc2VsZi5kb2RnZUJ5O1xuICAgIHZhciBhZGpEYXRhQXJyYXkgPSBkYXRhQXJyYXk7XG5cbiAgICBpZiAoZG9kZ2VEaW0pIHtcbiAgICAgIC8vIOWmguaenOaMh+WumuS6huWIhue7hGRpbeeahOWtl+autVxuICAgICAgYWRqRGF0YUFycmF5ID0gZ3JvdXAobWVyZ2VEYXRhLCBkb2RnZURpbSk7XG4gICAgfVxuXG4gICAgc2VsZi5jYWNoZU1hcCA9IHt9O1xuICAgIHNlbGYuYWRqRGF0YUFycmF5ID0gYWRqRGF0YUFycmF5O1xuICAgIHNlbGYubWVyZ2VEYXRhID0gbWVyZ2VEYXRhO1xuICAgIHNlbGYuYWRqdXN0RGF0YShhZGpEYXRhQXJyYXksIG1lcmdlRGF0YSk7XG4gICAgc2VsZi5hZGpEYXRhQXJyYXkgPSBudWxsO1xuICAgIHNlbGYubWVyZ2VEYXRhID0gbnVsbDtcbiAgfSxcbiAgZ2V0RGlzdHJpYnV0aW9uOiBmdW5jdGlvbiBnZXREaXN0cmlidXRpb24oZGltKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhQXJyYXkgPSBzZWxmLmFkakRhdGFBcnJheTtcbiAgICB2YXIgY2FjaGVNYXAgPSBzZWxmLmNhY2hlTWFwO1xuICAgIHZhciBtYXAgPSBjYWNoZU1hcFtkaW1dO1xuXG4gICAgaWYgKCFtYXApIHtcbiAgICAgIG1hcCA9IHt9O1xuICAgICAgZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gQXJyYXlVdGlsLnZhbHVlcyhkYXRhLCBkaW0pO1xuXG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBpZiAoIW1hcFt2YWxdKSB7XG4gICAgICAgICAgICBtYXBbdmFsXSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcFt2YWxdLnB1c2goaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2FjaGVNYXBbZGltXSA9IG1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9LFxuICBhZGp1c3REaW06IGZ1bmN0aW9uIGFkanVzdERpbShkaW0sIHZhbHVlcywgZGF0YSwgZnJhbWVDb3VudCwgZnJhbWVJbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWFwID0gc2VsZi5nZXREaXN0cmlidXRpb24oZGltKTtcbiAgICB2YXIgZ3JvdXBEYXRhID0gc2VsZi5ncm91cERhdGEoZGF0YSwgZGltKTsgLy8g5qC55o2u5YC85YiG57uEXG5cbiAgICBlYWNoKGdyb3VwRGF0YSwgZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgIGtleSA9IHBhcnNlRmxvYXQoa2V5KTtcbiAgICAgIHZhciByYW5nZTtcblxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgcHJlOiB2YWx1ZXNbMF0gLSAxLFxuICAgICAgICAgIG5leHQ6IHZhbHVlc1swXSArIDFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gc2VsZi5nZXRBZGp1c3RSYW5nZShkaW0sIGtleSwgdmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgZWFjaChncm91cCwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSByZWNvcmRbZGltXTtcbiAgICAgICAgdmFyIHZhbHVlQXJyID0gbWFwW3ZhbHVlXTtcbiAgICAgICAgdmFyIHZhbEluZGV4ID0gdmFsdWVBcnIuaW5kZXhPZihmcmFtZUluZGV4KTtcbiAgICAgICAgcmVjb3JkW2RpbV0gPSBzZWxmLmdldERvZGdlT2Zmc2V0KHJhbmdlLCB2YWxJbmRleCwgdmFsdWVBcnIubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDMwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgX2luaXREZWZhdWx0Q2ZnOiBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy54RmllbGQgPSBudWxsOyAvLyDosIPmlbTlr7nlupTnmoQgeCDmlrnlkJHlr7nlupTnmoTlrZfmrrXlkI3np7BcblxuICAgIHRoaXMueUZpZWxkID0gbnVsbDsgLy8g6LCD5pW05a+55bqU55qEIHkg5pa55ZCR5a+55bqU55qE5a2X5q615ZCN56ewXG5cbiAgICB0aGlzLmhlaWdodCA9IG51bGw7IC8vIOS7heacieS4gOS4que7tOW6puiwg+aVtOaXtu+8jOaAu+eahOmrmOW6plxuXG4gICAgdGhpcy5zaXplID0gMTA7IC8vIOWNleS4queCueeahOWkp+Wwj1xuXG4gICAgdGhpcy5yZXZlcnNlT3JkZXIgPSBmYWxzZTsgLy8g5piv5ZCm5Y+N5bqP6L+b6KGM5bGC5Y+gXG5cbiAgICB0aGlzLmFkanVzdE5hbWVzID0gWyd5J107IC8vIE9ubHkgc3VwcG9ydCBzdGFjayB5XG4gIH0sXG4gIHByb2Nlc3NPbmVEaW1TdGFjazogZnVuY3Rpb24gcHJvY2Vzc09uZURpbVN0YWNrKGRhdGFBcnJheSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgeEZpZWxkID0gc2VsZi54RmllbGQ7XG4gICAgdmFyIHlGaWVsZCA9IHNlbGYueUZpZWxkIHx8ICd5JztcbiAgICB2YXIgaGVpZ2h0ID0gc2VsZi5oZWlnaHQ7XG4gICAgdmFyIHN0YWNrWSA9IHt9OyAvLyDlpoLmnpzlsYLlj6DnmoTpobrluo/nv7vovaxcblxuICAgIGlmIChzZWxmLnJldmVyc2VPcmRlcikge1xuICAgICAgZGF0YUFycmF5ID0gZGF0YUFycmF5LnNsaWNlKDApLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFBcnJheVtpXTsgLy8gY2F0ZXNcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgICB2YXIgaXRlbSA9IGRhdGFbal07XG4gICAgICAgIHZhciBzaXplID0gaXRlbS5zaXplIHx8IHNlbGYuc2l6ZTtcbiAgICAgICAgdmFyIHN0YWNrSGVpZ2h0ID0gc2l6ZSAqIDIgLyBoZWlnaHQ7XG4gICAgICAgIHZhciB4ID0gaXRlbVt4RmllbGRdO1xuXG4gICAgICAgIGlmICghc3RhY2tZW3hdKSB7XG4gICAgICAgICAgc3RhY2tZW3hdID0gc3RhY2tIZWlnaHQgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbVt5RmllbGRdID0gc3RhY2tZW3hdO1xuICAgICAgICBzdGFja1lbeF0gKz0gc3RhY2tIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9jZXNzQWRqdXN0OiBmdW5jdGlvbiBwcm9jZXNzQWRqdXN0KGRhdGFBcnJheSkge1xuICAgIGlmICh0aGlzLnlGaWVsZCkge1xuICAgICAgdGhpcy5wcm9jZXNzU3RhY2soZGF0YUFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9jZXNzT25lRGltU3RhY2soZGF0YUFycmF5KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgbWl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEFycmF5VXRpbCA9IHtcbiAgbWVyZ2U6IF9fd2VicGFja19yZXF1aXJlX18oNDIpXG59O1xuXG52YXIgQWRqdXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbnZhciBBZGp1c3RNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUwKTtcblxudmFyIEppdHRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0FkanVzdCkge1xuICBfaW5oZXJpdHNMb29zZShKaXR0ZXIsIF9BZGp1c3QpO1xuXG4gIGZ1bmN0aW9uIEppdHRlcigpIHtcbiAgICByZXR1cm4gX0FkanVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSml0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIHRoaXMueEZpZWxkID0gbnVsbDsgLy8g6LCD5pW05a+55bqU55qEIHgg5pa55ZCR5a+55bqU55qE5a2X5q615ZCN56ewXG5cbiAgICB0aGlzLnlGaWVsZCA9IG51bGw7IC8vIOiwg+aVtOWvueW6lOeahCB5IOaWueWQkeWvueW6lOeahOWtl+auteWQjeensFxuXG4gICAgdGhpcy5hZGp1c3ROYW1lcyA9IFsneCcsICd5J107IC8vIOaMh3gseVxuXG4gICAgdGhpcy5ncm91cEZpZWxkcyA9IG51bGw7IC8vIOWPguS4juWIhue7hOeahOaVsOaNrue7tOW6plxuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzQWRqdXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0FkanVzdChkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1lcmdlRGF0YSA9IEFycmF5VXRpbC5tZXJnZShkYXRhQXJyYXkpO1xuICAgIHNlbGYuYWRqRGF0YUFycmF5ID0gZGF0YUFycmF5O1xuICAgIHNlbGYubWVyZ2VEYXRhID0gbWVyZ2VEYXRhO1xuICAgIHNlbGYuYWRqdXN0RGF0YShkYXRhQXJyYXksIG1lcmdlRGF0YSk7XG4gICAgc2VsZi5hZGpGcmFtZXMgPSBudWxsO1xuICAgIHNlbGYubWVyZ2VEYXRhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QWRqdXN0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0QWRqdXN0T2Zmc2V0KHByZSwgbmV4dCkge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKTsgLy8g6ZqP5py65L2N572u77yM5Z2H5YyA5YiG5biDXG5cbiAgICB2YXIgYXZnID0gbmV4dCAtIHByZTsgLy8gKiBsZW5ndGhcblxuICAgIHZhciBhcHBlbmQgPSBhdmcgKiAwLjA1O1xuICAgIHJldHVybiBwcmUgKyBhcHBlbmQgKyBhdmcgKiAwLjkgKiByO1xuICB9OyAvLyBhZGp1c3QgZ3JvdXAgZGF0YVxuXG5cbiAgX3Byb3RvLl9hZGp1c3RHcm91cCA9IGZ1bmN0aW9uIF9hZGp1c3RHcm91cChncm91cCwgZGltLCBrZXksIHZhbHVlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmFuZ2UgPSBzZWxmLmdldEFkanVzdFJhbmdlKGRpbSwga2V5LCB2YWx1ZXMpO1xuICAgIGVhY2goZ3JvdXAsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgIHJlY29yZFtkaW1dID0gc2VsZi5nZXRBZGp1c3RPZmZzZXQocmFuZ2UucHJlLCByYW5nZS5uZXh0KTsgLy8g6I635Y+W6LCD5pW055qE5L2N572uXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdERpbSA9IGZ1bmN0aW9uIGFkanVzdERpbShkaW0sIHZhbHVlcywgZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ3JvdXBEYXRhID0gc2VsZi5ncm91cERhdGEoZGF0YSwgZGltKTtcbiAgICBlYWNoKGdyb3VwRGF0YSwgZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgIGtleSA9IHBhcnNlRmxvYXQoa2V5KTtcblxuICAgICAgc2VsZi5fYWRqdXN0R3JvdXAoZ3JvdXAsIGRpbSwga2V5LCB2YWx1ZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBKaXR0ZXI7XG59KEFkanVzdCk7XG5cbm1peChKaXR0ZXIucHJvdG90eXBlLCBBZGp1c3RNaXhpbik7XG5BZGp1c3QuSml0dGVyID0gSml0dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBKaXR0ZXI7XG5cbi8qKiovIH0pLFxuLyogMzAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgbWF4QnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEFycmF5VXRpbCA9IHtcbiAgbWVyZ2U6IF9fd2VicGFja19yZXF1aXJlX18oNDIpXG59O1xuXG52YXIgQWRqdXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbnZhciBTeW1tZXRyaWMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BZGp1c3QpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3ltbWV0cmljLCBfQWRqdXN0KTtcblxuICBmdW5jdGlvbiBTeW1tZXRyaWMoKSB7XG4gICAgcmV0dXJuIF9BZGp1c3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN5bW1ldHJpYy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENmZygpIHtcbiAgICB0aGlzLnhGaWVsZCA9IG51bGw7IC8vIOiwg+aVtOWvueW6lOeahCB4IOaWueWQkeWvueW6lOeahOWtl+auteWQjeensFxuXG4gICAgdGhpcy55RmllbGQgPSBudWxsOyAvLyDosIPmlbTlr7nlupTnmoQgeSDmlrnlkJHlr7nlupTnmoTlrZfmrrXlkI3np7BcblxuICAgIHRoaXMuY2FjaGVNYXggPSBudWxsOyAvLyDnvJPlrZjnmoTmnIDlpKflgLxcblxuICAgIHRoaXMuYWRqdXN0TmFtZXMgPSBbJ3knXTsgLy8gT25seSBzdXBwb3J0IHN0YWNrIHlcblxuICAgIHRoaXMuZ3JvdXBGaWVsZHMgPSBudWxsOyAvLyDlj4LkuI7liIbnu4TnmoTmlbDmja7nu7TluqZcbiAgfTsgLy8g6I635Y+W5pyA5aSn55qEeeWAvFxuXG5cbiAgX3Byb3RvLl9nZXRNYXggPSBmdW5jdGlvbiBfZ2V0TWF4KGRpbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWVyZ2VEYXRhID0gc2VsZi5tZXJnZURhdGE7XG4gICAgdmFyIG1heFJlY29yZCA9IG1heEJ5KG1lcmdlRGF0YSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2RpbV07XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgdmFyIG1heFZhbHVlID0gbWF4UmVjb3JkW2RpbV07XG4gICAgdmFyIG1heCA9IGlzQXJyYXkobWF4VmFsdWUpID8gTWF0aC5tYXguYXBwbHkobnVsbCwgbWF4VmFsdWUpIDogbWF4VmFsdWU7XG4gICAgcmV0dXJuIG1heDtcbiAgfTsgLy8g6I635Y+W5q+P5Liq5a2X5q615pyA5aSn55qE5YC8XG5cblxuICBfcHJvdG8uX2dldFhWYWx1ZXNNYXggPSBmdW5jdGlvbiBfZ2V0WFZhbHVlc01heCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHlGaWVsZCA9IHNlbGYueUZpZWxkO1xuICAgIHZhciB4RmllbGQgPSBzZWxmLnhGaWVsZDtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICB2YXIgbWVyZ2VEYXRhID0gc2VsZi5tZXJnZURhdGE7XG4gICAgZWFjaChtZXJnZURhdGEsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciB4VmFsdWUgPSBvYmpbeEZpZWxkXTtcbiAgICAgIHZhciB5VmFsdWUgPSBvYmpbeUZpZWxkXTtcbiAgICAgIHZhciBtYXggPSBpc0FycmF5KHlWYWx1ZSkgPyBNYXRoLm1heC5hcHBseShudWxsLCB5VmFsdWUpIDogeVZhbHVlO1xuICAgICAgY2FjaGVbeFZhbHVlXSA9IGNhY2hlW3hWYWx1ZV0gfHwgMDtcblxuICAgICAgaWYgKGNhY2hlW3hWYWx1ZV0gPCBtYXgpIHtcbiAgICAgICAgY2FjaGVbeFZhbHVlXSA9IG1heDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07IC8vIOWFpeWPo+WHveaVsFxuXG5cbiAgX3Byb3RvLnByb2Nlc3NBZGp1c3QgPSBmdW5jdGlvbiBwcm9jZXNzQWRqdXN0KGRhdGFBcnJheSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWVyZ2VEYXRhID0gQXJyYXlVdGlsLm1lcmdlKGRhdGFBcnJheSk7XG4gICAgc2VsZi5tZXJnZURhdGEgPSBtZXJnZURhdGE7XG5cbiAgICBzZWxmLl9wcm9jZXNzU3ltbWV0cmljKGRhdGFBcnJheSk7XG5cbiAgICBzZWxmLm1lcmdlRGF0YSA9IG51bGw7XG4gIH07IC8vIOWkhOeQhuWvueensFxuXG5cbiAgX3Byb3RvLl9wcm9jZXNzU3ltbWV0cmljID0gZnVuY3Rpb24gX3Byb2Nlc3NTeW1tZXRyaWMoZGF0YUFycmF5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB4RmllbGQgPSBzZWxmLnhGaWVsZDtcbiAgICB2YXIgeUZpZWxkID0gc2VsZi55RmllbGQ7XG5cbiAgICB2YXIgbWF4ID0gc2VsZi5fZ2V0TWF4KHlGaWVsZCk7XG5cbiAgICB2YXIgZmlyc3QgPSBkYXRhQXJyYXlbMF1bMF07XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgaWYgKGZpcnN0ICYmIGlzQXJyYXkoZmlyc3RbeUZpZWxkXSkpIHtcbiAgICAgIGNhY2hlID0gc2VsZi5fZ2V0WFZhbHVlc01heCgpO1xuICAgIH1cblxuICAgIGVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZWFjaChkYXRhLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialt5RmllbGRdO1xuICAgICAgICB2YXIgb2Zmc2V0O1xuXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhciB4VmFsdWUgPSBvYmpbeEZpZWxkXTtcbiAgICAgICAgICB2YXIgdmFsdWVNYXggPSBjYWNoZVt4VmFsdWVdO1xuICAgICAgICAgIG9mZnNldCA9IChtYXggLSB2YWx1ZU1heCkgLyAyO1xuICAgICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuICAgICAgICAgIGVhY2godmFsdWUsIGZ1bmN0aW9uIChzdWJWYWwpIHtcbiAgICAgICAgICAgIC8vIOWkmuS4quWtl+autVxuICAgICAgICAgICAgdG1wLnB1c2gob2Zmc2V0ICsgc3ViVmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgICAgb2JqW3lGaWVsZF0gPSB0bXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gKG1heCAtIHZhbHVlKSAvIDI7XG4gICAgICAgICAgb2JqW3lGaWVsZF0gPSBbb2Zmc2V0LCB2YWx1ZSArIG9mZnNldF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTeW1tZXRyaWM7XG59KEFkanVzdCk7XG5cbkFkanVzdC5TeW1tZXRyaWMgPSBTeW1tZXRyaWM7XG5tb2R1bGUuZXhwb3J0cyA9IFN5bW1ldHJpYztcblxuLyoqKi8gfSksXG4vKiAzMDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9odG1sLCBfdG9vbHRpcDtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEcyIDMuMCBkYXJrIHRoZW1lXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQmFzaWNUaGVtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTsgLy8gdG9vbHRpcCDnm7jlhbMgZG9tIOeahCBjc3Mg57G75ZCNXG5cblxudmFyIFRPT0xUSVBfQ09OVEFJTkVSX0NMQVNTID0gJ2cyLXRvb2x0aXAnO1xudmFyIExFR0VORF9DT05UQUlORVJfQ0xBU1MgPSAnZzItbGVnZW5kJztcbnZhciBEYXJrVGhlbWUgPSBVdGlsLmRlZXBNaXgoe30sIEJhc2ljVGhlbWUsIHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGZpbGw6ICcjMUYxRjFGJyxcbiAgICByYWRpdXM6IDJcbiAgfSxcbiAgLy8g5a655Zmo5Yy65Z+fXG4gIHBsb3RCYWNrZ3JvdW5kOiB7XG4gICAgZmlsbDogJyMxRjFGMUYnXG4gIH0sXG4gIC8vIOe7mOWbvuWMuuWfn1xuICBheGlzOiB7XG4gICAgdG9wOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBzdHJva2U6ICcjNzM3MzczJ1xuICAgICAgfVxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBzdHJva2U6ICcjNzM3MzczJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgZmlsbDogJyNBNkE2QTYnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBncmlkOiB7XG4gICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgIHN0cm9rZTogJyM0MDQwNDAnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlOiAnIzQwNDA0MCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2lyY2xlOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBzdHJva2U6ICcjNzM3MzczJ1xuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlOiAnIzQwNDA0MCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmFkaXVzOiB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBzdHJva2U6ICcjNzM3MzczJ1xuICAgICAgfSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgc3Ryb2tlOiAnIzQwNDA0MCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGVsaXg6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICBzdHJva2U6ICcjNzM3MzczJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbGFiZWw6IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGZpbGw6ICcjQTZBNkE2J1xuICAgIH1cbiAgfSxcbiAgbGVnZW5kOiB7XG4gICAgcmlnaHQ6IHtcbiAgICAgIHRleHRTdHlsZToge1xuICAgICAgICBmaWxsOiAnIzczNzM3MydcbiAgICAgIH0sXG4gICAgICB1bkNoZWNrQ29sb3I6ICcjYmZiZmJmJ1xuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjNzM3MzczJ1xuICAgICAgfSxcbiAgICAgIC8vIOWbvuS+i+mhueaWh+acrOeahOagt+W8j1xuICAgICAgdW5DaGVja0NvbG9yOiAnI2JmYmZiZidcbiAgICB9LFxuICAgIHRvcDoge1xuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjNzM3MzczJ1xuICAgICAgfSxcbiAgICAgIC8vIOWbvuS+i+mhueaWh+acrOeahOagt+W8j1xuICAgICAgdW5DaGVja0NvbG9yOiAnI2JmYmZiZidcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjNzM3MzczJ1xuICAgICAgfSxcbiAgICAgIC8vIOWbvuS+i+mhueaWh+acrOeahOagt+W8j1xuICAgICAgdW5DaGVja0NvbG9yOiAnI2JmYmZiZidcbiAgICB9LFxuICAgIGh0bWw6IChfaHRtbCA9IHt9LCBfaHRtbFtcIlwiICsgTEVHRU5EX0NPTlRBSU5FUl9DTEFTU10gPSB7XG4gICAgICBjb2xvcjogJyNEOUQ5RDknXG4gICAgfSwgX2h0bWwpLFxuICAgIGdyYWRpZW50OiB7XG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyNEOUQ5RDknXG4gICAgICB9LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogJyM0MDQwNDAnXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB0b29sdGlwOiAoX3Rvb2x0aXAgPSB7fSwgX3Rvb2x0aXBbXCJcIiArIFRPT0xUSVBfQ09OVEFJTkVSX0NMQVNTXSA9IHtcbiAgICBjb2xvcjogJyNEOUQ5RDknLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgYm94U2hhZG93OiAnMHB4IDBweCAycHggIzAwMCdcbiAgfSwgX3Rvb2x0aXApLFxuICB0b29sdGlwQ3Jvc3NoYWlyc1JlY3Q6IHtcbiAgICB0eXBlOiAncmVjdCcsXG4gICAgcmVjdFN0eWxlOiB7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBvcGFjaXR5OiAwLjFcbiAgICB9XG4gIH0sXG4gIC8vIHRvb2x0aXAg6L6F5Yqp6IOM5pmv5qGG5qC35byPXG4gIHRvb2x0aXBDcm9zc2hhaXJzTGluZToge1xuICAgIGxpbmVTdHlsZToge1xuICAgICAgc3Ryb2tlOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQ1KSdcbiAgICB9XG4gIH0sXG4gIGd1aWRlOiB7XG4gICAgbGluZToge1xuICAgICAgdGV4dDoge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZpbGw6ICcjQTZBNkE2J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiAnI0E2QTZBNidcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lvbjoge1xuICAgICAgLy8gVE9ET1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICAvLyDovoXliqnmoYbnmoTovrnmoYblrr3luqZcbiAgICAgICAgZmlsbDogJyMwMDAnLFxuICAgICAgICAvLyDovoXliqnmoYbloavlhYXnmoTpopzoibJcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMDQgLy8g6L6F5Yqp5qGG55qE6IOM5pmv6YCP5piO5bqmXG4gICAgICAgIC8vIOi+heWKqeahhueahOWbvuW9ouagt+W8j+WxnuaAp1xuXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gRGFya1RoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDMwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgR2VvbUxhYmVscyA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG52YXIgUG9sYXJMYWJlbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NCk7XG5cbnZhciBQaWVMYWJlbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzNSk7XG5cbnZhciBJbnRlcnZhbExhYmVscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzM2KTtcblxudmFyIExhYmVscyA9IHtcbiAgZ2V0TGFiZWxzQ2xhc3M6IGZ1bmN0aW9uIGdldExhYmVsc0NsYXNzKGNvb3JkVHlwZSwgdHlwZSkge1xuICAgIHZhciByc3QgPSBHZW9tTGFiZWxzO1xuXG4gICAgaWYgKGNvb3JkVHlwZSA9PT0gJ3BvbGFyJykge1xuICAgICAgcnN0ID0gUG9sYXJMYWJlbHM7XG4gICAgfSBlbHNlIGlmIChjb29yZFR5cGUgPT09ICd0aGV0YScpIHtcbiAgICAgIC8vIHBpZSBjaGFydFxuICAgICAgcnN0ID0gUGllTGFiZWxzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJyB8fCB0eXBlID09PSAncG9seWdvbicpIHtcbiAgICAgIC8vIGJhclxuICAgICAgcnN0ID0gSW50ZXJ2YWxMYWJlbHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gTGFiZWxzO1xuXG4vKioqLyB9KSxcbi8qIDMwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgQXhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5BeGlzLkJhc2UgPSBBeGlzO1xuQXhpcy5DaXJjbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMCk7XG5BeGlzLkdyaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Myk7XG5BeGlzLkhlbGl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTEpO1xuQXhpcy5MaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTIpO1xuQXhpcy5Qb2x5bGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEzKTtcbm1vZHVsZS5leHBvcnRzID0gQXhpcztcblxuLyoqKi8gfSksXG4vKiAzMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIEdyZWVkeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTU1KTtcbi8qXG4gICAqICDmoLnmja7lpoLkuIvop4TliJnlsJ3or5XmlL7nva5sYWJlbFxuICAgKiAgICAgICAgICAgICAgICA1XG4gICAqICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogICAgICAgIHwgICAgMSAgIHwgICAwICAgfFxuICAgKiAgICA4ICAg4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUNOKAlOKAlOKAlOKAlOKAlOKAlOKAlOKAlCAgIDdcbiAgICogICAgICAgIHwgICAgMiAgIHwgICAzICAgfFxuICAgKiAgICAgICAg4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUXG4gICAqICAgICAgICAgICAgICAgICA2XG4gICAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdExhYmVsUG9zaXRpb24obGFiZWwsIHgsIHksIGluZGV4KSB7XG4gIHZhciBiYm94ID0gbGFiZWwuZ2V0QkJveCgpO1xuICB2YXIgd2lkdGggPSBiYm94LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gIHZhciBhdHRycyA9IHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICB9O1xuXG4gIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIDA6XG4gICAgICBhdHRycy55IC09IGhlaWdodCAvIDI7XG4gICAgICBhdHRycy50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcbiAgICAgIGF0dHJzLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIGF0dHJzLnkgKz0gaGVpZ2h0IC8gMjtcbiAgICAgIGF0dHJzLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMzpcbiAgICAgIGF0dHJzLnkgKz0gaGVpZ2h0IC8gMjtcbiAgICAgIGF0dHJzLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSA1OlxuICAgICAgYXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDY6XG4gICAgICBhdHRycy55ICs9IGhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgNzpcbiAgICAgIGF0dHJzLnggKz0gd2lkdGggLyAyO1xuICAgICAgYXR0cnMudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDg6XG4gICAgICBhdHRycy54IC09IHdpZHRoIC8gMjtcbiAgICAgIGF0dHJzLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGxhYmVsLmF0dHIoYXR0cnMpO1xuICByZXR1cm4gbGFiZWwuZ2V0QkJveCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsYWJlbHMpIHtcbiAgdmFyIGdyZWVkeSA9IG5ldyBHcmVlZHkoKTtcbiAgdmFyIHRvQmVSZW1vdmVkID0gW107XG4gIHZhciBiYm94LCBsYWJlbCwgeCwgeSwgY2FuRmlsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgIHggPSBsYWJlbC5hdHRyKCd4Jyk7XG4gICAgeSA9IGxhYmVsLmF0dHIoJ3knKTtcbiAgICBjYW5GaWxsID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgODsgX2krKykge1xuICAgICAgYmJveCA9IGFkanVzdExhYmVsUG9zaXRpb24obGFiZWwsIHgsIHksIF9pKTtcblxuICAgICAgaWYgKGdyZWVkeS5oYXNHYXAoYmJveCkpIHtcbiAgICAgICAgZ3JlZWR5LmZpbGxHYXAoYmJveCk7XG4gICAgICAgIGNhbkZpbGwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNhbkZpbGwpIHtcbiAgICAgIHRvQmVSZW1vdmVkLnB1c2gobGFiZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRvQmVSZW1vdmVkLmxlbmd0aDsgX2kyKyspIHtcbiAgICB0b0JlUmVtb3ZlZFtfaTJdLnJlbW92ZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNhbkZpbGw7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgR3JlZWR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTUpO1xuXG52YXIgTUFYX1RJTUVTID0gMjA7XG5cbmZ1bmN0aW9uIHNwaXJhbEZpbGwobGFiZWwsIGdyZWVkeSkge1xuICB2YXIgZHQgPSAtMTtcbiAgdmFyIHggPSBsYWJlbC5hdHRyKCd4JyksXG4gICAgICB5ID0gbGFiZWwuYXR0cigneScpO1xuICB2YXIgYmJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgdmFyIG1heERlbHRhID0gTWF0aC5zcXJ0KGJib3gud2lkdGggKiBiYm94LndpZHRoICsgYmJveC5oZWlnaHQgKiBiYm94LmhlaWdodCk7XG4gIHZhciBkeGR5LFxuICAgICAgdCA9IC1kdCxcbiAgICAgIGR4ID0gMCxcbiAgICAgIGR5ID0gMDtcblxuICB2YXIgZiA9IGZ1bmN0aW9uIGYodCkge1xuICAgIHJldHVybiBbKHQgKj0gMC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xuICB9O1xuXG4gIGlmIChncmVlZHkuaGFzR2FwKGJib3gpKSB7XG4gICAgZ3JlZWR5LmZpbGxHYXAoYmJveCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgY2FuRmlsbCA9IGZhbHNlLFxuICAgICAgdGltZXMgPSAwO1xuXG4gIHdoaWxlIChNYXRoLm1pbihNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSkgPCBtYXhEZWx0YSAmJiB0aW1lcyA8IE1BWF9USU1FUykge1xuICAgIGR4ZHkgPSBmKHQgKz0gZHQpO1xuICAgIGR4ID0gfn5keGR5WzBdO1xuICAgIGR5ID0gfn5keGR5WzFdO1xuICAgIGxhYmVsLmF0dHIoe1xuICAgICAgeDogeCArIGR4LFxuICAgICAgeTogeSArIGR5XG4gICAgfSk7XG4gICAgdGltZXMrKztcblxuICAgIGlmIChncmVlZHkuaGFzR2FwKGxhYmVsLmdldEJCb3goKSkpIHtcbiAgICAgIGdyZWVkeS5maWxsR2FwKGJib3gpO1xuICAgICAgY2FuRmlsbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuRmlsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGFiZWxzKSB7XG4gIHZhciBsYWJlbDtcbiAgdmFyIGdyZWVkeSA9IG5ldyBHcmVlZHkoKTtcbiAgdmFyIHRvQmVSZW1vdmVkID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcblxuICAgIGlmICghc3BpcmFsRmlsbChsYWJlbCwgZ3JlZWR5KSkge1xuICAgICAgdG9CZVJlbW92ZWQucHVzaChsYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvQmVSZW1vdmVkLmxlbmd0aDsgX2krKykge1xuICAgIHRvQmVSZW1vdmVkW19pXS5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYm94QWRqdXN0KGxhYmVscywgc2hhcGVzKSB7XG4gIHZhciBsYWJlbEJCb3gsIHNoYXBlQkJveDtcbiAgdmFyIHRvQmVSZW1vdmVkID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBsYWJlbEJCb3ggPSBsYWJlbHNbaV0uZ2V0QkJveCgpO1xuICAgIHNoYXBlQkJveCA9IHNoYXBlc1tpXS5nZXRCQm94KCk7XG5cbiAgICBpZiAobGFiZWxCQm94LndpZHRoID4gc2hhcGVCQm94LndpZHRoIHx8IGxhYmVsQkJveC5oZWlnaHQgPiBzaGFwZUJCb3guaGVpZ2h0KSB7XG4gICAgICB0b0JlUmVtb3ZlZC5wdXNoKGxhYmVsc1tpXSk7XG4gICAgfSBlbHNlIGlmIChsYWJlbEJCb3gud2lkdGggKiBsYWJlbEJCb3guaGVpZ2h0ID4gc2hhcGVCQm94LndpZHRoICogc2hhcGVCQm94LmhlaWdodCkge1xuICAgICAgdG9CZVJlbW92ZWQucHVzaChsYWJlbHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b0JlUmVtb3ZlZC5sZW5ndGg7IF9pKyspIHtcbiAgICB0b0JlUmVtb3ZlZFtfaV0ucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgdmVjMiA9IFV0aWwuTWF0cml4VXRpbC52ZWMyO1xuXG52YXIgQ2lyY2xlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShDaXJjbGUsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaXJjbGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0Jhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIOWdkOagh+i9tOeahOexu+Wei1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAgIC8qKlxuICAgICAgICog5oyH5a6a5Yi75bqm5LmL6Ze055qE6Ze06LedXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aWNrSW50ZXJ2YWw6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5byA5aeL5byn5bqmXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBzdGFydEFuZ2xlOiAtTWF0aC5QSSAvIDIsXG5cbiAgICAgIC8qKlxuICAgICAgICog57uT5p2f5byn5bqmXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDMgLyAyLFxuICAgICAgbGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOWdkOagh+i9tOe6v+eahOWbvuW9ouWxnuaApyzlpoLmnpzorr7nva7miJBudWxs77yM5YiZ5LiN5pi+56S66L2057q/XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0MwRDBFMCdcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOagh+azqOWdkOagh+e6v+eahOWbvuW9ouWxnuaAp1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNDMEQwRTAnLFxuICAgICAgICBsZW5ndGg6IDVcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6k5paH5pys6Led56a76L2057q/55qE6Led56a7XG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBfbGFiZWxPZmZzZXQ6IDVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VUaWNrID0gZnVuY3Rpb24gcGFyc2VUaWNrKHRpY2ssIGluZGV4LCBsZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdGljayxcbiAgICAgIHZhbHVlOiBpbmRleCAvIGxlbmd0aFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRDaXJjbGVQb2ludCA9IGZ1bmN0aW9uIF9nZXRDaXJjbGVQb2ludChhbmdsZSwgcmFkaXVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjZW50ZXIgPSBzZWxmLmdldCgnY2VudGVyJyk7XG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IHNlbGYuZ2V0KCdyYWRpdXMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY2VudGVyLnggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiBjZW50ZXIueSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1c1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFRpY2tQb2ludCA9IGZ1bmN0aW9uIGdldFRpY2tQb2ludCh2YWx1ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNlbGYuZ2V0KCdzdGFydEFuZ2xlJyk7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2VsZi5nZXQoJ2VuZEFuZ2xlJyk7XG4gICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZSArIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICogdmFsdWU7XG4gICAgcmV0dXJuIHNlbGYuX2dldENpcmNsZVBvaW50KGFuZ2xlKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2lkZVZlY3RvciA9IGZ1bmN0aW9uIGdldFNpZGVWZWN0b3Iob2Zmc2V0LCBwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2VudGVyID0gc2VsZi5nZXQoJ2NlbnRlcicpO1xuICAgIHZhciB2ZWN0b3IgPSBbcG9pbnQueCAtIGNlbnRlci54LCBwb2ludC55IC0gY2VudGVyLnldO1xuXG4gICAgaWYgKCFVdGlsLmlzTmlsKG9mZnNldCkpIHtcbiAgICAgIHZhciB2ZWNMZW4gPSB2ZWMyLmxlbmd0aCh2ZWN0b3IpO1xuICAgICAgdmVjMi5zY2FsZSh2ZWN0b3IsIHZlY3Rvciwgb2Zmc2V0IC8gdmVjTGVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuICB9O1xuXG4gIF9wcm90by5nZXRTaWRlUG9pbnQgPSBmdW5jdGlvbiBnZXRTaWRlUG9pbnQocG9pbnQsIG9mZnNldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmVjdG9yID0gc2VsZi5nZXRTaWRlVmVjdG9yKG9mZnNldCwgcG9pbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwb2ludC54ICsgdmVjdG9yWzBdLFxuICAgICAgeTogcG9pbnQueSArIHZlY3RvclsxXVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFRpY2tFbmQgPSBmdW5jdGlvbiBnZXRUaWNrRW5kKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRpY2tMaW5lID0gc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID8gbGVuZ3RoIDogdGlja0xpbmUubGVuZ3RoO1xuICAgIHJldHVybiBzZWxmLmdldFNpZGVQb2ludChzdGFydCwgbGVuZ3RoKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGV4dEFuY2hvciA9IGZ1bmN0aW9uIGdldFRleHRBbmNob3IodmVjdG9yKSB7XG4gICAgdmFyIGFsaWduO1xuXG4gICAgaWYgKFV0aWwuc25hcEVxdWFsKHZlY3RvclswXSwgMCkpIHtcbiAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgfSBlbHNlIGlmICh2ZWN0b3JbMF0gPiAwKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHZlY3RvclswXSA8IDApIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxpZ247XG4gIH07XG5cbiAgX3Byb3RvLmdldExpbmVQYXRoID0gZnVuY3Rpb24gZ2V0TGluZVBhdGgoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjZW50ZXIgPSBzZWxmLmdldCgnY2VudGVyJyk7XG4gICAgdmFyIHggPSBjZW50ZXIueDtcbiAgICB2YXIgeSA9IGNlbnRlci55O1xuICAgIHZhciByeCA9IHNlbGYuZ2V0KCdyYWRpdXMnKTtcbiAgICB2YXIgcnkgPSByeDtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNlbGYuZ2V0KCdzdGFydEFuZ2xlJyk7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2VsZi5nZXQoJ2VuZEFuZ2xlJyk7XG4gICAgdmFyIGlubmVyID0gc2VsZi5nZXQoJ2lubmVyJyk7XG4gICAgdmFyIHBhdGggPSBbXTtcblxuICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID09PSBNYXRoLlBJICogMikge1xuICAgICAgcGF0aCA9IFtbJ00nLCB4LCB5XSwgWydtJywgMCwgLXJ5XSwgWydhJywgcngsIHJ5LCAwLCAxLCAxLCAwLCAyICogcnldLCBbJ2EnLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLCBbJ3onXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydFBvaW50ID0gc2VsZi5fZ2V0Q2lyY2xlUG9pbnQoc3RhcnRBbmdsZSk7XG5cbiAgICAgIHZhciBlbmRQb2ludCA9IHNlbGYuX2dldENpcmNsZVBvaW50KGVuZEFuZ2xlKTtcblxuICAgICAgdmFyIGxhcmdlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IE1hdGguUEkgPyAxIDogMDtcbiAgICAgIHZhciBzd2VlcCA9IHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSA/IDAgOiAxO1xuXG4gICAgICBpZiAoIWlubmVyKSB7XG4gICAgICAgIHBhdGggPSBbWydNJywgeCwgeV0sIFsnTCcsIHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55XSwgWydBJywgcngsIHJ5LCAwLCBsYXJnZSwgc3dlZXAsIGVuZFBvaW50LngsIGVuZFBvaW50LnldLCBbJ0wnLCB4LCB5XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5uZXJTdGFydFZlY3RvciA9IHNlbGYuZ2V0U2lkZVZlY3Rvcihpbm5lciAqIHJ4LCBzdGFydFBvaW50KTtcbiAgICAgICAgdmFyIGlubmVyRW5kVmVjdG9yID0gc2VsZi5nZXRTaWRlVmVjdG9yKGlubmVyICogcngsIGVuZFBvaW50KTtcbiAgICAgICAgdmFyIGlubmVyU3RhcnRQb2ludCA9IHtcbiAgICAgICAgICB4OiBpbm5lclN0YXJ0VmVjdG9yWzBdICsgeCxcbiAgICAgICAgICB5OiBpbm5lclN0YXJ0VmVjdG9yWzFdICsgeVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW5uZXJFbmRQb2ludCA9IHtcbiAgICAgICAgICB4OiBpbm5lckVuZFZlY3RvclswXSArIHgsXG4gICAgICAgICAgeTogaW5uZXJFbmRWZWN0b3JbMV0gKyB5XG4gICAgICAgIH07XG4gICAgICAgIHBhdGggPSBbWydNJywgaW5uZXJTdGFydFBvaW50LngsIGlubmVyU3RhcnRQb2ludC55XSwgWydMJywgc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnldLCBbJ0EnLCByeCwgcnksIDAsIGxhcmdlLCBzd2VlcCwgZW5kUG9pbnQueCwgZW5kUG9pbnQueV0sIFsnTCcsIGlubmVyRW5kUG9pbnQueCwgaW5uZXJFbmRQb2ludC55XSwgWydBJywgcnggKiBpbm5lciwgcnkgKiBpbm5lciwgMCwgbGFyZ2UsIE1hdGguYWJzKHN3ZWVwIC0gMSksIGlubmVyU3RhcnRQb2ludC54LCBpbm5lclN0YXJ0UG9pbnQueV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIF9wcm90by5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKHRpY2ssIHBvaW50LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb2Zmc2V0ID0gc2VsZi5nZXQoJ2xhYmVsJykub2Zmc2V0IHx8IHNlbGYuZ2V0KCdfbGFiZWxPZmZzZXQnKSB8fCAwLjAwMTtcbiAgICBwb2ludCA9IHNlbGYuZ2V0U2lkZVBvaW50KHBvaW50LCBvZmZzZXQpO1xuXG4gICAgX0Jhc2UucHJvdG90eXBlLmFkZExhYmVsLmNhbGwodGhpcywgdGljaywgcG9pbnQsIGluZGV4KTtcbiAgfTtcblxuICBfcHJvdG8uYXV0b1JvdGF0ZUxhYmVscyA9IGZ1bmN0aW9uIGF1dG9Sb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrcyA9IHNlbGYuZ2V0KCd0aWNrcycpO1xuICAgIHZhciBsYWJlbFJlbmRlcmVyID0gc2VsZi5nZXQoJ2xhYmVsUmVuZGVyZXInKTtcblxuICAgIGlmIChsYWJlbFJlbmRlcmVyICYmIHRpY2tzLmxlbmd0aCA+IDEyKSB7XG4gICAgICAvLyDlsI/kuo4xMuS4quaWh+acrOaXtuaWh+acrOS4jeaXi+i9rFxuICAgICAgdmFyIHJhZGl1cyA9IHNlbGYuZ2V0KCdyYWRpdXMnKTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gc2VsZi5nZXQoJ3N0YXJ0QW5nbGUnKTtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHNlbGYuZ2V0KCdlbmRBbmdsZScpO1xuICAgICAgdmFyIHRvdGFsQW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICB2YXIgYXZnQW5nbGUgPSB0b3RhbEFuZ2xlIC8gKHRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIGF2Z1dpZHRoID0gTWF0aC5zaW4oYXZnQW5nbGUgLyAyKSAqIHJhZGl1cyAqIDI7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gc2VsZi5nZXRNYXhMYWJlbFdpZHRoKGxhYmVsUmVuZGVyZXIpO1xuICAgICAgVXRpbC5lYWNoKGxhYmVsUmVuZGVyZXIuZ2V0KCdncm91cCcpLmdldCgnY2hpbGRyZW4nKSwgZnVuY3Rpb24gKGxhYmVsLCBpbmRleCkge1xuICAgICAgICB2YXIgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGljay52YWx1ZSAqIHRvdGFsQW5nbGUgKyBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgbW9kZSA9IGFuZ2xlICUgKE1hdGguUEkgKiAyKTtcblxuICAgICAgICBpZiAobWF4TGVuZ3RoIDwgYXZnV2lkdGgpIHtcbiAgICAgICAgICAvLyDmlofmnKznmoTmnIDlpKflrr3luqblpKfkuo5cbiAgICAgICAgICBpZiAobW9kZSA8PSAwKSB7XG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW9kZSA+IE1hdGguUEkpIHtcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUgLSBNYXRoLlBJO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuZ2xlID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICBsYWJlbC5hdHRyKCd0ZXh0QWxpZ24nLCAnY2VudGVyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1vZGUgPiBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZSAtIE1hdGguUEk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb2RlIDwgTWF0aC5QSSAvIDIgKiAtMSkge1xuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwucm90YXRlQXRTdGFydChhbmdsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG4vKioqLyB9KSxcbi8qIDMxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIE1hdHJpeFV0aWwgPSBVdGlsLk1hdHJpeFV0aWwsXG4gICAgUGF0aFV0aWwgPSBVdGlsLlBhdGhVdGlsO1xudmFyIHZlYzIgPSBNYXRyaXhVdGlsLnZlYzI7XG5cbnZhciBIZWxpeCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoSGVsaXgsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBIZWxpeCgpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhlbGl4LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9CYXNlLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgaW5uZXI6IDAsXG4gICAgICB0eXBlOiAnaGVsaXgnLFxuICAgICAgbGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOWdkOagh+i9tOe6v+eahOWbvuW9ouWxnuaApyzlpoLmnpzorr7nva7miJBudWxs77yM5YiZ5LiN5pi+56S66L2057q/XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0MwRDBFMCdcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOagh+azqOWdkOagh+e6v+eahOWbvuW9ouWxnuaAp1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNDMEQwRTAnLFxuICAgICAgICBsZW5ndGg6IDVcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAxLjI1ICogTWF0aC5QSSxcbiAgICAgIGVuZEFuZ2xlOiA3LjI1ICogTWF0aC5QSSxcbiAgICAgIC8vIOieuuaXi+ezu+aVsFxuICAgICAgYTogMCxcbiAgICAgIC8vIOeUu+W4g+S4reW/g+WdkOagh1xuICAgICAgY2VudGVyOiBudWxsLFxuICAgICAgLy8g5Z2Q5qCH6L2057uY5Yi26LW354K5XG4gICAgICBheGlzU3RhcnQ6IG51bGwsXG4gICAgICAvLyDlnZDmoIfovbTnmoRu5Liq5Z2Q5qCH54K5XG4gICAgICBjcnA6IFtdXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExpbmVQYXRoID0gZnVuY3Rpb24gZ2V0TGluZVBhdGgoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjcnAgPSBzZWxmLmdldCgnY3JwJyk7XG4gICAgdmFyIGF4aXNTdGFydCA9IHNlbGYuZ2V0KCdheGlzU3RhcnQnKTtcbiAgICB2YXIgcGF0aCA9IFBhdGhVdGlsLmNhdG11bGxSb21Ub0JlemllcihjcnApO1xuICAgIHBhdGgudW5zaGlmdChbJ00nLCBheGlzU3RhcnQueCwgYXhpc1N0YXJ0LnldKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGlja1BvaW50ID0gZnVuY3Rpb24gZ2V0VGlja1BvaW50KHZhbHVlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2VsZi5nZXQoJ3N0YXJ0QW5nbGUnKTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzZWxmLmdldCgnZW5kQW5nbGUnKTtcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgKiB2YWx1ZTtcbiAgICByZXR1cm4gc2VsZi5fZ2V0SGVsaXhQb2ludChhbmdsZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRIZWxpeFBvaW50ID0gZnVuY3Rpb24gX2dldEhlbGl4UG9pbnQoYW5nbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNlbnRlciA9IHNlbGYuZ2V0KCdjZW50ZXInKTtcbiAgICB2YXIgYSA9IHNlbGYuZ2V0KCdhJyk7IC8vIOieuue6v+ezu+aVsFxuXG4gICAgdmFyIHJhZGl1cyA9IGEgKiBhbmdsZSArIHNlbGYuZ2V0KCdpbm5lcicpOyAvLyDonrrnur/mlrnnqItcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBjZW50ZXIueCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IGNlbnRlci55ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2lkZVZlY3RvciA9IGZ1bmN0aW9uIGdldFNpZGVWZWN0b3Iob2Zmc2V0LCBwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2VudGVyID0gc2VsZi5nZXQoJ2NlbnRlcicpO1xuICAgIHZhciB2ZWN0b3IgPSBbcG9pbnQueCAtIGNlbnRlci54LCBwb2ludC55IC0gY2VudGVyLnldO1xuXG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgdmFyIHZlY0xlbiA9IHZlYzIubGVuZ3RoKHZlY3Rvcik7XG4gICAgICB2ZWMyLnNjYWxlKHZlY3RvciwgdmVjdG9yLCBvZmZzZXQgLyB2ZWNMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiB2ZWN0b3I7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNpZGVQb2ludCA9IGZ1bmN0aW9uIGdldFNpZGVQb2ludChwb2ludCwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2ZWN0b3IgPSBzZWxmLmdldFNpZGVWZWN0b3Iob2Zmc2V0LCBwb2ludCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHBvaW50LnggKyB2ZWN0b3JbMF0sXG4gICAgICB5OiBwb2ludC55ICsgdmVjdG9yWzFdXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGlja0VuZCA9IGZ1bmN0aW9uIGdldFRpY2tFbmQoc3RhcnQsIGxlbmd0aCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGlja0xpbmUgPSBzZWxmLmdldCgndGlja0xpbmUnKTtcbiAgICBsZW5ndGggPSBsZW5ndGggPyBsZW5ndGggOiB0aWNrTGluZS5sZW5ndGg7XG4gICAgcmV0dXJuIHNlbGYuZ2V0U2lkZVBvaW50KHN0YXJ0LCBsZW5ndGgpO1xuICB9O1xuXG4gIHJldHVybiBIZWxpeDtcbn0oQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVsaXg7XG5cbi8qKiovIH0pLFxuLyogMzEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgTWF0cml4VXRpbCA9IFV0aWwuTWF0cml4VXRpbDtcbnZhciB2ZWMyID0gTWF0cml4VXRpbC52ZWMyO1xuXG52YXIgTGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGluZSwgX0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIExpbmUoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9CYXNlLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgeDogbnVsbCxcbiAgICAgIC8vIEB0eXBlIHtOdW1iZXJ9IOi3neemu+WIneWni+S9jee9rueahHjovbTlgY/np7vph48s5LuF5a+55LqO5bem5L6n44CB5Y+z5L6n55qE57q15ZCR5Z2Q5qCH5pyJ5pWIXG4gICAgICB5OiBudWxsLFxuICAgICAgLy8gQHR5cGUge051bWJlcn0g6Led56a75Yid5aeL5L2N572u55qEeei9tOWBj+enu+mHj++8jOS7heWvuemhtumDqOOAgeW6lemDqOeahOaoquWQkeWdkOagh+i9tOacieaViFxuICAgICAgbGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOWdkOagh+i9tOe6v+eahOWbvuW9ouWxnuaApyzlpoLmnpzorr7nva7miJBudWxs77yM5YiZ5LiN5pi+56S66L2057q/XG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgc3Ryb2tlOiAnI0MwRDBFMCdcbiAgICAgIH0sXG4gICAgICB0aWNrTGluZToge1xuICAgICAgICAvLyBAdHlwZSB7QXR0cnN9IOagh+azqOWdkOagh+e6v+eahOWbvuW9ouWxnuaAp1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogJyNDMEQwRTAnLFxuICAgICAgICBsZW5ndGg6IDVcbiAgICAgIH0sXG4gICAgICBpc1ZlcnRpY2FsOiBmYWxzZSxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgLy8gQHR5cGUge09iamVjdH0g6LW354K5XG4gICAgICBlbmQ6IG51bGwgLy8gQHR5cGUge09iamVjdH0g57uI54K5XG5cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2dldEF2Z0xhYmVsTGVuZ3RoID0gZnVuY3Rpb24gX2dldEF2Z0xhYmVsTGVuZ3RoKGxhYmVsUmVuZGVyZXIpIHtcbiAgICB2YXIgbGFiZWxzID0gbGFiZWxSZW5kZXJlci5nZXQoJ2dyb3VwJykuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHJldHVybiBsYWJlbHNbMV0uYXR0cigneCcpIC0gbGFiZWxzWzBdLmF0dHIoJ3gnKTtcbiAgfTtcblxuICBfcHJvdG8uX2dldEF2Z0xhYmVsSGVpZ2h0U3BhY2UgPSBmdW5jdGlvbiBfZ2V0QXZnTGFiZWxIZWlnaHRTcGFjZShsYWJlbFJlbmRlcmVyKSB7XG4gICAgdmFyIGxhYmVscyA9IGxhYmVsUmVuZGVyZXIuZ2V0KCdncm91cCcpLmdldCgnY2hpbGRyZW4nKTtcbiAgICByZXR1cm4gbGFiZWxzWzFdLmF0dHIoJ3knKSAtIGxhYmVsc1swXS5hdHRyKCd5Jyk7XG4gIH07XG4gIC8qKlxuICAgKiDojrflj5bot53nprvlnZDmoIfovbTnmoTlkJHph49cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSAge051bWJlcn0gb2Zmc2V0IOWBj+enu+WAvFxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgIOi/lOWbnuS6jOe7tOWQkemHj1xuICAgKi9cblxuXG4gIF9wcm90by5nZXRTaWRlVmVjdG9yID0gZnVuY3Rpb24gZ2V0U2lkZVZlY3RvcihvZmZzZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGlzVmVydGljYWwgPSBzZWxmLmdldCgnaXNWZXJ0aWNhbCcpO1xuICAgIHZhciBmYWN0b3IgPSBzZWxmLmdldCgnZmFjdG9yJyk7IC8vIGlmIChVdGlsLmlzQXJyYXkob2Zmc2V0KSkge1xuICAgIC8vICAgcmV0dXJuIG9mZnNldC5tYXAodmFsdWUgPT4gdmFsdWUgKiBmYWN0b3IpO1xuICAgIC8vIH1cblxuICAgIGlmICghVXRpbC5pc051bWJlcihvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IHNlbGYuZ2V0KCdzdGFydCcpO1xuICAgIHZhciBlbmQgPSBzZWxmLmdldCgnZW5kJyk7XG4gICAgdmFyIGF4aXNWZWN0b3IgPSBzZWxmLmdldEF4aXNWZWN0b3IoKTtcbiAgICB2YXIgbm9ybWFsID0gdmVjMi5ub3JtYWxpemUoW10sIGF4aXNWZWN0b3IpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBmYWxzZTtcblxuICAgIGlmIChpc1ZlcnRpY2FsICYmIHN0YXJ0LnkgPCBlbmQueSB8fCAhaXNWZXJ0aWNhbCAmJiBzdGFydC54ID4gZW5kLngpIHtcbiAgICAgIGRpcmVjdGlvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRpY2FsVmVjdG9yID0gdmVjMi52ZXJ0aWNhbChbXSwgbm9ybWFsLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiB2ZWMyLnNjYWxlKFtdLCB2ZXJ0aWNhbFZlY3Rvciwgb2Zmc2V0ICogZmFjdG9yKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXhpc1ZlY3RvciA9IGZ1bmN0aW9uIGdldEF4aXNWZWN0b3IoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXQoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZCA9IHRoaXMuZ2V0KCdlbmQnKTtcbiAgICByZXR1cm4gW2VuZC54IC0gc3RhcnQueCwgZW5kLnkgLSBzdGFydC55XTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TGluZVBhdGggPSBmdW5jdGlvbiBnZXRMaW5lUGF0aCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXJ0ID0gc2VsZi5nZXQoJ3N0YXJ0Jyk7XG4gICAgdmFyIGVuZCA9IHNlbGYuZ2V0KCdlbmQnKTtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHBhdGgucHVzaChbJ00nLCBzdGFydC54LCBzdGFydC55XSk7XG4gICAgcGF0aC5wdXNoKFsnTCcsIGVuZC54LCBlbmQueV0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaWNrRW5kID0gZnVuY3Rpb24gZ2V0VGlja0VuZChzdGFydCwgdmFsdWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9mZnNldFZlY3RvciA9IHNlbGYuZ2V0U2lkZVZlY3Rvcih2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHN0YXJ0LnggKyBvZmZzZXRWZWN0b3JbMF0sXG4gICAgICB5OiBzdGFydC55ICsgb2Zmc2V0VmVjdG9yWzFdXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGlja1BvaW50ID0gZnVuY3Rpb24gZ2V0VGlja1BvaW50KHRpY2tWYWx1ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhcnQgPSBzZWxmLmdldCgnc3RhcnQnKTtcbiAgICB2YXIgZW5kID0gc2VsZi5nZXQoJ2VuZCcpO1xuICAgIHZhciByYW5nZVggPSBlbmQueCAtIHN0YXJ0Lng7XG4gICAgdmFyIHJhbmdlWSA9IGVuZC55IC0gc3RhcnQueTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogc3RhcnQueCArIHJhbmdlWCAqIHRpY2tWYWx1ZSxcbiAgICAgIHk6IHN0YXJ0LnkgKyByYW5nZVkgKiB0aWNrVmFsdWVcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uIHJlbmRlclRpdGxlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdGl0bGUgPSBzZWxmLmdldCgndGl0bGUnKTtcbiAgICB2YXIgb2Zmc2V0UG9pbnQgPSBzZWxmLmdldFRpY2tQb2ludCgwLjUpO1xuICAgIHZhciB0aXRsZU9mZnNldCA9IHRpdGxlLm9mZnNldDtcblxuICAgIGlmIChVdGlsLmlzTmlsKHRpdGxlT2Zmc2V0KSkge1xuICAgICAgLy8g5rKh5pyJ5oyH5a6aIG9mZnNldCDliJnoh6rliqjorqHnrpdcbiAgICAgIHRpdGxlT2Zmc2V0ID0gMjA7XG4gICAgICB2YXIgbGFiZWxzR3JvdXAgPSBzZWxmLmdldCgnbGFiZWxzR3JvdXAnKTtcblxuICAgICAgaWYgKGxhYmVsc0dyb3VwKSB7XG4gICAgICAgIHZhciBsYWJlbExlbmd0aCA9IHNlbGYuZ2V0TWF4TGFiZWxXaWR0aChsYWJlbHNHcm91cCk7XG4gICAgICAgIHZhciBsYWJlbE9mZnNldCA9IHNlbGYuZ2V0KCdsYWJlbCcpLm9mZnNldCB8fCBzZWxmLmdldCgnX2xhYmVsT2Zmc2V0Jyk7XG4gICAgICAgIHRpdGxlT2Zmc2V0ICs9IGxhYmVsTGVuZ3RoICsgbGFiZWxPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRleHRTdHlsZSA9IHRpdGxlLnRleHRTdHlsZTtcbiAgICB2YXIgY2ZnID0gVXRpbC5taXgoe30sIHRleHRTdHlsZSk7XG5cbiAgICBpZiAodGl0bGUudGV4dCkge1xuICAgICAgdmFyIHZlY3RvciA9IHNlbGYuZ2V0QXhpc1ZlY3RvcigpOyAvLyDlnZDmoIfovbTmlrnlkJHnmoTlkJHph49cblxuICAgICAgaWYgKHRpdGxlLmF1dG9Sb3RhdGUgJiYgVXRpbC5pc05pbCh0ZXh0U3R5bGUucm90YXRlKSkge1xuICAgICAgICAvLyDoh6rliqjml4vovazlubbkuJTnlKjmiLfmsqHmnInmjIflrprmoIfpopjnmoTml4vovazop5LluqZcbiAgICAgICAgdmFyIGFuZ2xlID0gMDtcblxuICAgICAgICBpZiAoIVV0aWwuc25hcEVxdWFsKHZlY3RvclsxXSwgMCkpIHtcbiAgICAgICAgICAvLyDmiYDmnInmsLTlubPlnZDmoIfovbTvvIzmlofmnKzkuI3ovaznva5cbiAgICAgICAgICB2YXIgdjEgPSBbMSwgMF07XG4gICAgICAgICAgdmFyIHYyID0gW3ZlY3RvclswXSwgdmVjdG9yWzFdXTtcbiAgICAgICAgICBhbmdsZSA9IHZlYzIuYW5nbGVUbyh2MiwgdjEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ZnLnJvdGF0ZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICAgICAgfSBlbHNlIGlmICghVXRpbC5pc05pbCh0ZXh0U3R5bGUucm90YXRlKSkge1xuICAgICAgICAvLyDnlKjmiLforr7nva7kuobml4vovazop5LluqblsLHku6XnlKjmiLforr7nva7nmoTkuLrlh4ZcbiAgICAgICAgY2ZnLnJvdGF0ZSA9IHRleHRTdHlsZS5yb3RhdGUgLyAxODAgKiBNYXRoLlBJOyAvLyDlsIbop5LluqbovazmjaLkuLrlvKfluqZcbiAgICAgIH1cblxuICAgICAgdmFyIHNpZGVWZWN0b3IgPSBzZWxmLmdldFNpZGVWZWN0b3IodGl0bGVPZmZzZXQpO1xuICAgICAgdmFyIHBvaW50O1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGl0bGUucG9zaXRpb247XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwb2ludCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmdldCgnc3RhcnQnKS54ICsgc2lkZVZlY3RvclswXSxcbiAgICAgICAgICB5OiB0aGlzLmdldCgnc3RhcnQnKS55ICsgc2lkZVZlY3RvclsxXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgeDogdGhpcy5nZXQoJ2VuZCcpLnggKyBzaWRlVmVjdG9yWzBdLFxuICAgICAgICAgIHk6IHRoaXMuZ2V0KCdlbmQnKS55ICsgc2lkZVZlY3RvclsxXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSB7XG4gICAgICAgICAgeDogb2Zmc2V0UG9pbnQueCArIHNpZGVWZWN0b3JbMF0sXG4gICAgICAgICAgeTogb2Zmc2V0UG9pbnQueSArIHNpZGVWZWN0b3JbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2ZnLnggPSBwb2ludC54O1xuICAgICAgY2ZnLnkgPSBwb2ludC55O1xuICAgICAgY2ZnLnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgdmFyIGdyb3VwID0gc2VsZi5nZXQoJ2dyb3VwJyk7XG4gICAgICB2YXIgdGl0bGVTaGFwZSA9IGdyb3VwLmFkZFNoYXBlKCdUZXh0Jywge1xuICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgIGF0dHJzOiBjZmdcbiAgICAgIH0pO1xuICAgICAgdGl0bGVTaGFwZS5uYW1lID0gJ2F4aXMtdGl0bGUnO1xuICAgICAgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSAmJiB0aXRsZVNoYXBlLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYXV0b1JvdGF0ZUxhYmVscyA9IGZ1bmN0aW9uIGF1dG9Sb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYWJlbFJlbmRlcmVyID0gc2VsZi5nZXQoJ2xhYmVsUmVuZGVyZXInKTtcbiAgICB2YXIgdGl0bGUgPSBzZWxmLmdldCgndGl0bGUnKTtcblxuICAgIGlmIChsYWJlbFJlbmRlcmVyKSB7XG4gICAgICB2YXIgbGFiZWxHcm91cCA9IGxhYmVsUmVuZGVyZXIuZ2V0KCdncm91cCcpO1xuICAgICAgdmFyIGxhYmVscyA9IGxhYmVsR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgdmFyIG9mZnNldCA9IHNlbGYuZ2V0KCdsYWJlbCcpLm9mZnNldDtcbiAgICAgIHZhciBhcHBlbmQgPSAxMjtcbiAgICAgIHZhciB0aXRsZU9mZnNldCA9IHRpdGxlID8gdGl0bGUub2Zmc2V0IDogNDg7XG5cbiAgICAgIGlmICh0aXRsZU9mZnNldCA8IDApIHtcbiAgICAgICAgLy8g5aaC5p6c5piv6LSf55qE55qE6K+d5bCx5LiN5peL6L2sXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZlY3RvciA9IHNlbGYuZ2V0QXhpc1ZlY3RvcigpOyAvLyDlnZDmoIfovbTnmoTlkJHph4/vvIzku4XlpITnkIbmsLTlubPmiJbogIXlnoLnm7TnmoTlnLrmma9cblxuICAgICAgdmFyIGFuZ2xlO1xuICAgICAgdmFyIG1heFdpZHRoO1xuXG4gICAgICBpZiAoVXRpbC5zbmFwRXF1YWwodmVjdG9yWzBdLCAwKSAmJiB0aXRsZSAmJiB0aXRsZS50ZXh0KSB7XG4gICAgICAgIC8vIOWdkOagh+i9tOWeguebtO+8jOeUseS6juS4jeefpemBk+i+uei3ne+8jOWPquiDvemYsuatoui3n3RpdGxl6YeN5ZCI77yM5aaC5p6cdGl0bGXkuI3lrZjlnKjvvIzliJnkuI3oh6rliqjml4vovaxcbiAgICAgICAgbWF4V2lkdGggPSBzZWxmLmdldE1heExhYmVsV2lkdGgobGFiZWxSZW5kZXJlcik7XG5cbiAgICAgICAgaWYgKG1heFdpZHRoID4gdGl0bGVPZmZzZXQgLSBvZmZzZXQgLSBhcHBlbmQpIHtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcygodGl0bGVPZmZzZXQgLSBvZmZzZXQgLSBhcHBlbmQpIC8gbWF4V2lkdGgpICogLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoVXRpbC5zbmFwRXF1YWwodmVjdG9yWzFdLCAwKSAmJiBsYWJlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyDlnZDmoIfovbTmsLTlubPvvIzkuI3ogIPomZHovrnot53vvIzmoLnmja7mnIDplb/nmoTlkozlubPlnYflgLzov5vooYznv7vovaxcbiAgICAgICAgdmFyIGF2Z1dpZHRoID0gTWF0aC5hYnMoc2VsZi5fZ2V0QXZnTGFiZWxMZW5ndGgobGFiZWxSZW5kZXJlcikpO1xuICAgICAgICBtYXhXaWR0aCA9IHNlbGYuZ2V0TWF4TGFiZWxXaWR0aChsYWJlbFJlbmRlcmVyKTtcblxuICAgICAgICBpZiAobWF4V2lkdGggPiBhdmdXaWR0aCkge1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKCh0aXRsZU9mZnNldCAtIG9mZnNldCAtIGFwcGVuZCkgKiAxLjI1IC8gbWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICB2YXIgZmFjdG9yID0gc2VsZi5nZXQoJ2ZhY3RvcicpO1xuICAgICAgICBVdGlsLmVhY2gobGFiZWxzLCBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbC5yb3RhdGVBdFN0YXJ0KGFuZ2xlKTtcblxuICAgICAgICAgIGlmIChVdGlsLnNuYXBFcXVhbCh2ZWN0b3JbMV0sIDApKSB7XG4gICAgICAgICAgICBpZiAoZmFjdG9yID4gMCkge1xuICAgICAgICAgICAgICBsYWJlbC5hdHRyKCd0ZXh0QWxpZ24nLCAnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFiZWwuYXR0cigndGV4dEFsaWduJywgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF1dG9IaWRlTGFiZWxzID0gZnVuY3Rpb24gYXV0b0hpZGVMYWJlbHMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYWJlbFJlbmRlcmVyID0gc2VsZi5nZXQoJ2xhYmVsUmVuZGVyZXInKTtcbiAgICB2YXIgbGFiZWxTcGFjZTtcbiAgICB2YXIgdGlja1N0ZXA7XG4gICAgdmFyIGFwcGVuZCA9IDg7XG5cbiAgICBpZiAobGFiZWxSZW5kZXJlcikge1xuICAgICAgdmFyIGxhYmVsR3JvdXAgPSBsYWJlbFJlbmRlcmVyLmdldCgnZ3JvdXAnKTtcbiAgICAgIHZhciBsYWJlbHMgPSBsYWJlbEdyb3VwLmdldCgnY2hpbGRyZW4nKTtcbiAgICAgIHZhciB2ZWN0b3IgPSBzZWxmLmdldEF4aXNWZWN0b3IoKTsgLy8g5Z2Q5qCH6L2055qE5ZCR6YeP77yM5LuF5aSE55CG5rC05bmz5oiW6ICF5Z6C55u055qE5Zy65pmvXG5cbiAgICAgIGlmIChsYWJlbHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsLnNuYXBFcXVhbCh2ZWN0b3JbMF0sIDApKSB7XG4gICAgICAgIC8vIOWdkOagh+i9tOWeguebtFxuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gc2VsZi5nZXRNYXhMYWJlbEhlaWdodChsYWJlbFJlbmRlcmVyKSArIGFwcGVuZDtcbiAgICAgICAgdmFyIGF2Z0hlaWdodCA9IE1hdGguYWJzKHNlbGYuX2dldEF2Z0xhYmVsSGVpZ2h0U3BhY2UobGFiZWxSZW5kZXJlcikpO1xuXG4gICAgICAgIGlmIChtYXhIZWlnaHQgPiBhdmdIZWlnaHQpIHtcbiAgICAgICAgICBsYWJlbFNwYWNlID0gbWF4SGVpZ2h0O1xuICAgICAgICAgIHRpY2tTdGVwID0gYXZnSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFV0aWwuc25hcEVxdWFsKHZlY3RvclsxXSwgMCkgJiYgbGFiZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8g5Z2Q5qCH6L205rC05bmzXG4gICAgICAgIHZhciBtYXhXaWR0aCA9IHNlbGYuZ2V0TWF4TGFiZWxXaWR0aChsYWJlbFJlbmRlcmVyKSArIGFwcGVuZDtcbiAgICAgICAgdmFyIGF2Z1dpZHRoID0gTWF0aC5hYnMoc2VsZi5fZ2V0QXZnTGFiZWxMZW5ndGgobGFiZWxSZW5kZXJlcikpO1xuXG4gICAgICAgIGlmIChtYXhXaWR0aCA+IGF2Z1dpZHRoKSB7XG4gICAgICAgICAgbGFiZWxTcGFjZSA9IG1heFdpZHRoO1xuICAgICAgICAgIHRpY2tTdGVwID0gYXZnV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxhYmVsU3BhY2UgJiYgdGlja1N0ZXApIHtcbiAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5jZWlsKGxhYmVsU3BhY2UgLyB0aWNrU3RlcCk7XG4gICAgICAgIFV0aWwuZWFjaChsYWJlbHMsIGZ1bmN0aW9uIChsYWJlbCwgaSkge1xuICAgICAgICAgIGlmIChpICUgcmF0aW8gIT09IDApIHtcbiAgICAgICAgICAgIGxhYmVsLmF0dHIoJ3RleHQnLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExpbmU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0pLFxuLyogMzEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgTWF0cml4VXRpbCA9IFV0aWwuTWF0cml4VXRpbCxcbiAgICBQYXRoVXRpbCA9IFV0aWwuUGF0aFV0aWw7XG52YXIgdmVjMiA9IE1hdHJpeFV0aWwudmVjMjtcblxudmFyIFBvbHlsaW5lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShQb2x5bGluZSwgX0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIFBvbHlsaW5lKCkge1xuICAgIHJldHVybiBfQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9seWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0Jhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICB0eXBlOiAncG9seWxpbmUnXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExpbmVQYXRoID0gZnVuY3Rpb24gZ2V0TGluZVBhdGgoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrUG9pbnRzID0gc2VsZi5nZXQoJ3RpY2tQb2ludHMnKTtcbiAgICB2YXIgc3RhcnQgPSBzZWxmLmdldCgnc3RhcnQnKTtcbiAgICB2YXIgZW5kID0gc2VsZi5nZXQoJ2VuZCcpO1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBwb2ludHMucHVzaChzdGFydC54KTtcbiAgICBwb2ludHMucHVzaChzdGFydC55KTtcbiAgICBVdGlsLmVhY2godGlja1BvaW50cywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRpY2sueCk7XG4gICAgICBwb2ludHMucHVzaCh0aWNrLnkpO1xuICAgIH0pO1xuICAgIHBvaW50cy5wdXNoKGVuZC54KTtcbiAgICBwb2ludHMucHVzaChlbmQueSk7XG4gICAgdmFyIHBhdGggPSBQYXRoVXRpbC5jYXRtdWxsUm9tVG9CZXppZXIocG9pbnRzKTtcbiAgICBwYXRoLnVuc2hpZnQoWydNJywgc3RhcnQueCwgc3RhcnQueV0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaWNrUG9pbnQgPSBmdW5jdGlvbiBnZXRUaWNrUG9pbnQodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHRpY2tQb2ludHMgPSB0aGlzLmdldCgndGlja1BvaW50cycpO1xuICAgIHJldHVybiB0aWNrUG9pbnRzW2luZGV4XTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGlja0VuZCA9IGZ1bmN0aW9uIGdldFRpY2tFbmQoc3RhcnQsIHZhbHVlLCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGluZUF0dHJzID0gc2VsZi5nZXQoJ3RpY2tMaW5lJyk7XG4gICAgdmFyIHRpY2tMZW5ndGggPSB2YWx1ZSA/IHZhbHVlIDogbGluZUF0dHJzLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0VmVjdG9yID0gc2VsZi5nZXRTaWRlVmVjdG9yKHRpY2tMZW5ndGgsIHN0YXJ0LCBpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHN0YXJ0LnggKyBvZmZzZXRWZWN0b3JbMF0sXG4gICAgICB5OiBzdGFydC55ICsgb2Zmc2V0VmVjdG9yWzFdXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2lkZVZlY3RvciA9IGZ1bmN0aW9uIGdldFNpZGVWZWN0b3Iob2Zmc2V0LCBwb2ludCwgaW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByZVRpY2tQb2ludDtcblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcHJlVGlja1BvaW50ID0gc2VsZi5nZXQoJ3N0YXJ0Jyk7XG5cbiAgICAgIGlmIChwcmVUaWNrUG9pbnQueCA9PT0gcG9pbnQueCAmJiBwcmVUaWNrUG9pbnQueSA9PT0gcG9pbnQueSkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGlja1BvaW50cyA9IHNlbGYuZ2V0KCd0aWNrUG9pbnRzJyk7XG4gICAgICBwcmVUaWNrUG9pbnQgPSB0aWNrUG9pbnRzW2luZGV4IC0gMV07XG4gICAgfVxuXG4gICAgdmFyIHZlY3RvciA9IFtwb2ludC54IC0gcHJlVGlja1BvaW50LngsIHBvaW50LnkgLSBwcmVUaWNrUG9pbnQueV07XG4gICAgdmFyIG5vcm1hbCA9IHZlYzIubm9ybWFsaXplKFtdLCB2ZWN0b3IpO1xuICAgIHZhciB2ZXJ0aWNhbFZlY3RvciA9IHZlYzIudmVydGljYWwoW10sIG5vcm1hbCwgZmFsc2UpO1xuICAgIHJldHVybiB2ZWMyLnNjYWxlKFtdLCB2ZXJ0aWNhbFZlY3Rvciwgb2Zmc2V0KTtcbiAgfTtcblxuICByZXR1cm4gUG9seWxpbmU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlsaW5lO1xuXG4vKioqLyB9KSxcbi8qIDMxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3VpZGU6IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICBBcmM6IF9fd2VicGFja19yZXF1aXJlX18oMzE1KSxcbiAgRGF0YU1hcmtlcjogX193ZWJwYWNrX3JlcXVpcmVfXygzMTYpLFxuICBEYXRhUmVnaW9uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNyksXG4gIEh0bWw6IF9fd2VicGFja19yZXF1aXJlX18oMzE4KSxcbiAgSW1hZ2U6IF9fd2VicGFja19yZXF1aXJlX18oMzE5KSxcbiAgTGluZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMjApLFxuICBSZWdpb246IF9fd2VicGFja19yZXF1aXJlX18oMzIxKSxcbiAgVGV4dDogX193ZWJwYWNrX3JlcXVpcmVfXygzMjIpXG59O1xuXG4vKioqLyB9KSxcbi8qIDMxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEd1aWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBQSSA9IE1hdGguUEk7XG52YXIgYXRhbiA9IE1hdGguYXRhbjtcblxuZnVuY3Rpb24gY2FsY3VsYXRlQW5nbGUocG9pbnQsIGNlbnRlcikge1xuICB2YXIgeCA9IHBvaW50LnggLSBjZW50ZXIueDtcbiAgdmFyIHkgPSBwb2ludC55IC0gY2VudGVyLnk7XG4gIHZhciBkZWc7XG5cbiAgaWYgKHkgPT09IDApIHtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGRlZyA9IFBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVnID0gMjcwICogUEkgLyAxODA7XG4gICAgfVxuICB9IGVsc2UgaWYgKHggPj0gMCAmJiB5ID4gMCkge1xuICAgIGRlZyA9IFBJICogMiAtIGF0YW4oeCAvIHkpO1xuICB9IGVsc2UgaWYgKHggPD0gMCAmJiB5IDwgMCkge1xuICAgIGRlZyA9IFBJIC0gYXRhbih4IC8geSk7XG4gIH0gZWxzZSBpZiAoeCA+IDAgJiYgeSA8IDApIHtcbiAgICBkZWcgPSBQSSArIGF0YW4oLXggLyB5KTtcbiAgfSBlbHNlIGlmICh4IDwgMCAmJiB5ID4gMCkge1xuICAgIGRlZyA9IGF0YW4oeCAvIC15KTtcbiAgfVxuXG4gIHJldHVybiBkZWc7XG59XG5cbnZhciBBcmMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZSkge1xuICBfaW5oZXJpdHNMb29zZShBcmMsIF9HdWlkZSk7XG5cbiAgZnVuY3Rpb24gQXJjKCkge1xuICAgIHJldHVybiBfR3VpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFyYy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR3VpZGUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqeWFg+e0oOexu+Wei1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbmFtZTogJ2FyYycsXG5cbiAgICAgIC8qKlxuICAgICAgICog6L6F5Yqp5byn57q/55qE6LW35aeL54K5XG4gICAgICAgKiBAdHlwZSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBBcnJheX1cbiAgICAgICAqL1xuICAgICAgc3RhcnQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog6L6F5Yqp5byn57q/55qE57uI5q2i54K5XG4gICAgICAgKiBAdHlwZSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBBcnJheX1cbiAgICAgICAqL1xuICAgICAgZW5kOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqeaWh+acrOeahOagt+W8j+mFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgc3Ryb2tlOiAnIzk5OScsXG4gICAgICAgIGxpbmVXaWR0aDogMVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29vcmQsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ3N0YXJ0JykpO1xuICAgIHZhciBlbmQgPSBzZWxmLnBhcnNlUG9pbnQoY29vcmQsIHNlbGYuZ2V0KCdlbmQnKSk7XG4gICAgdmFyIGNvb3JkQ2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydCgoc3RhcnQueCAtIGNvb3JkQ2VudGVyLngpICogKHN0YXJ0LnggLSBjb29yZENlbnRlci54KSArIChzdGFydC55IC0gY29vcmRDZW50ZXIueSkgKiAoc3RhcnQueSAtIGNvb3JkQ2VudGVyLnkpKTtcbiAgICB2YXIgcGF0aDsgLy8g5aSE55CG5pW05ZyG55qE5oOF5Ya1XG5cbiAgICB2YXIgc3RhcnRBbmdsZSA9IGNhbGN1bGF0ZUFuZ2xlKHN0YXJ0LCBjb29yZENlbnRlcik7XG4gICAgdmFyIGVuZEFuZ2xlID0gY2FsY3VsYXRlQW5nbGUoZW5kLCBjb29yZENlbnRlcik7XG5cbiAgICBpZiAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG4gICAgICBlbmRBbmdsZSArPSBQSSAqIDI7XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNOdW1iZXJFcXVhbChzdGFydC54LCBlbmQueCkgJiYgVXRpbC5pc051bWJlckVxdWFsKHN0YXJ0LnksIGVuZC55KSAmJiAoc2VsZi5nZXQoJ3N0YXJ0JylbMF0gIT09IHNlbGYuZ2V0KCdlbmQnKVswXSB8fCBzZWxmLmdldCgnc3RhcnQnKVsxXSAhPT0gc2VsZi5nZXQoJ2VuZCcpWzFdKSkge1xuICAgICAgcGF0aCA9IFtbJ00nLCBzdGFydC54LCBzdGFydC55XSwgWydBJywgcmFkaXVzLCByYWRpdXMsIDAsIDEsIDEsIDIgKiBjb29yZENlbnRlci54IC0gc3RhcnQueCwgMiAqIGNvb3JkQ2VudGVyLnkgLSBzdGFydC55XSwgWydBJywgcmFkaXVzLCByYWRpdXMsIDAsIDEsIDEsIHN0YXJ0LngsIHN0YXJ0LnldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRBbmdsZSA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICUgKFBJICogMik7XG4gICAgICB2YXIgbGFyZ2VBcmMgPSBkQW5nbGUgPiBQSSA/IDEgOiAwO1xuICAgICAgcGF0aCA9IFtbJ00nLCBzdGFydC54LCBzdGFydC55XSwgWydBJywgcmFkaXVzLCByYWRpdXMsIDAsIGxhcmdlQXJjLCAxLCBlbmQueCwgZW5kLnldXTtcbiAgICB9XG5cbiAgICB2YXIgYXJjU2hhcGUgPSBncm91cC5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIHpJbmRleDogc2VsZi5nZXQoJ3pJbmRleCcpLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSwgc2VsZi5nZXQoJ3N0eWxlJykpXG4gICAgfSk7XG4gICAgYXJjU2hhcGUubmFtZSA9ICdndWlkZS1hcmMnO1xuICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgYXJjU2hhcGUuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgc2VsZi5zZXQoJ2VsJywgYXJjU2hhcGUpO1xuICB9O1xuXG4gIHJldHVybiBBcmM7XG59KEd1aWRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmM7XG5cbi8qKiovIH0pLFxuLyogMzE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIERhdGFNYXJrZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZSkge1xuICBfaW5oZXJpdHNMb29zZShEYXRhTWFya2VyLCBfR3VpZGUpO1xuXG4gIGZ1bmN0aW9uIERhdGFNYXJrZXIoKSB7XG4gICAgcmV0dXJuIF9HdWlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGF0YU1hcmtlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR3VpZGUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICBuYW1lOiAnZGF0YU1hcmtlcicsXG4gICAgICB6SW5kZXg6IDEsXG4gICAgICB0b3A6IHRydWUsXG4gICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgcjogMyxcbiAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXG4gICAgICAgICAgc3Ryb2tlOiAnIzE4OTBGRicsXG4gICAgICAgICAgbGluZVdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBzdHJva2U6ICcjQTNCMUJGJyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDFcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgICAgICBvcGFjaXR5OiAwLjY1LFxuICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICB0ZXh0QWxpZ246ICdzdGFydCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGVuZCBvZiBzdHlsZVxuICAgICAgZGlzcGxheToge1xuICAgICAgICBwb2ludDogdHJ1ZSxcbiAgICAgICAgbGluZTogdHJ1ZSxcbiAgICAgICAgdGV4dDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVMZW5ndGg6IDIwLFxuICAgICAgZGlyZWN0aW9uOiAndXB3YXJkJyxcbiAgICAgIGF1dG9BZGp1c3Q6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkLCBncm91cCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcG9pbnQgPSBzZWxmLnBhcnNlUG9pbnQoY29vcmQsIHNlbGYuZ2V0KCdwb3NpdGlvbicpKTsgLy8gY29udGFpbmVyXG5cbiAgICB2YXIgbWFya2VyR3JvdXAgPSBncm91cC5hZGRHcm91cCgpO1xuICAgIG1hcmtlckdyb3VwLm5hbWUgPSAnZ3VpZGUtZGF0YS1tYXJrZXInOyAvLyBtYXJrZXJHcm91cC50cmFuc2xhdGUocG9pbnQueCwgcG9pbnQueSk7XG5cbiAgICB2YXIgcG9zaXRpb25zID0gc2VsZi5fZ2V0RWxlbWVudFBvc2l0aW9uKHBvaW50KTtcblxuICAgIHZhciBkaXNwbGF5ID0gc2VsZi5nZXQoJ2Rpc3BsYXknKTtcbiAgICB2YXIgbGluZVNoYXBlO1xuICAgIHZhciB0ZXh0U2hhcGU7IC8vIGFkZCBsaW5lXG5cbiAgICBpZiAoZGlzcGxheS5saW5lKSB7XG4gICAgICB2YXIgbGluZURhdGEgPSBwb3NpdGlvbnMubGluZTtcbiAgICAgIGxpbmVTaGFwZSA9IHNlbGYuX2RyYXdMaW5lKGxpbmVEYXRhLCBtYXJrZXJHcm91cCk7XG4gICAgfSAvLyBhZGQgdGV4dFxuXG5cbiAgICBpZiAoZGlzcGxheS50ZXh0ICYmIHNlbGYuZ2V0KCdjb250ZW50JykpIHtcbiAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBwb3NpdGlvbnMudGV4dDtcbiAgICAgIHRleHRTaGFwZSA9IHNlbGYuX2RyYXdUZXh0KHRleHRQb3NpdGlvbiwgbWFya2VyR3JvdXApO1xuICAgIH0gLy8gYWRkIGNpcmNsZVxuXG5cbiAgICBpZiAoZGlzcGxheS5wb2ludCkge1xuICAgICAgdmFyIHBvaW50UG9pc2l0aW9uID0gcG9zaXRpb25zLnBvaW50O1xuXG4gICAgICBzZWxmLl9kcmF3UG9pbnQocG9pbnRQb2lzaXRpb24sIG1hcmtlckdyb3VwKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ2F1dG9BZGp1c3QnKSkge1xuICAgICAgdmFyIGJib3ggPSBtYXJrZXJHcm91cC5nZXRCQm94KCk7XG4gICAgICB2YXIgbWluWCA9IGJib3gubWluWCxcbiAgICAgICAgICBtaW5ZID0gYmJveC5taW5ZLFxuICAgICAgICAgIG1heFggPSBiYm94Lm1heFgsXG4gICAgICAgICAgbWF4WSA9IGJib3gubWF4WTtcbiAgICAgIHZhciBzdGFydCA9IGNvb3JkLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IGNvb3JkLmVuZDtcblxuICAgICAgaWYgKHRleHRTaGFwZSkge1xuICAgICAgICBpZiAobWluWCA8PSBzdGFydC54KSB7XG4gICAgICAgICAgLy8g5bem5L6n6LaF5Ye6XG4gICAgICAgICAgdGV4dFNoYXBlLmF0dHIoJ3RleHRBbGlnbicsICdzdGFydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFggPj0gZW5kLngpIHtcbiAgICAgICAgICAvLyDlj7PkvqfotoXlh7pcbiAgICAgICAgICB0ZXh0U2hhcGUuYXR0cigndGV4dEFsaWduJywgJ2VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHNlbGYuZ2V0KCdkaXJlY3Rpb24nKTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXB3YXJkJyAmJiBtaW5ZIDw9IGVuZC55IHx8IGRpcmVjdGlvbiAhPT0gJ3Vwd2FyZCcgJiYgbWF4WSA+PSBzdGFydC55KSB7XG4gICAgICAgICAgLy8g5LiK5pa55oiW6ICF5LiL5pa56LaF5Ye6XG4gICAgICAgICAgdmFyIHRleHRCYXNlbGluZTtcbiAgICAgICAgICB2YXIgZGlyO1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3Vwd2FyZCcgJiYgbWluWSA8PSBlbmQueSkge1xuICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICBkaXIgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIGRpciA9IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHRTaGFwZS5hdHRyKCd0ZXh0QmFzZWxpbmUnLCB0ZXh0QmFzZWxpbmUpO1xuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gMDtcblxuICAgICAgICAgIGlmIChzZWxmLmdldCgnZGlzcGxheScpLmxpbmUpIHtcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSBzZWxmLmdldCgnbGluZUxlbmd0aCcpO1xuICAgICAgICAgICAgdmFyIGxpbmVQYXRoID0gW1snTScsIHBvaW50LngsIHBvaW50LnldLCBbJ0wnLCBwb2ludC54LCBwb2ludC55ICsgbGluZUxlbmd0aCAqIGRpcl1dO1xuICAgICAgICAgICAgbGluZVNoYXBlLmF0dHIoJ3BhdGgnLCBsaW5lUGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld1kgPSBwb2ludC55ICsgKGxpbmVMZW5ndGggKyAyKSAqIGRpcjtcbiAgICAgICAgICB0ZXh0U2hhcGUuYXR0cigneScsIG5ld1kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSAmJiBtYXJrZXJHcm91cC5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCBzZWxmLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgICBzZWxmLnNldCgnZWwnLCBtYXJrZXJHcm91cCk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRFbGVtZW50UG9zaXRpb24gPSBmdW5jdGlvbiBfZ2V0RWxlbWVudFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB4ID0gcG9zaXRpb24ueCxcbiAgICAgICAgeSA9IHBvc2l0aW9uLnk7XG4gICAgdmFyIGxpbmVMZW5ndGggPSBzZWxmLmdldCgnZGlzcGxheScpLmxpbmUgPyBzZWxmLmdldCgnbGluZUxlbmd0aCcpIDogMDtcbiAgICB2YXIgZGlyZWN0aW9uID0gc2VsZi5nZXQoJ2RpcmVjdGlvbicpO1xuICAgIHZhciB0ZXh0U3R5bGUgPSBzZWxmLmdldCgnc3R5bGUnKS50ZXh0O1xuICAgIHRleHRTdHlsZS50ZXh0QmFzZWxpbmUgPSBkaXJlY3Rpb24gPT09ICd1cHdhcmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB2YXIgZGlyID0gZGlyZWN0aW9uID09PSAndXB3YXJkJyA/IC0xIDogMTtcbiAgICB2YXIgcG9pbnRQb2lzaXRpb24gPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gICAgdmFyIGxpbmVTdGFydCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICB2YXIgbGluZUVuZCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiBsaW5lTGVuZ3RoICogZGlyICsgeVxuICAgIH07XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiAobGluZUxlbmd0aCArIDIpICogZGlyICsgeVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBwb2ludFBvaXNpdGlvbixcbiAgICAgIGxpbmU6IFtsaW5lU3RhcnQsIGxpbmVFbmRdLFxuICAgICAgdGV4dDogdGV4dFBvc2l0aW9uXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2RyYXdMaW5lID0gZnVuY3Rpb24gX2RyYXdMaW5lKGxpbmVEYXRhLCBnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsaW5lU3R5bGUgPSBzZWxmLmdldCgnc3R5bGUnKS5saW5lO1xuICAgIHZhciBsaW5lUGF0aCA9IFtbJ00nLCBsaW5lRGF0YVswXS54LCBsaW5lRGF0YVswXS55XSwgWydMJywgbGluZURhdGFbMV0ueCwgbGluZURhdGFbMV0ueV1dO1xuICAgIHZhciBsaW5lU2hhcGUgPSBnLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgcGF0aDogbGluZVBhdGhcbiAgICAgIH0sIGxpbmVTdHlsZSlcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZVNoYXBlO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd1RleHQgPSBmdW5jdGlvbiBfZHJhd1RleHQocG9zaXRpb24sIGcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRleHRTdHlsZSA9IHRoaXMuZ2V0KCdzdHlsZScpLnRleHQ7XG4gICAgdmFyIHRleHRTaGFwZSA9IGcuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB0ZXh0OiBzZWxmLmdldCgnY29udGVudCcpXG4gICAgICB9LCB0ZXh0U3R5bGUsIHBvc2l0aW9uKVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0U2hhcGU7XG4gIH07XG5cbiAgX3Byb3RvLl9kcmF3UG9pbnQgPSBmdW5jdGlvbiBfZHJhd1BvaW50KHBvc2l0aW9uLCBnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwb2ludFN0eWxlID0gc2VsZi5nZXQoJ3N0eWxlJykucG9pbnQ7XG4gICAgdmFyIHBvaW50U2hhcGUgPSBnLmFkZFNoYXBlKCdjaXJjbGUnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe30sIHBvaW50U3R5bGUsIHBvc2l0aW9uKVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBEYXRhTWFya2VyO1xufShHdWlkZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1hcmtlcjtcblxuLyoqKi8gfSksXG4vKiAzMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Nik7XG5cbnZhciBHdWlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgRGF0YVJlZ2lvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0d1aWRlKSB7XG4gIF9pbmhlcml0c0xvb3NlKERhdGFSZWdpb24sIF9HdWlkZSk7XG5cbiAgZnVuY3Rpb24gRGF0YVJlZ2lvbigpIHtcbiAgICByZXR1cm4gX0d1aWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXRhUmVnaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HdWlkZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIG5hbWU6ICdkYXRhUmVnaW9uJyxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgLy8g5Y+q5pSv5oyB5pWw5YC8XG4gICAgICBlbmQ6IG51bGwsXG4gICAgICAvLyDlj6rmlK/mjIHmlbDlgLxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgLy8g5paH5pys5YaF5a65XG4gICAgICBzdHlsZToge1xuICAgICAgICByZWdpb246IHtcbiAgICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuICAgICAgICAgIG9wYWNpdHk6IDAuMDRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnYm90dG9tJyxcbiAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgZmlsbDogJ3JnYmEoMCwgMCwgMCwgLjY1KSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29vcmQsIGdyb3VwLCBkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBkcmF3IHJlZ2lvblxuXG4gICAgdmFyIGxpbmVMZW5ndGggPSBzZWxmLmdldCgnbGluZUxlbmd0aCcpIHx8IDA7IC8vIFRPRE86IOWmguS9leWRveWQjVxuXG4gICAgdmFyIHJlZ2lvbkRhdGEgPSBzZWxmLl9nZXRSZWdpb25EYXRhKGNvb3JkLCBkYXRhKTtcblxuICAgIGlmICghcmVnaW9uRGF0YS5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciByZWdpb25CQm94ID0gc2VsZi5fZ2V0QkJveChyZWdpb25EYXRhKTtcblxuICAgIHZhciBwYXRoID0gW107XG4gICAgcGF0aC5wdXNoKFsnTScsIHJlZ2lvbkRhdGFbMF0ueCwgcmVnaW9uQkJveC55TWluIC0gbGluZUxlbmd0aF0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlZ2lvbkRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwID0gWydMJywgcmVnaW9uRGF0YVtpXS54LCByZWdpb25EYXRhW2ldLnldO1xuICAgICAgcGF0aC5wdXNoKHApO1xuICAgIH1cblxuICAgIHBhdGgucHVzaChbJ0wnLCByZWdpb25EYXRhW3JlZ2lvbkRhdGEubGVuZ3RoIC0gMV0ueCwgcmVnaW9uQkJveC55TWluIC0gbGluZUxlbmd0aF0pOyAvLyBkcmF3XG5cbiAgICB2YXIgc3R5bGUgPSBzZWxmLmdldCgnc3R5bGUnKTtcbiAgICB2YXIgcmVnaW9uU3R5bGUgPSBzdHlsZS5yZWdpb247IC8vIOWFvOWuueS5i+WJjeeahOWGmeazlVxuXG4gICAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLnRleHQ7XG4gICAgdmFyIHJlZ2lvbkdyb3VwID0gZ3JvdXAuYWRkR3JvdXAoKTtcbiAgICByZWdpb25Hcm91cC5uYW1lID0gJ2d1aWRlLWRhdGEtcmVnaW9uJztcbiAgICByZWdpb25Hcm91cC5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0sIHJlZ2lvblN0eWxlKVxuICAgIH0pO1xuICAgIHZhciBjb250ZW50ID0gc2VsZi5nZXQoJ2NvbnRlbnQnKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICByZWdpb25Hcm91cC5hZGRTaGFwZSgnVGV4dCcsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICB4OiAocmVnaW9uQkJveC54TWluICsgcmVnaW9uQkJveC54TWF4KSAvIDIsXG4gICAgICAgICAgeTogcmVnaW9uQkJveC55TWluIC0gbGluZUxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiBjb250ZW50XG4gICAgICAgIH0sIHRleHRTdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgcmVnaW9uR3JvdXAuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgc2VsZi5zZXQoJ2VsJywgcmVnaW9uR3JvdXApO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0UmVnaW9uRGF0YSA9IGZ1bmN0aW9uIF9nZXRSZWdpb25EYXRhKGNvb3JkLCBkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYuZ2V0KCdzdGFydCcpO1xuICAgIHZhciBlbmQgPSBzZWxmLmdldCgnZW5kJyk7XG4gICAgdmFyIHhGaWVsZCA9IEhlbHBlci5nZXRGaXJzdFNjYWxlKHNlbGYuZ2V0KCd4U2NhbGVzJykpLmZpZWxkO1xuICAgIHZhciB5RmllbGQgPSBIZWxwZXIuZ2V0Rmlyc3RTY2FsZShzZWxmLmdldCgneVNjYWxlcycpKS5maWVsZDtcbiAgICB2YXIgc3RhcnRYVmFsdWUgPSBVdGlsLmlzQXJyYXkoc3RhcnQpID8gc3RhcnRbMF0gOiBzdGFydFt4RmllbGRdO1xuICAgIHZhciBlbmRYVmFsdWUgPSBVdGlsLmlzQXJyYXkoZW5kKSA/IGVuZFswXSA6IGVuZFt4RmllbGRdO1xuICAgIHZhciBzdGFydEluZGV4O1xuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaV07XG5cbiAgICAgIGlmIChpdGVtW3hGaWVsZF0gPT09IHN0YXJ0WFZhbHVlKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGFyci5wdXNoKHNlbGYucGFyc2VQb2ludChjb29yZCwgW2l0ZW1beEZpZWxkXSwgaXRlbVt5RmllbGRdXSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVt4RmllbGRdID09PSBlbmRYVmFsdWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBfcHJvdG8uX2dldEJCb3ggPSBmdW5jdGlvbiBfZ2V0QkJveChkYXRhKSB7XG4gICAgdmFyIHhzID0gW107XG4gICAgdmFyIHlzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHhzLnB1c2goZGF0YVtpXS54KTtcbiAgICAgIHlzLnB1c2goZGF0YVtpXS55KTtcbiAgICB9XG5cbiAgICB2YXIgeFJhbmdlID0gVXRpbC5hcnJheVV0aWwuZ2V0UmFuZ2UoeHMpO1xuICAgIHZhciB5UmFuZ2UgPSBVdGlsLmFycmF5VXRpbC5nZXRSYW5nZSh5cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhNaW46IHhSYW5nZS5taW4sXG4gICAgICB4TWF4OiB4UmFuZ2UubWF4LFxuICAgICAgeU1pbjogeVJhbmdlLm1pbixcbiAgICAgIHlNYXg6IHlSYW5nZS5tYXhcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBEYXRhUmVnaW9uO1xufShHdWlkZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVJlZ2lvbjtcblxuLyoqKi8gfSksXG4vKiAzMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBEb21VdGlsID0gVXRpbC5Eb21VdGlsO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIEh0bWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZSkge1xuICBfaW5oZXJpdHNMb29zZShIdG1sLCBfR3VpZGUpO1xuXG4gIGZ1bmN0aW9uIEh0bWwoKSB7XG4gICAgcmV0dXJuIF9HdWlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSHRtbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR3VpZGUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICBuYW1lOiAnaHRtbCcsXG4gICAgICB6SW5kZXg6IDcsXG4gICAgICBwb3NpdGlvbjogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBIb3Jpem9udGFsIGFsaWdubWVudCwgY2FuIGJlICdsZWZ0J+OAgSdtaWRkbGUn44CBJ3JpZ2h0J1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgYWxpZ25YOiAnbWlkZGxlJyxcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBhbGlnbm1lbnQsIGNhbiBiZSAndG9wJ+OAgSdtaWRkbGUn44CBJ2JvdHRvbSdcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGFsaWduWTogJ21pZGRsZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogSG9yaXpvbnRhbCBvZmZzZXRcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG9mZnNldFg6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVmVydGljYWwgb2Zmc2V0XG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBvZmZzZXRZOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICogaHRtbCBjb250ZW50XG4gICAgICAqQHR5cGUge1N0cmluZyB8IEZ1bmN0aW9ufVxuICAgICAgKi9cbiAgICAgIGh0bWw6IG51bGxcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIHJlbmRlciBIdG1sIEd1aWRlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkIHRoZSBpbnN0YW5jZSBvZiBDb29yZGluYXRlIGNsYXNzXG4gICAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXIgdGhlIGNvbnRhaW5lciB3aGljaCBjb250YWluIHRoZSBndWlkZSBjb21wb25lbnRcbiAgICovXG5cblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBvc2l0aW9uID0gc2VsZi5wYXJzZVBvaW50KGNvb3JkLCBzZWxmLmdldCgncG9zaXRpb24nKSk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBjb250YWluZXIuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJykucGFyZW50Tm9kZTtcbiAgICB2YXIgd3JhcHBlck5vZGUgPSBEb21VdGlsLmNyZWF0ZURvbSgnPGRpdiBjbGFzcz1cImctZ3VpZGVcIj48L2Rpdj4nKTtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHdyYXBwZXJOb2RlKTtcbiAgICB2YXIgaHRtbCA9IHNlbGYuZ2V0KCdodG1sQ29udGVudCcpIHx8IHNlbGYuZ2V0KCdodG1sJyk7XG5cbiAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICB2YXIgeFNjYWxlcyA9IHNlbGYuZ2V0KCd4U2NhbGVzJyk7XG4gICAgICB2YXIgeVNjYWxlcyA9IHNlbGYuZ2V0KCd5U2NhbGVzJyk7XG4gICAgICBodG1sID0gaHRtbCh4U2NhbGVzLCB5U2NhbGVzKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbE5vZGUgPSBEb21VdGlsLmNyZWF0ZURvbShodG1sKTtcbiAgICB3cmFwcGVyTm9kZS5hcHBlbmRDaGlsZChodG1sTm9kZSk7XG4gICAgRG9tVXRpbC5tb2RpZnlDU1Mod3JhcHBlck5vZGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnIC8vIHRvIGZpeCBkb20gaW4gdGhlIGRvY3VtZW50IHN0cmVhbSB0byBnZXQgdGhlIHRydWUgd2lkdGhcblxuICAgIH0pO1xuXG4gICAgc2VsZi5fc2V0RG9tUG9zaXRpb24od3JhcHBlck5vZGUsIGh0bWxOb2RlLCBwb3NpdGlvbik7XG5cbiAgICBzZWxmLnNldCgnZWwnLCB3cmFwcGVyTm9kZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9zZXREb21Qb3NpdGlvbiA9IGZ1bmN0aW9uIF9zZXREb21Qb3NpdGlvbihwYXJlbnREb20sIGNoaWxkRG9tLCBwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWxpZ25YID0gc2VsZi5nZXQoJ2FsaWduWCcpO1xuICAgIHZhciBhbGlnblkgPSBzZWxmLmdldCgnYWxpZ25ZJyk7XG4gICAgdmFyIGRvbVdpZHRoID0gRG9tVXRpbC5nZXRPdXRlcldpZHRoKGNoaWxkRG9tKTtcbiAgICB2YXIgZG9tSGVpZ2h0ID0gRG9tVXRpbC5nZXRPdXRlckhlaWdodChjaGlsZERvbSk7XG4gICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgeDogcG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnlcbiAgICB9O1xuXG4gICAgaWYgKGFsaWduWCA9PT0gJ21pZGRsZScgJiYgYWxpZ25ZID09PSAndG9wJykge1xuICAgICAgcG9zaXRpb24ueCAtPSBNYXRoLnJvdW5kKGRvbVdpZHRoIC8gMik7XG4gICAgfSBlbHNlIGlmIChhbGlnblggPT09ICdtaWRkbGUnICYmIGFsaWduWSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHBvc2l0aW9uLnggLT0gTWF0aC5yb3VuZChkb21XaWR0aCAvIDIpO1xuICAgICAgcG9zaXRpb24ueSAtPSBNYXRoLnJvdW5kKGRvbUhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChhbGlnblggPT09ICdsZWZ0JyAmJiBhbGlnblkgPT09ICdib3R0b20nKSB7XG4gICAgICBwb3NpdGlvbi55IC09IE1hdGgucm91bmQoZG9tSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ2xlZnQnICYmIGFsaWduWSA9PT0gJ21pZGRsZScpIHtcbiAgICAgIHBvc2l0aW9uLnkgLT0gTWF0aC5yb3VuZChkb21IZWlnaHQgLyAyKTtcbiAgICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ2xlZnQnICYmIGFsaWduWSA9PT0gJ3RvcCcpIHtcbiAgICAgIHBvc2l0aW9uLnggPSBwb2ludC54O1xuICAgICAgcG9zaXRpb24ueSA9IHBvaW50Lnk7XG4gICAgfSBlbHNlIGlmIChhbGlnblggPT09ICdyaWdodCcgJiYgYWxpZ25ZID09PSAnYm90dG9tJykge1xuICAgICAgcG9zaXRpb24ueCAtPSBNYXRoLnJvdW5kKGRvbVdpZHRoKTtcbiAgICAgIHBvc2l0aW9uLnkgLT0gTWF0aC5yb3VuZChkb21IZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoYWxpZ25YID09PSAncmlnaHQnICYmIGFsaWduWSA9PT0gJ21pZGRsZScpIHtcbiAgICAgIHBvc2l0aW9uLnggLT0gTWF0aC5yb3VuZChkb21XaWR0aCk7XG4gICAgICBwb3NpdGlvbi55IC09IE1hdGgucm91bmQoZG9tSGVpZ2h0IC8gMik7XG4gICAgfSBlbHNlIGlmIChhbGlnblggPT09ICdyaWdodCcgJiYgYWxpZ25ZID09PSAndG9wJykge1xuICAgICAgcG9zaXRpb24ueCAtPSBNYXRoLnJvdW5kKGRvbVdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g6buY6K6k5L2N5LqO5Lit5b+D54K5XG4gICAgICBwb3NpdGlvbi54IC09IE1hdGgucm91bmQoZG9tV2lkdGggLyAyKTtcbiAgICAgIHBvc2l0aW9uLnkgLT0gTWF0aC5yb3VuZChkb21IZWlnaHQgLyAyKTtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0WCA9IHNlbGYuZ2V0KCdvZmZzZXRYJyk7XG5cbiAgICBpZiAob2Zmc2V0WCkge1xuICAgICAgcG9zaXRpb24ueCArPSBvZmZzZXRYO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRZID0gc2VsZi5nZXQoJ29mZnNldFknKTtcblxuICAgIGlmIChvZmZzZXRZKSB7XG4gICAgICBwb3NpdGlvbi55ICs9IG9mZnNldFk7XG4gICAgfVxuXG4gICAgRG9tVXRpbC5tb2RpZnlDU1MocGFyZW50RG9tLCB7XG4gICAgICB0b3A6IE1hdGgucm91bmQocG9zaXRpb24ueSkgKyAncHgnLFxuICAgICAgbGVmdDogTWF0aC5yb3VuZChwb3NpdGlvbi54KSArICdweCcsXG4gICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgICB6SW5kZXg6IHNlbGYuZ2V0KCd6SW5kZXgnKVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogY2xlYXIgaHRtbCBndWlkZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gc2VsZi5nZXQoJ2VsJyk7XG4gICAgZWwgJiYgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfTtcblxuICByZXR1cm4gSHRtbDtcbn0oR3VpZGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw7XG5cbi8qKiovIH0pLFxuLyogMzE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIEltYWdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3VpZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW1hZ2UsIF9HdWlkZSk7XG5cbiAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgcmV0dXJuIF9HdWlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW1hZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0d1aWRlLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgdHlwZTogJ2ltYWdlJyxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgc3RhcnQgb2YgaW1hZ2VcbiAgICAgICAqIEB0eXBlIHtPYmplY3QgfCBGdW5jdGlvbiB8IEFycmF5fVxuICAgICAgICovXG4gICAgICBzdGFydDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgZW5kIG9mIGltYWdlXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBBcnJheX1cbiAgICAgICAqL1xuICAgICAgZW5kOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIGltYWdlIHVybFxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgc3JjOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIEhvcml6b250YWwgb2Zmc2V0XG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBvZmZzZXRYOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFZlcnRpY2FsIG9mZnNldFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0WTogbnVsbFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29vcmQsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ3N0YXJ0JykpO1xuICAgIHZhciBjZmcgPSB7XG4gICAgICB4OiBzdGFydC54LFxuICAgICAgeTogc3RhcnQueVxuICAgIH07XG4gICAgY2ZnLmltZyA9IHNlbGYuZ2V0KCdzcmMnKTtcblxuICAgIGlmICghc2VsZi5nZXQoJ2VuZCcpKSB7XG4gICAgICAvLyDlpoLmnpzlkqnmnInmjIflrprnu5PmnZ/ngrnvvIzliJkgc3RhcnQg5Li65Zu+54mH55qE5bem5LiK6KeS5Z2Q5qCHXG4gICAgICBjZmcud2lkdGggPSBzZWxmLmdldCgnd2lkdGgnKSB8fCAzMjtcbiAgICAgIGNmZy5oZWlnaHQgPSBzZWxmLmdldCgnaGVpZ2h0JykgfHwgMzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmQgPSBzZWxmLnBhcnNlUG9pbnQoY29vcmQsIHNlbGYuZ2V0KCdlbmQnKSk7IC8vIGNmZy53aWR0aCA9IE1hdGguYWJzKGVuZC54IC0gc3RhcnQueCk7XG4gICAgICAvLyBjZmcuaGVpZ2h0ID0gTWF0aC5hYnMoZW5kLnkgLSBzdGFydC55KTtcblxuICAgICAgY2ZnLndpZHRoID0gZW5kLnggLSBzdGFydC54O1xuICAgICAgY2ZnLmhlaWdodCA9IGVuZC55IC0gc3RhcnQueTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ29mZnNldFgnKSkge1xuICAgICAgY2ZnLnggKz0gc2VsZi5nZXQoJ29mZnNldFgnKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ29mZnNldFknKSkge1xuICAgICAgY2ZnLnkgKz0gc2VsZi5nZXQoJ29mZnNldFknKTtcbiAgICB9XG5cbiAgICB2YXIgaW1nR3VpZGUgPSBncm91cC5hZGRTaGFwZSgnSW1hZ2UnLCB7XG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBhdHRyczogY2ZnXG4gICAgfSk7XG4gICAgaW1nR3VpZGUubmFtZSA9ICdndWlkZS1pbWFnZSc7XG4gICAgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSAmJiBpbWdHdWlkZS5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCBzZWxmLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgICBzZWxmLnNldCgnZWwnLCBpbWdHdWlkZSk7XG4gIH07XG5cbiAgcmV0dXJuIEltYWdlO1xufShHdWlkZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2U7XG5cbi8qKiovIH0pLFxuLyogMzIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIHZlYzIgPSBVdGlsLk1hdHJpeFV0aWwudmVjMjtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCksXG4gICAgRk9OVF9GQU1JTFkgPSBfcmVxdWlyZS5GT05UX0ZBTUlMWTtcblxudmFyIExpbmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZSkge1xuICBfaW5oZXJpdHNMb29zZShMaW5lLCBfR3VpZGUpO1xuXG4gIGZ1bmN0aW9uIExpbmUoKSB7XG4gICAgcmV0dXJuIF9HdWlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR3VpZGUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqeWFg+e0oOexu+Wei1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbmFtZTogJ2xpbmUnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqee6v+eahOi1t+eCueS9jee9rlxuICAgICAgICogQHR5cGUge09iamVjdCB8IEZ1bmN0aW9uIHwgQXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHN0YXJ0OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqee6v+eahOe7iOeCueS9jee9rlxuICAgICAgICogQHR5cGUge09iamVjdCB8IEZ1bmN0aW9uIHwgQXJyYXl9XG4gICAgICAgKi9cbiAgICAgIGVuZDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDovoXliqnnur/nmoTlm77lvaLmoLflvI9cbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgbGluZVdpZHRoOiAxXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqeaWh+acrOmFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgdGV4dDoge1xuICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgIC8vIOaWh+acrOeahOaYvuekuuS9jee9ru+8miBzdGFydCAvIGNlbnRlciAvIGVuZCAvIOeZvuWIhuavlFxuICAgICAgICBhdXRvUm90YXRlOiB0cnVlLFxuICAgICAgICAvLyDmlofmnKzmmK/lkKbmsr/nnYDovoXliqnnur/nmoTmlrnlkJHoh6rliqjml4vovaxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBmaWxsOiAnIzk5OScsXG4gICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWVxuICAgICAgICB9LFxuICAgICAgICAvLyDovoXliqnmlofmnKznmoTmoLflvI9cbiAgICAgICAgY29udGVudDogbnVsbCAvLyDovoXliqnmlofmnKznmoTmloflrZdcblxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29vcmQsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ3N0YXJ0JykpO1xuICAgIHZhciBlbmQgPSBzZWxmLnBhcnNlUG9pbnQoY29vcmQsIHNlbGYuZ2V0KCdlbmQnKSk7XG4gICAgdmFyIGd1aWRlTGluZUdyb3VwID0gZ3JvdXAuYWRkR3JvdXAoe1xuICAgICAgdmlld0lkOiBncm91cC5nZXQoJ3ZpZXdJZCcpXG4gICAgfSk7XG5cbiAgICBzZWxmLl9kcmF3TGluZXMoc3RhcnQsIGVuZCwgZ3VpZGVMaW5lR3JvdXApO1xuXG4gICAgdmFyIHRleHQgPSBzZWxmLmdldCgndGV4dCcpO1xuXG4gICAgaWYgKHRleHQgJiYgdGV4dC5jb250ZW50KSB7XG4gICAgICBzZWxmLl9kcmF3VGV4dChzdGFydCwgZW5kLCBndWlkZUxpbmVHcm91cCk7XG4gICAgfVxuXG4gICAgc2VsZi5zZXQoJ2VsJywgZ3VpZGVMaW5lR3JvdXApO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd0xpbmVzID0gZnVuY3Rpb24gX2RyYXdMaW5lcyhzdGFydCwgZW5kLCBncm91cCkge1xuICAgIHZhciBwYXRoID0gW1snTScsIHN0YXJ0LngsIHN0YXJ0LnldLCBbJ0wnLCBlbmQueCwgZW5kLnldXTtcbiAgICB2YXIgZ3VpZGVMaW5lID0gZ3JvdXAuYWRkU2hhcGUoJ1BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9LCB0aGlzLmdldCgnbGluZVN0eWxlJykpXG4gICAgfSk7XG4gICAgZ3VpZGVMaW5lLm5hbWUgPSAnZ3VpZGUtbGluZSc7XG4gICAgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSAmJiBndWlkZUxpbmUuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9kcmF3VGV4dCA9IGZ1bmN0aW9uIF9kcmF3VGV4dChzdGFydCwgZW5kLCBncm91cCkge1xuICAgIHZhciB0ZXh0Q2ZnID0gdGhpcy5nZXQoJ3RleHQnKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0ZXh0Q2ZnLnBvc2l0aW9uO1xuICAgIHZhciB0ZXh0U3R5bGUgPSB0ZXh0Q2ZnLnN0eWxlIHx8IHt9O1xuICAgIHZhciBwZXJjZW50O1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgcGVyY2VudCA9IDAuNTtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNTdHJpbmcocG9zaXRpb24pICYmIHBvc2l0aW9uLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHBlcmNlbnQgPSBwYXJzZUludChwb3NpdGlvbiwgMTApIC8gMTAwO1xuICAgIH0gZWxzZSBpZiAoVXRpbC5pc051bWJlcihwb3NpdGlvbikpIHtcbiAgICAgIHBlcmNlbnQgPSBwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyY2VudCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHBlcmNlbnQgPiAxIHx8IHBlcmNlbnQgPCAwKSB7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2ZnID0ge1xuICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogcGVyY2VudCxcbiAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAqIHBlcmNlbnRcbiAgICB9O1xuXG4gICAgaWYgKHRleHRDZmcub2Zmc2V0WCkge1xuICAgICAgLy8g6K6+572u5LqG5YGP56e76YePXG4gICAgICBjZmcueCArPSB0ZXh0Q2ZnLm9mZnNldFg7XG4gICAgfVxuXG4gICAgaWYgKHRleHRDZmcub2Zmc2V0WSkge1xuICAgICAgLy8g6K6+572u5LqG5YGP56e76YePXG4gICAgICBjZmcueSArPSB0ZXh0Q2ZnLm9mZnNldFk7XG4gICAgfVxuXG4gICAgY2ZnLnRleHQgPSB0ZXh0Q2ZnLmNvbnRlbnQ7XG4gICAgY2ZnID0gVXRpbC5taXgoe30sIGNmZywgdGV4dFN0eWxlKTtcblxuICAgIGlmICh0ZXh0Q2ZnLmF1dG9Sb3RhdGUgJiYgVXRpbC5pc05pbCh0ZXh0U3R5bGUucm90YXRlKSkge1xuICAgICAgLy8g6Ieq5Yqo5peL6L2s5LiU55So5oi35rKh5pyJ6K6+572u5peL6L2s6KeS5bqmXG4gICAgICB2YXIgYW5nbGUgPSB2ZWMyLmFuZ2xlVG8oW2VuZC54IC0gc3RhcnQueCwgZW5kLnkgLSBzdGFydC55XSwgWzEsIDBdLCAxKTtcbiAgICAgIGNmZy5yb3RhdGUgPSBhbmdsZTtcbiAgICB9IGVsc2UgaWYgKCFVdGlsLmlzTmlsKHRleHRTdHlsZS5yb3RhdGUpKSB7XG4gICAgICAvLyDnlKjmiLforr7nva7kuobml4vovazop5LluqZcbiAgICAgIGNmZy5yb3RhdGUgPSB0ZXh0U3R5bGUucm90YXRlICogTWF0aC5QSSAvIDE4MDtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBncm91cC5hZGRTaGFwZSgnVGV4dCcsIHtcbiAgICAgIGF0dHJzOiBjZmdcbiAgICB9KTtcbiAgICBzaGFwZS5uYW1lID0gJ2d1aWRlLWxpbmUtdGV4dCc7XG4gICAgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSAmJiBzaGFwZS5zZXRTaWxlbnQoJ2FwcGVuZEluZm8nLCB0aGlzLmdldCgnYXBwZW5kSW5mbycpKTtcbiAgfTtcblxuICByZXR1cm4gTGluZTtcbn0oR3VpZGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0pLFxuLyogMzIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIFJlZ2lvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0d1aWRlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlZ2lvbiwgX0d1aWRlKTtcblxuICBmdW5jdGlvbiBSZWdpb24oKSB7XG4gICAgcmV0dXJuIF9HdWlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVnaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HdWlkZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIG5hbWU6ICdyZWdpb24nLFxuICAgICAgekluZGV4OiAxLFxuICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICBlbmQ6IG51bGwsXG4gICAgICBzdHlsZToge1xuICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgIGZpbGw6ICcjQ0NEN0VCJyxcbiAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgZ3JvdXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlY3RTdHlsZSA9IHNlbGYuZ2V0KCdzdHlsZScpO1xuXG4gICAgdmFyIHBhdGggPSBzZWxmLl9nZXRQYXRoKGNvb3JkKTtcblxuICAgIHZhciByZWdpb25Hcm91cCA9IGdyb3VwLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgekluZGV4OiBzZWxmLmdldCgnekluZGV4JyksXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9LCByZWN0U3R5bGUpXG4gICAgfSk7XG4gICAgcmVnaW9uR3JvdXAubmFtZSA9ICdndWlkZS1yZWdpb24nO1xuICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgcmVnaW9uR3JvdXAuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgc2VsZi5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgc2VsZi5zZXQoJ2VsJywgcmVnaW9uR3JvdXApO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0UGF0aCA9IGZ1bmN0aW9uIF9nZXRQYXRoKGNvb3JkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ3N0YXJ0JykpO1xuICAgIHZhciBlbmQgPSBzZWxmLnBhcnNlUG9pbnQoY29vcmQsIHNlbGYuZ2V0KCdlbmQnKSk7XG4gICAgdmFyIHBhdGggPSBbWydNJywgc3RhcnQueCwgc3RhcnQueV0sIFsnTCcsIGVuZC54LCBzdGFydC55XSwgWydMJywgZW5kLngsIGVuZC55XSwgWydMJywgc3RhcnQueCwgZW5kLnldLCBbJ3onXV07XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcmV0dXJuIFJlZ2lvbjtcbn0oR3VpZGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lvbjtcblxuLyoqKi8gfSksXG4vKiAzMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBHdWlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgVGV4dCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0d1aWRlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRleHQsIF9HdWlkZSk7XG5cbiAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICByZXR1cm4gX0d1aWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HdWlkZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIC8qKlxuICAgICAgICog6L6F5Yqp5YWD57Sg57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBuYW1lOiAndGV4dCcsXG5cbiAgICAgIC8qKlxuICAgICAgICog6L6F5Yqp5paH5pys55qE5L2N572uXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0IHwgRnVuY3Rpb24gfCBBcnJheX1cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog6L6F5Yqp5paH5pys55qE5pi+56S65paH5a2XXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBjb250ZW50OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOi+heWKqeaWh+acrOeahOagt+W8j+mFjee9rlxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyM5OTknLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB4IOaWueWQkeeahOWBj+enu+mHj1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0WDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiB5IOaWueWQkeeahOWBj+enu+mHj1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2Zmc2V0WTogbnVsbCxcbiAgICAgIHRvcDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY29vcmQsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwb2ludCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ3Bvc2l0aW9uJykpO1xuICAgIHZhciB0ZXh0U3R5bGUgPSBVdGlsLm1peCh7fSwgc2VsZi5nZXQoJ3N0eWxlJykpO1xuICAgIHZhciBvZmZzZXRYID0gc2VsZi5nZXQoJ29mZnNldFgnKTtcbiAgICB2YXIgb2Zmc2V0WSA9IHNlbGYuZ2V0KCdvZmZzZXRZJyk7XG5cbiAgICBpZiAob2Zmc2V0WCkge1xuICAgICAgcG9pbnQueCArPSBvZmZzZXRYO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRZKSB7XG4gICAgICBwb2ludC55ICs9IG9mZnNldFk7XG4gICAgfVxuXG4gICAgaWYgKHRleHRTdHlsZS5yb3RhdGUpIHtcbiAgICAgIHRleHRTdHlsZS5yb3RhdGUgPSB0ZXh0U3R5bGUucm90YXRlICogTWF0aC5QSSAvIDE4MDsgLy8g5bCG6KeS5bqm6L2s5o2i5Li65byn5bqmXG4gICAgfVxuXG4gICAgdmFyIGd1aWRlVGV4dCA9IGdyb3VwLmFkZFNoYXBlKCdUZXh0Jywge1xuICAgICAgekluZGV4OiBzZWxmLmdldCgnekluZGV4JyksXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB0ZXh0OiBzZWxmLmdldCgnY29udGVudCcpXG4gICAgICB9LCB0ZXh0U3R5bGUsIHBvaW50KVxuICAgIH0pO1xuICAgIGd1aWRlVGV4dC5uYW1lID0gJ2d1aWRlLXRleHQnO1xuICAgIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykgJiYgZ3VpZGVUZXh0LnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICAgIHNlbGYuc2V0KCdlbCcsIGd1aWRlVGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFRleHQ7XG59KEd1aWRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDMyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTGFiZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGFiZWw7XG5cbi8qKiovIH0pLFxuLyogMzI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBUaGUgZW50cnkgb2YgbGVnZW5kXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhdGVnb3J5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NyksXG4gIC8vIOWIhuexu+WbvuS+i1xuICBDYXRIdG1sOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OSksXG4gIC8vIOWIhuexu+WbvuS+i1xuICBDYXRQYWdlSHRtbDogX193ZWJwYWNrX3JlcXVpcmVfXygzMjUpLFxuICAvLyDliIbnsbvlm77kvotcbiAgLy8gVGFpbDogcmVxdWlyZSgnLi90YWlsJyksIC8vIOWwvumDqOi3n+maj+WbvuS+i1xuICBDb2xvcjogX193ZWJwYWNrX3JlcXVpcmVfXygzMjYpLFxuICAvLyDpopzoibLlm77kvotcbiAgU2l6ZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMjgpLFxuICAvLyDlpKflsI/lm77kvovvvIjpgILnlKjkuo7pmaTmmKDlsITngrnlpKflsI/ku6XlpJbnmoTlhbbku5blpKflsI/vvIlcbiAgQ2lyY2xlU2l6ZTogX193ZWJwYWNrX3JlcXVpcmVfXygzMjkpIC8vIOeCueWkp+Wwj+WbvuS+i1xuXG59O1xuXG4vKioqLyB9KSxcbi8qIDMyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIENhdEh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OSk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLFxuICAgIEZPTlRfRkFNSUxZID0gX3JlcXVpcmUuRk9OVF9GQU1JTFk7XG5cbnZhciBEb21VdGlsID0gVXRpbC5Eb21VdGlsO1xudmFyIExJU1RfQ0xBU1MgPSAnZzItbGVnZW5kLWxpc3QnO1xudmFyIENPTlRBSU5FUl9DTEFTUyA9ICdnMi1sZWdlbmQnO1xudmFyIFNMSVBfQ0xBU1MgPSAnZzItc2xpcCc7XG52YXIgQ0FSRVRfVVBfQ0xBU1MgPSAnZzItY2FyZXQtdXAnO1xudmFyIENBUkVUX0RPV05fQ0xBU1MgPSAnZzItY2FyZXQtZG93bic7XG52YXIgRU5BQkxFRF9DQVJFVF9DT0xPUiA9ICdyZ2JhKDAsMCwwLDAuNjUpJztcbnZhciBESVNBQkxFRF9DQVJFVF9DT0xPUiA9ICdyZ2JhKDAsMCwwLDAuMjUpJztcblxuZnVuY3Rpb24gZmluZE5vZGVCeUNsYXNzKG5vZGUsIGNsYXNzTmFtZSkge1xuICByZXR1cm4gbm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlbMF07XG59XG5cbnZhciBDYXRQYWdlSHRtbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NhdEh0bWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2F0UGFnZUh0bWwsIF9DYXRIdG1sKTtcblxuICBmdW5jdGlvbiBDYXRQYWdlSHRtbCgpIHtcbiAgICByZXR1cm4gX0NhdEh0bWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhdFBhZ2VIdG1sLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9DYXRIdG1sLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgKiB0eXBl5qCH6K+GXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0eXBlOiAnY2F0ZWdvcnktcGFnZS1sZWdlbmQnLFxuXG4gICAgICAvKipcbiAgICAgICAqIGh0bWwg5a655ZmoXG4gICAgICAgKiBAdHlwZSB7RE9NfVxuICAgICAgICovXG4gICAgICBjb250YWluZXI6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5ZCR5LiKIC8g5LiL57+76aG15Zu+5qCH55qE5qC35byPXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIGNhcmV0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMC42NSknXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOmhteeggeaWh+Wtl+eahOagt+W8j1xuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICBwYWdlTnVtU3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgIGZvbnRGYW1pbHk6IEZPTlRfRkFNSUxZLFxuICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiDnv7vpobXlnZcgRE9NIOeahOagt+W8j1xuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICBzbGlwRG9tU3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOe/u+mhteWdlyBET01cbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHNsaXBUcGw6ICc8ZGl2IGNsYXNzPVwiJyArIFNMSVBfQ0xBU1MgKyAnXCIgPicgKyAnPHN2ZyB2aWV3Qm94PVwiNjQgNjQgODk2IDg5NlwiIGNsYXNzPVwiZzItY2FyZXQtdXBcIiBkYXRhLWljb249XCJsZWZ0XCIgd2lkdGg9XCIxZW1cIiBoZWlnaHQ9XCIxZW1cIiBhcmlhLWhpZGRlbj1cInRydWVcIj4nICsgJzxwYXRoIGQ9XCJNNzI0IDIxOC4zVjE0MWMwLTYuNy03LjctMTAuNC0xMi45LTYuM0wyNjAuMyA0ODYuOGEzMS44NiAzMS44NiAwIDAgMCAwIDUwLjNsNDUwLjggMzUyLjFjNS4zIDQuMSAxMi45LjQgMTIuOS02LjN2LTc3LjNjMC00LjktMi4zLTkuNi02LjEtMTIuNmwtMzYwLTI4MSAzNjAtMjgxLjFjMy44LTMgNi4xLTcuNyA2LjEtMTIuNnpcIj48L3BhdGg+JyArICc8L3N2Zz4nICsgJzxwIGNsYXNzPVwiY3VyLXBhZ2VudW1cIiBzdHlsZSA9IFwiZGlzcGxheTppbmxpbmUtYmxvY2s7XCI+MTwvcD4nICsgJzxwIGNsYXNzPVwibmV4dC1wYWdlbnVtXCIgc3R5bGUgPSBcImRpc3BsYXk6aW5saW5lLWJsb2NrO1wiPi8yPC9wPicgKyAnPHN2ZyB2aWV3Qm94PVwiNjQgNjQgODk2IDg5NlwiIGNsYXNzPVwiZzItY2FyZXQtZG93blwiIGRhdGEtaWNvbj1cInJpZ2h0XCIgd2lkdGg9XCIxZW1cIiBoZWlnaHQ9XCIxZW1cIiBhcmlhLWhpZGRlbj1cInRydWVcIj4nICsgJzxwYXRoIGQ9XCJNNzY1LjcgNDg2LjhMMzE0LjkgMTM0LjdBNy45NyA3Ljk3IDAgMCAwIDMwMiAxNDF2NzcuM2MwIDQuOSAyLjMgOS42IDYuMSAxMi42bDM2MCAyODEuMS0zNjAgMjgxLjFjLTMuOSAzLTYuMSA3LjctNi4xIDEyLjZWODgzYzAgNi43IDcuNyAxMC40IDEyLjkgNi4zbDQ1MC44LTM1Mi4xYTMxLjk2IDMxLjk2IDAgMCAwIDAtNTAuNHpcIj48L3BhdGg+JyArICc8L3N2Zz4nICsgJzwvZGl2PicsXG5cbiAgICAgIC8qKlxuICAgICAgICog57+76aG15Z2X55qE5a695bqm77yM55So5LqO6K6+572u57+76aG15Z2X55u45a+55LqOIGxlZ2VuZCDnmoTkvY3nva5cbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHNsaXBXaWR0aDogNjUsXG5cbiAgICAgIC8qKlxuICAgICAgICogbGVnZW5kIOWGheWuuei2heWHuuWuueWZqOeahOWkhOeQhuaWueW8j1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbGVnZW5kT3ZlcmZsb3c6ICd1bnNldCdcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIF9DYXRIdG1sLnByb3RvdHlwZS5fcmVuZGVySFRNTC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyRmxpcFBhZ2UoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckZsaXBQYWdlID0gZnVuY3Rpb24gX3JlbmRlckZsaXBQYWdlKCkge1xuICAgIHZhciBsZWdlbmRXcmFwcGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShDT05UQUlORVJfQ0xBU1MpWzBdOyAvLyB1bFxuXG4gICAgdmFyIGl0ZW1MaXN0RG9tID0gZmluZE5vZGVCeUNsYXNzKGxlZ2VuZFdyYXBwZXIsIExJU1RfQ0xBU1MpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0KCdwb3NpdGlvbicpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIGl0ZW1EaXNwbGF5ID0gcG9zaXRpb24gPT09ICdyaWdodCcgfHwgcG9zaXRpb24gPT09ICdsZWZ0JyB8fCBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyAnYmxvY2snIDogJ2lubGluZS1ibG9jayc7IC8vIOe/u+mhtVxuXG4gICAgaWYgKGxlZ2VuZFdyYXBwZXIuc2Nyb2xsSGVpZ2h0ID4gbGVnZW5kV3JhcHBlci5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIC8vIGFwcGVuZCBhIHNsaXAgZGl2XG4gICAgICB2YXIgc2xpcFRwbCA9IHRoaXMuZ2V0KCdzbGlwVHBsJyk7XG4gICAgICB2YXIgc2xpcERvbSA9IERvbVV0aWwuY3JlYXRlRG9tKHNsaXBUcGwpO1xuICAgICAgdmFyIGNhcmV0VXBEb20gPSBmaW5kTm9kZUJ5Q2xhc3Moc2xpcERvbSwgQ0FSRVRfVVBfQ0xBU1MpO1xuICAgICAgdmFyIGNhcmV0RG93bkRvbSA9IGZpbmROb2RlQnlDbGFzcyhzbGlwRG9tLCBDQVJFVF9ET1dOX0NMQVNTKTtcbiAgICAgIERvbVV0aWwubW9kaWZ5Q1NTKGNhcmV0VXBEb20sIHRoaXMuZ2V0KCdjYXJldFN0eWxlJykpO1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1MoY2FyZXRVcERvbSwge1xuICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwLjI1KSdcbiAgICAgIH0pO1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1MoY2FyZXREb3duRG9tLCB0aGlzLmdldCgnY2FyZXRTdHlsZScpKTtcbiAgICAgIHZhciBjdXJQYWdlTnVtRG9tID0gZmluZE5vZGVCeUNsYXNzKHNsaXBEb20sICdjdXItcGFnZW51bScpO1xuICAgICAgdmFyIHRvdGFsUGFnZU51bURvbSA9IGZpbmROb2RlQnlDbGFzcyhzbGlwRG9tLCAnbmV4dC1wYWdlbnVtJyk7XG4gICAgICB2YXIgcGFnZU51bVN0eWxlID0gdGhpcy5nZXQoJ3BhZ2VOdW1TdHlsZScpO1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1MoY3VyUGFnZU51bURvbSwgVXRpbC5taXgoe30sIHBhZ2VOdW1TdHlsZSwge1xuICAgICAgICBwYWRkaW5nTGVmdDogJzEwcHgnXG4gICAgICB9KSk7XG4gICAgICBEb21VdGlsLm1vZGlmeUNTUyh0b3RhbFBhZ2VOdW1Eb20sIFV0aWwubWl4KHt9LCBwYWdlTnVtU3R5bGUsIHtcbiAgICAgICAgb3BhY2l0eTogMC4zLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6ICcxMHB4J1xuICAgICAgfSkpOyAvLyBsYXlvdXQgYXQgdGhlIGNlbnRlci1ib3R0b20gb2YgdGhlIGxlZ2VuZFdyYXBwZXJcblxuICAgICAgRG9tVXRpbC5tb2RpZnlDU1Moc2xpcERvbSwgVXRpbC5taXgoe30sIHRoaXMuZ2V0KCdzbGlwRG9tU3R5bGUnKSwge1xuICAgICAgICB0b3A6IGxlZ2VuZFdyYXBwZXIub2Zmc2V0SGVpZ2h0ICsgJ3B4J1xuICAgICAgfSkpO1xuICAgICAgbGVnZW5kV3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9IHRoaXMuZ2V0KCdsZWdlbmRPdmVyZmxvdycpO1xuICAgICAgbGVnZW5kV3JhcHBlci5hcHBlbmRDaGlsZChzbGlwRG9tKTtcbiAgICAgIHZhciBsaSA9IGl0ZW1MaXN0RG9tLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgY3VySGVpZ2h0ID0gMDsgLy8gZmluZCB0aGUgdG90YWwgcGFnZSBudW1iZXJcblxuICAgICAgdmFyIHBhZ2VzID0gMTtcbiAgICAgIHZhciBibG9ja0xpID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlbaV0uc3R5bGUuZGlzcGxheSA9IGl0ZW1EaXNwbGF5O1xuICAgICAgICBjdXJIZWlnaHQgPSBsaVtpXS5vZmZzZXRUb3AgKyBsaVtpXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKGN1ckhlaWdodCA+PSBsZWdlbmRXcmFwcGVyLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgIHBhZ2VzKys7XG4gICAgICAgICAgYmxvY2tMaS5mb3JFYWNoKGZ1bmN0aW9uIChibCkge1xuICAgICAgICAgICAgYmwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBibG9ja0xpID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja0xpLnB1c2gobGlbaV0pO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFBhZ2VOdW1Eb20uaW5uZXJUZXh0ID0gJy8nICsgcGFnZXM7IC8vIGluaXRpYWxpemUgdGhlIHBhZ2VcblxuICAgICAgbGkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICBsLnN0eWxlLmRpc3BsYXkgPSBpdGVtRGlzcGxheTtcbiAgICAgICAgY3VySGVpZ2h0ID0gbC5vZmZzZXRUb3AgKyBsLm9mZnNldEhlaWdodDtcblxuICAgICAgICBpZiAoY3VySGVpZ2h0ID4gbGVnZW5kV3JhcHBlci5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICBsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyDkuIrnv7vkuovku7ZcblxuICAgICAgY2FyZXRVcERvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaXQgaXMgdGhlIDFzdCBwYWdlXG4gICAgICAgIGlmIChsaVswXS5zdHlsZS5kaXNwbGF5ID09PSBpdGVtRGlzcGxheSkgcmV0dXJuOyAvLyBvdGhlcndpc2VcblxuICAgICAgICB2YXIgZmlyc3REaXNwbGF5SXRlbUlkeCA9IC0xO1xuICAgICAgICBsaS5mb3JFYWNoKGZ1bmN0aW9uIChsLCBpKSB7XG4gICAgICAgICAgaWYgKGwuc3R5bGUuZGlzcGxheSA9PT0gaXRlbURpc3BsYXkpIHtcbiAgICAgICAgICAgIGZpcnN0RGlzcGxheUl0ZW1JZHggPSBmaXJzdERpc3BsYXlJdGVtSWR4ID09PSAtMSA/IGkgOiBmaXJzdERpc3BsYXlJdGVtSWR4O1xuICAgICAgICAgICAgbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSBmaXJzdERpc3BsYXlJdGVtSWR4IC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgIGxpW19pXS5zdHlsZS5kaXNwbGF5ID0gaXRlbURpc3BsYXk7XG4gICAgICAgICAgY3VySGVpZ2h0ID0gbGlbZmlyc3REaXNwbGF5SXRlbUlkeCAtIDFdLm9mZnNldFRvcCArIGxpW2ZpcnN0RGlzcGxheUl0ZW1JZHggLSAxXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgbGlbX2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICBpZiAoY3VySGVpZ2h0IDwgbGVnZW5kV3JhcHBlci5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpW19pXS5zdHlsZS5kaXNwbGF5ID0gaXRlbURpc3BsYXk7XG4gICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9IC8vIGNoYW5nZSB0aGUgcGFnZSBudW1iZXJcblxuXG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IE51bWJlci5wYXJzZUludChjdXJQYWdlTnVtRG9tLmlubmVyVGV4dCwgMTApIC0gMTtcblxuICAgICAgICBpZiAoY3VycmVudFBhZ2UgPT09IDEpIHtcbiAgICAgICAgICBjYXJldFVwRG9tLnN0eWxlLmZpbGwgPSBESVNBQkxFRF9DQVJFVF9DT0xPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJldFVwRG9tLnN0eWxlLmZpbGwgPSBFTkFCTEVEX0NBUkVUX0NPTE9SO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FyZXREb3duRG9tLnN0eWxlLmZpbGwgPSBFTkFCTEVEX0NBUkVUX0NPTE9SO1xuICAgICAgICBjdXJQYWdlTnVtRG9tLmlubmVyVGV4dCA9IGN1cnJlbnRQYWdlO1xuICAgICAgfSk7IC8vIOS4i+e/u+S6i+S7tlxuXG4gICAgICBjYXJldERvd25Eb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGl0IGlzIHRoZSBsYXN0IHBhZ2VcbiAgICAgICAgaWYgKGxpW2xpLmxlbmd0aCAtIDFdLnN0eWxlLmRpc3BsYXkgPT09IGl0ZW1EaXNwbGF5KSByZXR1cm47IC8vIG90aGVyd2lzZVxuXG4gICAgICAgIHZhciBsYXN0RGlzcGxheUl0ZW1JZHggPSAtMTtcbiAgICAgICAgbGkuZm9yRWFjaChmdW5jdGlvbiAobCwgaSkge1xuICAgICAgICAgIGlmIChsLnN0eWxlLmRpc3BsYXkgPT09IGl0ZW1EaXNwbGF5KSB7XG4gICAgICAgICAgICBsYXN0RGlzcGxheUl0ZW1JZHggPSBpO1xuICAgICAgICAgICAgbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gbGFzdERpc3BsYXlJdGVtSWR4ICsgMTsgX2kyIDwgbGkubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGxpW19pMl0uc3R5bGUuZGlzcGxheSA9IGl0ZW1EaXNwbGF5O1xuICAgICAgICAgIGN1ckhlaWdodCA9IGxpW19pMl0ub2Zmc2V0VG9wICsgbGlbX2kyXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgbGlbX2kyXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGlmIChjdXJIZWlnaHQgPCBsZWdlbmRXcmFwcGVyLm9mZnNldEhlaWdodCkgbGlbX2kyXS5zdHlsZS5kaXNwbGF5ID0gaXRlbURpc3BsYXk7ZWxzZSBicmVhaztcbiAgICAgICAgfSAvLyBjaGFuZ2UgdGhlIHBhZ2UgbnVtYmVyXG5cblxuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSBOdW1iZXIucGFyc2VJbnQoY3VyUGFnZU51bURvbS5pbm5lclRleHQsIDEwKSArIDE7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlID09PSBpdGVtRGlzcGxheSkge1xuICAgICAgICAgIGNhcmV0RG93bkRvbS5zdHlsZS5maWxsID0gRElTQUJMRURfQ0FSRVRfQ09MT1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZXREb3duRG9tLnN0eWxlLmZpbGwgPSBFTkFCTEVEX0NBUkVUX0NPTE9SO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FyZXRVcERvbS5zdHlsZS5maWxsID0gRU5BQkxFRF9DQVJFVF9DT0xPUjtcbiAgICAgICAgY3VyUGFnZU51bURvbS5pbm5lclRleHQgPSBjdXJyZW50UGFnZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXQoJ3NsaXBEb20nLCBzbGlwRG9tKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF9DYXRIdG1sLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2xpcERvbSA9IHRoaXMuZ2V0KCdzbGlwRG9tJyk7XG5cbiAgICBpZiAoc2xpcERvbSAmJiBzbGlwRG9tLnBhcmVudE5vZGUpIHtcbiAgICAgIHNsaXBEb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzbGlwRG9tKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhdFBhZ2VIdG1sO1xufShDYXRIdG1sKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRQYWdlSHRtbDtcblxuLyoqKi8gfSksXG4vKiAzMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBjbGFzcyBvZiB0aGUgZ3JhZGllbnQgY29sb3IgbGVnZW5kXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuXG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpLFxuICAgIENvbG9yVXRpbCA9IF9yZXF1aXJlLkNvbG9yVXRpbDsgLy8gVE9ET++8mkNvbG9yVXRpbCDljIXpnIDopoHku44gYXR0ciDljIXkuK3mir3nprtcblxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBDb250aW51b3VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbnZhciBDb2xvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbnRpbnVvdXMpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29sb3IsIF9Db250aW51b3VzKTtcblxuICBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICByZXR1cm4gX0NvbnRpbnVvdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Db250aW51b3VzLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgKiDnsbvlnotcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHR5cGU6ICdjb2xvci1sZWdlbmQnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOW4g+WxgOaWueW8j1xuICAgICAgICogaG9yaXpvbnRhbCDmsLTlubNcbiAgICAgICAqIHZlcnRpY2FsIOWeguebtFxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4pOWktOa7keWdl+eahOagt+W8j1xuICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAqL1xuICAgICAgdHJpZ2dlckF0dHI6IHtcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBzaGFkb3dPZmZzZXRYOiAtMixcbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMixcbiAgICAgICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICAgIHNoYWRvd0NvbG9yOiAnI2NjYycsXG4gICAgICAgIHJhZGl1czogM1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiDlkIzkuIDliIbmrrXmmK/lkKbkvb/nlKjnm7jlkIzpopzoibLogIzkuI3kvb/nlKjmuJDlj5joibLvvIzlnKggc2xpZGFibGUgPSBmYWxzZSDml7bnlJ/mlYhcbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBpc1NlZ21lbnQ6IGZhbHNlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRQZXJjZW50YWdlID0gZnVuY3Rpb24gX3NldFBlcmNlbnRhZ2UoKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG4gICAgaWYgKGl0ZW1zWzBdLnBlcmNlbnRhZ2UpIHJldHVybjtcbiAgICB2YXIgbWluID0gaXRlbXNbMF0udmFsdWU7XG4gICAgdmFyIG1heCA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnZhbHVlO1xuICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0KSB7XG4gICAgICBpdC5wZXJjZW50YWdlID0gKGl0LnZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfTsgLy8gcmVuZGVyIHRoZSBzbGlkZXIgd2hpbGUgc2xpZGFibGUgPT09IHRydWVcblxuXG4gIF9wcm90by5fcmVuZGVyU2xpZGVyU2hhcGUgPSBmdW5jdGlvbiBfcmVuZGVyU2xpZGVyU2hhcGUoKSB7XG4gICAgdGhpcy5fc2V0UGVyY2VudGFnZSgpO1xuXG4gICAgdmFyIHNsaWRlciA9IHRoaXMuZ2V0KCdzbGlkZXInKTtcbiAgICB2YXIgYmFja2dyb3VuZEVsZW1lbnQgPSBzbGlkZXIuZ2V0KCdiYWNrZ3JvdW5kRWxlbWVudCcpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgnaGVpZ2h0Jyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldCgnaXRlbXMnKTtcbiAgICB2YXIgZmlsbCA9ICcnO1xuICAgIHZhciByZ2JDb2xvcjsgLy8gZ3JhZGllbnQgY29sb3IgZGlzdHJpYnV0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJjZW50YWdlXG5cbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICBmaWxsICs9ICdsICg5MCkgJztcbiAgICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmdiQ29sb3IgPSBDb2xvclV0aWwudG9SR0Iodi5jb2xvcik7XG4gICAgICAgIGZpbGwgKz0gMSAtIHYucGVyY2VudGFnZSArICc6JyArIHJnYkNvbG9yICsgJyAnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGwgKz0gJ2wgKDApICc7XG4gICAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJnYkNvbG9yID0gQ29sb3JVdGlsLnRvUkdCKHYuY29sb3IpO1xuICAgICAgICBmaWxsICs9IHYucGVyY2VudGFnZSArICc6JyArIHJnYkNvbG9yICsgJyAnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZE1pZGRsZUJhcihiYWNrZ3JvdW5kRWxlbWVudCwgJ1JlY3QnLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgZmlsbDogZmlsbCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDBcbiAgICB9KTtcbiAgfTsgLy8gcmVuZGVyIHRoZSBzaWxkZXIgd2hpbGUgc2xpZGFibGUgPT09IGZhbHNlXG5cblxuICBfcHJvdG8uX3JlbmRlclVuc2xpZGFibGUgPSBmdW5jdGlvbiBfcmVuZGVyVW5zbGlkYWJsZSgpIHtcbiAgICB0aGlzLl9zZXRQZXJjZW50YWdlKCk7XG5cbiAgICB2YXIgdGl0bGVTaGFwZSA9IHRoaXMuZ2V0KCd0aXRsZVNoYXBlJyk7XG4gICAgdmFyIHRpdGxlR2FwID0gdGhpcy5nZXQoJ3RpdGxlR2FwJyk7XG4gICAgdGl0bGVHYXAgPSB0aXRsZVNoYXBlID8gdGl0bGVTaGFwZS5nZXRCQm94KCkuaGVpZ2h0ICsgdGl0bGVHYXAgOiB0aXRsZUdhcDtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG4gICAgdmFyIGZpbGwgPSAnJztcbiAgICB2YXIgcmdiQ29sb3I7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgYmdHcm91cCA9IGdyb3VwLmFkZEdyb3VwKCk7XG4gICAgdmFyIGlzaXplID0gaXRlbXMubGVuZ3RoOyAvLyBncmFkaWVudCBjb2xvciBkaXN0cmlidXRlZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmNlbnRhZ2VcblxuICAgIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIGZpbGwgKz0gJ2wgKDkwKSAnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlzaXplOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgIT09IDAgJiYgaSAhPT0gaXNpemUgLSAxKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFsnTScsIDAsIGhlaWdodCAtIGl0ZW1zW2ldLnBlcmNlbnRhZ2UgKiBoZWlnaHRdKTtcbiAgICAgICAgICBwYXRoLnB1c2goWydMJywgd2lkdGgsIGhlaWdodCAtIGl0ZW1zW2ldLnBlcmNlbnRhZ2UgKiBoZWlnaHRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJnYkNvbG9yID0gQ29sb3JVdGlsLnRvUkdCKGl0ZW1zW2ldLmNvbG9yKTtcbiAgICAgICAgZmlsbCArPSAxIC0gaXRlbXNbaV0ucGVyY2VudGFnZSArICc6JyArIHJnYkNvbG9yICsgJyAnO1xuXG4gICAgICAgIGlmICh0aGlzLmdldCgnaXNTZWdtZW50JykgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyBvbmUgY29sb3IgaW5zdGVhZCBvZiBncmFkaWVudCBjb2xvciBmb3IgYSBibG9jayB3aGlsZSBpc1NlZ21lbnQgPT09IHRydWVcbiAgICAgICAgICB2YXIgcHJlUmdiQ29sb3IgPSBDb2xvclV0aWwudG9SR0IoaXRlbXNbaSAtIDFdLmNvbG9yKTtcbiAgICAgICAgICBmaWxsICs9IDEgLSBpdGVtc1tpXS5wZXJjZW50YWdlICsgJzonICsgcHJlUmdiQ29sb3IgKyAnICc7XG4gICAgICAgIH1cblxuICAgICAgICBiZ0dyb3VwLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICAgIGF0dHJzOiBVdGlsLm1peCh7fSwge1xuICAgICAgICAgICAgeDogd2lkdGggKyB0aGlzLmdldCgndGV4dE9mZnNldCcpIC8gMixcbiAgICAgICAgICAgIHk6IGhlaWdodCAtIGl0ZW1zW2ldLnBlcmNlbnRhZ2UgKiBoZWlnaHQsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLl9mb3JtYXRJdGVtVmFsdWUoaXRlbXNbaV0udmFsdWUpICsgJycgLy8g5Lul5a2X56ym5Liy5qC85byP5bGV56S6XG5cbiAgICAgICAgICB9LCB0aGlzLmdldCgndGV4dFN0eWxlJyksIHtcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0J1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3Jpem9udGFsXG4gICAgICBmaWxsICs9ICdsICgwKSAnO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaXNpemU7IF9pICs9IDEpIHtcbiAgICAgICAgaWYgKF9pICE9PSAwICYmIF9pICE9PSBpc2l6ZSAtIDEpIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydNJywgaXRlbXNbX2ldLnBlcmNlbnRhZ2UgKiB3aWR0aCwgMF0pO1xuICAgICAgICAgIHBhdGgucHVzaChbJ0wnLCBpdGVtc1tfaV0ucGVyY2VudGFnZSAqIHdpZHRoLCBoZWlnaHRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJnYkNvbG9yID0gQ29sb3JVdGlsLnRvUkdCKGl0ZW1zW19pXS5jb2xvcik7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdpc1NlZ21lbnQnKSAmJiBfaSA+IDApIHtcbiAgICAgICAgICB2YXIgX3ByZVJnYkNvbG9yID0gQ29sb3JVdGlsLnRvUkdCKGl0ZW1zW19pIC0gMV0uY29sb3IpO1xuXG4gICAgICAgICAgZmlsbCArPSBpdGVtc1tfaV0ucGVyY2VudGFnZSArICc6JyArIF9wcmVSZ2JDb2xvciArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbGwgKz0gaXRlbXNbX2ldLnBlcmNlbnRhZ2UgKyAnOicgKyByZ2JDb2xvciArICcgJztcbiAgICAgICAgYmdHcm91cC5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoe30sIHtcbiAgICAgICAgICAgIHg6IGl0ZW1zW19pXS5wZXJjZW50YWdlICogd2lkdGgsXG4gICAgICAgICAgICB5OiBoZWlnaHQgKyA1ICsgdGhpcy5nZXQoJ3RleHRPZmZzZXQnKSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Zvcm1hdEl0ZW1WYWx1ZShpdGVtc1tfaV0udmFsdWUpICsgJycgLy8g5Lul5a2X56ym5Liy5qC85byP5bGV56S6XG5cbiAgICAgICAgICB9LCB0aGlzLmdldCgndGV4dFN0eWxlJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJnR3JvdXAuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAwXG4gICAgICB9XG4gICAgfSk7IC8vIHRoZSB3aGl0ZSBsaW5lIHNlZ21lbnQgdG8gc2VwZXJhdGUgY29sb3IgYmxvY2tzXG5cbiAgICBiZ0dyb3VwLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSwgdGhpcy5nZXQoJ2xpbmVTdHlsZScpKVxuICAgIH0pO1xuICAgIGJnR3JvdXAubW92ZSgwLCB0aXRsZUdhcCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbG9yO1xufShDb250aW51b3VzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuLyoqKi8gfSksXG4vKiAzMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBjbGFzcyBvZiBzbGlkZXJcbiAqIEBhdXRob3Igc2ltYS56aGFuZ1xuICovXG5cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgRG9tVXRpbCA9IFV0aWwuRG9tVXRpbDtcbnZhciBHcm91cCA9IFV0aWwuR3JvdXA7XG5cbnZhciBTbGlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Hcm91cCkge1xuICBfaW5oZXJpdHNMb29zZShTbGlkZXIsIF9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gU2xpZGVyKCkge1xuICAgIHJldHVybiBfR3JvdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNsaWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIOiMg+WbtFxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICByYW5nZTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDkuK3mu5HlnZflsZ7mgKdcbiAgICAgICAqIOmAj+aYjueahO+8jOeUqOS6jueUqOaIt+S6pOS6klxuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICBtaWRkbGVBdHRyOiB7XG4gICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDBcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6IOM5pmvXG4gICAgICAgKiBAdHlwZSB7Ry1FbGVtZW50fVxuICAgICAgICovXG4gICAgICBiYWNrZ3JvdW5kRWxlbWVudDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDkuIvmu5HlnZdcbiAgICAgICAqIEB0eXBlIHtHLUVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIG1pbkhhbmRsZUVsZW1lbnQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5LiK5ruR5Z2XXG4gICAgICAgKiBAdHlwZSB7Ry1FbGVtZW50fVxuICAgICAgICovXG4gICAgICBtYXhIYW5kbGVFbGVtZW50OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4reWdl++8jFxuICAgICAgICog6YCP5piO55qE77yM55So5LqO55So5oi35Lqk5LqSXG4gICAgICAgKiBAdHlwZSB7Ry1FbGVtZW50fVxuICAgICAgICovXG4gICAgICBtaWRkbGVIYW5kbGVFbGVtZW50OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOW9k+WJjeeahOa/gOa0u+eahOWFg+e0oFxuICAgICAgICogQHR5cGUge0ctRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDluIPlsYDmlrnlvI/vvJogaG9yaXpvbnRhbO+8jHZlcnRpY2FsXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBsYXlvdXQ6ICd2ZXJ0aWNhbCcsXG5cbiAgICAgIC8qKlxuICAgICAgICog5a69XG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB3aWR0aDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDpq5hcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGhlaWdodDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlvZPliY3nmoRQYWdlWFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgcGFnZVg6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5b2T5YmN55qEUGFnZVlcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHBhZ2VZOiBudWxsXG4gICAgfTtcbiAgfTsgLy8gYXJyYW5nZSB0aGUgemluZGV4IGFuZCBjdXJzb3JzIG9mIGVhY2ggZWxlbWVudFxuXG5cbiAgX3Byb3RvLl9iZWZvcmVSZW5kZXJVSSA9IGZ1bmN0aW9uIF9iZWZvcmVSZW5kZXJVSSgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuICAgIHZhciBiYWNrZ3JvdW5kRWxlbWVudCA9IHRoaXMuZ2V0KCdiYWNrZ3JvdW5kRWxlbWVudCcpO1xuICAgIHZhciBtaW5IYW5kbGVFbGVtZW50ID0gdGhpcy5nZXQoJ21pbkhhbmRsZUVsZW1lbnQnKTtcbiAgICB2YXIgbWF4SGFuZGxlRWxlbWVudCA9IHRoaXMuZ2V0KCdtYXhIYW5kbGVFbGVtZW50Jyk7XG4gICAgdmFyIG1pZGRsZUhhbmRsZUVsZW1lbnQgPSB0aGlzLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgYXR0cnM6IHRoaXMuZ2V0KCdtaWRkbGVBdHRyJylcbiAgICB9KTtcbiAgICB2YXIgdHJpZ2VyQ3Vyc29yID0gbGF5b3V0ID09PSAndmVydGljYWwnID8gJ25zLXJlc2l6ZScgOiAnZXctcmVzaXplJztcbiAgICB0aGlzLmFkZChbYmFja2dyb3VuZEVsZW1lbnQsIG1pbkhhbmRsZUVsZW1lbnQsIG1heEhhbmRsZUVsZW1lbnRdKTtcbiAgICB0aGlzLnNldCgnbWlkZGxlSGFuZGxlRWxlbWVudCcsIG1pZGRsZUhhbmRsZUVsZW1lbnQpO1xuICAgIGJhY2tncm91bmRFbGVtZW50LnNldCgnekluZGV4JywgMCk7XG4gICAgbWlkZGxlSGFuZGxlRWxlbWVudC5zZXQoJ3pJbmRleCcsIDEpO1xuICAgIG1pbkhhbmRsZUVsZW1lbnQuc2V0KCd6SW5kZXgnLCAyKTtcbiAgICBtYXhIYW5kbGVFbGVtZW50LnNldCgnekluZGV4JywgMik7XG4gICAgbWlkZGxlSGFuZGxlRWxlbWVudC5hdHRyKCdjdXJzb3InLCAnbW92ZScpO1xuICAgIG1pbkhhbmRsZUVsZW1lbnQuYXR0cignY3Vyc29yJywgdHJpZ2VyQ3Vyc29yKTtcbiAgICBtYXhIYW5kbGVFbGVtZW50LmF0dHIoJ2N1cnNvcicsIHRyaWdlckN1cnNvcik7XG4gICAgdGhpcy5zb3J0KCk7XG4gIH07IC8vIHJlbmRlcmluZ1xuXG5cbiAgX3Byb3RvLl9yZW5kZXJVSSA9IGZ1bmN0aW9uIF9yZW5kZXJVSSgpIHtcbiAgICBpZiAodGhpcy5nZXQoJ2xheW91dCcpID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHRoaXMuX3JlbmRlckhvcml6b250YWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyVmVydGljYWwoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiBfdHJhbnNmb3JtKGxheW91dCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0KCdyYW5nZScpO1xuICAgIHZhciBtaW5SYXRpbyA9IHJhbmdlWzBdIC8gMTAwO1xuICAgIHZhciBtYXhSYXRpbyA9IHJhbmdlWzFdIC8gMTAwO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgnaGVpZ2h0Jyk7XG4gICAgdmFyIG1pbkhhbmRsZUVsZW1lbnQgPSB0aGlzLmdldCgnbWluSGFuZGxlRWxlbWVudCcpO1xuICAgIHZhciBtYXhIYW5kbGVFbGVtZW50ID0gdGhpcy5nZXQoJ21heEhhbmRsZUVsZW1lbnQnKTtcbiAgICB2YXIgbWlkZGxlSGFuZGxlRWxlbWVudCA9IHRoaXMuZ2V0KCdtaWRkbGVIYW5kbGVFbGVtZW50Jyk7XG4gICAgbWluSGFuZGxlRWxlbWVudC5yZXNldE1hdHJpeCgpO1xuICAgIG1heEhhbmRsZUVsZW1lbnQucmVzZXRNYXRyaXgoKTtcblxuICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgbWlkZGxlSGFuZGxlRWxlbWVudC5hdHRyKHtcbiAgICAgICAgeDogd2lkdGggKiBtaW5SYXRpbyxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IChtYXhSYXRpbyAtIG1pblJhdGlvKSAqIHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgICBtaW5IYW5kbGVFbGVtZW50LnRyYW5zbGF0ZShtaW5SYXRpbyAqIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWF4SGFuZGxlRWxlbWVudC50cmFuc2xhdGUobWF4UmF0aW8gKiB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxlSGFuZGxlRWxlbWVudC5hdHRyKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogaGVpZ2h0ICogKDEgLSBtYXhSYXRpbyksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiAobWF4UmF0aW8gLSBtaW5SYXRpbykgKiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgbWluSGFuZGxlRWxlbWVudC50cmFuc2xhdGUoMSwgKDEgLSBtaW5SYXRpbykgKiBoZWlnaHQpO1xuICAgICAgbWF4SGFuZGxlRWxlbWVudC50cmFuc2xhdGUoMSwgKDEgLSBtYXhSYXRpbykgKiBoZWlnaHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckhvcml6b250YWwgPSBmdW5jdGlvbiBfcmVuZGVySG9yaXpvbnRhbCgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0oJ2hvcml6b250YWwnKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlclZlcnRpY2FsID0gZnVuY3Rpb24gX3JlbmRlclZlcnRpY2FsKCkge1xuICAgIHRoaXMuX3RyYW5zZm9ybSgndmVydGljYWwnKTtcbiAgfTtcblxuICBfcHJvdG8uX2JpbmRVSSA9IGZ1bmN0aW9uIF9iaW5kVUkoKSB7XG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbk1vdXNlRG93bicpKTtcbiAgfTsgLy8gaWYgdGhlIHRhcmdldCBtYXRjaGVzIG5hbWVcblxuXG4gIF9wcm90by5faXNFbGVtZW50ID0gZnVuY3Rpb24gX2lzRWxlbWVudCh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuaXNHcm91cCkge1xuICAgICAgdmFyIGVsZW1lbnRDaGlsZHJlbiA9IGVsZW1lbnQuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRDaGlsZHJlbi5pbmRleE9mKHRhcmdldCkgPiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07IC8vIGdldCB0aGUgcmVzdWx0IHJhbmdlIGFmdGVyIGFkZGluZyBkaWZmIHRvIHJhbmdlXG4gIC8vIGluc3VyZSB0aGF0IHRoZSByZXN1bHQgb3V0IG9mIHRoZSBpbnRlcnZhbCBbMCwgMTAwXVxuXG5cbiAgX3Byb3RvLl9nZXRSYW5nZSA9IGZ1bmN0aW9uIF9nZXRSYW5nZShkaWZmLCByYW5nZSkge1xuICAgIHZhciByc3QgPSBkaWZmICsgcmFuZ2U7XG4gICAgcnN0ID0gcnN0ID4gMTAwID8gMTAwIDogcnN0O1xuICAgIHJzdCA9IHJzdCA8IDAgPyAwIDogcnN0O1xuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVTdGF0dXMgPSBmdW5jdGlvbiBfdXBkYXRlU3RhdHVzKGRpbSwgZXYpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBkaW0gPT09ICd4JyA/IHRoaXMuZ2V0KCd3aWR0aCcpIDogdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIGRpbSA9IFV0aWwudXBwZXJGaXJzdChkaW0pO1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0KCdyYW5nZScpO1xuICAgIHZhciBwYWdlID0gdGhpcy5nZXQoJ3BhZ2UnICsgZGltKTtcbiAgICB2YXIgY3VycmVudFRhcmdldCA9IHRoaXMuZ2V0KCdjdXJyZW50VGFyZ2V0Jyk7XG4gICAgdmFyIHJhbmdlU3Rhc2ggPSB0aGlzLmdldCgncmFuZ2VTdGFzaCcpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIHNpZ24gPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyAtMSA6IDE7XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gZXZbJ3BhZ2UnICsgZGltXTsgLy8gdGhlIGRpc3RhbmNlIG9mIHRoZSBtb3VzZSBkcmFnZ2luZ1xuXG4gICAgdmFyIGRpZmZQYWdlID0gY3VycmVudFBhZ2UgLSBwYWdlO1xuICAgIHZhciBkaWZmUmFuZ2UgPSBkaWZmUGFnZSAvIHRvdGFsTGVuZ3RoICogMTAwICogc2lnbjtcbiAgICB2YXIgZGlmZlN0YXNoUmFuZ2U7IC8vIHRoZSBtaW4gYW5kIG1heCB0cmlnZ2VyIG92ZXJsYXAsIHJhbmdlWzBdIGFuZCByYW5nZVsxXSBjaGFuZ2UgdG9nZXRoZXJcblxuICAgIGlmIChyYW5nZVsxXSA8PSByYW5nZVswXSkge1xuICAgICAgaWYgKHRoaXMuX2lzRWxlbWVudChjdXJyZW50VGFyZ2V0LCAnbWluSGFuZGxlRWxlbWVudCcpIHx8IHRoaXMuX2lzRWxlbWVudChjdXJyZW50VGFyZ2V0LCAnbWF4SGFuZGxlRWxlbWVudCcpKSB7XG4gICAgICAgIHJhbmdlWzBdID0gdGhpcy5fZ2V0UmFuZ2UoZGlmZlJhbmdlLCByYW5nZVswXSk7XG4gICAgICAgIHJhbmdlWzFdID0gdGhpcy5fZ2V0UmFuZ2UoZGlmZlJhbmdlLCByYW5nZVswXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVzZXIgZHJhZ3MgdGhlIG1pbiB0cmlnZ2VyXG4gICAgICBpZiAodGhpcy5faXNFbGVtZW50KGN1cnJlbnRUYXJnZXQsICdtaW5IYW5kbGVFbGVtZW50JykpIHtcbiAgICAgICAgcmFuZ2VbMF0gPSB0aGlzLl9nZXRSYW5nZShkaWZmUmFuZ2UsIHJhbmdlWzBdKTtcbiAgICAgIH0gLy8gdXNlciBkcmFncyB0aGUgbWF4IHRyaWdnZXJcblxuXG4gICAgICBpZiAodGhpcy5faXNFbGVtZW50KGN1cnJlbnRUYXJnZXQsICdtYXhIYW5kbGVFbGVtZW50JykpIHtcbiAgICAgICAgcmFuZ2VbMV0gPSB0aGlzLl9nZXRSYW5nZShkaWZmUmFuZ2UsIHJhbmdlWzFdKTtcbiAgICAgIH1cbiAgICB9IC8vIHRoZSB1c2VyIGRyYWdzIHRoZSBtaWRkbGUgYmFyXG5cblxuICAgIGlmICh0aGlzLl9pc0VsZW1lbnQoY3VycmVudFRhcmdldCwgJ21pZGRsZUhhbmRsZUVsZW1lbnQnKSkge1xuICAgICAgLy8gdGhlIGRpZmZyZW5jZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IHRyaWdnZXIgd2hpbGUgbW91c2UgZG93blxuICAgICAgZGlmZlN0YXNoUmFuZ2UgPSByYW5nZVN0YXNoWzFdIC0gcmFuZ2VTdGFzaFswXTtcbiAgICAgIHJhbmdlWzBdID0gdGhpcy5fZ2V0UmFuZ2UoZGlmZlJhbmdlLCByYW5nZVswXSk7IC8vIGtlZXAgdGhlIGRpZmZTdGFzaFJhbmdlXG5cbiAgICAgIHJhbmdlWzFdID0gcmFuZ2VbMF0gKyBkaWZmU3Rhc2hSYW5nZTtcblxuICAgICAgaWYgKHJhbmdlWzFdID4gMTAwKSB7XG4gICAgICAgIHJhbmdlWzFdID0gMTAwO1xuICAgICAgICByYW5nZVswXSA9IHJhbmdlWzFdIC0gZGlmZlN0YXNoUmFuZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdzbGlkZXJjaGFuZ2UnLCB7XG4gICAgICByYW5nZTogcmFuZ2VcbiAgICB9KTtcbiAgICB0aGlzLnNldCgncGFnZScgKyBkaW0sIGN1cnJlbnRQYWdlKTtcblxuICAgIHRoaXMuX3JlbmRlclVJKCk7XG5cbiAgICB0aGlzLmdldCgnY2FudmFzJykuZHJhdygpOyAvLyBuZWVkIGRlbGV0ZVxuXG4gICAgcmV0dXJuO1xuICB9OyAvLyB0aGUgbGlzdGVuZXIgb2YgbW91c2UgZG93blxuXG5cbiAgX3Byb3RvLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIF9vbk1vdXNlRG93bihldikge1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gZXYuY3VycmVudFRhcmdldDtcbiAgICB2YXIgb3JpZ2luRXZlbnQgPSBldi5ldmVudDtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldCgncmFuZ2UnKTtcbiAgICBvcmlnaW5FdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBvcmlnaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0KCdwYWdlWCcsIG9yaWdpbkV2ZW50LnBhZ2VYKTtcbiAgICB0aGlzLnNldCgncGFnZVknLCBvcmlnaW5FdmVudC5wYWdlWSk7XG4gICAgdGhpcy5zZXQoJ2N1cnJlbnRUYXJnZXQnLCBjdXJyZW50VGFyZ2V0KTsgLy8gc3Rhc2ggdGhlIHJhbmdlXG5cbiAgICB0aGlzLnNldCgncmFuZ2VTdGFzaCcsIFtyYW5nZVswXSwgcmFuZ2VbMV1dKTtcblxuICAgIHRoaXMuX2JpbmRDYW52YXNFdmVudHMoKTtcbiAgfTtcblxuICBfcHJvdG8uX2JpbmRDYW52YXNFdmVudHMgPSBmdW5jdGlvbiBfYmluZENhbnZhc0V2ZW50cygpIHtcbiAgICB2YXIgY29udGFpbmVyRE9NID0gdGhpcy5nZXQoJ2NhbnZhcycpLmdldCgnY29udGFpbmVyRE9NJyk7IC8vIHRoaXMub24oJ21vdXNlbW92ZScsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdfb25DYW52YXNNb3VzZU1vdmUnKSk7XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlTGlzdGVuZXIgPSBEb21VdGlsLmFkZEV2ZW50TGlzdGVuZXIoY29udGFpbmVyRE9NLCAnbW91c2Vtb3ZlJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbkNhbnZhc01vdXNlTW92ZScpKTtcbiAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gRG9tVXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lckRPTSwgJ21vdXNldXAnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uQ2FudmFzTW91c2VVcCcpKTtcbiAgICB0aGlzLm9uTW91c2VMZWF2ZUxpc3RlbmVyID0gRG9tVXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lckRPTSwgJ21vdXNlbGVhdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uQ2FudmFzTW91c2VVcCcpKTtcbiAgfTsgLy8gbGlzdGVuZXIgb2YgbW91c2UgY2xpY2sgYW5kIG1vdmUgPSBkcmFnXG5cblxuICBfcHJvdG8uX29uQ2FudmFzTW91c2VNb3ZlID0gZnVuY3Rpb24gX29uQ2FudmFzTW91c2VNb3ZlKGV2KSB7XG4gICAgaWYgKCF0aGlzLl9tb3VzZU91dEFyZWEoZXYpKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuXG4gICAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKCd4JywgZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKCd5JywgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gbGlzdGVuZXIgb2YgbW91c2UgdXBcblxuXG4gIF9wcm90by5fb25DYW52YXNNb3VzZVVwID0gZnVuY3Rpb24gX29uQ2FudmFzTW91c2VVcCgpIHtcbiAgICB0aGlzLl9yZW1vdmVEb2N1bWVudEV2ZW50cygpO1xuICB9OyAvLyByZW1vdmUgbGlzdGVuZXJzXG5cblxuICBfcHJvdG8uX3JlbW92ZURvY3VtZW50RXZlbnRzID0gZnVuY3Rpb24gX3JlbW92ZURvY3VtZW50RXZlbnRzKCkge1xuICAgIHRoaXMub25Nb3VzZU1vdmVMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyLnJlbW92ZSgpO1xuICB9OyAvLyBpZiB0aGUgbW91c2UgaXMgb3V0IG9mIHRoZSBhcmVhXG5cblxuICBfcHJvdG8uX21vdXNlT3V0QXJlYSA9IGZ1bmN0aW9uIF9tb3VzZU91dEFyZWEoZXYpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmdldCgnY2FudmFzJykuZ2V0KCdlbCcpO1xuICAgIHZhciBlbF9iYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KCdwYXJlbnQnKTtcbiAgICB2YXIgYmJveCA9IHBhcmVudC5nZXRCQm94KCk7XG4gICAgdmFyIGxlZnQgPSBwYXJlbnQuYXR0cignbWF0cml4JylbNl07XG4gICAgdmFyIHRvcCA9IHBhcmVudC5hdHRyKCdtYXRyaXgnKVs3XTtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgYmJveC53aWR0aDtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgYmJveC5oZWlnaHQ7XG4gICAgdmFyIG1vdXNlWCA9IGV2LmNsaWVudFggLSBlbF9iYm94Lng7XG4gICAgdmFyIG1vdXNlWSA9IGV2LmNsaWVudFkgLSBlbF9iYm94Lnk7XG5cbiAgICBpZiAobW91c2VYIDwgbGVmdCB8fCBtb3VzZVggPiByaWdodCB8fCBtb3VzZVkgPCB0b3AgfHwgbW91c2VZID4gYm90dG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oR3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcblxuLyoqKi8gfSksXG4vKiAzMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBjbGFzcyBvZiB0aGUgZ3JhZGllbnQgY29sb3IgbGVnZW5kXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuXG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIENvbnRpbnVvdXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxudmFyIFNpemUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db250aW51b3VzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNpemUsIF9Db250aW51b3VzKTtcblxuICBmdW5jdGlvbiBTaXplKCkge1xuICAgIHJldHVybiBfQ29udGludW91cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2l6ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQ29udGludW91cy5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIC8qKlxuICAgICAgICog57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0eXBlOiAnc2l6ZS1sZWdlbmQnLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIGhlaWdodDogMjAwLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4jeiDvea7keWKqOaXtuWciOeahOagt+W8j1xuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICBfdW5zbGlkYWJsZUVsZW1lbnRTdHlsZToge1xuICAgICAgICBmaWxsOiAnIzRFN0NDQycsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAxXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4remXtCBiYXIg55qE5YmN5pmv6aKc6ImyXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIGZyb250TWlkZGxlQmFyU3R5bGU6IHtcbiAgICAgICAgZmlsbDogJ3JnYig2NCwgMTQxLCAyNTEpJ1xuICAgICAgfVxuICAgIH0pO1xuICB9OyAvLyByZW5kZXIgdGhlIHNsaWRlciBzaGFwZVxuXG5cbiAgX3Byb3RvLl9yZW5kZXJTbGlkZXJTaGFwZSA9IGZ1bmN0aW9uIF9yZW5kZXJTbGlkZXJTaGFwZSgpIHtcbiAgICB2YXIgc2xpZGVyID0gdGhpcy5nZXQoJ3NsaWRlcicpO1xuICAgIHZhciBiYWNrZ3JvdW5kRWxlbWVudCA9IHNsaWRlci5nZXQoJ2JhY2tncm91bmRFbGVtZW50Jyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpOyAvLyBjb25zdCB4ID0gbWluUmFkaXVzO1xuXG4gICAgdmFyIHkgPSB0aGlzLmdldCgnaGVpZ2h0JykgLyAyO1xuICAgIHZhciBmcm9udE1pZGRsZUJhclN0eWxlID0gdGhpcy5nZXQoJ2Zyb250TWlkZGxlQmFyU3R5bGUnKTsgLy8gYmFja2dyb3VuZCBvZiBtaWRkbGUgYmFyXG5cbiAgICB2YXIgcG9pbnRzID0gbGF5b3V0ID09PSAndmVydGljYWwnID8gW1swLCAwXSwgW3dpZHRoLCAwXSwgW3dpZHRoLCBoZWlnaHRdLCBbd2lkdGggLSA0LCBoZWlnaHRdXSA6IFtbMCwgeSArIGhlaWdodCAvIDJdLCBbMCwgeSArIGhlaWdodCAvIDIgLSA0XSwgW3dpZHRoLCB5IC0gaGVpZ2h0IC8gMl0sIFt3aWR0aCwgeSArIGhlaWdodCAvIDJdXTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWlkZGxlQmFyKGJhY2tncm91bmRFbGVtZW50LCAnUG9seWdvbicsIFV0aWwubWl4KHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSwgZnJvbnRNaWRkbGVCYXJTdHlsZSkpO1xuICB9OyAvLyByZW5kZXIgdGhlIG1pZGRsZSBiYXIgd2hpbGUgc2xpZGFibGUgPT09IGZhbHNlLFxuICAvLyB0aGVyZSBhcmUgbm8gdHJpZ2dlcnMgZm9yIHRoaXMgc2l0dWF0aW9uXG5cblxuICBfcHJvdG8uX3JlbmRlclVuc2xpZGFibGUgPSBmdW5jdGlvbiBfcmVuZGVyVW5zbGlkYWJsZSgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgnaGVpZ2h0Jyk7XG4gICAgdmFyIGZyb250TWlkZGxlQmFyU3R5bGUgPSB0aGlzLmdldCgnZnJvbnRNaWRkbGVCYXJTdHlsZScpO1xuICAgIHZhciBwb2ludHMgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBbWzAsIDBdLCBbd2lkdGgsIDBdLCBbd2lkdGgsIGhlaWdodF0sIFt3aWR0aCAtIDQsIGhlaWdodF1dIDogW1swLCBoZWlnaHRdLCBbMCwgaGVpZ2h0IC0gNF0sIFt3aWR0aCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV07XG4gICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2dyb3VwJyk7XG4gICAgdmFyIGJnR3JvdXAgPSBncm91cC5hZGRHcm91cCgpO1xuICAgIGJnR3JvdXAuYWRkU2hhcGUoJ1BvbHlnb24nLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSwgZnJvbnRNaWRkbGVCYXJTdHlsZSlcbiAgICB9KTtcblxuICAgIHZhciBtaW5UZXh0ID0gdGhpcy5fZm9ybWF0SXRlbVZhbHVlKHRoaXMuZ2V0KCdmaXJzdEl0ZW0nKS52YWx1ZSk7XG5cbiAgICB2YXIgbWF4VGV4dCA9IHRoaXMuX2Zvcm1hdEl0ZW1WYWx1ZSh0aGlzLmdldCgnbGFzdEl0ZW0nKS52YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2xheW91dCcpID09PSAndmVydGljYWwnKSB7XG4gICAgICB0aGlzLl9hZGRUZXh0KHdpZHRoICsgMTAsIGhlaWdodCAtIDMsIG1pblRleHQpOyAvLyBtaW5cblxuXG4gICAgICB0aGlzLl9hZGRUZXh0KHdpZHRoICsgMTAsIDMsIG1heFRleHQpOyAvLyBtYXhcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRUZXh0KDAsIGhlaWdodCwgbWluVGV4dCk7IC8vIG1pblxuXG5cbiAgICAgIHRoaXMuX2FkZFRleHQod2lkdGgsIGhlaWdodCwgbWF4VGV4dCk7IC8vIG1heFxuXG4gICAgfVxuICB9OyAvLyBhZGQgbWluIGFuZCBtYXggdGV4dCB3aGlsZSBzbGlkYWJsZSA9PT0gZmFsc2VcblxuXG4gIF9wcm90by5fYWRkVGV4dCA9IGZ1bmN0aW9uIF9hZGRUZXh0KHgsIHksIHRleHQpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldCgnZ3JvdXAnKTtcbiAgICB2YXIgdGV4dEdyb3VwID0gZ3JvdXAuYWRkR3JvdXAoKTtcbiAgICB2YXIgdGV4dFN0eWxlID0gdGhpcy5nZXQoJ3RleHRTdHlsZScpO1xuICAgIHZhciB0aXRsZVNoYXBlID0gdGhpcy5nZXQoJ3RpdGxlU2hhcGUnKTtcbiAgICB2YXIgdGl0bGVHYXAgPSB0aGlzLmdldCgndGl0bGVHYXAnKTtcblxuICAgIGlmICh0aXRsZVNoYXBlKSB7XG4gICAgICB0aXRsZUdhcCArPSB0aXRsZVNoYXBlLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0KCdsYXlvdXQnKSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgdGV4dEdyb3VwLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IHggKyB0aGlzLmdldCgndGV4dE9mZnNldCcpLFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgdGV4dDogdGV4dCA9PT0gMCA/ICcwJyA6IHRleHRcbiAgICAgICAgfSwgdGV4dFN0eWxlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gdGl0bGVHYXAgKyB0aGlzLmdldCgndGV4dE9mZnNldCcpIC0gMjA7XG4gICAgICBpZiAoIXRpdGxlU2hhcGUpIHkgKz0gMTA7XG4gICAgICB0ZXh0R3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IHRleHQgPT09IDAgPyAnMCcgOiB0ZXh0XG4gICAgICAgIH0sIHRleHRTdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2l6ZTtcbn0oQ29udGludW91cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcblxuLyoqKi8gfSksXG4vKiAzMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBjbGFzcyBvZiB0aGUgc2l6ZSBsZWdlbmRcbiAqIEBhdXRob3Igc2ltYS56aGFuZ1xuICogQGF1dGhvciB5ZSBsaXVcbiAqL1xuXG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTsgLy8gY29uc3QgR2xvYmFsID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJyk7XG5cblxudmFyIENvbnRpbnVvdXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxudmFyIFNMSURFUl9IRUlHSFQgPSAyO1xudmFyIENJUkNMRV9HQVAgPSAxNjtcbnZhciBNQVhfU0laRSA9IDE2O1xudmFyIE1JTl9TSVpFID0gNTtcblxudmFyIENpcmNsZVNpemUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Db250aW51b3VzKSB7XG4gIF9pbmhlcml0c0xvb3NlKENpcmNsZVNpemUsIF9Db250aW51b3VzKTtcblxuICBmdW5jdGlvbiBDaXJjbGVTaXplKCkge1xuICAgIHJldHVybiBfQ29udGludW91cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2lyY2xlU2l6ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQ29udGludW91cy5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIC8qKlxuICAgICAgICog57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0eXBlOiAnc2l6ZS1jaXJjbGUtbGVnZW5kJyxcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDIwMCxcblxuICAgICAgLyoqXG4gICAgICAgKiDkuI3og73mu5Hliqjml7blnIjnmoTmoLflvI9cbiAgICAgICAqIEB0eXBlIHtBVFRSU31cbiAgICAgICAqL1xuICAgICAgX3Vuc2xpZGFibGVDaXJjbGVTdHlsZToge1xuICAgICAgICBzdHJva2U6ICdyZ2IoOTksIDE2MSwgMjQ4KScsXG4gICAgICAgIGZpbGw6ICdyZ2IoOTksIDE2MSwgMjQ4KScsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjMsXG4gICAgICAgIGxpbmVXaWR0aDogMS41XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIOa7keWdl+eahOagt+W8j1xuICAgICAgICogQHR5cGUge0FUVFJTfVxuICAgICAgICovXG4gICAgICB0cmlnZ2VyQXR0cjoge1xuICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICBzaGFkb3dPZmZzZXRYOiAtMixcbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMixcbiAgICAgICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICAgIHNoYWRvd0NvbG9yOiAnI2NjYydcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog5Lit6Ze0IGJhciDnmoTliY3mma/popzoibJcbiAgICAgICAqIEB0eXBlIHtBVFRSU31cbiAgICAgICAqL1xuICAgICAgZnJvbnRNaWRkbGVCYXJTdHlsZToge1xuICAgICAgICBmaWxsOiAncmdiKDY0LCAxNDEsIDI1MSknXG4gICAgICB9XG4gICAgfSk7XG4gIH07IC8vIHJlbmRlciB0aGUgc2xpZGVyIHNoYXBlXG5cblxuICBfcHJvdG8uX3JlbmRlclNsaWRlclNoYXBlID0gZnVuY3Rpb24gX3JlbmRlclNsaWRlclNoYXBlKCkge1xuICAgIHZhciBtaW5SYWRpdXMgPSBNSU5fU0laRTtcbiAgICB2YXIgc2xpZGVyID0gdGhpcy5nZXQoJ3NsaWRlcicpO1xuICAgIHZhciBiYWNrZ3JvdW5kRWxlbWVudCA9IHNsaWRlci5nZXQoJ2JhY2tncm91bmRFbGVtZW50Jyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgd2lkdGggPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyBTTElERVJfSEVJR0hUIDogdGhpcy5nZXQoJ3dpZHRoJyk7XG4gICAgdmFyIGhlaWdodCA9IGxheW91dCA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuZ2V0KCdoZWlnaHQnKSA6IFNMSURFUl9IRUlHSFQ7XG4gICAgdmFyIHggPSBtaW5SYWRpdXM7XG4gICAgdmFyIHkgPSB0aGlzLmdldCgnaGVpZ2h0JykgLyAyO1xuICAgIHZhciBmcm9udE1pZGRsZUJhclN0eWxlID0gdGhpcy5nZXQoJ2Zyb250TWlkZGxlQmFyU3R5bGUnKTsgLy8gYmFja2dyb3VuZCBvZiBtaWRkbGUgYmFyXG5cbiAgICB2YXIgcG9pbnRzID0gbGF5b3V0ID09PSAndmVydGljYWwnID8gW1swLCAwXSwgW3dpZHRoLCAwXSwgW3dpZHRoLCBoZWlnaHRdLCBbMCwgaGVpZ2h0XV0gOiBbWzAsIHkgKyBoZWlnaHRdLCBbMCwgeSAtIGhlaWdodF0sIFt4ICsgd2lkdGggLSA0LCB5IC0gaGVpZ2h0XSwgW3ggKyB3aWR0aCAtIDQsIHkgKyBoZWlnaHRdXTtcbiAgICByZXR1cm4gdGhpcy5fYWRkTWlkZGxlQmFyKGJhY2tncm91bmRFbGVtZW50LCAnUG9seWdvbicsIFV0aWwubWl4KHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSwgZnJvbnRNaWRkbGVCYXJTdHlsZSkpO1xuICB9OyAvLyB0cmlnZ2VycyB3aGlsZSBsYXlvdXQgPT09IGhvcml6b250YWxcblxuXG4gIF9wcm90by5fYWRkSG9yaXpvbnRhbFRyaWdnZXIgPSBmdW5jdGlvbiBfYWRkSG9yaXpvbnRhbFRyaWdnZXIodHlwZSwgYmxvY2tBdHRyLCB0ZXh0QXR0ciwgcmFkaXVzKSB7XG4gICAgdmFyIHNsaWRlciA9IHRoaXMuZ2V0KCdzbGlkZXInKTtcbiAgICB2YXIgdHJpZ2dlciA9IHNsaWRlci5nZXQodHlwZSArICdIYW5kbGVFbGVtZW50Jyk7XG4gICAgdmFyIHkgPSAtdGhpcy5nZXQoJ2hlaWdodCcpIC8gMjtcbiAgICB2YXIgYnV0dG9uID0gdHJpZ2dlci5hZGRTaGFwZSgnY2lyY2xlJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcjogcmFkaXVzXG4gICAgICB9LCBibG9ja0F0dHIpXG4gICAgfSk7XG4gICAgdmFyIHRleHQgPSB0cmlnZ2VyLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHRleHRBdHRyLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IHkgKyByYWRpdXMgKyAxMCxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuICAgIHZhciB0cmlnZXJDdXJzb3IgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyAnbnMtcmVzaXplJyA6ICdldy1yZXNpemUnO1xuICAgIGJ1dHRvbi5hdHRyKCdjdXJzb3InLCB0cmlnZXJDdXJzb3IpO1xuICAgIHRleHQuYXR0cignY3Vyc29yJywgdHJpZ2VyQ3Vyc29yKTtcbiAgICB0aGlzLnNldCh0eXBlICsgJ0J1dHRvbkVsZW1lbnQnLCBidXR0b24pO1xuICAgIHRoaXMuc2V0KHR5cGUgKyAnVGV4dEVsZW1lbnQnLCB0ZXh0KTtcbiAgfTsgLy8gdHJpZ2dlcnMgd2hpbGUgbGF5b3V0ID09PSB2ZXJ0aWNhbFxuXG5cbiAgX3Byb3RvLl9hZGRWZXJ0aWNhbFRyaWdnZXIgPSBmdW5jdGlvbiBfYWRkVmVydGljYWxUcmlnZ2VyKHR5cGUsIGJsb2NrQXR0ciwgdGV4dEF0dHIsIHJhZGl1cykge1xuICAgIHZhciBzbGlkZXIgPSB0aGlzLmdldCgnc2xpZGVyJyk7XG4gICAgdmFyIHRyaWdnZXIgPSBzbGlkZXIuZ2V0KHR5cGUgKyAnSGFuZGxlRWxlbWVudCcpO1xuICAgIHZhciBidXR0b24gPSB0cmlnZ2VyLmFkZFNoYXBlKCdjaXJjbGUnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICByOiByYWRpdXNcbiAgICAgIH0sIGJsb2NrQXR0cilcbiAgICB9KTtcbiAgICB2YXIgdGV4dCA9IHRyaWdnZXIuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgodGV4dEF0dHIsIHtcbiAgICAgICAgeDogcmFkaXVzICsgMTAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXQoJ2xheW91dCcpO1xuICAgIHZhciB0cmlnZXJDdXJzb3IgPSBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcgPyAnbnMtcmVzaXplJyA6ICdldy1yZXNpemUnO1xuICAgIGJ1dHRvbi5hdHRyKCdjdXJzb3InLCB0cmlnZXJDdXJzb3IpO1xuICAgIHRleHQuYXR0cignY3Vyc29yJywgdHJpZ2VyQ3Vyc29yKTtcbiAgICB0aGlzLnNldCh0eXBlICsgJ0J1dHRvbkVsZW1lbnQnLCBidXR0b24pO1xuICAgIHRoaXMuc2V0KHR5cGUgKyAnVGV4dEVsZW1lbnQnLCB0ZXh0KTtcbiAgfTsgLy8gcmVuZGVyIHRoZSB0cmlnZ2Vyc1xuXG5cbiAgX3Byb3RvLl9yZW5kZXJUcmlnZ2VyID0gZnVuY3Rpb24gX3JlbmRlclRyaWdnZXIoKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMuZ2V0KCdmaXJzdEl0ZW0nKTtcbiAgICB2YXIgbWF4ID0gdGhpcy5nZXQoJ2xhc3RJdGVtJyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgdGV4dFN0eWxlID0gdGhpcy5nZXQoJ3RleHRTdHlsZScpO1xuICAgIHZhciB0cmlnZ2VyQXR0ciA9IHRoaXMuZ2V0KCd0cmlnZ2VyQXR0cicpO1xuICAgIHZhciBtaW5CbG9ja0F0dHIgPSBVdGlsLm1peCh7fSwgdHJpZ2dlckF0dHIpO1xuICAgIHZhciBtYXhCbG9ja0F0dHIgPSBVdGlsLm1peCh7fSwgdHJpZ2dlckF0dHIpO1xuICAgIHZhciBtaW5SYWRpdXMgPSBNSU5fU0laRTtcbiAgICB2YXIgbWF4UmFkaXVzID0gTUFYX1NJWkU7XG4gICAgdmFyIG1pblRleHRBdHRyID0gVXRpbC5taXgoe1xuICAgICAgdGV4dDogdGhpcy5fZm9ybWF0SXRlbVZhbHVlKG1pbi52YWx1ZSkgKyAnJ1xuICAgIH0sIHRleHRTdHlsZSk7XG4gICAgdmFyIG1heFRleHRBdHRyID0gVXRpbC5taXgoe1xuICAgICAgdGV4dDogdGhpcy5fZm9ybWF0SXRlbVZhbHVlKG1heC52YWx1ZSkgKyAnJ1xuICAgIH0sIHRleHRTdHlsZSk7XG5cbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICB0aGlzLl9hZGRWZXJ0aWNhbFRyaWdnZXIoJ21pbicsIG1pbkJsb2NrQXR0ciwgbWluVGV4dEF0dHIsIG1pblJhZGl1cyk7XG5cbiAgICAgIHRoaXMuX2FkZFZlcnRpY2FsVHJpZ2dlcignbWF4JywgbWF4QmxvY2tBdHRyLCBtYXhUZXh0QXR0ciwgbWF4UmFkaXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkSG9yaXpvbnRhbFRyaWdnZXIoJ21pbicsIG1pbkJsb2NrQXR0ciwgbWluVGV4dEF0dHIsIG1pblJhZGl1cyk7XG5cbiAgICAgIHRoaXMuX2FkZEhvcml6b250YWxUcmlnZ2VyKCdtYXgnLCBtYXhCbG9ja0F0dHIsIG1heFRleHRBdHRyLCBtYXhSYWRpdXMpO1xuICAgIH1cbiAgfTsgLy8gdXNlciBpbnRlcmFjdGlvbnNcblxuXG4gIF9wcm90by5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5nZXQoJ3NsaWRhYmxlJykpIHtcbiAgICAgIHZhciBzbGlkZXIgPSB0aGlzLmdldCgnc2xpZGVyJyk7XG4gICAgICBzbGlkZXIub24oJ3NsaWRlcmNoYW5nZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBldi5yYW5nZTtcblxuICAgICAgICB2YXIgZmlyc3RJdGVtVmFsdWUgPSBfdGhpcy5nZXQoJ2ZpcnN0SXRlbScpLnZhbHVlO1xuXG4gICAgICAgIHZhciBsYXN0SXRlbVZhbHVlID0gX3RoaXMuZ2V0KCdsYXN0SXRlbScpLnZhbHVlO1xuXG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IGZpcnN0SXRlbVZhbHVlICsgcmFuZ2VbMF0gLyAxMDAgKiAobGFzdEl0ZW1WYWx1ZSAtIGZpcnN0SXRlbVZhbHVlKTtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gZmlyc3RJdGVtVmFsdWUgKyByYW5nZVsxXSAvIDEwMCAqIChsYXN0SXRlbVZhbHVlIC0gZmlyc3RJdGVtVmFsdWUpO1xuICAgICAgICB2YXIgbWluUmFkaXVzID0gTUlOX1NJWkUgKyByYW5nZVswXSAvIDEwMCAqIChNQVhfU0laRSAtIE1JTl9TSVpFKTtcbiAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1JTl9TSVpFICsgcmFuZ2VbMV0gLyAxMDAgKiAoTUFYX1NJWkUgLSBNSU5fU0laRSk7XG5cbiAgICAgICAgX3RoaXMuX3VwZGF0ZUVsZW1lbnQobWluVmFsdWUsIG1heFZhbHVlLCBtaW5SYWRpdXMsIG1heFJhZGl1cyk7XG5cbiAgICAgICAgdmFyIGl0ZW1GaWx0ZXJlZCA9IG5ldyBFdmVudCgnaXRlbWZpbHRlcicsIGV2LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgaXRlbUZpbHRlcmVkLnJhbmdlID0gW21pblZhbHVlLCBtYXhWYWx1ZV07XG5cbiAgICAgICAgX3RoaXMuZW1pdCgnaXRlbWZpbHRlcicsIGl0ZW1GaWx0ZXJlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIHVwZGF0ZSB0aGUgdHJpZ2dlcnNcblxuXG4gIF9wcm90by5fdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF91cGRhdGVFbGVtZW50KG1pbiwgbWF4LCBtaW5SLCBtYXhSKSB7XG4gICAgLy8gdXBkYXRlIHRoZSB0ZXh0IG9mIHRoZSB0cmlnZ2Vyc1xuICAgIF9Db250aW51b3VzLnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudC5jYWxsKHRoaXMsIG1pbiwgbWF4KTtcblxuICAgIHZhciBtaW5UZXh0RWxlbWVudCA9IHRoaXMuZ2V0KCdtaW5UZXh0RWxlbWVudCcpO1xuICAgIHZhciBtYXhUZXh0RWxlbWVudCA9IHRoaXMuZ2V0KCdtYXhUZXh0RWxlbWVudCcpO1xuICAgIHZhciBtaW5DaXJjbGVFbGVtZW50ID0gdGhpcy5nZXQoJ21pbkJ1dHRvbkVsZW1lbnQnKTtcbiAgICB2YXIgbWF4Q2lyY2xlRWxlbWVudCA9IHRoaXMuZ2V0KCdtYXhCdXR0b25FbGVtZW50Jyk7IC8vIHVwZGF0ZSB0aGUgcmFkaXVzIG9mIHRoZSB0cmlnZ2Vyc1xuXG4gICAgbWluQ2lyY2xlRWxlbWVudC5hdHRyKCdyJywgbWluUik7XG4gICAgbWF4Q2lyY2xlRWxlbWVudC5hdHRyKCdyJywgbWF4Uik7IC8vIHVwZGF0ZSB0aGUgdGV4dCBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlcnNcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldCgnbGF5b3V0Jyk7XG5cbiAgICBpZiAobGF5b3V0ID09PSAndmVydGljYWwnKSB7XG4gICAgICBtaW5UZXh0RWxlbWVudC5hdHRyKCd4JywgbWluUiArIDEwKTtcbiAgICAgIG1heFRleHRFbGVtZW50LmF0dHIoJ3gnLCBtYXhSICsgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeSA9IC10aGlzLmdldCgnaGVpZ2h0JykgLyAyO1xuICAgICAgbWluVGV4dEVsZW1lbnQuYXR0cigneScsIHkgKyBtaW5SICsgMTApO1xuICAgICAgbWF4VGV4dEVsZW1lbnQuYXR0cigneScsIHkgKyBtYXhSICsgMTApO1xuICAgIH1cbiAgfTsgLy8gYWRkIGEgY2lyY2xlIGZvciBzbGlkYWJsZSA9PT0gZmFsc2VcblxuXG4gIF9wcm90by5fYWRkQ2lyY2xlID0gZnVuY3Rpb24gX2FkZENpcmNsZSh4LCB5LCByLCB0ZXh0LCBtYXhXaWR0aCkge1xuICAgIHZhciBncm91cCA9IHRoaXMuZ2V0KCdncm91cCcpO1xuICAgIHZhciBjaXJjbGVHcm91cCA9IGdyb3VwLmFkZEdyb3VwKCk7XG4gICAgdmFyIGNpcmNsZVN0eWxlID0gdGhpcy5nZXQoJ191bnNsaWRhYmxlQ2lyY2xlU3R5bGUnKTtcbiAgICB2YXIgdGV4dFN0eWxlID0gdGhpcy5nZXQoJ3RleHRTdHlsZScpO1xuICAgIHZhciB0aXRsZVNoYXBlID0gdGhpcy5nZXQoJ3RpdGxlU2hhcGUnKTtcbiAgICB2YXIgdGl0bGVHYXAgPSB0aGlzLmdldCgndGl0bGVHYXAnKTtcblxuICAgIGlmICh0aXRsZVNoYXBlKSB7XG4gICAgICB0aXRsZUdhcCArPSB0aXRsZVNoYXBlLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgY2lyY2xlR3JvdXAuYWRkU2hhcGUoJ2NpcmNsZScsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHkgKyB0aXRsZUdhcCxcbiAgICAgICAgcjogciA9PT0gMCA/IDEgOiByXG4gICAgICB9LCBjaXJjbGVTdHlsZSlcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmdldCgnbGF5b3V0JykgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIGNpcmNsZUdyb3VwLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IG1heFdpZHRoICsgMjAgKyB0aGlzLmdldCgndGV4dE9mZnNldCcpLFxuICAgICAgICAgIHk6IHkgKyB0aXRsZUdhcCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0ID09PSAwID8gJzAnIDogdGV4dFxuICAgICAgICB9LCB0ZXh0U3R5bGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2lyY2xlR3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5ICsgdGl0bGVHYXAgKyBtYXhXaWR0aCArIDEzICsgdGhpcy5nZXQoJ3RleHRPZmZzZXQnKSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0ID09PSAwID8gJzAnIDogdGV4dFxuICAgICAgICB9LCB0ZXh0U3R5bGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIHRoZSBjaXJjbGVzIHdoaWxlIHNsaWRhYmxlID09PSBmYWxzZVxuXG5cbiAgX3Byb3RvLl9yZW5kZXJVbnNsaWRhYmxlID0gZnVuY3Rpb24gX3JlbmRlclVuc2xpZGFibGUoKSB7XG4gICAgdmFyIGZpcnN0SXRlbVZhbHVlID0gdGhpcy5nZXQoJ2ZpcnN0SXRlbScpLnZhbHVlO1xuICAgIHZhciBsYXN0SXRlbVZhbHVlID0gdGhpcy5nZXQoJ2xhc3RJdGVtJykudmFsdWU7XG5cbiAgICBpZiAoZmlyc3RJdGVtVmFsdWUgPiBsYXN0SXRlbVZhbHVlKSB7XG4gICAgICB2YXIgdG1wID0gbGFzdEl0ZW1WYWx1ZTtcbiAgICAgIGxhc3RJdGVtVmFsdWUgPSBmaXJzdEl0ZW1WYWx1ZTtcbiAgICAgIGZpcnN0SXRlbVZhbHVlID0gdG1wO1xuICAgIH1cblxuICAgIHZhciBtaW5UZXh0ID0gdGhpcy5fZm9ybWF0SXRlbVZhbHVlKGZpcnN0SXRlbVZhbHVlKTtcblxuICAgIHZhciBtYXhUZXh0ID0gdGhpcy5fZm9ybWF0SXRlbVZhbHVlKGxhc3RJdGVtVmFsdWUpO1xuXG4gICAgdmFyIG1pblJhZGl1cyA9IGZpcnN0SXRlbVZhbHVlIDwgTUlOX1NJWkUgPyBNSU5fU0laRSA6IGZpcnN0SXRlbVZhbHVlO1xuICAgIHZhciBtYXhSYWRpdXMgPSBsYXN0SXRlbVZhbHVlID4gTUFYX1NJWkUgPyBNQVhfU0laRSA6IGxhc3RJdGVtVmFsdWU7XG5cbiAgICBpZiAobWluUmFkaXVzID4gbWF4UmFkaXVzKSB7XG4gICAgICBtaW5SYWRpdXMgPSBNSU5fU0laRTtcbiAgICAgIG1heFJhZGl1cyA9IE1BWF9TSVpFO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldCgnbGF5b3V0JykgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHRoaXMuX2FkZENpcmNsZShtYXhSYWRpdXMsIG1heFJhZGl1cywgbWluUmFkaXVzLCBtaW5UZXh0LCAyICogbWF4UmFkaXVzKTsgLy8gbWluXG5cblxuICAgICAgdGhpcy5fYWRkQ2lyY2xlKG1heFJhZGl1cywgbWF4UmFkaXVzICogMiArIENJUkNMRV9HQVAgKyBtaW5SYWRpdXMsIG1heFJhZGl1cywgbWF4VGV4dCwgMiAqIG1heFJhZGl1cyk7IC8vIG1heFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZENpcmNsZShtYXhSYWRpdXMsIG1heFJhZGl1cywgbWluUmFkaXVzLCBtaW5UZXh0LCAyICogbWF4UmFkaXVzKTsgLy8gbWluXG5cblxuICAgICAgdGhpcy5fYWRkQ2lyY2xlKG1heFJhZGl1cyAqIDIgKyBDSVJDTEVfR0FQICsgbWluUmFkaXVzLCBtYXhSYWRpdXMsIG1heFJhZGl1cywgbWF4VGV4dCwgMiAqIG1heFJhZGl1cyk7IC8vIG1heFxuXG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hY3RpdmF0ZSA9IGZ1bmN0aW9uIGFjdGl2YXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmdldCgnc2xpZGFibGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9Db250aW51b3VzLnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4gQ2lyY2xlU2l6ZTtcbn0oQ29udGludW91cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlU2l6ZTtcblxuLyoqKi8gfSksXG4vKiAzMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuVG9vbHRpcC5IdG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzEpO1xuVG9vbHRpcC5DYW52YXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Myk7XG5Ub29sdGlwLk1pbmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMyk7XG5tb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXA7XG5cbi8qKiovIH0pLFxuLyogMzMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxudmFyIFRvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgRG9tVXRpbCA9IFV0aWwuRG9tVXRpbDtcblxudmFyIFRvb2x0aXBUaGVtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMyKTtcblxudmFyIENyb3NzaGFpciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwKTtcblxudmFyIFBvc2l0aW9uTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MSk7XG5cbnZhciBNYXJrZXJHcm91cE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjIpO1xuXG52YXIgQ09OVEFJTkVSX0NMQVNTID0gJ2cyLXRvb2x0aXAnO1xudmFyIFRJVExFX0NMQVNTID0gJ2cyLXRvb2x0aXAtdGl0bGUnO1xudmFyIExJU1RfQ0xBU1MgPSAnZzItdG9vbHRpcC1saXN0JztcbnZhciBNQVJLRVJfQ0xBU1MgPSAnZzItdG9vbHRpcC1tYXJrZXInO1xudmFyIFZBTFVFX0NMQVNTID0gJ2cyLXRvb2x0aXAtdmFsdWUnO1xudmFyIExJU1RfSVRFTV9DTEFTUyA9ICdnMi10b29sdGlwLWxpc3QtaXRlbSc7XG5cbmZ1bmN0aW9uIGZpbmQoZG9tLCBjbHMpIHtcbiAgcmV0dXJuIGRvbS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNscylbMF07XG59XG5cbmZ1bmN0aW9uIG1lcmdlU3R5bGVzKHN0eWxlcywgY2ZnKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChjZmdba10pIHtcbiAgICAgIHN0eWxlc1trXSA9IFV0aWwubWl4KHN0eWxlc1trXSwgY2ZnW2tdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3R5bGVzO1xufVxuXG52YXIgSHRtbFRvb2x0aXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Ub29sdGlwKSB7XG4gIF9pbmhlcml0c0xvb3NlKEh0bWxUb29sdGlwLCBfVG9vbHRpcCk7XG5cbiAgdmFyIF9wcm90byA9IEh0bWxUb29sdGlwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9Ub29sdGlwLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICByZXR1cm4gVXRpbC5taXgoe30sIGNmZywge1xuICAgICAgLyoqXG4gICAgICAgICAqIHRvb2x0aXAg5a655Zmo5qih5p2/XG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAqL1xuICAgICAgY29udGFpbmVyVHBsOiAnIDxkaXYgY2xhc3M9XCInICsgQ09OVEFJTkVSX0NMQVNTICsgJ1wiPiAnICsgJzxkaXYgY2xhc3M9XCInICsgVElUTEVfQ0xBU1MgKyAnXCI+PC9kaXY+JyArICc8dWwgY2xhc3M9XCInICsgTElTVF9DTEFTUyArICdcIj48L3VsPicgKyAnPC9kaXY+JyxcblxuICAgICAgLyoqXG4gICAgICAgKiB0b29sdGlwIOWIl+ihqOmhueaooeadv1xuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgaXRlbVRwbDogJzxsaSBkYXRhLWluZGV4PXtpbmRleH0+JyArICc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6e2NvbG9yfTtcIiBjbGFzcz0nICsgTUFSS0VSX0NMQVNTICsgJz48L3NwYW4+JyArICd7bmFtZX08c3BhbiBjbGFzcz0nICsgVkFMVUVfQ0xBU1MgKyAnPnt2YWx1ZX08L3NwYW4+PC9saT4nLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRvb2x0aXAgaHRtbOWGheWuuVxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgaHRtbENvbnRlbnQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogdG9vbHRpcCDlhoXlrrnot5/pmo/pvKDmoIfnp7vliqhcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBmb2xsb3c6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICog5piv5ZCm5YWB6K646byg5qCH5YGc55WZ5ZyoIHRvb2x0aXAg5LiK77yM6buY6K6k5LiN5YWB6K64XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgZW50ZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEh0bWxUb29sdGlwKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1Rvb2x0aXAuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFBvc2l0aW9uTWl4aW4pO1xuICAgIFV0aWwuYXNzaWduKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBNYXJrZXJHcm91cE1peGluKTtcbiAgICB2YXIgc3R5bGUgPSBUb29sdGlwVGhlbWU7XG4gICAgX3RoaXMuc3R5bGUgPSBtZXJnZVN0eWxlcyhzdHlsZSwgY2ZnKTtcblxuICAgIF90aGlzLl9pbml0XygpO1xuXG4gICAgaWYgKF90aGlzLmdldCgnaXRlbXMnKSkge1xuICAgICAgX3RoaXMucmVuZGVyKCk7XG4gICAgfSAvLyBjcm9zc2hhaXJcblxuXG4gICAgdmFyIGNyb3NzaGFpciA9IF90aGlzLmdldCgnY3Jvc3NoYWlycycpO1xuXG4gICAgaWYgKGNyb3NzaGFpcikge1xuICAgICAgdmFyIHBsb3QgPSBjcm9zc2hhaXIudHlwZSA9PT0gJ3JlY3QnID8gX3RoaXMuZ2V0KCdiYWNrUGxvdCcpIDogX3RoaXMuZ2V0KCdmcm9udFBsb3QnKTtcbiAgICAgIHZhciBjcm9zc2hhaXJHcm91cCA9IG5ldyBDcm9zc2hhaXIoVXRpbC5taXgoe1xuICAgICAgICBwbG90OiBwbG90LFxuICAgICAgICBwbG90UmFuZ2U6IF90aGlzLmdldCgncGxvdFJhbmdlJyksXG4gICAgICAgIGNhbnZhczogX3RoaXMuZ2V0KCdjYW52YXMnKVxuICAgICAgfSwgX3RoaXMuZ2V0KCdjcm9zc2hhaXJzJykpKTtcbiAgICAgIGNyb3NzaGFpckdyb3VwLmhpZGUoKTtcblxuICAgICAgX3RoaXMuc2V0KCdjcm9zc2hhaXJHcm91cCcsIGNyb3NzaGFpckdyb3VwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfcHJvdG8uX2luaXRfID0gZnVuY3Rpb24gX2luaXRfKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyVHBsID0gc2VsZi5nZXQoJ2NvbnRhaW5lclRwbCcpO1xuICAgIHZhciBvdXR0ZXJOb2RlID0gc2VsZi5nZXQoJ2NhbnZhcycpLmdldCgnZWwnKS5wYXJlbnROb2RlO1xuICAgIHZhciBjb250YWluZXI7XG5cbiAgICBpZiAoIXRoaXMuZ2V0KCdodG1sQ29udGVudCcpKSB7XG4gICAgICBpZiAoL15cXCMvLnRlc3QoY29udGFpbmVyVHBsKSkge1xuICAgICAgICAvLyDlpoLmnpzkvKDlhaUgZG9tIOiKgueCueeahCBpZFxuICAgICAgICB2YXIgaWQgPSBjb250YWluZXJUcGwucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGVEb20oY29udGFpbmVyVHBsKTtcbiAgICAgICAgRG9tVXRpbC5tb2RpZnlDU1MoY29udGFpbmVyLCBzZWxmLnN0eWxlW0NPTlRBSU5FUl9DTEFTU10pO1xuICAgICAgICBvdXR0ZXJOb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIG91dHRlck5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnNldCgnY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jbGVhcigpO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdodG1sQ29udGVudCcpKSB7XG4gICAgICB2YXIgb3V0dGVyTm9kZSA9IHNlbGYuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJykucGFyZW50Tm9kZTtcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2dldEh0bWxDb250ZW50KCk7XG5cbiAgICAgIG91dHRlck5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgIHNlbGYuc2V0KCdjb250YWluZXInLCBjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9yZW5kZXJUcGwoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJUcGwgPSBmdW5jdGlvbiBfcmVuZGVyVHBsKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2hvd1RpdGxlID0gc2VsZi5nZXQoJ3Nob3dUaXRsZScpO1xuICAgIHZhciB0aXRsZUNvbnRlbnQgPSBzZWxmLmdldCgndGl0bGVDb250ZW50Jyk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgdGl0bGVEb20gPSBmaW5kKGNvbnRhaW5lciwgVElUTEVfQ0xBU1MpO1xuICAgIHZhciBsaXN0RG9tID0gZmluZChjb250YWluZXIsIExJU1RfQ0xBU1MpO1xuICAgIHZhciBpdGVtcyA9IHNlbGYuZ2V0KCdpdGVtcycpO1xuXG4gICAgaWYgKHRpdGxlRG9tICYmIHNob3dUaXRsZSkge1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1ModGl0bGVEb20sIHNlbGYuc3R5bGVbVElUTEVfQ0xBU1NdKTtcbiAgICAgIHRpdGxlRG9tLmlubmVySFRNTCA9IHRpdGxlQ29udGVudDtcbiAgICB9XG5cbiAgICBpZiAobGlzdERvbSkge1xuICAgICAgRG9tVXRpbC5tb2RpZnlDU1MobGlzdERvbSwgc2VsZi5zdHlsZVtMSVNUX0NMQVNTXSk7XG4gICAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBsaXN0RG9tLmFwcGVuZENoaWxkKHNlbGYuX2FkZEl0ZW0oaXRlbSwgaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdodG1sQ29udGVudCcpKSB7XG4gICAgICBjb250YWluZXIgJiYgY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGl0bGVEb20gPSBmaW5kKGNvbnRhaW5lciwgVElUTEVfQ0xBU1MpO1xuICAgICAgdmFyIGxpc3REb20gPSBmaW5kKGNvbnRhaW5lciwgTElTVF9DTEFTUyk7XG5cbiAgICAgIGlmICh0aXRsZURvbSkge1xuICAgICAgICB0aXRsZURvbS5pbm5lckhUTUwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3REb20pIHtcbiAgICAgICAgbGlzdERvbS5pbm5lckhUTUwgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHZhciBjcm9zc2hhaXJHcm91cCA9IHRoaXMuZ2V0KCdjcm9zc2hhaXJHcm91cCcpO1xuICAgIGNyb3NzaGFpckdyb3VwICYmIGNyb3NzaGFpckdyb3VwLnNob3coKTtcbiAgICB2YXIgbWFya2VyR3JvdXAgPSB0aGlzLmdldCgnbWFya2VyR3JvdXAnKTtcbiAgICBtYXJrZXJHcm91cCAmJiBtYXJrZXJHcm91cC5zaG93KCk7XG5cbiAgICBfVG9vbHRpcC5wcm90b3R5cGUuc2hvdy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgfTtcblxuICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcbiAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHZhciBjcm9zc2hhaXJHcm91cCA9IHRoaXMuZ2V0KCdjcm9zc2hhaXJHcm91cCcpO1xuICAgIGNyb3NzaGFpckdyb3VwICYmIGNyb3NzaGFpckdyb3VwLmhpZGUoKTtcbiAgICB2YXIgbWFya2VyR3JvdXAgPSB0aGlzLmdldCgnbWFya2VyR3JvdXAnKTtcbiAgICBtYXJrZXJHcm91cCAmJiBtYXJrZXJHcm91cC5oaWRlKCk7XG5cbiAgICBfVG9vbHRpcC5wcm90b3R5cGUuaGlkZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmdldCgnY29udGFpbmVyJyk7XG4gICAgdmFyIGNvbnRhaW5lclRwbCA9IHNlbGYuZ2V0KCdjb250YWluZXJUcGwnKTtcblxuICAgIGlmIChjb250YWluZXIgJiYgIS9eXFwjLy50ZXN0KGNvbnRhaW5lclRwbCkpIHtcbiAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIGNyb3NzaGFpckdyb3VwID0gdGhpcy5nZXQoJ2Nyb3NzaGFpckdyb3VwJyk7XG4gICAgY3Jvc3NoYWlyR3JvdXAgJiYgY3Jvc3NoYWlyR3JvdXAuZGVzdHJveSgpO1xuICAgIHZhciBtYXJrZXJHcm91cCA9IHRoaXMuZ2V0KCdtYXJrZXJHcm91cCcpO1xuICAgIG1hcmtlckdyb3VwICYmIG1hcmtlckdyb3VwLnJlbW92ZSgpO1xuXG4gICAgX1Rvb2x0aXAucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZEl0ZW0gPSBmdW5jdGlvbiBfYWRkSXRlbShpdGVtLCBpbmRleCkge1xuICAgIHZhciBpdGVtVHBsID0gdGhpcy5nZXQoJ2l0ZW1UcGwnKTsgLy8gVE9ETzog5pyJ5Y+v6IO95piv5Liq5Zue6LCD5Ye95pWwXG5cbiAgICB2YXIgaXRlbURpdiA9IFV0aWwuc3Vic3RpdHV0ZShpdGVtVHBsLCBVdGlsLm1peCh7XG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9LCBpdGVtKSk7XG4gICAgdmFyIGl0ZW1ET00gPSBEb21VdGlsLmNyZWF0ZURvbShpdGVtRGl2KTtcbiAgICBEb21VdGlsLm1vZGlmeUNTUyhpdGVtRE9NLCB0aGlzLnN0eWxlW0xJU1RfSVRFTV9DTEFTU10pO1xuICAgIHZhciBtYXJrZXJEb20gPSBmaW5kKGl0ZW1ET00sIE1BUktFUl9DTEFTUyk7XG5cbiAgICBpZiAobWFya2VyRG9tKSB7XG4gICAgICBEb21VdGlsLm1vZGlmeUNTUyhtYXJrZXJEb20sIHRoaXMuc3R5bGVbTUFSS0VSX0NMQVNTXSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlRG9tID0gZmluZChpdGVtRE9NLCBWQUxVRV9DTEFTUyk7XG5cbiAgICBpZiAodmFsdWVEb20pIHtcbiAgICAgIERvbVV0aWwubW9kaWZ5Q1NTKHZhbHVlRG9tLCB0aGlzLnN0eWxlW1ZBTFVFX0NMQVNTXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1ET007XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRIdG1sQ29udGVudCA9IGZ1bmN0aW9uIF9nZXRIdG1sQ29udGVudCgpIHtcbiAgICB2YXIgaHRtbENvbnRlbnQgPSB0aGlzLmdldCgnaHRtbENvbnRlbnQnKTtcbiAgICB2YXIgdGl0bGUgPSB0aGlzLmdldCgndGl0bGVDb250ZW50Jyk7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5nZXQoJ2l0ZW1zJyk7XG4gICAgdmFyIGh0bWxTdHJpbmcgPSBodG1sQ29udGVudCh0aXRsZSwgaXRlbXMpO1xuICAgIHZhciBlbGUgPSBEb21VdGlsLmNyZWF0ZURvbShodG1sU3RyaW5nKTtcbiAgICByZXR1cm4gZWxlO1xuICB9O1xuXG4gIF9wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFBvc2l0aW9uKHgsIHksIHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldCgnY29udGFpbmVyJyk7XG4gICAgdmFyIG91dHRlck5vZGUgPSB0aGlzLmdldCgnY2FudmFzJykuZ2V0KCdlbCcpO1xuICAgIHZhciB2aWV3V2lkdGggPSBEb21VdGlsLmdldFdpZHRoKG91dHRlck5vZGUpO1xuICAgIHZhciB2aWV3SGVpZ2h0ID0gRG9tVXRpbC5nZXRIZWlnaHQob3V0dGVyTm9kZSk7XG4gICAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBlbmR4ID0geDtcbiAgICB2YXIgZW5keSA9IHk7XG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIHZhciBwcmVQb3NpdGlvbiA9IHRoaXMuZ2V0KCdwcmVQb3NpdGlvbicpIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmdldCgnZW50ZXJhYmxlJykpIHtcbiAgICAgIHkgPSB5IC0gY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICBwb3NpdGlvbiA9IFt4LCB5XTtcblxuICAgICAgaWYgKHByZVBvc2l0aW9uICYmIHggLSBwcmVQb3NpdGlvbi54ID4gMCkge1xuICAgICAgICAvLyDnlZkgMXB4IOmYsuatoum8oOagh+eCueWHu+S6i+S7tuaXoOazleWcqOeUu+W4g+S4iuinpuWPkVxuICAgICAgICB4IC09IGNvbnRhaW5lci5jbGllbnRXaWR0aCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldCgncG9zaXRpb24nKSkge1xuICAgICAgdmFyIF9jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBfY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fY2FsY1Rvb2x0aXBQb3NpdGlvbih4LCB5LCB0aGlzLmdldCgncG9zaXRpb24nKSwgX2NvbnRhaW5lcldpZHRoLCBfY29udGFpbmVySGVpZ2h0LCB0YXJnZXQpO1xuICAgICAgeCA9IHBvc2l0aW9uWzBdO1xuICAgICAgeSA9IHBvc2l0aW9uWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX2NvbnN0cmFpbnRQb3NpdGlvbkluQm91bmRhcnkoeCwgeSwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICAgIHggPSBwb3NpdGlvblswXTtcbiAgICAgIHkgPSBwb3NpdGlvblsxXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXQoJ2luUGxvdCcpKSB7XG4gICAgICAvLyB0b29sdGlwIOW/hemhu+mZkOWItuWcqOe7mOWbvuWMuuWfn+WGhVxuICAgICAgdmFyIHBsb3RSYW5nZSA9IHRoaXMuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICAgIHBvc2l0aW9uID0gdGhpcy5fY29uc3RyYWludFBvc2l0aW9uSW5QbG90KHgsIHksIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIHBsb3RSYW5nZSwgdGhpcy5nZXQoJ2VudGVyYWJsZScpKTtcbiAgICAgIHggPSBwb3NpdGlvblswXTtcbiAgICAgIHkgPSBwb3NpdGlvblsxXTtcbiAgICB9XG5cbiAgICB2YXIgbWFya2VySXRlbXMgPSB0aGlzLmdldCgnbWFya2VySXRlbXMnKTtcblxuICAgIGlmICghVXRpbC5pc0VtcHR5KG1hcmtlckl0ZW1zKSkge1xuICAgICAgZW5keCA9IG1hcmtlckl0ZW1zWzBdLng7XG4gICAgICBlbmR5ID0gbWFya2VySXRlbXNbMF0ueTtcbiAgICB9XG5cbiAgICB0aGlzLnNldCgncHJlUG9zaXRpb24nLCBwb3NpdGlvbik7IC8vIOiusOW9leS4iuasoeeahOS9jee9rlxuXG4gICAgdmFyIGZvbGxvdyA9IHRoaXMuZ2V0KCdmb2xsb3cnKTtcblxuICAgIGlmIChmb2xsb3cpIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICBjb250YWluZXIuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgfVxuXG4gICAgdmFyIGNyb3NzaGFpckdyb3VwID0gdGhpcy5nZXQoJ2Nyb3NzaGFpckdyb3VwJyk7XG5cbiAgICBpZiAoY3Jvc3NoYWlyR3JvdXApIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0KCdpdGVtcycpO1xuICAgICAgY3Jvc3NoYWlyR3JvdXAuc2V0UG9zaXRpb24oZW5keCwgZW5keSwgaXRlbXMpO1xuICAgIH1cblxuICAgIF9Ub29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHgsIHkpO1xuICB9O1xuXG4gIHJldHVybiBIdG1sVG9vbHRpcDtcbn0oVG9vbHRpcCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbFRvb2x0aXA7XG5cbi8qKiovIH0pLFxuLyogMzMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfVG9vbHRpcFRoZW1lO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSxcbiAgICBGT05UX0ZBTUlMWSA9IF9yZXF1aXJlLkZPTlRfRkFNSUxZOyAvLyB0b29sdGlwIOebuOWFsyBkb20g55qEIGNzcyDnsbvlkI1cblxuXG52YXIgVE9PTFRJUF9DT05UQUlORVJfQ0xBU1MgPSAnZzItdG9vbHRpcCc7XG52YXIgVE9PTFRJUF9USVRMRV9DTEFTUyA9ICdnMi10b29sdGlwLXRpdGxlJztcbnZhciBUT09MVElQX0xJU1RfQ0xBU1MgPSAnZzItdG9vbHRpcC1saXN0JztcbnZhciBUT09MVElQX0xJU1RfSVRFTV9DTEFTUyA9ICdnMi10b29sdGlwLWxpc3QtaXRlbSc7XG52YXIgVE9PTFRJUF9NQVJLRVJfQ0xBU1MgPSAnZzItdG9vbHRpcC1tYXJrZXInO1xudmFyIFRPT0xUSVBfVkFMVUVfQ0xBU1MgPSAnZzItdG9vbHRpcC12YWx1ZSc7XG52YXIgVG9vbHRpcFRoZW1lID0gKF9Ub29sdGlwVGhlbWUgPSB7XG4gIGNyb3NzaGFpcnM6IGZhbHNlLFxuICBvZmZzZXQ6IDE1XG59LCBfVG9vbHRpcFRoZW1lW1wiXCIgKyBUT09MVElQX0NPTlRBSU5FUl9DTEFTU10gPSB7XG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgLy8gQDIwMTgtMDctMjUgYnkgYmx1ZS5sYiDov5nph4zljrvmjonmta7liqjvvIzngavni5DkuIrlrZjlnKjmoLflvI/plJnkvY1cbiAgLy8gd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gIHpJbmRleDogOCxcbiAgdHJhbnNpdGlvbjogJ3Zpc2liaWxpdHkgMC4ycyBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSksIGxlZnQgMC40cyBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSksIHRvcCAwLjRzIGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKScsXG4gIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45KScsXG4gIGJveFNoYWRvdzogJzBweCAwcHggMTBweCAjYWVhZWFlJyxcbiAgYm9yZGVyUmFkaXVzOiAnM3B4JyxcbiAgY29sb3I6ICdyZ2IoODcsIDg3LCA4NyknLFxuICBmb250U2l6ZTogJzEycHgnLFxuICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWSxcbiAgbGluZUhlaWdodDogJzIwcHgnLFxuICBwYWRkaW5nOiAnMTBweCAxMHB4IDZweCAxMHB4J1xufSwgX1Rvb2x0aXBUaGVtZVtcIlwiICsgVE9PTFRJUF9USVRMRV9DTEFTU10gPSB7XG4gIG1hcmdpbkJvdHRvbTogJzRweCdcbn0sIF9Ub29sdGlwVGhlbWVbXCJcIiArIFRPT0xUSVBfTElTVF9DTEFTU10gPSB7XG4gIG1hcmdpbjogMCxcbiAgbGlzdFN0eWxlVHlwZTogJ25vbmUnLFxuICBwYWRkaW5nOiAwXG59LCBfVG9vbHRpcFRoZW1lW1wiXCIgKyBUT09MVElQX0xJU1RfSVRFTV9DTEFTU10gPSB7XG4gIG1hcmdpbkJvdHRvbTogJzRweCdcbn0sIF9Ub29sdGlwVGhlbWVbXCJcIiArIFRPT0xUSVBfTUFSS0VSX0NMQVNTXSA9IHtcbiAgd2lkdGg6ICc1cHgnLFxuICBoZWlnaHQ6ICc1cHgnLFxuICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgbWFyZ2luUmlnaHQ6ICc4cHgnXG59LCBfVG9vbHRpcFRoZW1lW1wiXCIgKyBUT09MVElQX1ZBTFVFX0NMQVNTXSA9IHtcbiAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gIGZsb2F0OiAncmlnaHQnLFxuICBtYXJnaW5MZWZ0OiAnMzBweCdcbn0sIF9Ub29sdGlwVGhlbWUpO1xubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwVGhlbWU7XG5cbi8qKiovIH0pLFxuLyogMzMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgQ2FudmFzVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYzKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCksXG4gICAgRk9OVF9GQU1JTFkgPSBfcmVxdWlyZS5GT05UX0ZBTUlMWTtcblxudmFyIERvbVV0aWwgPSBVdGlsLkRvbVV0aWw7XG52YXIgTWF0cml4VXRpbCA9IFV0aWwuTWF0cml4VXRpbDtcblxudmFyIE1pbmlUb29sdGlwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ2FudmFzVG9vbHRpcCkge1xuICBfaW5oZXJpdHNMb29zZShNaW5pVG9vbHRpcCwgX0NhbnZhc1Rvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIE1pbmlUb29sdGlwKCkge1xuICAgIHJldHVybiBfQ2FudmFzVG9vbHRpcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWluaVRvb2x0aXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0NhbnZhc1Rvb2x0aXAucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICAvKipcbiAgICAgICAqIOm7mOiupOiDjOaZr+adv+agt+W8j1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgYm9hcmRTdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAvLyBmaWxsOiAncmdiYSg1MCwgNTAsIDUwLCAxKScsXG4gICAgICAgIHJhZGl1czogM1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiDpu5jorqR2YWx1Zeagt+W8j1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqICovXG4gICAgICB2YWx1ZVN0eWxlOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBmb250RmFtaWx5OiBGT05UX0ZBTUlMWSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBzdHJva2U6ICcjZmZmJyxcbiAgICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxuICAgICAgICB0ZXh0QWxpZ246ICdzdGFydCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICog6buY6K6kcGFkZGluZ+WAvFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDUsXG4gICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDVcbiAgICAgIH0sXG4gICAgICB0cmlhbmdsZVdpZHRoOiAxMCxcbiAgICAgIHRyaWFuZ2xlSGVpZ2h0OiA0XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0XyA9IGZ1bmN0aW9uIF9pbml0XygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhZGRpbmcgPSBzZWxmLmdldCgncGFkZGluZycpO1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLmdldCgnZnJvbnRQbG90Jyk7IC8vIGNvbnRhaW5lclxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHBhcmVudC5hZGRHcm91cCgpO1xuICAgIHNlbGYuc2V0KCdjb250YWluZXInLCBjb250YWluZXIpOyAvLyBib2FyZFxuXG4gICAgdmFyIGJvYXJkID0gY29udGFpbmVyLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHt9LCBzZWxmLmdldCgnYm9hcmRTdHlsZScpKVxuICAgIH0pO1xuICAgIHNlbGYuc2V0KCdib2FyZCcsIGJvYXJkKTsgLy8gdHJpYW5nbGVTaHBlXG5cbiAgICB2YXIgdHJpYW5nbGVTaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIGZpbGw6IHNlbGYuZ2V0KCdib2FyZFN0eWxlJykuZmlsbFxuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYuc2V0KCd0cmlhbmdsZVNoYXBlJywgdHJpYW5nbGVTaGFwZSk7IC8vIGl0ZW1Hcm91cFxuXG4gICAgdmFyIGl0ZW1Hcm91cCA9IGNvbnRhaW5lci5hZGRHcm91cCgpO1xuICAgIGl0ZW1Hcm91cC5tb3ZlKHBhZGRpbmcubGVmdCwgcGFkZGluZy50b3ApOyAvLyB2YWx1ZVxuXG4gICAgdmFyIHZhbHVlU2hhcGUgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoe30sIHNlbGYuZ2V0KCd2YWx1ZVN0eWxlJykpXG4gICAgfSk7XG4gICAgc2VsZi5zZXQoJ3ZhbHVlU2hhcGUnLCB2YWx1ZVNoYXBlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNsZWFyKCk7XG4gICAgdmFyIGJvYXJkID0gc2VsZi5nZXQoJ2JvYXJkJyk7XG4gICAgdmFyIHZhbHVlU2hhcGUgPSBzZWxmLmdldCgndmFsdWVTaGFwZScpO1xuICAgIHZhciBwYWRkaW5nID0gc2VsZi5nZXQoJ3BhZGRpbmcnKTtcbiAgICB2YXIgaXRlbSA9IHNlbGYuZ2V0KCdpdGVtcycpWzBdO1xuXG4gICAgaWYgKHZhbHVlU2hhcGUpIHtcbiAgICAgIHZhbHVlU2hhcGUuYXR0cigndGV4dCcsIGl0ZW0udmFsdWUpO1xuICAgIH0gLy8gdXBkYXRlIGJvYXJkIGJhc2VkIG9uIGJib3hcblxuXG4gICAgdmFyIGJib3ggPSB2YWx1ZVNoYXBlID8gdmFsdWVTaGFwZS5nZXRCQm94KCkgOiB7XG4gICAgICB3aWR0aDogODAsXG4gICAgICBoZWlnaHQ6IDMwXG4gICAgfTtcbiAgICB2YXIgd2lkdGggPSBwYWRkaW5nLmxlZnQgKyBiYm94LndpZHRoICsgcGFkZGluZy5yaWdodDtcbiAgICB2YXIgaGVpZ2h0ID0gcGFkZGluZy50b3AgKyBiYm94LmhlaWdodCArIHBhZGRpbmcuYm90dG9tO1xuICAgIGJvYXJkLmF0dHIoJ3dpZHRoJywgd2lkdGgpO1xuICAgIGJvYXJkLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7IC8vIHVwZGF0ZSB0cmlhbmdsZSBzaGFwZVxuXG4gICAgc2VsZi5fY2VudGVyVHJpYW5nbGVTaGFwZSgpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciB2YWx1ZVNoYXBlID0gdGhpcy5nZXQoJ3ZhbHVlU2hhcGUnKTtcbiAgICB2YWx1ZVNoYXBlLmF0dHIoJ3RleHQnLCAnJyk7XG4gIH07XG5cbiAgX3Byb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmdldCgnY29udGFpbmVyJyk7XG4gICAgdmFyIHBsb3RSYW5nZSA9IHNlbGYuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICB2YXIgYmJveCA9IGNvbnRhaW5lci5nZXRCQm94KCk7XG4gICAgdmFyIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgeCAtPSB3aWR0aCAvIDI7XG5cbiAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQubmFtZSA9PT0gJ3BvaW50JyB8fCB0YXJnZXQubmFtZSA9PT0gJ2ludGVydmFsJykpIHtcbiAgICAgIHZhciB0YXJnZXRZID0gdGFyZ2V0LmdldEJCb3goKS55O1xuICAgICAgeSA9IHRhcmdldFk7XG4gICAgfVxuXG4gICAgeSAtPSBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5nZXQoJ2luUGxvdCcpKSB7XG4gICAgICAvLyBjb25zdHJhaW4gaW4gcGxvdFxuICAgICAgaWYgKHggPCBwbG90UmFuZ2UudGwueCkge1xuICAgICAgICB4ID0gcGxvdFJhbmdlLnRsLng7XG5cbiAgICAgICAgc2VsZi5fbGVmdFRyaWFuZ2xlU2hhcGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoeCArIHdpZHRoIC8gMiA+IHBsb3RSYW5nZS50ci54KSB7XG4gICAgICAgIHggPSBwbG90UmFuZ2UudHIueCAtIHdpZHRoO1xuXG4gICAgICAgIHNlbGYuX3JpZ2h0VHJpYW5nbGVTaGFwZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fY2VudGVyVHJpYW5nbGVTaGFwZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA8IHBsb3RSYW5nZS50bC55KSB7XG4gICAgICAgIHkgPSBwbG90UmFuZ2UudGwueTtcbiAgICAgIH0gZWxzZSBpZiAoeSArIGhlaWdodCA+IHBsb3RSYW5nZS5ibC55KSB7XG4gICAgICAgIHkgPSBwbG90UmFuZ2UuYmwueSAtIGhlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc3RyYWluIGluIGRvbVxuICAgICAgdmFyIG91dHRlck5vZGUgPSB0aGlzLmdldCgnY2FudmFzJykuZ2V0KCdlbCcpO1xuICAgICAgdmFyIHZpZXdXaWR0aCA9IERvbVV0aWwuZ2V0V2lkdGgob3V0dGVyTm9kZSk7XG4gICAgICB2YXIgdmlld0hlaWdodCA9IERvbVV0aWwuZ2V0SGVpZ2h0KG91dHRlck5vZGUpO1xuXG4gICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgeCA9IDA7XG5cbiAgICAgICAgc2VsZi5fbGVmdFRyaWFuZ2xlU2hhcGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoeCArIHdpZHRoIC8gMiA+IHZpZXdXaWR0aCkge1xuICAgICAgICB4ID0gdmlld1dpZHRoIC0gd2lkdGg7XG5cbiAgICAgICAgc2VsZi5fcmlnaHRUcmlhbmdsZVNoYXBlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9jZW50ZXJUcmlhbmdsZVNoYXBlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeSArIGhlaWdodCA+IHZpZXdIZWlnaHQpIHtcbiAgICAgICAgeSA9IHZpZXdIZWlnaHQgLSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVsTWF0cml4ID0gWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdO1xuICAgIHZhciBtYXQgPSBNYXRyaXhVdGlsLnRyYW5zZm9ybSh1bE1hdHJpeCwgW1sndCcsIHgsIHldXSk7XG4gICAgY29udGFpbmVyLnN0b3BBbmltYXRlKCk7XG4gICAgY29udGFpbmVyLmFuaW1hdGUoe1xuICAgICAgbWF0cml4OiBtYXRcbiAgICB9LCB0aGlzLmdldCgnYW5pbWF0aW9uRHVyYXRpb24nKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9jZW50ZXJUcmlhbmdsZVNoYXBlID0gZnVuY3Rpb24gX2NlbnRlclRyaWFuZ2xlU2hhcGUoKSB7XG4gICAgdmFyIHRyaWFuZ2xlID0gdGhpcy5nZXQoJ3RyaWFuZ2xlU2hhcGUnKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgndHJpYW5nbGVXaWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgndHJpYW5nbGVIZWlnaHQnKTtcbiAgICB2YXIgYm9hcmRCQm94ID0gdGhpcy5nZXQoJ2JvYXJkJykuZ2V0QkJveCgpO1xuICAgIHZhciBib2FyZFdpZHRoID0gYm9hcmRCQm94LndpZHRoO1xuICAgIHZhciBib2FyZEhlaWdodCA9IGJvYXJkQkJveC5oZWlnaHQ7XG4gICAgdmFyIHBhdGhBcnJheSA9IFtbJ00nLCAwLCAwXSwgWydMJywgd2lkdGgsIDBdLCBbJ0wnLCB3aWR0aCAvIDIsIGhlaWdodF0sIFsnTCcsIDAsIDBdLCBbJ1onXV07XG4gICAgdHJpYW5nbGUuYXR0cigncGF0aCcsIHBhdGhBcnJheSk7XG4gICAgdHJpYW5nbGUubW92ZShib2FyZFdpZHRoIC8gMiAtIHdpZHRoIC8gMiwgYm9hcmRIZWlnaHQgLSAxKTtcbiAgfTtcblxuICBfcHJvdG8uX2xlZnRUcmlhbmdsZVNoYXBlID0gZnVuY3Rpb24gX2xlZnRUcmlhbmdsZVNoYXBlKCkge1xuICAgIHZhciB0cmlhbmdsZSA9IHRoaXMuZ2V0KCd0cmlhbmdsZVNoYXBlJyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXQoJ3RyaWFuZ2xlV2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ3RyaWFuZ2xlSGVpZ2h0Jyk7XG4gICAgdmFyIGJvYXJkQkJveCA9IHRoaXMuZ2V0KCdib2FyZCcpLmdldEJCb3goKTtcbiAgICB2YXIgYm9hcmRIZWlnaHQgPSBib2FyZEJCb3guaGVpZ2h0O1xuICAgIHZhciBwYXRoQXJyYXkgPSBbWydNJywgMCwgMF0sIFsnTCcsIHdpZHRoLCAwXSwgWydMJywgMCwgaGVpZ2h0ICsgM10sIFsnTCcsIDAsIDBdLCBbJ1onXV07XG4gICAgdHJpYW5nbGUuYXR0cigncGF0aCcsIHBhdGhBcnJheSk7XG4gICAgdHJpYW5nbGUubW92ZSgwLCBib2FyZEhlaWdodCAtIDMpO1xuICB9O1xuXG4gIF9wcm90by5fcmlnaHRUcmlhbmdsZVNoYXBlID0gZnVuY3Rpb24gX3JpZ2h0VHJpYW5nbGVTaGFwZSgpIHtcbiAgICB2YXIgdHJpYW5nbGUgPSB0aGlzLmdldCgndHJpYW5nbGVTaGFwZScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd0cmlhbmdsZVdpZHRoJyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0KCd0cmlhbmdsZUhlaWdodCcpO1xuICAgIHZhciBib2FyZEJCb3ggPSB0aGlzLmdldCgnYm9hcmQnKS5nZXRCQm94KCk7XG4gICAgdmFyIGJvYXJkV2lkdGggPSBib2FyZEJCb3gud2lkdGg7XG4gICAgdmFyIGJvYXJkSGVpZ2h0ID0gYm9hcmRCQm94LmhlaWdodDtcbiAgICB2YXIgcGF0aEFycmF5ID0gW1snTScsIDAsIDBdLCBbJ0wnLCB3aWR0aCwgMF0sIFsnTCcsIHdpZHRoLCBoZWlnaHQgKyA0XSwgWydMJywgMCwgMF0sIFsnWiddXTtcbiAgICB0cmlhbmdsZS5hdHRyKCdwYXRoJywgcGF0aEFycmF5KTtcbiAgICB0cmlhbmdsZS5tb3ZlKGJvYXJkV2lkdGggLSB3aWR0aCAtIDEsIGJvYXJkSGVpZ2h0IC0gNCk7XG4gIH07XG5cbiAgcmV0dXJuIE1pbmlUb29sdGlwO1xufShDYW52YXNUb29sdGlwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaW5pVG9vbHRpcDtcblxuLyoqKi8gfSksXG4vKiAzMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hdHJpeFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLk1hdHJpeFV0aWw7XG5cbnZhciBWZWN0b3IyID0gTWF0cml4VXRpbC52ZWMyO1xuXG5mdW5jdGlvbiBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBoYXNDb25zdHJhaW50ID0gISFjb25zdHJhaW50O1xuICB2YXIgbWluLCBtYXg7XG5cbiAgaWYgKGhhc0NvbnN0cmFpbnQpIHtcbiAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBtaW4gPSBWZWN0b3IyLm1pbihbXSwgbWluLCBwb2ludCk7XG4gICAgICBtYXggPSBWZWN0b3IyLm1heChbXSwgbWF4LCBwb2ludCk7XG4gICAgfVxuXG4gICAgbWluID0gVmVjdG9yMi5taW4oW10sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgbWF4ID0gVmVjdG9yMi5tYXgoW10sIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgdmFyIF9wb2ludCA9IHBvaW50c1tfaV07XG5cbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbX2kgPyBfaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgIG5leHRQb2ludCA9IHBvaW50c1soX2kgKyAxKSAlIGxlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfaSA9PT0gMCB8fCBfaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBjcHMucHVzaChfcG9pbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tfaSAtIDFdO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbX2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdiA9IFtdO1xuICAgIHYgPSBWZWN0b3IyLnN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7XG4gICAgdiA9IFZlY3RvcjIuc2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSBWZWN0b3IyLmRpc3RhbmNlKF9wb2ludCwgcHJldlBvaW50KTtcbiAgICB2YXIgZDEgPSBWZWN0b3IyLmRpc3RhbmNlKF9wb2ludCwgbmV4dFBvaW50KTtcbiAgICB2YXIgc3VtID0gZDAgKyBkMTtcblxuICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgIGQwIC89IHN1bTtcbiAgICAgIGQxIC89IHN1bTtcbiAgICB9XG5cbiAgICB2YXIgdjEgPSBWZWN0b3IyLnNjYWxlKFtdLCB2LCAtZDApO1xuICAgIHZhciB2MiA9IFZlY3RvcjIuc2NhbGUoW10sIHYsIGQxKTtcbiAgICB2YXIgY3AwID0gVmVjdG9yMi5hZGQoW10sIF9wb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSBWZWN0b3IyLmFkZChbXSwgX3BvaW50LCB2Mik7XG5cbiAgICBpZiAoaGFzQ29uc3RyYWludCkge1xuICAgICAgY3AwID0gVmVjdG9yMi5tYXgoW10sIGNwMCwgbWluKTtcbiAgICAgIGNwMCA9IFZlY3RvcjIubWluKFtdLCBjcDAsIG1heCk7XG4gICAgICBjcDEgPSBWZWN0b3IyLm1heChbXSwgY3AxLCBtaW4pO1xuICAgICAgY3AxID0gVmVjdG9yMi5taW4oW10sIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxuZnVuY3Rpb24gY2F0bXVsbFJvbTJiZXppZXIoY3JwLCB6LCBjb25zdHJhaW50KSB7XG4gIHZhciBpc0xvb3AgPSAhIXo7XG4gIHZhciBwb2ludExpc3QgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNycC5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBwb2ludExpc3QucHVzaChbY3JwW2ldLCBjcnBbaSArIDFdXSk7XG4gIH1cblxuICB2YXIgY29udHJvbFBvaW50TGlzdCA9IHNtb290aEJlemllcihwb2ludExpc3QsIDAuNCwgaXNMb29wLCBjb25zdHJhaW50KTtcbiAgdmFyIGxlbiA9IHBvaW50TGlzdC5sZW5ndGg7XG4gIHZhciBkMSA9IFtdO1xuICB2YXIgY3AxO1xuICB2YXIgY3AyO1xuICB2YXIgcDtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW4gLSAxOyBfaTIrKykge1xuICAgIGNwMSA9IGNvbnRyb2xQb2ludExpc3RbX2kyICogMl07XG4gICAgY3AyID0gY29udHJvbFBvaW50TGlzdFtfaTIgKiAyICsgMV07XG4gICAgcCA9IHBvaW50TGlzdFtfaTIgKyAxXTtcbiAgICBkMS5wdXNoKFsnQycsIGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXV0pO1xuICB9XG5cbiAgaWYgKGlzTG9vcCkge1xuICAgIGNwMSA9IGNvbnRyb2xQb2ludExpc3RbbGVuXTtcbiAgICBjcDIgPSBjb250cm9sUG9pbnRMaXN0W2xlbiArIDFdO1xuICAgIHAgPSBwb2ludExpc3RbMF07XG4gICAgZDEucHVzaChbJ0MnLCBjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV1dKTtcbiAgfVxuXG4gIHJldHVybiBkMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhdG11bGxSb20yYmV6aWVyOiBjYXRtdWxsUm9tMmJlemllclxufTtcblxuLyoqKi8gfSksXG4vKiAzMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFBvbGFyTGFiZWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQpO1xuXG52YXIgUGF0aFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBNQVJHSU4gPSA1O1xuXG5mdW5jdGlvbiBnZXRFbmRQb2ludChjZW50ZXIsIGFuZ2xlLCByKSB7XG4gIHJldHVybiB7XG4gICAgeDogY2VudGVyLnggKyByICogTWF0aC5jb3MoYW5nbGUpLFxuICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKGFuZ2xlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBhbnRpQ29sbGlzaW9uKGxhYmVscywgbGluZUhlaWdodCwgcGxvdFJhbmdlLCBjZW50ZXIsIGlzUmlnaHQpIHtcbiAgLy8gYWRqdXN0IHkgcG9zaXRpb24gb2YgbGFiZWxzIHRvIGF2b2lkIG92ZXJsYXBwaW5nXG4gIHZhciBvdmVybGFwcGluZyA9IHRydWU7XG4gIHZhciBzdGFydCA9IHBsb3RSYW5nZS5zdGFydDtcbiAgdmFyIGVuZCA9IHBsb3RSYW5nZS5lbmQ7XG4gIHZhciBzdGFydFkgPSBNYXRoLm1pbihzdGFydC55LCBlbmQueSk7XG4gIHZhciB0b3RhbEhlaWdodCA9IE1hdGguYWJzKHN0YXJ0LnkgLSBlbmQueSk7XG4gIHZhciBpO1xuICB2YXIgbWF4WSA9IDA7XG4gIHZhciBtaW5ZID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgdmFyIGJveGVzID0gbGFiZWxzLm1hcChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwueSA+IG1heFkpIHtcbiAgICAgIG1heFkgPSBsYWJlbC55O1xuICAgIH1cblxuICAgIGlmIChsYWJlbC55IDwgbWluWSkge1xuICAgICAgbWluWSA9IGxhYmVsLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IGxpbmVIZWlnaHQsXG4gICAgICB0YXJnZXRzOiBbbGFiZWwueSAtIHN0YXJ0WV1cbiAgICB9O1xuICB9KTtcbiAgbWluWSAtPSBzdGFydFk7XG5cbiAgaWYgKG1heFkgLSBzdGFydFkgPiB0b3RhbEhlaWdodCkge1xuICAgIHRvdGFsSGVpZ2h0ID0gbWF4WSAtIHN0YXJ0WTtcbiAgfVxuXG4gIHdoaWxlIChvdmVybGFwcGluZykge1xuICAgIC8qIGVzbGludCBuby1sb29wLWZ1bmM6IDAgKi9cbiAgICBib3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChib3gpIHtcbiAgICAgIHZhciB0YXJnZXQgPSAoTWF0aC5taW4uYXBwbHkobWluWSwgYm94LnRhcmdldHMpICsgTWF0aC5tYXguYXBwbHkobWluWSwgYm94LnRhcmdldHMpKSAvIDI7XG4gICAgICBib3gucG9zID0gTWF0aC5taW4oTWF0aC5tYXgobWluWSwgdGFyZ2V0IC0gYm94LnNpemUgLyAyKSwgdG90YWxIZWlnaHQgLSBib3guc2l6ZSk7IC8vIGJveC5wb3MgPSBNYXRoLm1heCgwLCB0YXJnZXQgLSBib3guc2l6ZSAvIDIpO1xuICAgIH0pOyAvLyBkZXRlY3Qgb3ZlcmxhcHBpbmcgYW5kIGpvaW4gYm94ZXNcblxuICAgIG92ZXJsYXBwaW5nID0gZmFsc2U7XG4gICAgaSA9IGJveGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSBib3hlc1tpIC0gMV07XG4gICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcblxuICAgICAgICBpZiAocHJldmlvdXNCb3gucG9zICsgcHJldmlvdXNCb3guc2l6ZSA+IGJveC5wb3MpIHtcbiAgICAgICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgICAgIHByZXZpb3VzQm94LnNpemUgKz0gYm94LnNpemU7XG4gICAgICAgICAgcHJldmlvdXNCb3gudGFyZ2V0cyA9IHByZXZpb3VzQm94LnRhcmdldHMuY29uY2F0KGJveC50YXJnZXRzKTsgLy8gb3ZlcmZsb3csIHNoaWZ0IHVwXG5cbiAgICAgICAgICBpZiAocHJldmlvdXNCb3gucG9zICsgcHJldmlvdXNCb3guc2l6ZSA+IHRvdGFsSGVpZ2h0KSB7XG4gICAgICAgICAgICBwcmV2aW91c0JveC5wb3MgPSB0b3RhbEhlaWdodCAtIHByZXZpb3VzQm94LnNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm94ZXMuc3BsaWNlKGksIDEpOyAvLyByZW1vdmluZyBib3hcblxuICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGkgPSAwOyAvLyBzdGVwIDQ6IG5vcm1hbGl6ZSB5IGFuZCBhZGp1c3QgeFxuXG4gIGJveGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgcG9zSW5Db21wb3NpdGVCb3ggPSBzdGFydFkgKyBsaW5lSGVpZ2h0IC8gMjsgLy8gbWlkZGxlIG9mIHRoZSBsYWJlbFxuXG4gICAgYi50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGFiZWxzW2ldLnkgPSBiLnBvcyArIHBvc0luQ29tcG9zaXRlQm94O1xuICAgICAgcG9zSW5Db21wb3NpdGVCb3ggKz0gbGluZUhlaWdodDtcbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfSk7IC8vICh4IC0gY3gpXjIgKyAoeSAtIGN5KV4yID0gdG90YWxSXjJcblxuICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICB2YXIgclBvdzIgPSBsYWJlbC5yICogbGFiZWwucjtcbiAgICB2YXIgZHlQb3cyID0gTWF0aC5wb3coTWF0aC5hYnMobGFiZWwueSAtIGNlbnRlci55KSwgMik7XG5cbiAgICBpZiAoclBvdzIgPCBkeVBvdzIpIHtcbiAgICAgIGxhYmVsLnggPSBjZW50ZXIueDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGR4ID0gTWF0aC5zcXJ0KHJQb3cyIC0gZHlQb3cyKTtcblxuICAgICAgaWYgKCFpc1JpZ2h0KSB7XG4gICAgICAgIC8vIGxlZnRcbiAgICAgICAgbGFiZWwueCA9IGNlbnRlci54IC0gZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByaWdodFxuICAgICAgICBsYWJlbC54ID0gY2VudGVyLnggKyBkeDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgUGllTGFiZWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUG9sYXJMYWJlbHMpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGllTGFiZWxzLCBfUG9sYXJMYWJlbHMpO1xuXG4gIGZ1bmN0aW9uIFBpZUxhYmVscygpIHtcbiAgICByZXR1cm4gX1BvbGFyTGFiZWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQaWVMYWJlbHMucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IEdsb2JhbC50aGV0YUxhYmVsc1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldERlZmF1bHRPZmZzZXQgPSBmdW5jdGlvbiBnZXREZWZhdWx0T2Zmc2V0KHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCB8fCAwO1xuICB9O1xuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiB0byBhdm9pZCBvdmVybGFwcGluZ1xuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBsYWJlbHMgdG8gYmUgcGxhY2VkXG4gICAqIEByZXR1cm4ge0FycmF5fSBpdGVtc1xuICAgKi9cblxuXG4gIF9wcm90by5hZGp1c3RJdGVtcyA9IGZ1bmN0aW9uIGFkanVzdEl0ZW1zKGl0ZW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvZmZzZXQgPSBpdGVtc1swXSA/IGl0ZW1zWzBdLm9mZnNldCA6IDA7XG5cbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgaXRlbXMgPSBzZWxmLl9kaXN0cmlidXRlKGl0ZW1zLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBfUG9sYXJMYWJlbHMucHJvdG90eXBlLmFkanVzdEl0ZW1zLmNhbGwodGhpcywgaXRlbXMpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZGlzdHJpYnV0ZSBsYWJlbHNcbiAgICogQHBhcmFtIHtBcnJheX0gbGFiZWxzIGxhYmVsc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IG9mZnNldFxuICAgKiBAcmV0dXJuIHtBcnJheX0gbGFiZWxzXG4gICAqL1xuXG5cbiAgX3Byb3RvLl9kaXN0cmlidXRlID0gZnVuY3Rpb24gX2Rpc3RyaWJ1dGUobGFiZWxzLCBvZmZzZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHJhZGl1cyA9IGNvb3JkLmdldFJhZGl1cygpO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gc2VsZi5nZXQoJ2xhYmVsJykubGFiZWxIZWlnaHQ7XG4gICAgdmFyIGNlbnRlciA9IGNvb3JkLmdldENlbnRlcigpO1xuICAgIHZhciB0b3RhbFIgPSByYWRpdXMgKyBvZmZzZXQ7XG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gdG90YWxSICogMiArIGxpbmVIZWlnaHQgKiAyO1xuICAgIHZhciBwbG90UmFuZ2UgPSB7XG4gICAgICBzdGFydDogY29vcmQuc3RhcnQsXG4gICAgICBlbmQ6IGNvb3JkLmVuZFxuICAgIH07XG4gICAgdmFyIGdlb20gPSBzZWxmLmdldCgnZ2VvbScpO1xuXG4gICAgaWYgKGdlb20pIHtcbiAgICAgIHZhciB2aWV3ID0gZ2VvbS5nZXQoJ3ZpZXcnKTtcbiAgICAgIHBsb3RSYW5nZSA9IHZpZXcuZ2V0Vmlld1JlZ2lvbigpO1xuICAgIH0gLy8gc3RlcCAxOiBzZXBhcmF0ZSBsYWJlbHNcblxuXG4gICAgdmFyIGhhbHZlcyA9IFtbXSwgLy8gbGVmdFxuICAgIFtdIC8vIHJpZ2h0XG4gICAgXTtcbiAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFiZWwudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIC8vIGxlZnRcbiAgICAgICAgaGFsdmVzWzBdLnB1c2gobGFiZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmlnaHQgb3IgY2VudGVyIHdpbGwgYmUgcHV0IG9uIHRoZSByaWdodCBzaWRlXG4gICAgICAgIGhhbHZlc1sxXS5wdXNoKGxhYmVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBoYWx2ZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFsZiwgaW5kZXgpIHtcbiAgICAgIC8vIHN0ZXAgMjogcmVkdWNlIGxhYmVsc1xuICAgICAgdmFyIG1heExhYmVsc0NvdW50Rm9yT25lU2lkZSA9IHBhcnNlSW50KHRvdGFsSGVpZ2h0IC8gbGluZUhlaWdodCwgMTApO1xuXG4gICAgICBpZiAoaGFsZi5sZW5ndGggPiBtYXhMYWJlbHNDb3VudEZvck9uZVNpZGUpIHtcbiAgICAgICAgaGFsZi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgLy8gc29ydCBieSBwZXJjZW50YWdlIERFU0NcbiAgICAgICAgICByZXR1cm4gYlsnLi5wZXJjZW50J10gLSBhWycuLnBlcmNlbnQnXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbGYuc3BsaWNlKG1heExhYmVsc0NvdW50Rm9yT25lU2lkZSwgaGFsZi5sZW5ndGggLSBtYXhMYWJlbHNDb3VudEZvck9uZVNpZGUpO1xuICAgICAgfSAvLyBzdGVwIDM6IGRpc3RyaWJ1dGUgcG9zaXRpb24gKHggYW5kIHkpXG5cblxuICAgICAgaGFsZi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8vIHNvcnQgYnkgeSBBU0NcbiAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgIH0pO1xuICAgICAgYW50aUNvbGxpc2lvbihoYWxmLCBsaW5lSGVpZ2h0LCBwbG90UmFuZ2UsIGNlbnRlciwgaW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBoYWx2ZXNbMF0uY29uY2F0KGhhbHZlc1sxXSk7XG4gIH07IC8vIOi/nuaOpee6v1xuXG5cbiAgX3Byb3RvLmxpbmVUb0xhYmVsID0gZnVuY3Rpb24gbGluZVRvTGFiZWwobGFiZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHIgPSBjb29yZC5nZXRSYWRpdXMoKTtcbiAgICB2YXIgZGlzdGFuY2UgPSBsYWJlbC5vZmZzZXQ7XG4gICAgdmFyIGFuZ2xlID0gbGFiZWwub3JpZ25BbmdsZSB8fCBsYWJlbC5hbmdsZTtcbiAgICB2YXIgY2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIHN0YXJ0ID0gZ2V0RW5kUG9pbnQoY2VudGVyLCBhbmdsZSwgciArIE1BUkdJTiAvIDIpO1xuICAgIHZhciBpbm5lciA9IGdldEVuZFBvaW50KGNlbnRlciwgYW5nbGUsIHIgKyBkaXN0YW5jZSAvIDIpO1xuXG4gICAgaWYgKCFsYWJlbC5sYWJlbExpbmUpIHtcbiAgICAgIGxhYmVsLmxhYmVsTGluZSA9IHNlbGYuZ2V0KCdsYWJlbCcpLmxhYmVsTGluZSB8fCB7fTtcbiAgICB9XG5cbiAgICBsYWJlbC5sYWJlbExpbmUucGF0aCA9IFsnTScgKyBzdGFydC54LCBzdGFydC55ICsgJyBRJyArIGlubmVyLngsIGlubmVyLnkgKyAnICcgKyBsYWJlbC54LCBsYWJlbC55XS5qb2luKCcsJyk7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIGdldCByb3RhdGlvbiBmb3IgbGFiZWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIGFuZ2xlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgb2Zmc2V0XG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldExhYmVsUm90YXRlID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGUoYW5nbGUsIG9mZnNldCkge1xuICAgIHZhciByb3RhdGU7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgcm90YXRlID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICBpZiAocm90YXRlID4gOTApIHtcbiAgICAgICAgcm90YXRlID0gcm90YXRlIC0gMTgwO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRlIDwgLTkwKSB7XG4gICAgICAgIHJvdGF0ZSA9IHJvdGF0ZSArIDE4MDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm90YXRlIC8gMTgwICogTWF0aC5QSTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogZ2V0IHRleHQgYWxpZ24gZm9yIGxhYmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCBwb2ludFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFsaWduXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldExhYmVsQWxpZ24gPSBmdW5jdGlvbiBnZXRMYWJlbEFsaWduKHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciBjZW50ZXIgPSBjb29yZC5nZXRDZW50ZXIoKTtcbiAgICB2YXIgYWxpZ247XG5cbiAgICBpZiAocG9pbnQuYW5nbGUgPD0gTWF0aC5QSSAvIDIgJiYgcG9pbnQueCA+PSBjZW50ZXIueCkge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gc2VsZi5nZXREZWZhdWx0T2Zmc2V0KHBvaW50KTtcblxuICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXJjUG9pbnQgPSBmdW5jdGlvbiBnZXRBcmNQb2ludChwb2ludCkge1xuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UG9pbnRBbmdsZSA9IGZ1bmN0aW9uIGdldFBvaW50QW5nbGUocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBVdGlsLmlzQXJyYXkocG9pbnQueCkgPyBwb2ludC54WzBdIDogcG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnlbMF1cbiAgICB9O1xuICAgIHNlbGYudHJhbnNMYWJlbFBvaW50KHN0YXJ0UG9pbnQpOyAvLyDovazmjaLliLDnlLvluIPlnZDmoIfvvIzlpoLmnpzlnZDmoIfns7vlj5HnlJ/mlLnlj5hcblxuICAgIHZhciBlbmRQb2ludCA9IHtcbiAgICAgIHg6IFV0aWwuaXNBcnJheShwb2ludC54KSA/IHBvaW50LnhbMV0gOiBwb2ludC54LFxuICAgICAgeTogcG9pbnQueVsxXVxuICAgIH07XG4gICAgc2VsZi50cmFuc0xhYmVsUG9pbnQoZW5kUG9pbnQpOyAvLyDovazmjaLliLDnlLvluIPlnZDmoIfvvIzlpoLmnpzlnZDmoIfns7vlj5HnlJ/mlLnlj5hcblxuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IFBhdGhVdGlsLmdldFBvaW50QW5nbGUoY29vcmQsIHN0YXJ0UG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnBvaW50cyAmJiBwb2ludC5wb2ludHNbMF0ueSA9PT0gcG9pbnQucG9pbnRzWzFdLnkpIHtcbiAgICAgIGFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZEFuZ2xlID0gUGF0aFV0aWwuZ2V0UG9pbnRBbmdsZShjb29yZCwgZW5kUG9pbnQpO1xuXG4gICAgICBpZiAoc3RhcnRBbmdsZSA+PSBlbmRBbmdsZSkge1xuICAgICAgICAvLyAxMDAlIHBpZSBzbGljZVxuICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgTWF0aC5QSSAqIDI7XG4gICAgICB9XG5cbiAgICAgIGFuZ2xlID0gc3RhcnRBbmdsZSArIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGU7XG4gIH07XG5cbiAgX3Byb3RvLmdldENpcmNsZVBvaW50ID0gZnVuY3Rpb24gZ2V0Q2lyY2xlUG9pbnQoYW5nbGUsIG9mZnNldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29vcmQgPSBzZWxmLmdldCgnY29vcmQnKTtcbiAgICB2YXIgY2VudGVyID0gY29vcmQuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIHIgPSBjb29yZC5nZXRSYWRpdXMoKSArIG9mZnNldDtcbiAgICB2YXIgcG9pbnQgPSBnZXRFbmRQb2ludChjZW50ZXIsIGFuZ2xlLCByKTtcbiAgICBwb2ludC5hbmdsZSA9IGFuZ2xlO1xuICAgIHBvaW50LnIgPSByO1xuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICByZXR1cm4gUGllTGFiZWxzO1xufShQb2xhckxhYmVscyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGllTGFiZWxzO1xuXG4vKioqLyB9KSxcbi8qIDMzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR2VvbUxhYmVscyA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG52YXIgSW50ZXJ2YWxMYWJlbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tTGFiZWxzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludGVydmFsTGFiZWxzLCBfR2VvbUxhYmVscyk7XG5cbiAgZnVuY3Rpb24gSW50ZXJ2YWxMYWJlbHMoKSB7XG4gICAgcmV0dXJuIF9HZW9tTGFiZWxzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnRlcnZhbExhYmVscy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldExhYmVsUG9zaXRpb24gPSBmdW5jdGlvbiBzZXRMYWJlbFBvc2l0aW9uKHBvaW50LCBvcmlnaW5Qb2ludCwgaW5kZXgsIHBvc2l0aW9uKSB7XG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24ocG9pbnQudGV4dCwgb3JpZ2luUG9pbnQuX29yaWdpbiwgaW5kZXgpO1xuICAgIH1cblxuICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB0cmFuc3Bvc2VkID0gY29vcmQuaXNUcmFuc3Bvc2VkO1xuICAgIHZhciBwb2ludDAgPSBjb29yZC5jb252ZXJ0UG9pbnQob3JpZ2luUG9pbnQucG9pbnRzWzBdKTtcbiAgICB2YXIgcG9pbnQxID0gY29vcmQuY29udmVydFBvaW50KG9yaWdpblBvaW50LnBvaW50c1syXSk7XG4gICAgdmFyIHdpZHRoID0gKHBvaW50MC54IC0gcG9pbnQxLngpIC8gMiAqICh0cmFuc3Bvc2VkID8gLTEgOiAxKTtcbiAgICB2YXIgaGVpZ2h0ID0gKHBvaW50MC55IC0gcG9pbnQxLnkpIC8gMiAqICh0cmFuc3Bvc2VkID8gLTEgOiAxKTtcblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgaWYgKHRyYW5zcG9zZWQpIHtcbiAgICAgICAgICBwb2ludC54IC09IHdpZHRoO1xuICAgICAgICAgIHBvaW50LnkgKz0gaGVpZ2h0O1xuICAgICAgICAgIHBvaW50LnRleHRBbGlnbiA9IHBvaW50LnRleHRBbGlnbiB8fCAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludC54IC09IHdpZHRoO1xuICAgICAgICAgIHBvaW50LnkgKz0gaGVpZ2h0O1xuICAgICAgICAgIHBvaW50LnRleHRBbGlnbiA9IHBvaW50LnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGlmICh0cmFuc3Bvc2VkKSB7XG4gICAgICAgICAgcG9pbnQueCAtPSB3aWR0aDtcbiAgICAgICAgICBwb2ludC55IC09IGhlaWdodDtcbiAgICAgICAgICBwb2ludC50ZXh0QWxpZ24gPSBwb2ludC50ZXh0QWxpZ24gfHwgJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQueCArPSB3aWR0aDtcbiAgICAgICAgICBwb2ludC55ICs9IGhlaWdodDtcbiAgICAgICAgICBwb2ludC50ZXh0QWxpZ24gPSBwb2ludC50ZXh0QWxpZ24gfHwgJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBpZiAodHJhbnNwb3NlZCkge1xuICAgICAgICAgIHBvaW50LnggLT0gd2lkdGggKiAyO1xuICAgICAgICAgIHBvaW50LnRleHRBbGlnbiA9IHBvaW50LnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQueSArPSBoZWlnaHQgKiAyO1xuICAgICAgICAgIHBvaW50LnRleHRBbGlnbiA9IHBvaW50LnRleHRBbGlnbiB8fCAnY2VudGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICBpZiAodHJhbnNwb3NlZCkge1xuICAgICAgICAgIHBvaW50LnggLT0gd2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQueSArPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludC50ZXh0QWxpZ24gPSBwb2ludC50ZXh0QWxpZ24gfHwgJ2NlbnRlcic7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBpZiAodHJhbnNwb3NlZCkge1xuICAgICAgICAgIHBvaW50LnRleHRBbGlnbiA9IHBvaW50LnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnQudGV4dEFsaWduID0gcG9pbnQudGV4dEFsaWduIHx8ICdjZW50ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSW50ZXJ2YWxMYWJlbHM7XG59KEdlb21MYWJlbHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVydmFsTGFiZWxzO1xuXG4vKioqLyB9KSxcbi8qIDMzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIHRvb2x0aXAgaGFuZGxlclxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxcbiAgICBkZWZhdWx0Q29sb3IgPSBfcmVxdWlyZS5kZWZhdWx0Q29sb3I7XG5cbnZhciBGSUVMRF9PUklHSU4gPSAnX29yaWdpbic7XG5cbmZ1bmN0aW9uIGdldFNjYWxlTmFtZShzY2FsZSkge1xuICByZXR1cm4gc2NhbGUuYWxpYXMgfHwgc2NhbGUuZmllbGQ7XG59XG5cbnZhciBUb29sdGlwTWl4aW4gPSB7XG4gIF9nZXRJbnRlcnZhbFNpemU6IGZ1bmN0aW9uIF9nZXRJbnRlcnZhbFNpemUob2JqKSB7XG4gICAgdmFyIHNpemUgPSBudWxsO1xuICAgIHZhciB0eXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgY29vcmQgPSB0aGlzLmdldCgnY29vcmQnKTtcblxuICAgIGlmIChjb29yZC5pc1JlY3QgJiYgKHR5cGUgPT09ICdpbnRlcnZhbCcgfHwgdHlwZSA9PT0gJ3NjaGVtYScpKSB7XG4gICAgICBzaXplID0gdGhpcy5nZXRTaXplKG9ialtGSUVMRF9PUklHSU5dKTsgLy8g5aaC5p6c5a2X5q615Y+R55Sf5LqG5pig5bCE77yM5a695bqm6K6h566X5bCx5Lya5oql6ZSZXG5cbiAgICAgIHZhciBkaW0gPSBjb29yZC5pc1RyYW5zcG9zZWQgPyAneScgOiAneCc7XG5cbiAgICAgIGlmIChVdGlsLmlzQXJyYXkob2JqW2RpbV0pKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKG9ialtkaW1dWzFdIC0gb2JqW2RpbV1bMF0pO1xuICAgICAgICBzaXplID0gc2l6ZSA8IHdpZHRoID8gbnVsbCA6IHNpemU7IC8vIOebtOaWueWbvuiuoeeul+mUmeivr1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBfc25hcEVxdWFsOiBmdW5jdGlvbiBfc25hcEVxdWFsKHYxLCB2Miwgc2NhbGUpIHtcbiAgICB2YXIgZXF1YWxzO1xuICAgIHYxID0gc2NhbGUudHJhbnNsYXRlKHYxKTtcbiAgICB2MiA9IHNjYWxlLnRyYW5zbGF0ZSh2Mik7XG5cbiAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSkge1xuICAgICAgZXF1YWxzID0gdjEgPT09IHYyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcXVhbHMgPSBVdGlsLnNuYXBFcXVhbCh2MSwgdjIpO1xuICAgIH1cblxuICAgIHJldHVybiBlcXVhbHM7XG4gIH0sXG4gIF9nZXRTY2FsZVZhbHVlQnlQb2ludDogZnVuY3Rpb24gX2dldFNjYWxlVmFsdWVCeVBvaW50KHBvaW50KSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIGludmVydFBvaW50ID0gY29vcmQuaW52ZXJ0KHBvaW50KTtcbiAgICB2YXIgeFZhbHVlID0gaW52ZXJ0UG9pbnQueDtcblxuICAgIGlmICh0aGlzLmlzSW5DaXJjbGUoKSAmJiB4VmFsdWUgPiAoMSArIHhTY2FsZS5yYW5nZU1heCgpKSAvIDIpIHtcbiAgICAgIHhWYWx1ZSA9IHhTY2FsZS5yYW5nZU1pbigpOyAvLyDmnoHlnZDmoIfkuIvvvIxzY2FsZSDnmoQgcmFuZ2Ug6KKr5YGa6L+H54m55q6K5aSE55CGIHNlZSB2aWV3LmpzI0w4OFxuICAgIH1cblxuICAgIHJlc3VsdCA9IHhTY2FsZS5pbnZlcnQoeFZhbHVlKTtcblxuICAgIGlmICh4U2NhbGUuaXNDYXRlZ29yeSkge1xuICAgICAgcmVzdWx0ID0geFNjYWxlLnRyYW5zbGF0ZShyZXN1bHQpOyAvLyDpmLLmraLliIbnsbvnsbvlnotcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBfZ2V0T3JpZ2luQnlQb2ludDogZnVuY3Rpb24gX2dldE9yaWdpbkJ5UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcbiAgICB2YXIgeEZpZWxkID0geFNjYWxlLmZpZWxkO1xuICAgIHZhciB5RmllbGQgPSB5U2NhbGUuZmllbGQ7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGludmVydFBvaW50ID0gY29vcmQuaW52ZXJ0KHBvaW50KTtcbiAgICB2YXIgeFZhbHVlID0geFNjYWxlLmludmVydChpbnZlcnRQb2ludC54KTtcbiAgICB2YXIgeVZhbHVlID0geVNjYWxlLmludmVydChpbnZlcnRQb2ludC55KTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0W3hGaWVsZF0gPSB4VmFsdWU7XG4gICAgcmVzdWx0W3lGaWVsZF0gPSB5VmFsdWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgX2dldFNjYWxlOiBmdW5jdGlvbiBfZ2V0U2NhbGUoZmllbGQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjYWxlcyA9IHNlbGYuZ2V0KCdzY2FsZXMnKTtcbiAgICB2YXIgcnN0ID0gbnVsbDtcbiAgICBVdGlsLmVhY2goc2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIGlmIChzY2FsZS5maWVsZCA9PT0gZmllbGQpIHtcbiAgICAgICAgcnN0ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9LFxuICAvLyDojrflj5blgLzlr7nlupTnmoTluqbph49cbiAgX2dldFRpcFZhbHVlU2NhbGU6IGZ1bmN0aW9uIF9nZXRUaXBWYWx1ZVNjYWxlKCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0QXR0cnNGb3JMZWdlbmQoKTtcbiAgICB2YXIgc2NhbGU7XG4gICAgVXRpbC5lYWNoKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgdmFyIHRtcFNjYWxlID0gYXR0ci5nZXRTY2FsZShhdHRyLnR5cGUpO1xuXG4gICAgICBpZiAodG1wU2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgICAgLy8g5aaC5p6c5oyH5a6a5a2X5q615piv6Z2ecG9zaXRpb27nmoTvvIzlkIzml7bmmK/ov57nu63nmoRcbiAgICAgICAgc2NhbGUgPSB0bXBTY2FsZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB4U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuXG4gICAgaWYgKCFzY2FsZSAmJiB5U2NhbGUgJiYgeVNjYWxlLmZpZWxkID09PSAnLi55Jykge1xuICAgICAgcmV0dXJuIHhTY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGUgfHwgeVNjYWxlIHx8IHhTY2FsZTtcbiAgfSxcbiAgX2dldFRpcFRpdGxlU2NhbGU6IGZ1bmN0aW9uIF9nZXRUaXBUaXRsZVNjYWxlKHRpdGxlRmllbGQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGl0bGVGaWVsZCkge1xuICAgICAgcmV0dXJuIHNlbGYuX2dldFNjYWxlKHRpdGxlRmllbGQpO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbiA9IHNlbGYuZ2V0QXR0cigncG9zaXRpb24nKTtcbiAgICB2YXIgZmllbGRzID0gcG9zaXRpb24uZ2V0RmllbGRzKCk7XG4gICAgdmFyIHRtcEZpZWxkO1xuICAgIFV0aWwuZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKGZpZWxkLmluZGV4T2YoJy4uJykgPT09IC0xKSB7XG4gICAgICAgIHRtcEZpZWxkID0gZmllbGQ7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZi5fZ2V0U2NhbGUodG1wRmllbGQpO1xuICB9LFxuICBfZmlsdGVyVmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXJWYWx1ZShhcnIsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIHlGaWVsZCA9IHlTY2FsZS5maWVsZDtcbiAgICB2YXIgaW52ZXJ0UG9pbnQgPSBjb29yZC5pbnZlcnQocG9pbnQpO1xuICAgIHZhciB5VmFsdWUgPSBpbnZlcnRQb2ludC55O1xuICAgIHlWYWx1ZSA9IHlTY2FsZS5pbnZlcnQoeVZhbHVlKTtcbiAgICB2YXIgcnN0ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICBVdGlsLmVhY2goYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIgb3JpZ2luID0gb2JqW0ZJRUxEX09SSUdJTl07XG5cbiAgICAgIGlmIChvcmlnaW5beUZpZWxkXVswXSA8PSB5VmFsdWUgJiYgb3JpZ2luW3lGaWVsZF1bMV0gPj0geVZhbHVlKSB7XG4gICAgICAgIHJzdCA9IG9iajtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGdldFhEaXN0YW5jZTogZnVuY3Rpb24gZ2V0WERpc3RhbmNlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGlzdGFuY2UgPSBzZWxmLmdldCgneERpc3RhbmNlJyk7XG5cbiAgICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcblxuICAgICAgaWYgKHhTY2FsZS5pc0NhdGVnb3J5KSB7XG4gICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4U2NhbGUudmFsdWVzOyAvLyB2YWx1ZXMg5piv5peg5bqP55qEXG5cbiAgICAgICAgdmFyIG1pbiA9IHhTY2FsZS50cmFuc2xhdGUodmFsdWVzWzBdKTtcbiAgICAgICAgdmFyIG1heCA9IG1pbjtcbiAgICAgICAgVXRpbC5lYWNoKHZhbHVlcywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgLy8g5pe26Ze057G75Z6L6ZyA6KaBIHRyYW5zbGF0ZVxuICAgICAgICAgIHZhbHVlID0geFNjYWxlLnRyYW5zbGF0ZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7IC8vIOW6lOivpeaYr+mZpOS7pSBsZW5ndGggLSAxXG5cbiAgICAgICAgZGlzdGFuY2UgPSAobWF4IC0gbWluKSAvIChsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zZXQoJ3hEaXN0YW5jZScsIGRpc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG4gIH0sXG4gIGZpbmRQb2ludDogZnVuY3Rpb24gZmluZFBvaW50KHBvaW50LCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSBzZWxmLmdldCgndHlwZScpO1xuICAgIHZhciB4U2NhbGUgPSBzZWxmLmdldFhTY2FsZSgpO1xuICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZSgpO1xuICAgIHZhciB4RmllbGQgPSB4U2NhbGUuZmllbGQ7XG4gICAgdmFyIHlGaWVsZCA9IHlTY2FsZS5maWVsZDtcbiAgICB2YXIgcnN0ID0gbnVsbDtcblxuICAgIGlmIChVdGlsLmluZGV4T2YoWydoZWF0bWFwJywgJ3BvaW50J10sIHR5cGUpID4gLTEpIHtcbiAgICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgICAgdmFyIGludmVydFBvaW50ID0gY29vcmQuaW52ZXJ0KHBvaW50KTtcbiAgICAgIHZhciB4VmFsdWUgPSB4U2NhbGUuaW52ZXJ0KGludmVydFBvaW50LngpO1xuICAgICAgdmFyIHlWYWx1ZSA9IHlTY2FsZS5pbnZlcnQoaW52ZXJ0UG9pbnQueSk7XG4gICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICBVdGlsLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgucG93KG9ialtGSUVMRF9PUklHSU5dW3hGaWVsZF0gLSB4VmFsdWUsIDIpICsgTWF0aC5wb3cob2JqW0ZJRUxEX09SSUdJTl1beUZpZWxkXSAtIHlWYWx1ZSwgMik7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgcnN0ID0gb2JqO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByc3Q7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0ID0gZGF0YUFycmF5WzBdO1xuICAgIHZhciBsYXN0ID0gZGF0YUFycmF5W2RhdGFBcnJheS5sZW5ndGggLSAxXTtcblxuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHJldHVybiByc3Q7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gc2VsZi5fZ2V0U2NhbGVWYWx1ZUJ5UG9pbnQocG9pbnQpOyAvLyDmoLnmja7or6Xngrnojrflvpflr7nlupTluqbph4/lkI7mlbDmja7nmoTlgLxcblxuXG4gICAgdmFyIGZpcnN0WFZhbHVlID0gZmlyc3RbRklFTERfT1JJR0lOXVt4RmllbGRdO1xuICAgIHZhciBmaXJzdFlWYWx1ZSA9IGZpcnN0W0ZJRUxEX09SSUdJTl1beUZpZWxkXTtcbiAgICB2YXIgbGFzdFhWYWx1ZSA9IGxhc3RbRklFTERfT1JJR0lOXVt4RmllbGRdO1xuICAgIHZhciBpc1lSYW5nZSA9IHlTY2FsZS5pc0xpbmVhciAmJiBVdGlsLmlzQXJyYXkoZmlyc3RZVmFsdWUpOyAvLyDogIPomZEgeCDnu7Tluqbnm7jlkIzvvIx5IOaYr+aVsOe7hOWMuumXtOeahOaDheWGtVxuICAgIC8vIOWmguaenHjnmoTlgLzmmK/mlbDnu4RcblxuICAgIGlmIChVdGlsLmlzQXJyYXkoZmlyc3RYVmFsdWUpKSB7XG4gICAgICBVdGlsLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSByZWNvcmRbRklFTERfT1JJR0lOXTtcblxuICAgICAgICBpZiAoeFNjYWxlLnRyYW5zbGF0ZShvcmlnaW5beEZpZWxkXVswXSkgPD0gdmFsdWUgJiYgeFNjYWxlLnRyYW5zbGF0ZShvcmlnaW5beEZpZWxkXVsxXSkgPj0gdmFsdWUpIHtcbiAgICAgICAgICBpZiAoaXNZUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICghVXRpbC5pc0FycmF5KHJzdCkpIHtcbiAgICAgICAgICAgICAgcnN0ID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJzdC5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJzdCA9IHJlY29yZDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoVXRpbC5pc0FycmF5KHJzdCkpIHtcbiAgICAgICAgcnN0ID0gdGhpcy5fZmlsdGVyVmFsdWUocnN0LCBwb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0O1xuXG4gICAgICBpZiAoIXhTY2FsZS5pc0xpbmVhciAmJiB4U2NhbGUudHlwZSAhPT0gJ3RpbWVDYXQnKSB7XG4gICAgICAgIFV0aWwuZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlY29yZFtGSUVMRF9PUklHSU5dO1xuXG4gICAgICAgICAgaWYgKHNlbGYuX3NuYXBFcXVhbChvcmlnaW5beEZpZWxkXSwgdmFsdWUsIHhTY2FsZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1lSYW5nZSkge1xuICAgICAgICAgICAgICBpZiAoIVV0aWwuaXNBcnJheShyc3QpKSB7XG4gICAgICAgICAgICAgICAgcnN0ID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByc3QucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnN0ID0gcmVjb3JkO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4U2NhbGUudHJhbnNsYXRlKG9yaWdpblt4RmllbGRdKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGFzdCA9IHJlY29yZDtcbiAgICAgICAgICAgIG5leHQgPSBkYXRhQXJyYXlbaW5kZXggKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChVdGlsLmlzQXJyYXkocnN0KSkge1xuICAgICAgICAgIHJzdCA9IHRoaXMuX2ZpbHRlclZhbHVlKHJzdCwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKHZhbHVlID4geFNjYWxlLnRyYW5zbGF0ZShsYXN0WFZhbHVlKSB8fCB2YWx1ZSA8IHhTY2FsZS50cmFuc2xhdGUoZmlyc3RYVmFsdWUpKSAmJiAodmFsdWUgPiB4U2NhbGUubWF4IHx8IHZhbHVlIDwgeFNjYWxlLm1pbikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdElkeCA9IDA7XG4gICAgICAgIHZhciBsYXN0SWR4ID0gZGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtaWRkbGVJZHg7XG5cbiAgICAgICAgd2hpbGUgKGZpcnN0SWR4IDw9IGxhc3RJZHgpIHtcbiAgICAgICAgICBtaWRkbGVJZHggPSBNYXRoLmZsb29yKChmaXJzdElkeCArIGxhc3RJZHgpIC8gMik7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhQXJyYXlbbWlkZGxlSWR4XVtGSUVMRF9PUklHSU5dW3hGaWVsZF07XG5cbiAgICAgICAgICBpZiAoc2VsZi5fc25hcEVxdWFsKGl0ZW0sIHZhbHVlLCB4U2NhbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YUFycmF5W21pZGRsZUlkeF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHhTY2FsZS50cmFuc2xhdGUoaXRlbSkgPD0geFNjYWxlLnRyYW5zbGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZpcnN0SWR4ID0gbWlkZGxlSWR4ICsgMTtcbiAgICAgICAgICAgIGxhc3QgPSBkYXRhQXJyYXlbbWlkZGxlSWR4XTtcbiAgICAgICAgICAgIG5leHQgPSBkYXRhQXJyYXlbbWlkZGxlSWR4ICsgMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0SWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgIGxhc3QgPSBkYXRhQXJyYXlbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RJZHggPSBtaWRkbGVJZHggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGFzdCAmJiBuZXh0KSB7XG4gICAgICAgIC8vIOiuoeeul+acgOmAvOi/keeahFxuICAgICAgICBpZiAoTWF0aC5hYnMoeFNjYWxlLnRyYW5zbGF0ZShsYXN0W0ZJRUxEX09SSUdJTl1beEZpZWxkXSkgLSB2YWx1ZSkgPiBNYXRoLmFicyh4U2NhbGUudHJhbnNsYXRlKG5leHRbRklFTERfT1JJR0lOXVt4RmllbGRdKSAtIHZhbHVlKSkge1xuICAgICAgICAgIGxhc3QgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpc3RhbmNlID0gc2VsZi5nZXRYRGlzdGFuY2UoKTsgLy8g5q+P5Liq5YiG57G76Ze055qE5bmz5Z2H6Ze06LedXG5cbiAgICBpZiAoIXJzdCAmJiBNYXRoLmFicyh4U2NhbGUudHJhbnNsYXRlKGxhc3RbRklFTERfT1JJR0lOXVt4RmllbGRdKSAtIHZhbHVlKSA8PSBkaXN0YW5jZSAvIDIpIHtcbiAgICAgIHJzdCA9IGxhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiDojrflj5Z0b29sdGlw55qE5qCH6aKYXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3JpZ2luIOeCueeahOWOn+Wni+S/oeaBr1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlRmllbGQg5qCH6aKY55qE5a2X5q61XG4gICAqIEByZXR1cm4ge1N0cmluZ30g5o+Q56S65L+h5oGv55qE5qCH6aKYXG4gICAqL1xuICBnZXRUaXBUaXRsZTogZnVuY3Rpb24gZ2V0VGlwVGl0bGUob3JpZ2luLCB0aXRsZUZpZWxkKSB7XG4gICAgdmFyIHRpcFRpdGxlID0gJyc7XG5cbiAgICB2YXIgdGl0bGVTY2FsZSA9IHRoaXMuX2dldFRpcFRpdGxlU2NhbGUodGl0bGVGaWVsZCk7XG5cbiAgICBpZiAodGl0bGVTY2FsZSkge1xuICAgICAgdmFyIHZhbHVlID0gb3JpZ2luW3RpdGxlU2NhbGUuZmllbGRdO1xuICAgICAgdGlwVGl0bGUgPSB0aXRsZVNjYWxlLmdldFRleHQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoJ3R5cGUnKSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAvLyDng63lipvlm77lnKjkuI3lrZjlnKggdGl0bGUg55qE5pe25YCZ54m55q6K5aSE55CGXG4gICAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgICAgdmFyIHhWYWx1ZSA9IHhTY2FsZS5nZXRUZXh0KG9yaWdpblt4U2NhbGUuZmllbGRdKTtcbiAgICAgIHZhciB5VmFsdWUgPSB5U2NhbGUuZ2V0VGV4dChvcmlnaW5beVNjYWxlLmZpZWxkXSk7XG4gICAgICB0aXBUaXRsZSA9ICcoICcgKyB4VmFsdWUgKyAnLCAnICsgeVZhbHVlICsgJyApJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGlwVGl0bGU7XG4gIH0sXG4gIGdldFRpcFZhbHVlOiBmdW5jdGlvbiBnZXRUaXBWYWx1ZShvcmlnaW4sIHZhbHVlU2NhbGUpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGZpZWxkID0gdmFsdWVTY2FsZS5maWVsZDtcbiAgICB2YXIga2V5ID0gb3JpZ2luLmtleTtcbiAgICB2YWx1ZSA9IG9yaWdpbltmaWVsZF07XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgVXRpbC5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgIHRtcC5wdXNoKHZhbHVlU2NhbGUuZ2V0VGV4dChzdWIpKTtcbiAgICAgIH0pO1xuICAgICAgdmFsdWUgPSB0bXAuam9pbignLScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlU2NhbGUuZ2V0VGV4dCh2YWx1ZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICog6I635Y+WdG9vbHRpcOeahOWQjeensFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9yaWdpbiDngrnnmoTljp/lp4vkv6Hmga9cbiAgICogQHJldHVybiB7U3RyaW5nfSDmj5DnpLrkv6Hmga/nmoTlkI3np7BcbiAgICovXG4gIGdldFRpcE5hbWU6IGZ1bmN0aW9uIGdldFRpcE5hbWUob3JpZ2luKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIG5hbWVTY2FsZTtcblxuICAgIHZhciBncm91cFNjYWxlcyA9IHRoaXMuX2dldEdyb3VwU2NhbGVzKCk7XG5cbiAgICBpZiAoZ3JvdXBTY2FsZXMubGVuZ3RoKSB7XG4gICAgICAvLyDlpoLmnpzlrZjlnKjliIbnu4TnsbvlnovvvIzlj5bnrKzkuIDkuKrliIbnu4TnsbvlnotcbiAgICAgIFV0aWwuZWFjaChncm91cFNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIG5hbWVTY2FsZSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobmFtZVNjYWxlKSB7XG4gICAgICB2YXIgZmllbGQgPSBuYW1lU2NhbGUuZmllbGQ7XG4gICAgICBuYW1lID0gbmFtZVNjYWxlLmdldFRleHQob3JpZ2luW2ZpZWxkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZVNjYWxlID0gdGhpcy5fZ2V0VGlwVmFsdWVTY2FsZSgpO1xuXG4gICAgICBuYW1lID0gZ2V0U2NhbGVOYW1lKHZhbHVlU2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bngrnlr7nlupR0b29sdGlw55qE5L+h5oGvXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDljp/lp4vnmoTmlbDmja7orrDlvZVcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0aXRsZUZpZWxkIHRvb2x0aXBUaXRsZSDphY3nva7kv6Hmga9cbiAgICogQHJldHVybiB7QXJyYXl9ICDkuIDmnaHmiJbogIXlpJrmnaHorrDlvZVcbiAgICovXG4gIGdldFRpcEl0ZW1zOiBmdW5jdGlvbiBnZXRUaXBJdGVtcyhwb2ludCwgdGl0bGVGaWVsZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3JpZ2luID0gcG9pbnRbRklFTERfT1JJR0lOXTtcbiAgICB2YXIgdGlwVGl0bGUgPSBzZWxmLmdldFRpcFRpdGxlKG9yaWdpbiwgdGl0bGVGaWVsZCk7XG4gICAgdmFyIHRvb2x0aXBDZmcgPSBzZWxmLmdldCgndG9vbHRpcENmZycpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbU5hbWUsIGl0ZW1WYWx1ZSwgY2ZnKSB7XG4gICAgICBpZiAoIVV0aWwuaXNOaWwoaXRlbVZhbHVlKSAmJiBpdGVtVmFsdWUgIT09ICcnKSB7XG4gICAgICAgIC8vIOWAvOS4um51bGznmoTml7blgJnvvIzlv73op4ZcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgdGl0bGU6IHRpcFRpdGxlLFxuICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBuYW1lOiBpdGVtTmFtZSB8fCB0aXBUaXRsZSxcbiAgICAgICAgICB2YWx1ZTogaXRlbVZhbHVlLFxuICAgICAgICAgIGNvbG9yOiBwb2ludC5jb2xvciB8fCBkZWZhdWx0Q29sb3IsXG4gICAgICAgICAgbWFya2VyOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGl0ZW0uc2l6ZSA9IHNlbGYuX2dldEludGVydmFsU2l6ZShwb2ludCk7XG4gICAgICAgIGl0ZW1zLnB1c2goVXRpbC5taXgoe30sIGl0ZW0sIGNmZykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b29sdGlwQ2ZnKSB7XG4gICAgICB2YXIgZmllbGRzID0gdG9vbHRpcENmZy5maWVsZHM7XG4gICAgICB2YXIgY2ZnID0gdG9vbHRpcENmZy5jZmc7XG4gICAgICB2YXIgY2FsbGJhY2tQYXJhbXMgPSBbXTtcbiAgICAgIFV0aWwuZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBjYWxsYmFja1BhcmFtcy5wdXNoKG9yaWdpbltmaWVsZF0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjZmcpIHtcbiAgICAgICAgLy8g5a2Y5Zyo5Zue6LCD5Ye95pWwXG4gICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY2ZnKSkge1xuICAgICAgICAgIGNmZyA9IGNmZy5hcHBseShudWxsLCBjYWxsYmFja1BhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbUNmZyA9IFV0aWwubWl4KHt9LCB7XG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIHRpdGxlOiB0aXBUaXRsZSxcbiAgICAgICAgICBjb2xvcjogcG9pbnQuY29sb3IgfHwgZGVmYXVsdENvbG9yLFxuICAgICAgICAgIG1hcmtlcjogdHJ1ZSAvLyDpu5jorqTlsZXnpLogbWFya2VyXG5cbiAgICAgICAgfSwgY2ZnKTtcbiAgICAgICAgaXRlbUNmZy5zaXplID0gc2VsZi5fZ2V0SW50ZXJ2YWxTaXplKHBvaW50KTtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtQ2ZnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWwuZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgIGlmICghVXRpbC5pc05pbChvcmlnaW5bZmllbGRdKSkge1xuICAgICAgICAgICAgLy8g5a2X5q615pWw5o2u5Li6bnVsbCAsdW5kZWZpbmVk5pe25LiN5pi+56S6XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBzZWxmLl9nZXRTY2FsZShmaWVsZCk7XG5cbiAgICAgICAgICAgIG5hbWUgPSBnZXRTY2FsZU5hbWUoc2NhbGUpO1xuICAgICAgICAgICAgdmFsdWUgPSBzY2FsZS5nZXRUZXh0KG9yaWdpbltmaWVsZF0pO1xuICAgICAgICAgICAgYWRkSXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlU2NhbGUgPSBzZWxmLl9nZXRUaXBWYWx1ZVNjYWxlKCk7XG5cbiAgICAgIGlmICghVXRpbC5pc05pbChvcmlnaW5bdmFsdWVTY2FsZS5maWVsZF0pKSB7XG4gICAgICAgIC8vIOWtl+auteaVsOaNruS4um51bGwgLHVuZGVmaW5lZOaXtuS4jeaYvuekulxuICAgICAgICB2YWx1ZSA9IHNlbGYuZ2V0VGlwVmFsdWUob3JpZ2luLCB2YWx1ZVNjYWxlKTtcbiAgICAgICAgbmFtZSA9IHNlbGYuZ2V0VGlwTmFtZShvcmlnaW4pO1xuICAgICAgICBhZGRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH0sXG4gIGlzU2hhcmVUb29sdGlwOiBmdW5jdGlvbiBpc1NoYXJlVG9vbHRpcCgpIHtcbiAgICB2YXIgc2hhcmVUb29sdGlwID0gdGhpcy5nZXQoJ3NoYXJlVG9vbHRpcCcpO1xuICAgIHZhciB0eXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0KCd2aWV3Jyk7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAodmlldy5nZXQoJ3BhcmVudCcpKSB7XG4gICAgICBvcHRpb25zID0gdmlldy5nZXQoJ3BhcmVudCcpLmdldCgnb3B0aW9ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gdmlldy5nZXQoJ29wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgICB2YXIgY29vcmRUeXBlID0gY29vcmQudHlwZTtcblxuICAgICAgaWYgKGNvb3JkVHlwZSA9PT0gJ3RoZXRhJyB8fCBjb29yZFR5cGUgPT09ICdwb2xhcicgJiYgY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICAgIHNoYXJlVG9vbHRpcCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2V0WVNjYWxlKCkgfHwgVXRpbC5pbkFycmF5KFsnY29udG91cicsICdwb2ludCcsICdwb2x5Z29uJywgJ2VkZ2UnXSwgdHlwZSkpIHtcbiAgICAgIHNoYXJlVG9vbHRpcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRvb2x0aXAgJiYgVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy50b29sdGlwLnNoYXJlZCkpIHtcbiAgICAgIC8vIOS7peeUqOaIt+iuvue9rueahOS4uuWHhlxuICAgICAgc2hhcmVUb29sdGlwID0gb3B0aW9ucy50b29sdGlwLnNoYXJlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcmVUb29sdGlwO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwTWl4aW47XG5cbi8qKiovIH0pLFxuLyogMzM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgaW50ZXJhY3Rpb24gd2hlbiBnZW9tIHdhcyBhY3RpdmVkXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRklFTERfT1JJR0lOID0gJ19vcmlnaW4nO1xuXG5mdW5jdGlvbiBpc1NhbWVTaGFwZShzaGFwZTEsIHNoYXBlMikge1xuICBpZiAoVXRpbC5pc05pbChzaGFwZTEpIHx8IFV0aWwuaXNOaWwoc2hhcGUyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzaGFwZTFPcmlnaW4gPSBzaGFwZTEuZ2V0KCdvcmlnaW4nKTtcbiAgdmFyIHNoYXBlMk9yaWdpbiA9IHNoYXBlMi5nZXQoJ29yaWdpbicpO1xuICByZXR1cm4gVXRpbC5pc0VxdWFsKHNoYXBlMU9yaWdpbiwgc2hhcGUyT3JpZ2luKTtcbn1cblxuZnVuY3Rpb24gaXNDaGFuZ2UocHJlU2hhcGVzLCBzaGFwZXMpIHtcbiAgaWYgKCFwcmVTaGFwZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcmVTaGFwZXMubGVuZ3RoICE9PSBzaGFwZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcnN0ID0gZmFsc2U7XG4gIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHtcbiAgICBpZiAoIWlzU2FtZVNoYXBlKHNoYXBlLCBwcmVTaGFwZXNbaW5kZXhdKSkge1xuICAgICAgcnN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcnN0O1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5BdHRycyhhY3RpdmVDZmcsIHNoYXBlKSB7XG4gIHZhciBvcmlnaW5BdHRycyA9IHt9O1xuICBVdGlsLmVhY2goYWN0aXZlQ2ZnLCBmdW5jdGlvbiAodiwgaykge1xuICAgIHZhciBvcmlnaW5WYWx1ZSA9IHNoYXBlLmF0dHIoayk7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KG9yaWdpblZhbHVlKSkge1xuICAgICAgb3JpZ2luVmFsdWUgPSBVdGlsLmNsb25lRGVlcChvcmlnaW5WYWx1ZSk7IC8vIOe8k+WtmOWOn+adpeeahOWxnuaAp++8jOeUseS6jiAuYXR0cignbWF0cml4Jykg5piv5pWw57uE77yM5omA5Lul5q2k5aSE6ZyA6KaB5rex5bqm5aSN5Yi2XG4gICAgfVxuXG4gICAgb3JpZ2luQXR0cnNba10gPSBvcmlnaW5WYWx1ZTtcbiAgfSk7XG4gIHJldHVybiBvcmlnaW5BdHRycztcbn1cblxudmFyIEFjdGl2ZU1peGluID0ge1xuICBfaXNBbGxvd0FjdGl2ZTogZnVuY3Rpb24gX2lzQWxsb3dBY3RpdmUoKSB7XG4gICAgdmFyIGFsbG93QWN0aXZlID0gdGhpcy5nZXQoJ2FsbG93QWN0aXZlJyk7XG5cbiAgICBpZiAoVXRpbC5pc05pbChhbGxvd0FjdGl2ZSkpIHtcbiAgICAgIC8vIOeUqOaIt+acquiuvue9ru+8jOS9v+eUqOm7mOiupOeahOetlueVpVxuICAgICAgdmFyIHZpZXcgPSB0aGlzLmdldCgndmlldycpO1xuICAgICAgdmFyIGlzU2hhcmVUb29sdGlwID0gdGhpcy5pc1NoYXJlVG9vbHRpcCgpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB2aWV3LmdldCgnb3B0aW9ucycpOyAvLyDpu5jorqTmg4XlhrXkuIvvvIx0b29sdGlwIOWFs+mXreaIluiAhSB0b29sdGlwIOaooeW8j+S4uiBzaGFyZWQgPT09IGZhbHNlIOeahOaXtuWAmeWFgeiuuCBhY3RpdmVcblxuICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCA9PT0gZmFsc2UgfHwgIWlzU2hhcmVUb29sdGlwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWxsb3dBY3RpdmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBfb25Nb3VzZWVudGVyOiBmdW5jdGlvbiBfb25Nb3VzZWVudGVyKGV2KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzaGFwZSA9IGV2LnNoYXBlO1xuICAgIHZhciBzaGFwZUNvbnRhaW5lciA9IHNlbGYuZ2V0KCdzaGFwZUNvbnRhaW5lcicpO1xuXG4gICAgaWYgKHNoYXBlICYmIHNoYXBlQ29udGFpbmVyLmNvbnRhaW4oc2hhcGUpICYmIHNlbGYuX2lzQWxsb3dBY3RpdmUoKSkge1xuICAgICAgLy8gc2hhcGUuZ2V0KCdhbmltYXRpbmcnKVxuICAgICAgc2VsZi5zZXRTaGFwZXNBY3RpdmVkKHNoYXBlKTtcbiAgICB9XG4gIH0sXG4gIF9vbk1vdXNlbGVhdmU6IGZ1bmN0aW9uIF9vbk1vdXNlbGVhdmUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi5nZXQoJ3ZpZXcnKTtcbiAgICB2YXIgY2FudmFzID0gdmlldy5nZXQoJ2NhbnZhcycpO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdhY3RpdmVTaGFwZXMnKSkge1xuICAgICAgc2VsZi5jbGVhckFjdGl2ZWRTaGFwZXMoKTtcbiAgICAgIGNhbnZhcy5kcmF3KCk7XG4gICAgfVxuICB9LFxuICBfYmluZEFjdGl2ZUFjdGlvbjogZnVuY3Rpb24gX2JpbmRBY3RpdmVBY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi5nZXQoJ3ZpZXcnKTtcbiAgICB2YXIgdHlwZSA9IHNlbGYuZ2V0KCd0eXBlJyk7XG4gICAgdmlldy5vbih0eXBlICsgJzptb3VzZWVudGVyJywgVXRpbC53cmFwQmVoYXZpb3Ioc2VsZiwgJ19vbk1vdXNlZW50ZXInKSk7XG4gICAgdmlldy5vbih0eXBlICsgJzptb3VzZWxlYXZlJywgVXRpbC53cmFwQmVoYXZpb3Ioc2VsZiwgJ19vbk1vdXNlbGVhdmUnKSk7XG4gIH0sXG4gIF9vZmZBY3RpdmVBY3Rpb246IGZ1bmN0aW9uIF9vZmZBY3RpdmVBY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi5nZXQoJ3ZpZXcnKTtcbiAgICB2YXIgdHlwZSA9IHNlbGYuZ2V0KCd0eXBlJyk7XG4gICAgdmlldy5vZmYodHlwZSArICc6bW91c2VlbnRlcicsIFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHNlbGYsICdfb25Nb3VzZWVudGVyJykpO1xuICAgIHZpZXcub2ZmKHR5cGUgKyAnOm1vdXNlbGVhdmUnLCBVdGlsLmdldFdyYXBCZWhhdmlvcihzZWxmLCAnX29uTW91c2VsZWF2ZScpKTtcbiAgfSxcbiAgX3NldEFjdGl2ZVNoYXBlOiBmdW5jdGlvbiBfc2V0QWN0aXZlU2hhcGUoc2hhcGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFjdGl2ZWRPcHRpb25zID0gc2VsZi5nZXQoJ2FjdGl2ZWRPcHRpb25zJykgfHwge307XG4gICAgdmFyIHNoYXBlRGF0YSA9IHNoYXBlLmdldCgnb3JpZ2luJyk7XG4gICAgdmFyIHNoYXBlTmFtZSA9IHNoYXBlRGF0YS5zaGFwZSB8fCBzZWxmLmdldERlZmF1bHRWYWx1ZSgnc2hhcGUnKTtcblxuICAgIGlmIChVdGlsLmlzQXJyYXkoc2hhcGVOYW1lKSkge1xuICAgICAgc2hhcGVOYW1lID0gc2hhcGVOYW1lWzBdO1xuICAgIH1cblxuICAgIHZhciBzaGFwZUZhY3RvcnkgPSBzZWxmLmdldCgnc2hhcGVGYWN0b3J5Jyk7XG4gICAgdmFyIHNoYXBlQ2ZnID0gVXRpbC5taXgoe30sIHNoYXBlLmF0dHIoKSwge1xuICAgICAgb3JpZ2luOiBzaGFwZURhdGFcbiAgICB9KTtcbiAgICB2YXIgYWN0aXZlQ2ZnID0gc2hhcGVGYWN0b3J5LmdldEFjdGl2ZUNmZyhzaGFwZU5hbWUsIHNoYXBlQ2ZnKTtcblxuICAgIGlmIChhY3RpdmVkT3B0aW9ucy5zdHlsZSkge1xuICAgICAgVXRpbC5taXgoYWN0aXZlQ2ZnLCBhY3RpdmVkT3B0aW9ucy5zdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbkF0dHJzID0gZ2V0T3JpZ2luQXR0cnMoYWN0aXZlQ2ZnLCBzaGFwZSk7XG4gICAgc2hhcGUuc2V0U2lsZW50KCdfb3JpZ2luQXR0cnMnLCBvcmlnaW5BdHRycyk7XG5cbiAgICBpZiAoYWN0aXZlZE9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgc2hhcGUuYW5pbWF0ZShhY3RpdmVDZmcsIDMwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlLmF0dHIoYWN0aXZlQ2ZnKTtcbiAgICB9XG5cbiAgICBzaGFwZS5zZXQoJ3pJbmRleCcsIDEpOyAvLyDmj5DliY1cbiAgfSxcbiAgc2V0U2hhcGVzQWN0aXZlZDogZnVuY3Rpb24gc2V0U2hhcGVzQWN0aXZlZChzaGFwZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIVV0aWwuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVzXTtcbiAgICB9XG5cbiAgICB2YXIgcHJlU2hhcGVzID0gc2VsZi5nZXQoJ2FjdGl2ZVNoYXBlcycpOyAvLyDojrflj5bkuIrmrKHooqvmv4DmtLvnmoQgc2hhcGVzXG5cbiAgICBpZiAoIWlzQ2hhbmdlKHByZVNoYXBlcywgc2hhcGVzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gc2VsZi5nZXQoJ3ZpZXcnKTtcbiAgICB2YXIgY2FudmFzID0gdmlldy5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBzaGFwZUNvbnRhaW5lciA9IHNlbGYuZ2V0KCdzaGFwZUNvbnRhaW5lcicpO1xuICAgIHZhciBhY3RpdmVkT3B0aW9ucyA9IHNlbGYuZ2V0KCdhY3RpdmVkT3B0aW9ucycpO1xuXG4gICAgaWYgKGFjdGl2ZWRPcHRpb25zICYmIGFjdGl2ZWRPcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgLy8g5LiK5qyh55qE5Yqo55S75pyq5a6M5oiQ77yM5omA5Lul6KaB5YGc5q2i5o6J5Yqo55S7XG4gICAgICBVdGlsLmVhY2goc2hhcGVzLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmdldCgnYW5pbWF0aW5nJykpIHtcbiAgICAgICAgICBzaGFwZS5zdG9wQW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYuaGlnaGxpZ2h0U2hhcGVzKHNoYXBlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmVTaGFwZXMpIHtcbiAgICAgICAgc2VsZi5jbGVhckFjdGl2ZWRTaGFwZXMoKTsgLy8g5YWI5riF6Zmk5r+A5rS75YWD57SgXG4gICAgICB9XG5cbiAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuZ2V0KCdhbmltYXRpbmcnKSkge1xuICAgICAgICAgIHNoYXBlLnN0b3BBbmltYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuZ2V0KCd2aXNpYmxlJykgJiYgIXNoYXBlLmdldCgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgIHNlbGYuX3NldEFjdGl2ZVNoYXBlKHNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZi5zZXQoJ2FjdGl2ZVNoYXBlcycsIHNoYXBlcyk7XG4gICAgc2hhcGVDb250YWluZXIuc29ydCgpO1xuICAgIGNhbnZhcy5kcmF3KCk7XG4gIH0sXG4gIGNsZWFyQWN0aXZlZFNoYXBlczogZnVuY3Rpb24gY2xlYXJBY3RpdmVkU2hhcGVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2hhcGVDb250YWluZXIgPSBzZWxmLmdldCgnc2hhcGVDb250YWluZXInKTtcbiAgICB2YXIgYWN0aXZlZE9wdGlvbnMgPSBzZWxmLmdldCgnYWN0aXZlZE9wdGlvbnMnKTtcbiAgICB2YXIgYWN0aXZlQW5pbWF0ZSA9IGFjdGl2ZWRPcHRpb25zICYmIGFjdGl2ZWRPcHRpb25zLmFuaW1hdGU7XG5cbiAgICBpZiAoc2hhcGVDb250YWluZXIgJiYgIXNoYXBlQ29udGFpbmVyLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIHZhciBhY3RpdmVTaGFwZXMgPSBzZWxmLmdldCgnYWN0aXZlU2hhcGVzJyk7XG4gICAgICBVdGlsLmVhY2goYWN0aXZlU2hhcGVzLCBmdW5jdGlvbiAoYWN0aXZlU2hhcGUpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVTaGFwZS5nZXQoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luQXR0cnMgPSBhY3RpdmVTaGFwZS5nZXQoJ19vcmlnaW5BdHRycycpO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUFuaW1hdGUpIHtcbiAgICAgICAgICAgIGFjdGl2ZVNoYXBlLnN0b3BBbmltYXRlKCk7XG4gICAgICAgICAgICBhY3RpdmVTaGFwZS5hbmltYXRlKG9yaWdpbkF0dHJzLCAzMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTaGFwZS5hdHRyKG9yaWdpbkF0dHJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3RpdmVTaGFwZS5zZXRaSW5kZXgoMCk7XG4gICAgICAgICAgYWN0aXZlU2hhcGUuc2V0KCdfb3JpZ2luQXR0cnMnLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcHJlSGlnaGxpZ2h0U2hhcGVzID0gc2VsZi5nZXQoJ3ByZUhpZ2hsaWdodFNoYXBlcycpO1xuXG4gICAgICBpZiAocHJlSGlnaGxpZ2h0U2hhcGVzKSB7XG4gICAgICAgIHZhciBzaGFwZXMgPSBzaGFwZUNvbnRhaW5lci5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgIGlmICghc2hhcGUuZ2V0KCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luQXR0cnMgPSBzaGFwZS5nZXQoJ19vcmlnaW5BdHRycycpO1xuXG4gICAgICAgICAgICBpZiAob3JpZ2luQXR0cnMpIHtcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUFuaW1hdGUpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zdG9wQW5pbWF0ZSgpO1xuICAgICAgICAgICAgICAgIHNoYXBlLmFuaW1hdGUob3JpZ2luQXR0cnMsIDMwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuYXR0cihvcmlnaW5BdHRycyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFwZS5zZXRaSW5kZXgoMCk7XG4gICAgICAgICAgICAgIHNoYXBlLnNldCgnX29yaWdpbkF0dHJzJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8g5oGi5aSN5Y6f5p2l5o6S5bqPXG5cblxuICAgICAgdmFyIGNoaWxkcmVuID0gc2hhcGVDb250YWluZXIuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgY2hpbGRyZW4uc29ydChmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgICAgICByZXR1cm4gb2JqMS5fSU5ERVggLSBvYmoyLl9JTkRFWDtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zZXQoJ2FjdGl2ZVNoYXBlcycsIG51bGwpO1xuICAgICAgc2VsZi5zZXQoJ3ByZUhpZ2hsaWdodFNoYXBlcycsIG51bGwpO1xuICAgIH1cbiAgfSxcbiAgZ2V0R3JvdXBTaGFwZXNCeVBvaW50OiBmdW5jdGlvbiBnZXRHcm91cFNoYXBlc0J5UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gc2VsZi5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgdmFyIGFjdGl2ZVNoYXBlcyA9IFtdO1xuXG4gICAgaWYgKHNoYXBlQ29udGFpbmVyKSB7XG4gICAgICB2YXIgeEZpZWxkID0gc2VsZi5nZXRYU2NhbGUoKS5maWVsZDtcbiAgICAgIHZhciBzaGFwZXMgPSBzZWxmLmdldFNoYXBlcygpO1xuXG4gICAgICB2YXIgb3JpZ2luT2JqID0gc2VsZi5fZ2V0T3JpZ2luQnlQb2ludChwb2ludCk7XG5cbiAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gc2hhcGUuZ2V0KCdvcmlnaW4nKTtcblxuICAgICAgICBpZiAoc2hhcGUuZ2V0KCd2aXNpYmxlJykgJiYgb3JpZ2luKSB7XG4gICAgICAgICAgLy8g5pyJ5Y+v6IO95LiN5piv5Zu+5b2i77yM6ICM5pivbGFiZWzmlofmnKzvvIzmiYDku6XliKTmlq3kuIDkuItcbiAgICAgICAgICB2YXIgc2hhcGVYVmFsdWUgPSBvcmlnaW5bRklFTERfT1JJR0lOXVt4RmllbGRdO1xuXG4gICAgICAgICAgaWYgKHNoYXBlWFZhbHVlID09PSBvcmlnaW5PYmpbeEZpZWxkXSkge1xuICAgICAgICAgICAgYWN0aXZlU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZVNoYXBlcztcbiAgfSxcbiAgZ2V0U2luZ2xlU2hhcGVCeVBvaW50OiBmdW5jdGlvbiBnZXRTaW5nbGVTaGFwZUJ5UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gc2VsZi5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgdmFyIGNhbnZhcyA9IHNoYXBlQ29udGFpbmVyLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBjYW52YXMuZ2V0KCdwaXhlbFJhdGlvJyk7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChzaGFwZUNvbnRhaW5lcikge1xuICAgICAgcmVzdWx0ID0gc2hhcGVDb250YWluZXIuZ2V0U2hhcGUocG9pbnQueCAqIHBpeGVsUmF0aW8sIHBvaW50LnkgKiBwaXhlbFJhdGlvKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5nZXQoJ29yaWdpbicpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSxcbiAgaGlnaGxpZ2h0U2hhcGVzOiBmdW5jdGlvbiBoaWdobGlnaHRTaGFwZXMoX2hpZ2hsaWdodFNoYXBlcywgaGlnaGxpZ2h0Q2ZnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFVdGlsLmlzQXJyYXkoX2hpZ2hsaWdodFNoYXBlcykpIHtcbiAgICAgIF9oaWdobGlnaHRTaGFwZXMgPSBbX2hpZ2hsaWdodFNoYXBlc107XG4gICAgfVxuXG4gICAgdmFyIHByZUhpZ2hsaWdodFNoYXBlcyA9IHNlbGYuZ2V0KCdhY3RpdmVTaGFwZXMnKTsgLy8g6I635Y+W5LiK5qyh6KKr5r+A5rS755qEIHNoYXBlc1xuXG4gICAgaWYgKCFpc0NoYW5nZShwcmVIaWdobGlnaHRTaGFwZXMsIF9oaWdobGlnaHRTaGFwZXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZUhpZ2hsaWdodFNoYXBlcykge1xuICAgICAgc2VsZi5jbGVhckFjdGl2ZWRTaGFwZXMoKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVzID0gc2VsZi5nZXRTaGFwZXMoKTtcbiAgICB2YXIgYWN0aXZlZE9wdGlvbnMgPSBzZWxmLmdldCgnYWN0aXZlZE9wdGlvbnMnKTtcbiAgICB2YXIgYWN0aXZlQW5pbWF0ZSA9IGFjdGl2ZWRPcHRpb25zICYmIGFjdGl2ZWRPcHRpb25zLmFuaW1hdGU7XG4gICAgdmFyIGFjdGl2ZVN0eWxlID0gYWN0aXZlZE9wdGlvbnMgJiYgYWN0aXZlZE9wdGlvbnMuc3R5bGU7XG4gICAgVXRpbC5lYWNoKHNoYXBlcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICB2YXIgY2hhbmdlQXR0cnMgPSB7fTtcbiAgICAgIHNoYXBlLnN0b3BBbmltYXRlKCk7XG5cbiAgICAgIGlmIChVdGlsLmluZGV4T2YoX2hpZ2hsaWdodFNoYXBlcywgc2hhcGUpICE9PSAtMSkge1xuICAgICAgICBVdGlsLm1peChjaGFuZ2VBdHRycywgYWN0aXZlU3R5bGUsIGhpZ2hsaWdodENmZyk7XG4gICAgICAgIHNoYXBlLnNldFpJbmRleCgxKTsgLy8g5o+Q5YmNXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlsLm1peChjaGFuZ2VBdHRycywge1xuICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjMsXG4gICAgICAgICAgLy8gQDIwMTgtMDctMTEgYnkgYmx1ZS5sYiDnlLHkuo7nur/lm77lj6rmnIlzdG9rZe+8jGZpbGxPcGFjaXR55LiN55Sf5pWI77yM5pyA5aW96L+Y5piv55u05o6l5pS55oiQ5pW05Liq5Zu+5b2i6YCP5piO5bqmb3BhY2l0eVxuICAgICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgICB9KTtcbiAgICAgICAgc2hhcGUuc2V0WkluZGV4KDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luQXR0cnMgPSBnZXRPcmlnaW5BdHRycyhjaGFuZ2VBdHRycywgc2hhcGUpO1xuICAgICAgc2hhcGUuc2V0U2lsZW50KCdfb3JpZ2luQXR0cnMnLCBvcmlnaW5BdHRycyk7XG5cbiAgICAgIGlmIChhY3RpdmVBbmltYXRlKSB7XG4gICAgICAgIHNoYXBlLmFuaW1hdGUoY2hhbmdlQXR0cnMsIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5hdHRyKGNoYW5nZUF0dHJzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxmLnNldCgncHJlSGlnaGxpZ2h0U2hhcGVzJywgX2hpZ2hsaWdodFNoYXBlcyk7XG4gICAgc2VsZi5zZXQoJ2FjdGl2ZVNoYXBlcycsIF9oaWdobGlnaHRTaGFwZXMpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBY3RpdmVNaXhpbjtcblxuLyoqKi8gfSksXG4vKiAzMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHRoZSBpbnRlcmFjdGlvbiB3aGVuIGdlb20gd2FzIHNlbGVjdGVkXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRklFTERfT1JJR0lOID0gJ19vcmlnaW4nO1xuXG5mdW5jdGlvbiBpc1NhbWVTaGFwZShzaGFwZTEsIHNoYXBlMikge1xuICBpZiAoVXRpbC5pc05pbChzaGFwZTEpIHx8IFV0aWwuaXNOaWwoc2hhcGUyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzaGFwZTFPcmlnaW4gPSBzaGFwZTEuZ2V0KCdvcmlnaW4nKTtcbiAgdmFyIHNoYXBlMk9yaWdpbiA9IHNoYXBlMi5nZXQoJ29yaWdpbicpO1xuICByZXR1cm4gVXRpbC5pc0VxdWFsKHNoYXBlMU9yaWdpbiwgc2hhcGUyT3JpZ2luKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JpZ2luQXR0cnMoc2VsZWN0ZWRDZmcsIHNoYXBlKSB7XG4gIHZhciBvcmlnaW5BdHRycyA9IHt9O1xuICBVdGlsLmVhY2goc2VsZWN0ZWRDZmcsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgaWYgKGsgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICBrID0gJ21hdHJpeCc7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpblZhbHVlID0gc2hhcGUuYXR0cihrKTtcblxuICAgIGlmIChVdGlsLmlzQXJyYXkob3JpZ2luVmFsdWUpKSB7XG4gICAgICBvcmlnaW5WYWx1ZSA9IFV0aWwuY2xvbmVEZWVwKG9yaWdpblZhbHVlKTsgLy8g57yT5a2Y5Y6f5p2l55qE5bGe5oCn77yM55Sx5LqOIC5hdHRyKCdtYXRyaXgnKSDmmK/mlbDnu4TvvIzmiYDku6XmraTlpITpnIDopoHmt7HluqblpI3liLZcbiAgICB9XG5cbiAgICBvcmlnaW5BdHRyc1trXSA9IG9yaWdpblZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIG9yaWdpbkF0dHJzO1xufVxuXG52YXIgU2VsZWN0TWl4aW4gPSB7XG4gIF9pc0FsbG93U2VsZWN0OiBmdW5jdGlvbiBfaXNBbGxvd1NlbGVjdCgpIHtcbiAgICB2YXIgaXNBbGxvd1NlbGVjdCA9IHRoaXMuZ2V0KCdhbGxvd1NlbGVjdCcpO1xuXG4gICAgaWYgKFV0aWwuaXNOaWwoaXNBbGxvd1NlbGVjdCkpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5nZXQoJ3R5cGUnKTtcbiAgICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgICAgdmFyIGNvb3JkVHlwZSA9IGNvb3JkICYmIGNvb3JkLnR5cGU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnICYmIGNvb3JkVHlwZSA9PT0gJ3RoZXRhJykge1xuICAgICAgICAvLyDppbzlm77pu5jorqTlj6/ku6Xov5vooYzpgInkuK1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOeUqOaIt+iuvue9ruS6hiBzZWxlY3Qg6YWN572uXG4gICAgICByZXR1cm4gaXNBbGxvd1NlbGVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIF9vbkNsaWNrOiBmdW5jdGlvbiBfb25DbGljayhldikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLl9pc0FsbG93U2VsZWN0KCkpIHtcbiAgICAgIC8vIOWFgeiuuOmAieS4reS4i+aJjeaJp+ihjFxuICAgICAgc2VsZi5jbGVhckFjdGl2ZWRTaGFwZXMoKTsgLy8g5riF6ZmkaG92ZXLmlYjmnpxcblxuICAgICAgdmFyIHNoYXBlID0gZXYuc2hhcGU7XG4gICAgICB2YXIgc2hhcGVDb250YWluZXIgPSBzZWxmLmdldCgnc2hhcGVDb250YWluZXInKTtcblxuICAgICAgaWYgKHNoYXBlICYmICFzaGFwZS5nZXQoJ2FuaW1hdGluZycpICYmIHNoYXBlQ29udGFpbmVyLmNvbnRhaW4oc2hhcGUpKSB7XG4gICAgICAgIHNlbGYuc2V0U2hhcGVTZWxlY3RlZChzaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfYmluZFNlbGVjdGVkQWN0aW9uOiBmdW5jdGlvbiBfYmluZFNlbGVjdGVkQWN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmlldyA9IHNlbGYuZ2V0KCd2aWV3Jyk7XG4gICAgdmFyIHR5cGUgPSBzZWxmLmdldCgndHlwZScpO1xuICAgIHZpZXcub24odHlwZSArICc6Y2xpY2snLCBVdGlsLndyYXBCZWhhdmlvcihzZWxmLCAnX29uQ2xpY2snKSk7XG4gIH0sXG4gIF9vZmZTZWxlY3RlZEFjdGlvbjogZnVuY3Rpb24gX29mZlNlbGVjdGVkQWN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmlldyA9IHNlbGYuZ2V0KCd2aWV3Jyk7XG4gICAgdmFyIHR5cGUgPSBzZWxmLmdldCgndHlwZScpO1xuICAgIHZpZXcub2ZmKHR5cGUgKyAnOmNsaWNrJywgVXRpbC5nZXRXcmFwQmVoYXZpb3Ioc2VsZiwgJ19vbkNsaWNrJykpO1xuICB9LFxuICBfc2V0U2hhcGVTdGF0dXM6IGZ1bmN0aW9uIF9zZXRTaGFwZVN0YXR1cyhzaGFwZSwgc3RhdHVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi5nZXQoJ3ZpZXcnKTtcbiAgICB2YXIgc2VsZWN0ZWRPcHRpb25zID0gc2VsZi5nZXQoJ3NlbGVjdGVkT3B0aW9ucycpIHx8IHt9O1xuICAgIHZhciBhbmltYXRlID0gc2VsZWN0ZWRPcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlOyAvLyDpu5jorqTlhYHorrjliqjnlLtcblxuICAgIHZhciBjYW52YXMgPSB2aWV3LmdldCgnY2FudmFzJyk7XG4gICAgc2hhcGUuc2V0KCdzZWxlY3RlZCcsIHN0YXR1cyk7XG4gICAgdmFyIHNoYXBlRGF0YSA9IHNoYXBlLmdldCgnb3JpZ2luJyk7XG5cbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAvLyDpgInkuK3nirbmgIFcbiAgICAgIHZhciBzaGFwZU5hbWUgPSBzaGFwZURhdGEuc2hhcGUgfHwgc2VsZi5nZXREZWZhdWx0VmFsdWUoJ3NoYXBlJyk7XG5cbiAgICAgIGlmIChVdGlsLmlzQXJyYXkoc2hhcGVOYW1lKSkge1xuICAgICAgICBzaGFwZU5hbWUgPSBzaGFwZU5hbWVbMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFwZUZhY3RvcnkgPSBzZWxmLmdldCgnc2hhcGVGYWN0b3J5Jyk7XG4gICAgICB2YXIgY2ZnID0gVXRpbC5taXgoe1xuICAgICAgICBnZW9tOiBzZWxmLFxuICAgICAgICBwb2ludDogc2hhcGVEYXRhXG4gICAgICB9LCBzZWxlY3RlZE9wdGlvbnMpO1xuICAgICAgdmFyIHNlbGVjdGVkU3R5bGUgPSBzaGFwZUZhY3RvcnkuZ2V0U2VsZWN0ZWRDZmcoc2hhcGVOYW1lLCBjZmcpO1xuICAgICAgVXRpbC5taXgoc2VsZWN0ZWRTdHlsZSwgY2ZnLnN0eWxlKTsgLy8g55So5oi36K6+572u55qE5LyY5YWI57qn5pu06auYXG5cbiAgICAgIGlmICghc2hhcGUuZ2V0KCdfb3JpZ2luQXR0cnMnKSkge1xuICAgICAgICAvLyDnvJPlrZjljp/mnInlsZ7mgKdcbiAgICAgICAgaWYgKHNoYXBlLmdldCgnYW5pbWF0aW5nJykpIHtcbiAgICAgICAgICAvLyDlgZzmraLliqjnlLtcbiAgICAgICAgICBzaGFwZS5zdG9wQW5pbWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGUuc2V0KCdfb3JpZ2luQXR0cnMnLCBnZXRPcmlnaW5BdHRycyhzZWxlY3RlZFN0eWxlLCBzaGFwZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICBzaGFwZS5hbmltYXRlKHNlbGVjdGVkU3R5bGUsIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5hdHRyKHNlbGVjdGVkU3R5bGUpO1xuICAgICAgICBjYW52YXMuZHJhdygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3JpZ2luQXR0cnMgPSBzaGFwZS5nZXQoJ19vcmlnaW5BdHRycycpO1xuICAgICAgc2hhcGUuc2V0KCdfb3JpZ2luQXR0cnMnLCBudWxsKTtcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgc2hhcGUuYW5pbWF0ZShvcmlnaW5BdHRycywgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlLmF0dHIob3JpZ2luQXR0cnMpO1xuICAgICAgICBjYW52YXMuZHJhdygpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0U2hhcGVTZWxlY3RlZDogZnVuY3Rpb24gc2V0U2hhcGVTZWxlY3RlZChzaGFwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBzZWxlY3RlZFNoYXBlcyA9IHNlbGYuX2dldFNlbGVjdGVkU2hhcGVzKCk7XG5cbiAgICB2YXIgc2VsZWN0ZWRPcHRpb25zID0gc2VsZi5nZXQoJ3NlbGVjdGVkT3B0aW9ucycpIHx8IHt9O1xuICAgIHZhciBjYW5jZWxhYmxlID0gc2VsZWN0ZWRPcHRpb25zLmNhbmNlbGFibGUgIT09IGZhbHNlOyAvLyDpgInkuK3nirbmgIHmmK/lkKblhYHorrjlj5bmtojvvIzpu5jorqTlhYHorrhcblxuICAgIGlmIChzZWxlY3RlZE9wdGlvbnMubW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgLy8g5pSv5oyB5aSa6YCJXG4gICAgICBpZiAoVXRpbC5pbmRleE9mKHNlbGVjdGVkU2hhcGVzLCBzaGFwZSkgPT09IC0xKSB7XG4gICAgICAgIHNlbGVjdGVkU2hhcGVzLnB1c2goc2hhcGUpO1xuXG4gICAgICAgIHNlbGYuX3NldFNoYXBlU3RhdHVzKHNoYXBlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuY2VsYWJsZSkge1xuICAgICAgICAvLyDlm77lvaLlt7Lnu4/ooqvpgInkuK3lubbkuJTpgInkuK3nirbmgIHlhYHorrjlj5bmtojpgInkuK1cbiAgICAgICAgVXRpbC5BcnJheS5yZW1vdmUoc2VsZWN0ZWRTaGFwZXMsIHNoYXBlKTtcblxuICAgICAgICBzZWxmLl9zZXRTaGFwZVN0YXR1cyhzaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZWN0ZWRTaGFwZSA9IHNlbGVjdGVkU2hhcGVzWzBdO1xuXG4gICAgICBpZiAoY2FuY2VsYWJsZSkge1xuICAgICAgICAvLyDlpoLmnpzlhYHorrjlj5bmtojvvIzliJnpgInkuK1udWxsXG4gICAgICAgIHNoYXBlID0gaXNTYW1lU2hhcGUoc2VsZWN0ZWRTaGFwZSwgc2hhcGUpID8gbnVsbCA6IHNoYXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2FtZVNoYXBlKHNlbGVjdGVkU2hhcGUsIHNoYXBlKSkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSkge1xuICAgICAgICAgIHNlbGYuX3NldFNoYXBlU3RhdHVzKHNlbGVjdGVkU2hhcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgIHNlbGYuX3NldFNoYXBlU3RhdHVzKHNoYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2xlYXJTZWxlY3RlZDogZnVuY3Rpb24gY2xlYXJTZWxlY3RlZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlQ29udGFpbmVyID0gc2VsZi5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG5cbiAgICBpZiAoc2hhcGVDb250YWluZXIgJiYgIXNoYXBlQ29udGFpbmVyLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIHZhciBzZWxlY3RlZFNoYXBlcyA9IHNlbGYuX2dldFNlbGVjdGVkU2hhcGVzKCk7XG5cbiAgICAgIFV0aWwuZWFjaChzZWxlY3RlZFNoYXBlcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHNlbGYuX3NldFNoYXBlU3RhdHVzKHNoYXBlLCBmYWxzZSk7XG5cbiAgICAgICAgc2hhcGUuc2V0KCdfb3JpZ2luQXR0cnMnLCBudWxsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6K6+572u6K6w5b2V5a+55bqU55qE5Zu+5b2i6YCJ5LitXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQg6YCJ5Lit55qE6K6w5b2VXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHJldHVybiB7R2VvbX0g6L+U5Zue5b2T5YmN55qEIEdlb21ldHJ5XG4gICAqL1xuICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gc2V0U2VsZWN0ZWQocmVjb3JkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzaGFwZXMgPSBzZWxmLmdldFNoYXBlcygpO1xuICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIG9yaWdpbiA9IHNoYXBlLmdldCgnb3JpZ2luJyk7XG5cbiAgICAgIGlmIChvcmlnaW4gJiYgb3JpZ2luW0ZJRUxEX09SSUdJTl0gPT09IHJlY29yZCkge1xuICAgICAgICBzZWxmLnNldFNoYXBlU2VsZWN0ZWQoc2hhcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZ2V0U2VsZWN0ZWRTaGFwZXM6IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZFNoYXBlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlcyA9IHNlbGYuZ2V0U2hhcGVzKCk7XG4gICAgdmFyIHNlbGVjdGVkU2hhcGVzID0gW107XG4gICAgVXRpbC5lYWNoKHNoYXBlcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICBpZiAoc2hhcGUuZ2V0KCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIHNlbGVjdGVkU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYuc2V0KCdzZWxlY3RlZFNoYXBlcycsIHNlbGVjdGVkU2hhcGVzKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTaGFwZXM7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdE1peGluO1xuXG4vKioqLyB9KSxcbi8qIDM0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIGlmIChVdGlsLmlzQXJyYXkoZmllbGQpKSB7XG4gICAgcmV0dXJuIGZpZWxkO1xuICB9XG5cbiAgaWYgKFV0aWwuaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgcmV0dXJuIGZpZWxkLnNwbGl0KCcqJyk7XG4gIH1cblxuICByZXR1cm4gW2ZpZWxkXTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDluqbph4/nmoTmjqfliLblmahcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgU2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgZGF0ZVJlZ2V4ID0gL14oPzooPyEwMDAwKVswLTldezR9KFstLy5dKykoPzooPzowP1sxLTldfDFbMC0yXSlcXDEoPzowP1sxLTldfDFbMC05XXwyWzAtOF0pfCg/OjA/WzEzLTldfDFbMC0yXSlcXDEoPzoyOXwzMCl8KD86MD9bMTM1NzhdfDFbMDJdKVxcMSg/OjMxKSl8KD86WzAtOV17Mn0oPzowWzQ4XXxbMjQ2OF1bMDQ4XXxbMTM1NzldWzI2XSl8KD86MFs0OF18WzI0NjhdWzA0OF18WzEzNTc5XVsyNl0pMDApKFstLy5dPykwPzJcXDIoPzoyOSkpKFxccysoWzAxXXwoWzAxXVswLTldfDJbMC0zXSkpOihbMC05XXxbMC01XVswLTldKTooWzAtOV18WzAtNV1bMC05XSkpPyQvO1xudmFyIFRZUEVTID0ge1xuICBMSU5FQVI6ICdsaW5lYXInLFxuICBDQVQ6ICdjYXQnLFxuICBUSU1FOiAndGltZSdcbn07XG5cbnZhciBTY2FsZUNvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2FsZUNvbnRyb2xsZXIoY2ZnKSB7XG4gICAgLy8gZGVmcyDliJflrprkuYlcbiAgICB0aGlzLmRlZnMgPSB7fTtcbiAgICB0aGlzLnZpZXdUaGVtZSA9IHtcbiAgICAgIHNjYWxlczoge31cbiAgICB9OyAvLyBmaWx0ZXJlZCBmaWVsZHNcblxuICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgIFV0aWwuYXNzaWduKHRoaXMsIGNmZyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2NhbGVDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2dldERlZiA9IGZ1bmN0aW9uIF9nZXREZWYoZmllbGQpIHtcbiAgICB2YXIgZGVmcyA9IHRoaXMuZGVmcztcbiAgICB2YXIgdmlld1RoZW1lID0gdGhpcy52aWV3VGhlbWU7XG4gICAgdmFyIGRlZiA9IG51bGw7XG5cbiAgICBpZiAodmlld1RoZW1lLnNjYWxlc1tmaWVsZF0gfHwgZGVmc1tmaWVsZF0pIHtcbiAgICAgIGRlZiA9IFV0aWwubWl4KHt9LCB2aWV3VGhlbWUuc2NhbGVzW2ZpZWxkXSk7IC8vIOWkhOeQhuimhuebluWxnuaAp+eahOmXrumimFxuXG4gICAgICBVdGlsLmVhY2goZGVmc1tmaWVsZF0sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGlmIChVdGlsLmlzTmlsKHYpKSB7XG4gICAgICAgICAgZGVsZXRlIGRlZltrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tmaWVsZF0pIHtcbiAgICAgICAgZGVsZXRlIGRlZi5taW47XG4gICAgICAgIGRlbGV0ZSBkZWYubWF4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWY7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXREZWZhdWx0VHlwZSA9IGZ1bmN0aW9uIF9nZXREZWZhdWx0VHlwZShmaWVsZCwgZGF0YSkge1xuICAgIHZhciB0eXBlID0gVFlQRVMuTElORUFSO1xuICAgIHZhciB2YWx1ZSA9IFV0aWwuQXJyYXkuZmlyc3RWYWx1ZShkYXRhLCBmaWVsZCk7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZVJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICB0eXBlID0gVFlQRVMuVElNRTtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB0eXBlID0gVFlQRVMuQ0FUO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U2NhbGVDZmcgPSBmdW5jdGlvbiBfZ2V0U2NhbGVDZmcodHlwZSwgZmllbGQsIGRhdGEpIHtcbiAgICB2YXIgY2ZnID0ge1xuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfTtcbiAgICB2YXIgdmFsdWVzID0gVXRpbC5BcnJheS52YWx1ZXMoZGF0YSwgZmllbGQpO1xuICAgIGNmZy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBpZiAoIVNjYWxlLmlzQ2F0ZWdvcnkodHlwZSkgJiYgdHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBVdGlsLkFycmF5LmdldFJhbmdlKHZhbHVlcyk7XG4gICAgICBjZmcubWluID0gcmFuZ2UubWluO1xuICAgICAgY2ZnLm1heCA9IHJhbmdlLm1heDtcbiAgICAgIGNmZy5uaWNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICBjZmcubmljZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZVNjYWxlID0gZnVuY3Rpb24gY3JlYXRlU2NhbGUoZmllbGQsIGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgZGVmID0gc2VsZi5fZ2V0RGVmKGZpZWxkKTtcblxuICAgIHZhciBzY2FsZTsgLy8g5aaC5p6c5pWw5o2u5Li656m655u05o6l6L+U5Zue5bi46YeP5bqm6YePXG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAoZGVmICYmIGRlZi50eXBlKSB7XG4gICAgICAgIHNjYWxlID0gU2NhbGVbZGVmLnR5cGVdKGRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IFNjYWxlLmlkZW50aXR5KHtcbiAgICAgICAgICB2YWx1ZTogZmllbGQsXG4gICAgICAgICAgZmllbGQ6IGZpZWxkLnRvU3RyaW5nKCksXG4gICAgICAgICAgdmFsdWVzOiBbZmllbGRdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0VmFsdWUgPSBVdGlsLkFycmF5LmZpcnN0VmFsdWUoZGF0YSwgZmllbGQpO1xuXG4gICAgaWYgKFV0aWwuaXNOdW1iZXIoZmllbGQpIHx8IFV0aWwuaXNOaWwoZmlyc3RWYWx1ZSkgJiYgIWRlZikge1xuICAgICAgc2NhbGUgPSBTY2FsZS5pZGVudGl0eSh7XG4gICAgICAgIHZhbHVlOiBmaWVsZCxcbiAgICAgICAgZmllbGQ6IGZpZWxkLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlczogW2ZpZWxkXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOWmguaenOW3sue7j+WumuS5iei/h+i/meS4quW6pumHj1xuICAgICAgdmFyIHR5cGU7XG5cbiAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgdHlwZSA9IGRlZi50eXBlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSB8fCBzZWxmLl9nZXREZWZhdWx0VHlwZShmaWVsZCwgZGF0YSk7XG5cbiAgICAgIHZhciBjZmcgPSBzZWxmLl9nZXRTY2FsZUNmZyh0eXBlLCBmaWVsZCwgZGF0YSk7XG5cbiAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgVXRpbC5taXgoY2ZnLCBkZWYpO1xuICAgICAgfVxuXG4gICAgICBzY2FsZSA9IFNjYWxlW3R5cGVdKGNmZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBTY2FsZUNvbnRyb2xsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGVDb250cm9sbGVyO1xuXG4vKioqLyB9KSxcbi8qIDM0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGNvbnRyb2xsZXIgb2YgY29vcmRpbmF0ZVxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENvb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDMpO1xuXG52YXIgQ29vcmRDb250cm9sbGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29vcmRDb250cm9sbGVyKG9wdGlvbikge1xuICAgIHRoaXMudHlwZSA9ICdyZWN0JztcbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNmZyA9IHt9O1xuICAgIFV0aWwubWl4KHRoaXMsIG9wdGlvbik7XG4gICAgdGhpcy5vcHRpb24gPSBvcHRpb24gfHwge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29vcmRDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldChjb29yZE9wdGlvbikge1xuICAgIHRoaXMuYWN0aW9ucyA9IGNvb3JkT3B0aW9uLmFjdGlvbnMgfHwgW107XG4gICAgdGhpcy50eXBlID0gY29vcmRPcHRpb24udHlwZTtcbiAgICB0aGlzLmNmZyA9IGNvb3JkT3B0aW9uLmNmZztcbiAgICB0aGlzLm9wdGlvbi5hY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIHRoaXMub3B0aW9uLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy5vcHRpb24uY2ZnID0gdGhpcy5jZmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLl9leGVjQWN0aW9ucyA9IGZ1bmN0aW9uIF9leGVjQWN0aW9ucyhjb29yZCkge1xuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgIFV0aWwuZWFjaChhY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgbSA9IGFjdGlvblswXTtcbiAgICAgIGNvb3JkW21dKGFjdGlvblsxXSwgYWN0aW9uWzJdKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaGFzQWN0aW9uID0gZnVuY3Rpb24gaGFzQWN0aW9uKGFjdGlvbk5hbWUpIHtcbiAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICB2YXIgcnN0ID0gZmFsc2U7XG4gICAgVXRpbC5lYWNoKGFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGlmIChhY3Rpb25OYW1lID09PSBhY3Rpb25bMF0pIHtcbiAgICAgICAgcnN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH07XG4gIC8qKlxuICAgKiDliJvlu7rlnZDmoIfns7vlr7nosaFcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydCDlnZDmoIfns7votbflp4vngrlcbiAgICogQHBhcmFtICB7T2JqZWN0fSBlbmQgICDlnZDmoIfns7vnu5PmnZ/ngrlcbiAgICogQHJldHVybiB7RnVuY3Rpb259IOWdkOagh+ezu+eahOaehOmAoOWHveaVsFxuICAgKi9cblxuXG4gIF9wcm90by5jcmVhdGVDb29yZCA9IGZ1bmN0aW9uIGNyZWF0ZUNvb3JkKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSBzZWxmLnR5cGU7XG4gICAgdmFyIGNmZyA9IHNlbGYuY2ZnO1xuICAgIHZhciBDOyAvLyDmnoTpgKDlh73mlbBcblxuICAgIHZhciBjb29yZDtcbiAgICB2YXIgY29vcmRDZmcgPSBVdGlsLm1peCh7XG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH0sIGNmZyk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3RoZXRhJykge1xuICAgICAgLy8gZGVmaW5pdGlvbiBvZiB0aGV0YSBjb29yZFxuICAgICAgQyA9IENvb3JkLlBvbGFyO1xuXG4gICAgICBpZiAoIXNlbGYuaGFzQWN0aW9uKCd0cmFuc3Bvc2UnKSkge1xuICAgICAgICBzZWxmLnRyYW5zcG9zZSgpOyAvLyDmnoHlnZDmoIfvvIzlkIzml7Z0cmFuc3Bvc2VcbiAgICAgIH1cblxuICAgICAgY29vcmQgPSBuZXcgQyhjb29yZENmZyk7XG4gICAgICBjb29yZC50eXBlID0gdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgQyA9IENvb3JkW1V0aWwudXBwZXJGaXJzdCh0eXBlIHx8ICcnKV0gfHwgQ29vcmQuUmVjdDtcbiAgICAgIGNvb3JkID0gbmV3IEMoY29vcmRDZmcpO1xuICAgIH1cblxuICAgIHNlbGYuX2V4ZWNBY3Rpb25zKGNvb3JkKTtcblxuICAgIHJldHVybiBjb29yZDtcbiAgfTtcblxuICBfcHJvdG8ucm90YXRlID0gZnVuY3Rpb24gcm90YXRlKGFuZ2xlKSB7XG4gICAgYW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG4gICAgdGhpcy5hY3Rpb25zLnB1c2goWydyb3RhdGUnLCBhbmdsZV0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZWZsZWN0ID0gZnVuY3Rpb24gcmVmbGVjdChkaW0pIHtcbiAgICB0aGlzLmFjdGlvbnMucHVzaChbJ3JlZmxlY3QnLCBkaW1dKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShzeCwgc3kpIHtcbiAgICB0aGlzLmFjdGlvbnMucHVzaChbJ3NjYWxlJywgc3gsIHN5XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZSgpIHtcbiAgICB0aGlzLmFjdGlvbnMucHVzaChbJ3RyYW5zcG9zZSddKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQ29vcmRDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvb3JkQ29udHJvbGxlcjtcblxuLyoqKi8gfSksXG4vKiAzNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgZW50cnkgb2YgY29vcmRpbmF0ZVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqL1xuXG52YXIgQ29vcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuQ29vcmQuQ2FydGVzaWFuID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDQpO1xuQ29vcmQuUmVjdCA9IENvb3JkLkNhcnRlc2lhbjtcbkNvb3JkLlBvbGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDUpO1xuQ29vcmQuSGVsaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0Nik7XG5tb2R1bGUuZXhwb3J0cyA9IENvb3JkO1xuXG4vKioqLyB9KSxcbi8qIDM0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgdGhlIGNsYXNzIG9mIENhcnRlc2lhbiBDb29yZGluYXRlXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuXG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG52YXIgQ2FydGVzaWFuID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHMoQ2FydGVzaWFuLCBfQmFzZSk7XG5cbiAgX2NyZWF0ZUNsYXNzKENhcnRlc2lhbiwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmYXVsdENmZ1wiLFxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgICB2YXIgY2ZnID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FydGVzaWFuLnByb3RvdHlwZSksIFwiZ2V0RGVmYXVsdENmZ1wiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gbWl4KHt9LCBjZmcsIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4nLFxuICAgICAgICBpc1JlY3Q6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENhcnRlc2lhbihjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FydGVzaWFuKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKENhcnRlc2lhbikuY2FsbCh0aGlzLCBjZmcpKTtcblxuICAgIF90aGlzLl9pbml0KCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FydGVzaWFuLCBbe1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdGhpcy5lbmQ7XG4gICAgICB2YXIgeCA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LngsXG4gICAgICAgIGVuZDogZW5kLnhcbiAgICAgIH07XG4gICAgICB2YXIgeSA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnksXG4gICAgICAgIGVuZDogZW5kLnlcbiAgICAgIH07XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcblxuICAgICAgaWYgKHRoaXMuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICAgIHggPSBwb2ludC55O1xuICAgICAgICB5ID0gcG9pbnQueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBwb2ludC54O1xuICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5jb252ZXJ0RGltKHgsICd4JyksXG4gICAgICAgIHk6IHRoaXMuY29udmVydERpbSh5LCAneScpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnRQb2ludChwb2ludCkge1xuICAgICAgdmFyIHggPSB0aGlzLmludmVydERpbShwb2ludC54LCAneCcpO1xuICAgICAgdmFyIHkgPSB0aGlzLmludmVydERpbShwb2ludC55LCAneScpO1xuXG4gICAgICBpZiAodGhpcy5pc1RyYW5zcG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB5LFxuICAgICAgICAgIHk6IHhcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FydGVzaWFuO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXJ0ZXNpYW47XG5cbi8qKiovIH0pLFxuLyogMzQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbi8qKlxuICogQGZpbGVPdmVydmlldyB0aGUgY2xhc3Mgb2YgUG9sYXIgQ29vcmRpbmF0ZVxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cblxuXG52YXIgTWF0cml4VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgaXNOdW1iZXJFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG52YXIgbWl4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxudmFyIG1hdDMgPSBNYXRyaXhVdGlsLm1hdDM7XG52YXIgdmVjMiA9IE1hdHJpeFV0aWwudmVjMjtcbnZhciB2ZWMzID0gTWF0cml4VXRpbC52ZWMzO1xuXG52YXIgUG9sYXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0cyhQb2xhciwgX0Jhc2UpO1xuXG4gIF9jcmVhdGVDbGFzcyhQb2xhciwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmYXVsdENmZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgICAgdmFyIGNmZyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFBvbGFyLnByb3RvdHlwZSksIFwiZ2V0RGVmYXVsdENmZ1wiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gbWl4KHt9LCBjZmcsIHtcbiAgICAgICAgc3RhcnRBbmdsZTogLU1hdGguUEkgLyAyLFxuICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDMgLyAyLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgdHlwZTogJ3BvbGFyJyxcbiAgICAgICAgaXNQb2xhcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gUG9sYXIoY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbGFyKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFBvbGFyKS5jYWxsKHRoaXMsIGNmZykpO1xuXG4gICAgX3RoaXMuX2luaXQoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2xhciwgW3tcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgICB2YXIgaW5uZXJSYWRpdXMgPSB0aGlzLmlubmVyUmFkaXVzO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0QW5nbGU7XG4gICAgICB2YXIgZW5kQW5nbGUgPSB0aGlzLmVuZEFuZ2xlO1xuXG4gICAgICB3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG4gICAgICAgIGVuZEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICB2YXIgb25lQm94ID0gdGhpcy5nZXRPbmVCb3goKTtcbiAgICAgIHZhciBvbmVXaWR0aCA9IG9uZUJveC5tYXhYIC0gb25lQm94Lm1pblg7XG4gICAgICB2YXIgb25lSGVpZ2h0ID0gb25lQm94Lm1heFkgLSBvbmVCb3gubWluWTtcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5hYnMob25lQm94Lm1pblgpIC8gb25lV2lkdGg7XG4gICAgICB2YXIgdG9wID0gTWF0aC5hYnMob25lQm94Lm1pblkpIC8gb25lSGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIHZhciBtYXhSYWRpdXM7XG4gICAgICB2YXIgY2lyY2xlQ2VudHJlO1xuXG4gICAgICBpZiAoaGVpZ2h0IC8gb25lSGVpZ2h0ID4gd2lkdGggLyBvbmVXaWR0aCkge1xuICAgICAgICAvLyB3aWR0aOS4uuS4u1xuICAgICAgICBtYXhSYWRpdXMgPSB3aWR0aCAvIG9uZVdpZHRoO1xuICAgICAgICBjaXJjbGVDZW50cmUgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggLSAoMC41IC0gbGVmdCkgKiB3aWR0aCxcbiAgICAgICAgICB5OiBjZW50ZXIueSAtICgwLjUgLSB0b3ApICogbWF4UmFkaXVzICogb25lSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWlnaHTkuLrkuLtcbiAgICAgICAgbWF4UmFkaXVzID0gaGVpZ2h0IC8gb25lSGVpZ2h0O1xuICAgICAgICBjaXJjbGVDZW50cmUgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggLSAoMC41IC0gbGVmdCkgKiBtYXhSYWRpdXMgKiBvbmVXaWR0aCxcbiAgICAgICAgICB5OiBjZW50ZXIueSAtICgwLjUgLSB0b3ApICogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghcmFkaXVzKSB7XG4gICAgICAgIHJhZGl1cyA9IG1heFJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAocmFkaXVzID4gMCAmJiByYWRpdXMgPD0gMSkge1xuICAgICAgICByYWRpdXMgPSBtYXhSYWRpdXMgKiByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl1cyA8PSAwIHx8IHJhZGl1cyA+IG1heFJhZGl1cykge1xuICAgICAgICByYWRpdXMgPSBtYXhSYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0ge1xuICAgICAgICBzdGFydDogc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kOiBlbmRBbmdsZVxuICAgICAgfTtcbiAgICAgIHZhciB5ID0ge1xuICAgICAgICBzdGFydDogaW5uZXJSYWRpdXMgKiByYWRpdXMsXG4gICAgICAgIGVuZDogcmFkaXVzXG4gICAgICB9O1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIHRoaXMuY2lyY2xlQ2VudHJlID0gY2lyY2xlQ2VudHJlO1xuICAgICAgdGhpcy5jZW50ZXIgPSBjaXJjbGVDZW50cmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZW50ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaXJjbGVDZW50cmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9uZUJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPbmVCb3goKSB7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHRoaXMuZW5kQW5nbGU7XG5cbiAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID49IE1hdGguUEkgKiAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluWDogLTEsXG4gICAgICAgICAgbWF4WDogMSxcbiAgICAgICAgICBtaW5ZOiAtMSxcbiAgICAgICAgICBtYXhZOiAxXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB4cyA9IFswLCBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgTWF0aC5jb3MoZW5kQW5nbGUpXTtcbiAgICAgIHZhciB5cyA9IFswLCBNYXRoLnNpbihzdGFydEFuZ2xlKSwgTWF0aC5zaW4oZW5kQW5nbGUpXTtcblxuICAgICAgZm9yICh2YXIgaSA9IE1hdGgubWluKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTsgaSA8IE1hdGgubWF4KHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTsgaSArPSBNYXRoLlBJIC8gMTgpIHtcbiAgICAgICAgeHMucHVzaChNYXRoLmNvcyhpKSk7XG4gICAgICAgIHlzLnB1c2goTWF0aC5zaW4oaSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4cyksXG4gICAgICAgIG1heFg6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHhzKSxcbiAgICAgICAgbWluWTogTWF0aC5taW4uYXBwbHkoTWF0aCwgeXMpLFxuICAgICAgICBtYXhZOiBNYXRoLm1heC5hcHBseShNYXRoLCB5cylcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYWRpdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuICAgICAgdmFyIHggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHBvaW50LnkgOiBwb2ludC54O1xuICAgICAgdmFyIHkgPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHBvaW50LnggOiBwb2ludC55O1xuICAgICAgeCA9IHRoaXMuY29udmVydERpbSh4LCAneCcpO1xuICAgICAgeSA9IHRoaXMuY29udmVydERpbSh5LCAneScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBNYXRoLmNvcyh4KSAqIHksXG4gICAgICAgIHk6IGNlbnRlci55ICsgTWF0aC5zaW4oeCkgKiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnRQb2ludChwb2ludCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgICB2YXIgdlBvaW50ID0gW3BvaW50LnggLSBjZW50ZXIueCwgcG9pbnQueSAtIGNlbnRlci55XTtcbiAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgdmFyIG0gPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG4gICAgICBtYXQzLnJvdGF0ZShtLCBtLCB4LnN0YXJ0KTtcbiAgICAgIHZhciB2U3RhcnQgPSBbMSwgMCwgMF07XG4gICAgICB2ZWMzLnRyYW5zZm9ybU1hdDModlN0YXJ0LCB2U3RhcnQsIG0pO1xuICAgICAgdlN0YXJ0ID0gW3ZTdGFydFswXSwgdlN0YXJ0WzFdXTtcbiAgICAgIHZhciBhbmdsZSA9IHZlYzIuYW5nbGVUbyh2U3RhcnQsIHZQb2ludCwgeC5lbmQgPCB4LnN0YXJ0KTtcblxuICAgICAgaWYgKGlzTnVtYmVyRXF1YWwoYW5nbGUsIE1hdGguUEkgKiAyKSkge1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByYWRpdXMgPSB2ZWMyLmxlbmd0aCh2UG9pbnQpO1xuICAgICAgdmFyIHhQZXJjZW50ID0gYW5nbGUgLyAoeC5lbmQgLSB4LnN0YXJ0KTtcbiAgICAgIHhQZXJjZW50ID0geC5lbmQgLSB4LnN0YXJ0ID4gMCA/IHhQZXJjZW50IDogLXhQZXJjZW50O1xuICAgICAgdmFyIHlQZXJjZW50ID0gdGhpcy5pbnZlcnREaW0ocmFkaXVzLCAneScpO1xuICAgICAgdmFyIHJzdCA9IHt9O1xuICAgICAgcnN0LnggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHlQZXJjZW50IDogeFBlcmNlbnQ7XG4gICAgICByc3QueSA9IHRoaXMuaXNUcmFuc3Bvc2VkID8geFBlcmNlbnQgOiB5UGVyY2VudDtcbiAgICAgIHJldHVybiByc3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbGFyO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xhcjtcblxuLyoqKi8gfSksXG4vKiAzNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHRoZSBjbGFzcyBvZiBIZWxpeCBDb29yZGluYXRlXG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xuXG5cbnZhciBNYXRyaXhVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbnZhciBpc051bWJlckVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG52YXIgdmVjMiA9IE1hdHJpeFV0aWwudmVjMjtcblxudmFyIEhlbGl4ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHMoSGVsaXgsIF9CYXNlKTtcblxuICBfY3JlYXRlQ2xhc3MoSGVsaXgsIFt7XG4gICAga2V5OiBcImdldERlZmF1bHRDZmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICAgIHZhciBjZmcgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihIZWxpeC5wcm90b3R5cGUpLCBcImdldERlZmF1bHRDZmdcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIG1peCh7fSwgY2ZnLCB7XG4gICAgICAgIHN0YXJ0QW5nbGU6IDEuMjUgKiBNYXRoLlBJLFxuICAgICAgICBlbmRBbmdsZTogNy4yNSAqIE1hdGguUEksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICB0eXBlOiAnaGVsaXgnLFxuICAgICAgICBpc0hlbGl4OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBIZWxpeChjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVsaXgpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSGVsaXgpLmNhbGwodGhpcywgY2ZnKSk7XG5cbiAgICBfdGhpcy5faW5pdCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhlbGl4LCBbe1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgICB2YXIgaW5uZXJSYWRpdXMgPSB0aGlzLmlubmVyUmFkaXVzO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0QW5nbGU7XG4gICAgICB2YXIgZW5kQW5nbGUgPSB0aGlzLmVuZEFuZ2xlO1xuICAgICAgdmFyIGluZGV4ID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpICsgMTsgLy8g6J6657q/5ZyI5pWwXG5cbiAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG5cbiAgICAgIGlmIChyYWRpdXMgJiYgcmFkaXVzID49IDAgJiYgcmFkaXVzIDw9IDEpIHtcbiAgICAgICAgbWF4UmFkaXVzID0gbWF4UmFkaXVzICogcmFkaXVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IE1hdGguZmxvb3IobWF4UmFkaXVzICogKDEgLSBpbm5lclJhZGl1cykgLyBpbmRleCk7XG4gICAgICB2YXIgYSA9IGQgLyAoTWF0aC5QSSAqIDIpOyAvLyDonrrnur/ns7vmlbBcblxuICAgICAgdmFyIHggPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydEFuZ2xlLFxuICAgICAgICBlbmQ6IGVuZEFuZ2xlXG4gICAgICB9O1xuICAgICAgdmFyIHkgPSB7XG4gICAgICAgIHN0YXJ0OiBpbm5lclJhZGl1cyAqIG1heFJhZGl1cyxcbiAgICAgICAgZW5kOiBpbm5lclJhZGl1cyAqIG1heFJhZGl1cyArIGQgKiAwLjk5XG4gICAgICB9O1xuICAgICAgdGhpcy5hID0gYTtcbiAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNlbnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bCG55m+5YiG5q+U5pWw5o2u5Y+Y5oiQ5bGP5bmV5Z2Q5qCHXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDlvZLkuIDljJbnmoTngrnlnZDmoIdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIOi/lOWbnuWvueW6lOeahOWxj+W5leWdkOagh1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciB5O1xuXG4gICAgICBpZiAodGhpcy5pc1RyYW5zcG9zZWQpIHtcbiAgICAgICAgeCA9IHBvaW50Lnk7XG4gICAgICAgIHkgPSBwb2ludC54O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHBvaW50Lng7XG4gICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhpID0gdGhpcy5jb252ZXJ0RGltKHgsICd4Jyk7XG4gICAgICB2YXIgciA9IGEgKiB0aGk7XG4gICAgICB2YXIgbmV3WSA9IHRoaXMuY29udmVydERpbSh5LCAneScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBNYXRoLmNvcyh0aGkpICogKHIgKyBuZXdZKSxcbiAgICAgICAgeTogY2VudGVyLnkgKyBNYXRoLnNpbih0aGkpICogKHIgKyBuZXdZKVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5bCG5bGP5bmV5Z2Q5qCH54K56L+Y5Y6f5oiQ55m+5YiG5q+U5pWw5o2uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCDlsY/luZXlnZDmoIdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIOi/lOWbnuWvueW6lOeahOW9kuS4gOWMluWQjueahOaVsOaNrlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgdmFyIGQgPSB0aGlzLmQgKyB0aGlzLnkuc3RhcnQ7XG4gICAgICB2YXIgdiA9IHZlYzIuc3VidHJhY3QoW10sIFtwb2ludC54LCBwb2ludC55XSwgW2NlbnRlci54LCBjZW50ZXIueV0pO1xuICAgICAgdmFyIHRoaSA9IHZlYzIuYW5nbGVUbyh2LCBbMSwgMF0sIHRydWUpO1xuICAgICAgdmFyIHJNaW4gPSB0aGkgKiBhOyAvLyDlnZDmoIfkuI7ljp/ngrnnmoTov57nur/lnKjnrKzkuIDlnIjkuIrnmoTkuqTngrnvvIzmnIDlsI9y5YC8XG5cbiAgICAgIGlmICh2ZWMyLmxlbmd0aCh2KSA8IHJNaW4pIHtcbiAgICAgICAgLy8g5Z2Q5qCH5LiO5Y6f54K555qE6L+e57q/5LiN5Y+v6IO95bCP5LqO5pyA5bCPcuWAvO+8jOS9huS4jeaOkumZpOWboOWwj+aVsOiuoeeul+S6p+eUn+eahOeVpeWwj+S6jnJNaW7nmoTmg4XlhrVcbiAgICAgICAgck1pbiA9IHZlYzIubGVuZ3RoKHYpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKCh2ZWMyLmxlbmd0aCh2KSAtIHJNaW4pIC8gZCk7IC8vIOW9k+WJjeeCueS9jeS6juesrGluZGV45ZyIXG5cbiAgICAgIHRoaSA9IDIgKiBpbmRleCAqIE1hdGguUEkgKyB0aGk7XG4gICAgICB2YXIgciA9IGEgKiB0aGk7XG4gICAgICB2YXIgbmV3WSA9IHZlYzIubGVuZ3RoKHYpIC0gcjtcbiAgICAgIG5ld1kgPSBpc051bWJlckVxdWFsKG5ld1ksIDApID8gMCA6IG5ld1k7XG4gICAgICB2YXIgeCA9IHRoaXMuaW52ZXJ0RGltKHRoaSwgJ3gnKTtcbiAgICAgIHZhciB5ID0gdGhpcy5pbnZlcnREaW0obmV3WSwgJ3knKTtcbiAgICAgIHggPSBpc051bWJlckVxdWFsKHgsIDApID8gMCA6IHg7XG4gICAgICB5ID0gaXNOdW1iZXJFcXVhbCh5LCAwKSA/IDAgOiB5O1xuICAgICAgdmFyIHJzdCA9IHt9O1xuICAgICAgcnN0LnggPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHkgOiB4O1xuICAgICAgcnN0LnkgPSB0aGlzLmlzVHJhbnNwb3NlZCA/IHggOiB5O1xuICAgICAgcmV0dXJuIHJzdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGVsaXg7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlbGl4O1xuXG4vKioqLyB9KSxcbi8qIDM0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGNvbnRyb2xsZXIgb2YgYXhpc1xuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSksXG4gICAgQXhpcyA9IF9yZXF1aXJlLkF4aXM7XG5cbnZhciB2ZWMyID0gVXRpbC5NYXRyaXhVdGlsLnZlYzI7XG5cbmZ1bmN0aW9uIGZvcm1hdFRpY2tzKHRpY2tzKSB7XG4gIHZhciB0bXAgPSBbXTtcblxuICBpZiAodGlja3MubGVuZ3RoID4gMCkge1xuICAgIHRtcCA9IHRpY2tzLnNsaWNlKDApO1xuICAgIHZhciBmaXJzdCA9IHRtcFswXTtcbiAgICB2YXIgbGFzdCA9IHRtcFt0bXAubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZmlyc3QudmFsdWUgIT09IDApIHtcbiAgICAgIHRtcC51bnNoaWZ0KHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsYXN0LnZhbHVlICE9PSAxKSB7XG4gICAgICB0bXAucHVzaCh7XG4gICAgICAgIHZhbHVlOiAxXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG1wO1xufVxuXG5mdW5jdGlvbiBmaWxsQXhpc1RpY2tzKHRpY2tzLCBpc0xpbmVhciwgZ3JpZENlbnRlcmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICh0aWNrcy5sZW5ndGggPCAxKSByZXR1cm4gcmVzdWx0O1xuXG4gIGlmICh0aWNrcy5sZW5ndGggPj0gMiAmJiBpc0xpbmVhciAmJiBncmlkQ2VudGVyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgdGV4dDogJycsXG4gICAgICB0aWNrVmFsdWU6ICcnLFxuICAgICAgdmFsdWU6IDBcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aWNrc1swXS52YWx1ZSAhPT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHRleHQ6ICcnLFxuICAgICAgdGlja1ZhbHVlOiAnJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSk7XG4gIH1cblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRpY2tzKTtcblxuICBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS52YWx1ZSAhPT0gMSkge1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHRleHQ6ICcnLFxuICAgICAgdGlja1ZhbHVlOiAnJyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVGcm9tUG9zaXRpb24ocG9zaXRpb24sIHZhbCkge1xuICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICB2YWwgPSAwO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uID09PSAnbWlkZGxlJykge1xuICAgIHZhbCA9IDAuNTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbi5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgdmFsID0gcGFyc2VJbnQocG9zaXRpb24sIDEwKSAvIDEwMDtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBBeGlzQ29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXNDb250cm9sbGVyKGNmZykge1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmNvb3JkID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIFV0aWwubWl4KHRoaXMsIGNmZyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXhpc0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5faXNIaWRlID0gZnVuY3Rpb24gX2lzSGlkZShmaWVsZCkge1xuICAgIC8vIOWvueW6lOeahOWdkOagh+i9tOaYr+WQpumakOiXj1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1tmaWVsZF0gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRNaWRkbGVWYWx1ZSA9IGZ1bmN0aW9uIF9nZXRNaWRkbGVWYWx1ZShjdXJWYWx1ZSwgdGlja3MsIGluZGV4LCBpc0xpbmVhcikge1xuICAgIGlmIChjdXJWYWx1ZSA9PT0gMCAmJiAhaXNMaW5lYXIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChjdXJWYWx1ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIG5leHRWYWx1ZSA9IHRpY2tzW2luZGV4ICsgMV0udmFsdWU7XG5cbiAgICBpZiAoIWlzTGluZWFyICYmIG5leHRWYWx1ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIChjdXJWYWx1ZSArIG5leHRWYWx1ZSkgLyAyO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0TGluZVJhbmdlID0gZnVuY3Rpb24gX2dldExpbmVSYW5nZShjb29yZCwgc2NhbGUsIGRpbVR5cGUsIGluZGV4KSB7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGlzVmVydGljYWw7XG4gICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHBvc2l0aW9uID0gJyc7XG5cbiAgICBpZiAob3B0aW9uc1tmaWVsZF0gJiYgb3B0aW9uc1tmaWVsZF0ucG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gb3B0aW9uc1tmaWVsZF0ucG9zaXRpb247XG4gICAgfSAvLyBUT0RPIG1pZGRsZSAmIHBlcmNlbnRhZ2UgZm9yIHBvc2l0aW9uXG5cblxuICAgIGlmIChkaW1UeXBlID09PSAneCcpIHtcbiAgICAgIC8vIHjovbTnmoTlnZDmoIfovbQs5bqV6YOo55qE5qiq5Z2Q5qCHXG4gICAgICB2YXIgeSA9IHBvc2l0aW9uID09PSAndG9wJyA/IDEgOiAwO1xuICAgICAgeSA9IGdldERlZmF1bHRWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgeSk7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICAgIGlzVmVydGljYWwgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8geei9tOWdkOagh+i9tFxuICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgIC8vIOWkmui9tOeahOaDheWGtVxuICAgICAgICB2YXIgeCA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAwIDogMTtcbiAgICAgICAgeCA9IGdldERlZmF1bHRWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgeCk7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiAxXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDljZXkuKp56L2077yM5oiW6ICF56ys5LiA5Liqeei9tFxuICAgICAgICB2YXIgX3ggPSBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IDEgOiAwO1xuXG4gICAgICAgIF94ID0gZ2V0RGVmYXVsdFZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uLCBfeCk7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIHg6IF94LFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgZW5kID0ge1xuICAgICAgICAgIHg6IF94LFxuICAgICAgICAgIHk6IDFcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaXNWZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgc3RhcnQgPSBjb29yZC5jb252ZXJ0KHN0YXJ0KTtcbiAgICBlbmQgPSBjb29yZC5jb252ZXJ0KGVuZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRMaW5lQ2ZnID0gZnVuY3Rpb24gX2dldExpbmVDZmcoY29vcmQsIHNjYWxlLCBkaW1UeXBlLCBpbmRleCkge1xuICAgIHZhciBmYWN0b3I7XG5cbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9nZXRMaW5lUmFuZ2UoY29vcmQsIHNjYWxlLCBkaW1UeXBlLCBpbmRleCk7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IHJhbmdlLmlzVmVydGljYWw7IC8vIOagh+ivhuivpeWdkOagh+i9tOaYr+WQpuaYr+e6teWdkOagh1xuXG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB2YXIgY2VudGVyID0gY29vcmQuY2VudGVyO1xuXG4gICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgaXNWZXJ0aWNhbCA9ICFpc1ZlcnRpY2FsO1xuICAgIH1cblxuICAgIGlmIChpc1ZlcnRpY2FsICYmIHN0YXJ0LnggPiBjZW50ZXIueCB8fCAhaXNWZXJ0aWNhbCAmJiBzdGFydC55ID4gY2VudGVyLnkpIHtcbiAgICAgIGZhY3RvciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhY3RvciA9IC0xO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1ZlcnRpY2FsOiBpc1ZlcnRpY2FsLFxuICAgICAgZmFjdG9yOiBmYWN0b3IsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gIH07IC8vIOiOt+WPluWchuW8p+WdkOagh+i9tOmFjee9rumhueS/oeaBr1xuXG5cbiAgX3Byb3RvLl9nZXRDaXJjbGVDZmcgPSBmdW5jdGlvbiBfZ2V0Q2lyY2xlQ2ZnKGNvb3JkKSB7XG4gICAgdmFyIGNpcmNsZUNmZyA9IHt9O1xuICAgIHZhciByYW5nZVggPSBjb29yZC54O1xuICAgIHZhciByYW5nZVkgPSBjb29yZC55O1xuICAgIHZhciBpc1JlZmxlY3RZID0gcmFuZ2VZLnN0YXJ0ID4gcmFuZ2VZLmVuZDtcbiAgICB2YXIgc3RhcnQ7XG5cbiAgICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgeDogaXNSZWZsZWN0WSA/IDAgOiAxLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogaXNSZWZsZWN0WSA/IDAgOiAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHN0YXJ0ID0gY29vcmQuY29udmVydChzdGFydCk7XG4gICAgdmFyIGNlbnRlciA9IGNvb3JkLmNpcmNsZUNlbnRyZTtcbiAgICB2YXIgc3RhcnRWZWN0b3IgPSBbc3RhcnQueCAtIGNlbnRlci54LCBzdGFydC55IC0gY2VudGVyLnldO1xuICAgIHZhciBub3JtYWxWZWN0b3IgPSBbMSwgMF07XG4gICAgdmFyIHN0YXJ0QW5nbGU7XG5cbiAgICBpZiAoc3RhcnQueSA+IGNlbnRlci55KSB7XG4gICAgICBzdGFydEFuZ2xlID0gdmVjMi5hbmdsZShzdGFydFZlY3Rvciwgbm9ybWFsVmVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRBbmdsZSA9IHZlYzIuYW5nbGUoc3RhcnRWZWN0b3IsIG5vcm1hbFZlY3RvcikgKiAtMTtcbiAgICB9XG5cbiAgICB2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKHJhbmdlWC5lbmQgLSByYW5nZVguc3RhcnQpO1xuICAgIGNpcmNsZUNmZy5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICBjaXJjbGVDZmcuZW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICBjaXJjbGVDZmcuY2VudGVyID0gY2VudGVyO1xuICAgIGNpcmNsZUNmZy5yYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3coc3RhcnQueCAtIGNlbnRlci54LCAyKSArIE1hdGgucG93KHN0YXJ0LnkgLSBjZW50ZXIueSwgMikpO1xuICAgIGNpcmNsZUNmZy5pbm5lciA9IGNvb3JkLmlubmVyUmFkaXVzIHx8IDA7XG4gICAgcmV0dXJuIGNpcmNsZUNmZztcbiAgfTtcblxuICBfcHJvdG8uX2dldFJhZGl1c0NmZyA9IGZ1bmN0aW9uIF9nZXRSYWRpdXNDZmcoY29vcmQpIHtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IGNvb3JkLnguc3RhcnQ7XG4gICAgdmFyIGZhY3RvciA9IHN0YXJ0QW5nbGUgPCAwID8gLTEgOiAxO1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgZW5kO1xuXG4gICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmYWN0b3I6IGZhY3RvcixcbiAgICAgIHN0YXJ0OiBjb29yZC5jb252ZXJ0KHN0YXJ0KSxcbiAgICAgIGVuZDogY29vcmQuY29udmVydChlbmQpXG4gICAgfTtcbiAgfTsgLy8g56Gu5a6a5Z2Q5qCH6L2055qE5L2N572uXG5cblxuICBfcHJvdG8uX2dldEF4aXNQb3NpdGlvbiA9IGZ1bmN0aW9uIF9nZXRBeGlzUG9zaXRpb24oY29vcmQsIGRpbVR5cGUsIGluZGV4LCBmaWVsZCkge1xuICAgIHZhciBwb3NpdGlvbiA9ICcnOyAvLyDnlKjmiLfoh6rlt7HlrprkuYnkuoYgcG9zaXRpb25cblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBjb25zdCBWQUxJRF9QT1NJVElPTlMgPSBbXG4gICAgLy8gICAndG9wJyxcbiAgICAvLyAgICdsZWZ0JyxcbiAgICAvLyAgICdyaWdodCcsXG4gICAgLy8gICAnYm90dG9tJ1xuICAgIC8vIF07XG5cbiAgICBpZiAob3B0aW9uc1tmaWVsZF0gJiYgb3B0aW9uc1tmaWVsZF0ucG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gb3B0aW9uc1tmaWVsZF0ucG9zaXRpb247IC8vIGlmIChWQUxJRF9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPiAtMSkge1xuICAgICAgLy8gICByZXR1cm4gcG9zaXRpb247XG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb29yZFR5cGUgPSBjb29yZC50eXBlO1xuXG4gICAgICBpZiAoY29vcmQuaXNSZWN0KSB7XG4gICAgICAgIGlmIChkaW1UeXBlID09PSAneCcpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9ICdib3R0b20nO1xuICAgICAgICB9IGVsc2UgaWYgKGRpbVR5cGUgPT09ICd5Jykge1xuICAgICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29vcmRUeXBlID09PSAnaGVsaXgnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gJ2hlbGl4JztcbiAgICAgIH0gZWxzZSBpZiAoZGltVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gY29vcmQuaXNUcmFuc3Bvc2VkID8gJ3JhZGl1cycgOiAnY2lyY2xlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc2l0aW9uID0gY29vcmQuaXNUcmFuc3Bvc2VkID8gJ2NpcmNsZScgOiAncmFkaXVzJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07IC8vIOiOt+WPluWdkOagh+i9tOaehOaIkOeahOmFjee9ruS/oeaBr1xuXG5cbiAgX3Byb3RvLl9nZXRBeGlzRGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9nZXRBeGlzRGVmYXVsdENmZyhjb29yZCwgc2NhbGUsIHR5cGUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLnZpZXdUaGVtZTtcbiAgICB2YXIgY2ZnID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgY2ZnID0gVXRpbC5kZWVwTWl4KHt9LCB2aWV3VGhlbWUuYXhpc1twb3NpdGlvbl0sIGNmZywgb3B0aW9uc1tmaWVsZF0pO1xuICAgIGNmZy52aWV3VGhlbWUgPSB2aWV3VGhlbWU7XG5cbiAgICBpZiAoY2ZnLnRpdGxlKSB7XG4gICAgICB2YXIgdGl0bGUgPSBVdGlsLmlzUGxhaW5PYmplY3QoY2ZnLnRpdGxlKSA/IGNmZy50aXRsZSA6IHt9O1xuICAgICAgdGl0bGUudGV4dCA9IHRpdGxlLnRleHQgfHwgc2NhbGUuYWxpYXMgfHwgZmllbGQ7XG4gICAgICBVdGlsLmRlZXBNaXgoY2ZnLCB7XG4gICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2ZnLnRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcblxuICAgIGlmIChjb29yZC5pc1BvbGFyICYmICFzY2FsZS5pc0NhdGVnb3J5KSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3gnICYmIE1hdGguYWJzKGNvb3JkLmVuZEFuZ2xlIC0gY29vcmQuc3RhcnRBbmdsZSkgPT09IE1hdGguUEkgKiAyKSB7XG4gICAgICAgIGNmZy50aWNrcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZmcuY29vcmQgPSBjb29yZDtcblxuICAgIGlmIChjZmcubGFiZWwgJiYgVXRpbC5pc05pbChjZmcubGFiZWwuYXV0b1JvdGF0ZSkpIHtcbiAgICAgIGNmZy5sYWJlbC5hdXRvUm90YXRlID0gdHJ1ZTsgLy8g5YWB6K646Ieq5Yqo5peL6L2s77yM6YG/5YWN6YeN5Y+gXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3hGaWVsZCcpICYmIG9wdGlvbnMueEZpZWxkLmhhc093blByb3BlcnR5KCdncmlkJykpIHtcbiAgICAgIGlmIChjZmcucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICBVdGlsLmRlZXBNaXgoY2ZnLCBvcHRpb25zLnhGaWVsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNmZztcbiAgfTsgLy8g56Gu5a6a5Z2Q5qCH6L2055qE6YWN572u5L+h5oGvXG5cblxuICBfcHJvdG8uX2dldEF4aXNDZmcgPSBmdW5jdGlvbiBfZ2V0QXhpc0NmZyhjb29yZCwgc2NhbGUsIHZlcnRpY2FsU2NhbGUsIGRpbVR5cGUsIGluZGV4LCB2aWV3SWQpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgaW5kZXggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBzZWxmLl9nZXRBeGlzUG9zaXRpb24oY29vcmQsIGRpbVR5cGUsIGluZGV4LCBzY2FsZS5maWVsZCk7XG5cbiAgICB2YXIgY2ZnID0gc2VsZi5fZ2V0QXhpc0RlZmF1bHRDZmcoY29vcmQsIHNjYWxlLCBkaW1UeXBlLCBwb3NpdGlvbik7XG5cbiAgICBpZiAoIVV0aWwuaXNFbXB0eShjZmcuZ3JpZCkgJiYgdmVydGljYWxTY2FsZSkge1xuICAgICAgLy8g55Sf5oiQIGdyaWRQb2ludHNcbiAgICAgIHZhciBncmlkUG9pbnRzID0gW107XG4gICAgICB2YXIgdGlja1ZhbHVlcyA9IFtdO1xuICAgICAgdmFyIHZlcnRpY2FsVGlja3MgPSBmb3JtYXRUaWNrcyh2ZXJ0aWNhbFNjYWxlLmdldFRpY2tzKCkpOyAvLyDmsqHmnInlnoLnm7TnmoTlnZDmoIfngrnml7bkuI3kvJrlj6rmoIXmoLxcblxuICAgICAgaWYgKHZlcnRpY2FsVGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0aWNrcyA9IGZpbGxBeGlzVGlja3MoY2ZnLnRpY2tzLCBzY2FsZS5pc0xpbmVhciwgY2ZnLmdyaWQuYWxpZ24gPT09ICdjZW50ZXInKTtcbiAgICAgICAgVXRpbC5lYWNoKHRpY2tzLCBmdW5jdGlvbiAodGljaywgaWR4KSB7XG4gICAgICAgICAgdGlja1ZhbHVlcy5wdXNoKHRpY2sudGlja1ZhbHVlKTtcbiAgICAgICAgICB2YXIgc3ViUG9pbnRzID0gW107XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGljay52YWx1ZTtcblxuICAgICAgICAgIGlmIChjZmcuZ3JpZC5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZi5fZ2V0TWlkZGxlVmFsdWUodmFsdWUsIHRpY2tzLCBpZHgsIHNjYWxlLmlzTGluZWFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIVV0aWwuaXNOaWwodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VYID0gY29vcmQueDtcbiAgICAgICAgICAgIHZhciByYW5nZVkgPSBjb29yZC55O1xuICAgICAgICAgICAgVXRpbC5lYWNoKHZlcnRpY2FsVGlja3MsIGZ1bmN0aW9uICh2ZXJ0aWNhbFRpY2spIHtcbiAgICAgICAgICAgICAgdmFyIHggPSBkaW1UeXBlID09PSAneCcgPyB2YWx1ZSA6IHZlcnRpY2FsVGljay52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHkgPSBkaW1UeXBlID09PSAneCcgPyB2ZXJ0aWNhbFRpY2sudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHBvaW50ID0gY29vcmQuY29udmVydCh7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IGNvb3JkLmNpcmNsZUNlbnRyZTtcblxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVkuc3RhcnQgPiByYW5nZVkuZW5kKSB7XG4gICAgICAgICAgICAgICAgICB5ID0gMSAtIHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9pbnQuZmxhZyA9IHJhbmdlWC5zdGFydCA+IHJhbmdlWC5lbmQgPyAwIDogMTtcbiAgICAgICAgICAgICAgICBwb2ludC5yYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnQueCAtIGNlbnRlci54LCAyKSArIE1hdGgucG93KHBvaW50LnkgLSBjZW50ZXIueSwgMikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3ViUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmlkUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICBfaWQ6IHZpZXdJZCArICctJyArIGRpbVR5cGUgKyBpbmRleCArICctZ3JpZC0nICsgdGljay50aWNrVmFsdWUsXG4gICAgICAgICAgICAgIHBvaW50czogc3ViUG9pbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjZmcuZ3JpZC5pdGVtcyA9IGdyaWRQb2ludHM7XG4gICAgICBjZmcuZ3JpZC50aWNrVmFsdWVzID0gdGlja1ZhbHVlcztcbiAgICB9XG5cbiAgICBjZmcudHlwZSA9IHNjYWxlLnR5cGU7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uX2dldEhlbGl4Q2ZnID0gZnVuY3Rpb24gX2dldEhlbGl4Q2ZnKGNvb3JkKSB7XG4gICAgdmFyIGhlbGl4Q2ZnID0ge307XG4gICAgdmFyIGEgPSBjb29yZC5hO1xuICAgIHZhciBzdGFydEFuZ2xlID0gY29vcmQuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcbiAgICB2YXIgaW5kZXggPSAxMDA7XG4gICAgdmFyIGNycCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gY29vcmQuY29udmVydCh7XG4gICAgICAgIHg6IGkgLyAxMDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuICAgICAgY3JwLnB1c2gocG9pbnQueCk7XG4gICAgICBjcnAucHVzaChwb2ludC55KTtcbiAgICB9XG5cbiAgICB2YXIgYXhpc1N0YXJ0ID0gY29vcmQuY29udmVydCh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0pO1xuICAgIGhlbGl4Q2ZnLmEgPSBhO1xuICAgIGhlbGl4Q2ZnLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIGhlbGl4Q2ZnLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgaGVsaXhDZmcuY3JwID0gY3JwO1xuICAgIGhlbGl4Q2ZnLmF4aXNTdGFydCA9IGF4aXNTdGFydDtcbiAgICBoZWxpeENmZy5jZW50ZXIgPSBjb29yZC5jZW50ZXI7XG4gICAgaGVsaXhDZmcuaW5uZXIgPSBjb29yZC55LnN0YXJ0OyAvLyDlhoXljYrlvoRcblxuICAgIHJldHVybiBoZWxpeENmZztcbiAgfTtcblxuICBfcHJvdG8uX2RyYXdBeGlzID0gZnVuY3Rpb24gX2RyYXdBeGlzKGNvb3JkLCBzY2FsZSwgdmVydGljYWxTY2FsZSwgZGltVHlwZSwgdmlld0lkLCB4QXhpcywgaW5kZXgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIHZhciBDOyAvLyDlnZDmoIfovbTnsbtcblxuICAgIHZhciBhcHBlbmRDZmc7IC8vIOavj+S4quWdkOagh+i9tCBzdGFydCBlbmQg562J57uY5Yi26L6555WM55qE5L+h5oGvXG5cbiAgICBpZiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbicpIHtcbiAgICAgIEMgPSBBeGlzLkxpbmU7XG4gICAgICBhcHBlbmRDZmcgPSB0aGlzLl9nZXRMaW5lQ2ZnKGNvb3JkLCBzY2FsZSwgZGltVHlwZSwgaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoY29vcmQudHlwZSA9PT0gJ2hlbGl4JyAmJiBkaW1UeXBlID09PSAneCcpIHtcbiAgICAgIEMgPSBBeGlzLkhlbGl4O1xuICAgICAgYXBwZW5kQ2ZnID0gdGhpcy5fZ2V0SGVsaXhDZmcoY29vcmQpO1xuICAgIH0gZWxzZSBpZiAoZGltVHlwZSA9PT0gJ3gnKSB7XG4gICAgICBDID0gQXhpcy5DaXJjbGU7XG4gICAgICBhcHBlbmRDZmcgPSB0aGlzLl9nZXRDaXJjbGVDZmcoY29vcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDID0gQXhpcy5MaW5lO1xuICAgICAgYXBwZW5kQ2ZnID0gdGhpcy5fZ2V0UmFkaXVzQ2ZnKGNvb3JkKTtcbiAgICB9XG5cbiAgICB2YXIgY2ZnID0gdGhpcy5fZ2V0QXhpc0NmZyhjb29yZCwgc2NhbGUsIHZlcnRpY2FsU2NhbGUsIGRpbVR5cGUsIGluZGV4LCB2aWV3SWQpO1xuXG4gICAgY2ZnID0gVXRpbC5taXgoe30sIGNmZywgYXBwZW5kQ2ZnKTtcblxuICAgIGlmIChkaW1UeXBlID09PSAneScgJiYgeEF4aXMgJiYgeEF4aXMuZ2V0KCd0eXBlJykgPT09ICdjaXJjbGUnKSB7XG4gICAgICBjZmcuY2lyY2xlID0geEF4aXM7XG4gICAgfVxuXG4gICAgY2ZnLl9pZCA9IHZpZXdJZCArICctJyArIGRpbVR5cGU7XG5cbiAgICBpZiAoIVV0aWwuaXNOaWwoaW5kZXgpKSB7XG4gICAgICBjZmcuX2lkID0gdmlld0lkICsgJy0nICsgZGltVHlwZSArIGluZGV4O1xuICAgIH1cblxuICAgIFV0aWwubWl4KGNmZywge1xuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBncm91cDogY29udGFpbmVyXG4gICAgfSk7XG4gICAgdmFyIGF4aXMgPSBuZXcgQyhjZmcpO1xuICAgIGF4aXMucmVuZGVyKCk7XG4gICAgdGhpcy5heGVzLnB1c2goYXhpcyk7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZUF4aXMgPSBmdW5jdGlvbiBjcmVhdGVBeGlzKHhTY2FsZSwgeVNjYWxlcywgdmlld0lkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZCA9IHRoaXMuY29vcmQ7XG4gICAgdmFyIGNvb3JkVHlwZSA9IGNvb3JkLnR5cGU7IC8vIHRoZXRh5Z2Q5qCH57O76buY6K6k5LiN57uY5Yi25Z2Q5qCH6L20XG5cbiAgICBpZiAoY29vcmRUeXBlICE9PSAndGhldGEnICYmICEoY29vcmRUeXBlID09PSAncG9sYXInICYmIGNvb3JkLmlzVHJhbnNwb3NlZCkpIHtcbiAgICAgIHZhciB4QXhpcztcblxuICAgICAgaWYgKHhTY2FsZSAmJiAhc2VsZi5faXNIaWRlKHhTY2FsZS5maWVsZCkpIHtcbiAgICAgICAgeEF4aXMgPSBzZWxmLl9kcmF3QXhpcyhjb29yZCwgeFNjYWxlLCB5U2NhbGVzWzBdLCAneCcsIHZpZXdJZCk7IC8vIOe7mOWItiB4IOi9tFxuICAgICAgfVxuXG4gICAgICBpZiAoIVV0aWwuaXNFbXB0eSh5U2NhbGVzKSAmJiBjb29yZFR5cGUgIT09ICdoZWxpeCcpIHtcbiAgICAgICAgVXRpbC5lYWNoKHlTY2FsZXMsIGZ1bmN0aW9uICh5U2NhbGUsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9pc0hpZGUoeVNjYWxlLmZpZWxkKSkge1xuICAgICAgICAgICAgc2VsZi5fZHJhd0F4aXMoY29vcmQsIHlTY2FsZSwgeFNjYWxlLCAneScsIHZpZXdJZCwgeEF4aXMsIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hhbmdlVmlzaWJsZSA9IGZ1bmN0aW9uIGNoYW5nZVZpc2libGUodmlzaWJsZSkge1xuICAgIHZhciBheGVzID0gdGhpcy5heGVzO1xuICAgIFV0aWwuZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgYXhpcy5zZXQoJ3Zpc2libGUnLCB2aXNpYmxlKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF4ZXMgPSBzZWxmLmF4ZXM7XG4gICAgVXRpbC5lYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICBheGlzLmNsZWFyKCk7XG4gICAgfSk7XG4gICAgc2VsZi5heGVzID0gW107XG4gIH07XG5cbiAgcmV0dXJuIEF4aXNDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNDb250cm9sbGVyO1xuXG4vKioqLyB9KSxcbi8qIDM0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHdWlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5KTtcblxudmFyIEd1aWRlQ29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEd1aWRlQ29udHJvbGxlcihjZmcpIHtcbiAgICB0aGlzLmd1aWRlcyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgIHRoaXMueFNjYWxlcyA9IG51bGw7XG4gICAgdGhpcy55U2NhbGVzID0gbnVsbDtcbiAgICB0aGlzLnZpZXcgPSBudWxsO1xuICAgIHRoaXMudmlld1RoZW1lID0gbnVsbDtcbiAgICB0aGlzLmZyb250R3JvdXAgPSBudWxsO1xuICAgIHRoaXMuYmFja0dyb3VwID0gbnVsbDtcbiAgICBVdGlsLm1peCh0aGlzLCBjZmcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEd1aWRlQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9jcmVhdEd1aWRlcyA9IGZ1bmN0aW9uIF9jcmVhdEd1aWRlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHhTY2FsZXMgPSB0aGlzLnhTY2FsZXM7XG4gICAgdmFyIHlTY2FsZXMgPSB0aGlzLnlTY2FsZXM7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHRoaXMudmlld1RoZW1lO1xuXG4gICAgaWYgKHRoaXMuYmFja0NvbnRhaW5lciAmJiB2aWV3KSB7XG4gICAgICB0aGlzLmJhY2tHcm91cCA9IHRoaXMuYmFja0NvbnRhaW5lci5hZGRHcm91cCh7XG4gICAgICAgIHZpZXdJZDogdmlldy5nZXQoJ19pZCcpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcm9udENvbnRhaW5lciAmJiB2aWV3KSB7XG4gICAgICB0aGlzLmZyb250R3JvdXAgPSB0aGlzLmZyb250Q29udGFpbmVyLmFkZEdyb3VwKHtcbiAgICAgICAgdmlld0lkOiB2aWV3LmdldCgnX2lkJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgdHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgdmFyIGNvbmZpZyA9IFV0aWwuZGVlcE1peCh7XG4gICAgICAgIHhTY2FsZXM6IHhTY2FsZXMsXG4gICAgICAgIHlTY2FsZXM6IHlTY2FsZXMsXG4gICAgICAgIHZpZXdUaGVtZTogdmlld1RoZW1lXG4gICAgICB9LCB2aWV3VGhlbWUgPyB2aWV3VGhlbWUuZ3VpZGVbdHlwZV0gOiB7fSwgb3B0aW9uKTtcbiAgICAgIHR5cGUgPSBVdGlsLnVwcGVyRmlyc3QodHlwZSk7XG4gICAgICB2YXIgZ3VpZGUgPSBuZXcgR3VpZGVbdHlwZV0oY29uZmlnKTtcbiAgICAgIHNlbGYuZ3VpZGVzLnB1c2goZ3VpZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmLmd1aWRlcztcbiAgfTtcblxuICBfcHJvdG8ubGluZSA9IGZ1bmN0aW9uIGxpbmUoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucHVzaChVdGlsLm1peCh7XG4gICAgICB0eXBlOiAnbGluZSdcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXJjID0gZnVuY3Rpb24gYXJjKGNmZykge1xuICAgIGlmIChjZmcgPT09IHZvaWQgMCkge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnB1c2goVXRpbC5taXgoe1xuICAgICAgdHlwZTogJ2FyYydcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucHVzaChVdGlsLm1peCh7XG4gICAgICB0eXBlOiAndGV4dCdcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5wdXNoKFV0aWwubWl4KHtcbiAgICAgIHR5cGU6ICdpbWFnZSdcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVnaW9uID0gZnVuY3Rpb24gcmVnaW9uKGNmZykge1xuICAgIGlmIChjZmcgPT09IHZvaWQgMCkge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnB1c2goVXRpbC5taXgoe1xuICAgICAgdHlwZTogJ3JlZ2lvbidcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVnaW9uRmlsdGVyID0gZnVuY3Rpb24gcmVnaW9uRmlsdGVyKGNmZykge1xuICAgIGlmIChjZmcgPT09IHZvaWQgMCkge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLnB1c2goVXRpbC5taXgoe1xuICAgICAgdHlwZTogJ3JlZ2lvbkZpbHRlcidcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZGF0YU1hcmtlciA9IGZ1bmN0aW9uIGRhdGFNYXJrZXIoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucHVzaChVdGlsLm1peCh7XG4gICAgICB0eXBlOiAnZGF0YU1hcmtlcidcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZGF0YVJlZ2lvbiA9IGZ1bmN0aW9uIGRhdGFSZWdpb24oY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucHVzaChVdGlsLm1peCh7XG4gICAgICB0eXBlOiAnZGF0YVJlZ2lvbidcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMucHVzaChVdGlsLm1peCh7XG4gICAgICB0eXBlOiAnaHRtbCdcbiAgICB9LCBjZmcpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi52aWV3O1xuICAgIHZhciB2aWV3RGF0YSA9IHZpZXcgJiYgdmlldy5nZXQoJ2RhdGEnKTtcblxuICAgIHZhciBndWlkZXMgPSBzZWxmLl9jcmVhdEd1aWRlcygpO1xuXG4gICAgVXRpbC5lYWNoKGd1aWRlcywgZnVuY3Rpb24gKGd1aWRlKSB7XG4gICAgICB2YXIgY29udGFpbmVyO1xuXG4gICAgICBpZiAoZ3VpZGUuZ2V0KCd0b3AnKSkge1xuICAgICAgICAvLyDpu5jorqQgZ3VpZGUg57uY5Yi25YiwIGJhY2tQbG9077yM55So5oi35Lmf5Y+v5Lul5aOw5piOIHRvcDogdHJ1Ze+8jOaYvuekuuWcqOacgOS4iuWxglxuICAgICAgICBjb250YWluZXIgPSBzZWxmLmZyb250R3JvdXAgfHwgc2VsZi5mcm9udENvbnRhaW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lciA9IHNlbGYuYmFja0dyb3VwIHx8IHNlbGYuYmFja0NvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgZ3VpZGUucmVuZGVyKGNvb3JkLCBjb250YWluZXIsIHZpZXdEYXRhLCB2aWV3KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmNoYW5nZVZpc2libGUgPSBmdW5jdGlvbiBjaGFuZ2VWaXNpYmxlKHZpc2libGUpIHtcbiAgICB2YXIgZ3VpZGVzID0gdGhpcy5ndWlkZXM7XG4gICAgVXRpbC5lYWNoKGd1aWRlcywgZnVuY3Rpb24gKGd1aWRlKSB7XG4gICAgICBndWlkZS5jaGFuZ2VWaXNpYmxlKHZpc2libGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBndWlkZXMgPSB0aGlzLmd1aWRlcztcbiAgICBVdGlsLmVhY2goZ3VpZGVzLCBmdW5jdGlvbiAoZ3VpZGUpIHtcbiAgICAgIGd1aWRlLmNsZWFyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ndWlkZXMgPSBbXTtcbiAgICB0aGlzLmJhY2tHcm91cCAmJiB0aGlzLmJhY2tHcm91cC5yZW1vdmUoKTtcbiAgICB0aGlzLmZyb250R3JvdXAgJiYgdGhpcy5mcm9udEdyb3VwLnJlbW92ZSgpO1xuICB9O1xuXG4gIHJldHVybiBHdWlkZUNvbnRyb2xsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3VpZGVDb250cm9sbGVyO1xuXG4vKioqLyB9KSxcbi8qIDM0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSxcbiAgICBHdWlkZSA9IF9yZXF1aXJlLkd1aWRlO1xuXG52YXIgUmVnaW9uRmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTApO1xuXG5HdWlkZS5SZWdpb25GaWx0ZXIgPSBSZWdpb25GaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEd1aWRlO1xuXG4vKioqLyB9KSxcbi8qIDM1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR3VpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSksXG4gICAgUGF0aCA9IF9yZXF1aXJlLlBhdGg7XG5cbnZhciBSZWdpb25GaWx0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZSkge1xuICBfaW5oZXJpdHNMb29zZShSZWdpb25GaWx0ZXIsIF9HdWlkZSk7XG5cbiAgZnVuY3Rpb24gUmVnaW9uRmlsdGVyKCkge1xuICAgIHJldHVybiBfR3VpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlZ2lvbkZpbHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR3VpZGUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICBuYW1lOiAncmVnaW9uRmlsdGVyJyxcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIHRvcDogdHJ1ZSxcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgZW5kOiBudWxsLFxuICAgICAgY29sb3I6IG51bGwsXG4gICAgICBhcHBseTogbnVsbCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkLCBncm91cCwgdmlld0RhdGEsIHZpZXcpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxheWVyID0gZ3JvdXAuYWRkR3JvdXAoKTtcbiAgICBsYXllci5uYW1lID0gJ2d1aWRlLXJlZ2lvbi1maWx0ZXInO1xuICAgIHZpZXcub25jZSgnYWZ0ZXJwYWludCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIDIwMTgtMDgtMDggYnkgYmx1ZS5sYiBwYWRkaW5n5Li6YXV0b+aXtu+8jOS8muWvvOiHtOmHjeaWsOe7mOWItuS4gOasoe+8jOi/meaXtuWAmWxheWVy5bey57uP6KKr6ZSA5q+B5LqGXG4gICAgICBpZiAobGF5ZXIuZ2V0KCdkZXN0cm95ZWQnKSkgcmV0dXJuO1xuXG4gICAgICBzZWxmLl9kcmF3U2hhcGVzKHZpZXcsIGxheWVyKTtcblxuICAgICAgdmFyIGNsaXAgPSBzZWxmLl9kcmF3Q2xpcChjb29yZCk7XG5cbiAgICAgIGxheWVyLmF0dHIoe1xuICAgICAgICBjbGlwOiBjbGlwXG4gICAgICB9KTtcbiAgICAgIHNlbGYuc2V0KCdjbGlwJywgY2xpcCk7XG4gICAgICBzZWxmLmdldCgnYXBwZW5kSW5mbycpICYmIGxheWVyLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHNlbGYuZ2V0KCdhcHBlbmRJbmZvJykpO1xuICAgICAgc2VsZi5zZXQoJ2VsJywgbGF5ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd1NoYXBlcyA9IGZ1bmN0aW9uIF9kcmF3U2hhcGVzKHZpZXcsIGxheWVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgZ2VvbXMgPSB2aWV3LmdldEFsbEdlb21zKCk7XG4gICAgZ2VvbXMubWFwKGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICB2YXIgc2hhcGVzID0gZ2VvbS5nZXRTaGFwZXMoKTtcbiAgICAgIHZhciBnZW9tVHlwZSA9IGdlb20uZ2V0KCd0eXBlJyk7XG5cbiAgICAgIHZhciBmaWx0ZXIgPSBzZWxmLl9nZW9tRmlsdGVyKGdlb21UeXBlKTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBzaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgIHZhciBzaGFwZVR5cGUgPSBzaGFwZS50eXBlOyAvLyBjb25zdCBzaGFwZUF0dHIgPSBVdGlsLm1peCh7fSwgc2hhcGUuYXR0cigpKTtcblxuICAgICAgICAgIHZhciBzaGFwZUF0dHIgPSBVdGlsLmNsb25lRGVlcChzaGFwZS5hdHRyKCkpO1xuXG4gICAgICAgICAgc2VsZi5fYWRqdXN0RGlzcGxheShzaGFwZUF0dHIpO1xuXG4gICAgICAgICAgdmFyIHMgPSBsYXllci5hZGRTaGFwZShzaGFwZVR5cGUsIHtcbiAgICAgICAgICAgIGF0dHJzOiBzaGFwZUF0dHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2VvbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIF9wcm90by5fZHJhd0NsaXAgPSBmdW5jdGlvbiBfZHJhd0NsaXAoY29vcmQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0YXJ0ID0gc2VsZi5wYXJzZVBvaW50KGNvb3JkLCBzZWxmLmdldCgnc3RhcnQnKSk7XG4gICAgdmFyIGVuZCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5nZXQoJ2VuZCcpKTtcbiAgICB2YXIgcGF0aCA9IFtbJ00nLCBzdGFydC54LCBzdGFydC55XSwgWydMJywgZW5kLngsIHN0YXJ0LnldLCBbJ0wnLCBlbmQueCwgZW5kLnldLCBbJ0wnLCBzdGFydC54LCBlbmQueV0sIFsneiddXTtcbiAgICB2YXIgY2xpcCA9IG5ldyBQYXRoKHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xpcDtcbiAgfTtcblxuICBfcHJvdG8uX2FkanVzdERpc3BsYXkgPSBmdW5jdGlvbiBfYWRqdXN0RGlzcGxheShhdHRyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb2xvciA9IHNlbGYuZ2V0KCdjb2xvcicpO1xuXG4gICAgaWYgKGF0dHIuZmlsbCkge1xuICAgICAgYXR0ci5maWxsID0gYXR0ci5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBhdHRyLnN0cm9rZSA9IGF0dHIuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgfTtcblxuICBfcHJvdG8uX2dlb21GaWx0ZXIgPSBmdW5jdGlvbiBfZ2VvbUZpbHRlcihnZW9tVHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXBwbHkgPSBzZWxmLmdldCgnYXBwbHknKTtcblxuICAgIGlmIChhcHBseSkge1xuICAgICAgcmV0dXJuIFV0aWwuY29udGFpbnMoYXBwbHksIGdlb21UeXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBfR3VpZGUucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgY2xpcCA9IHRoaXMuZ2V0KCdjbGlwJyk7XG4gICAgY2xpcCAmJiBjbGlwLnJlbW92ZSgpO1xuICB9O1xuXG4gIHJldHVybiBSZWdpb25GaWx0ZXI7XG59KEd1aWRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpb25GaWx0ZXI7XG5cbi8qKiovIH0pLFxuLyogMzUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSksXG4gICAgTGVnZW5kID0gX3JlcXVpcmUuTGVnZW5kO1xuXG52YXIgVGFpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUyKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBiYm94T2ZCYWNrUGxvdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY2KTtcblxudmFyIHBsb3RSYW5nZTJCQm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjgpO1xuXG52YXIgRklFTERfT1JJR0lOID0gJ19vcmlnaW4nO1xudmFyIE1BUktFUl9TSVpFID0gNC41O1xudmFyIHJlcXVpcmVBbmltYXRpb25GcmFtZUZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5mdW5jdGlvbiBfc25hcEVxdWFsKHYxLCB2Miwgc2NhbGUpIHtcbiAgdmFyIGlzRXF1YWw7XG5cbiAgaWYgKFV0aWwuaXNOaWwoc2NhbGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdjEgPSBzY2FsZS50cmFuc2xhdGUodjEpO1xuICB2MiA9IHNjYWxlLnRyYW5zbGF0ZSh2Mik7XG5cbiAgaWYgKHNjYWxlLmlzQ2F0ZWdvcnkpIHtcbiAgICBpc0VxdWFsID0gdjEgPT09IHYyO1xuICB9IGVsc2Uge1xuICAgIGlzRXF1YWwgPSBNYXRoLmFicyh2MSAtIHYyKSA8PSAxO1xuICB9XG5cbiAgcmV0dXJuIGlzRXF1YWw7XG59XG5cbmZ1bmN0aW9uIGZpbmRHZW9tKGdlb21zLCB2YWx1ZSkge1xuICB2YXIgcnN0O1xuICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgaWYgKGdlb20uZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHZhciB5U2NhbGUgPSBnZW9tLmdldFlTY2FsZSgpO1xuXG4gICAgICBpZiAoeVNjYWxlLmZpZWxkID09PSB2YWx1ZSkge1xuICAgICAgICByc3QgPSBnZW9tO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJzdDtcbn1cblxudmFyIExlZ2VuZENvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZWdlbmRDb250cm9sbGVyKGNmZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm9wdGlvbnMgPSB7fTtcbiAgICBVdGlsLm1peChzZWxmLCBjZmcpO1xuICAgIHNlbGYuY2xlYXIoKTtcbiAgICB2YXIgY2hhcnQgPSBzZWxmLmNoYXJ0O1xuICAgIHNlbGYuY29udGFpbmVyID0gY2hhcnQuZ2V0KCdmcm9udFBsb3QnKTtcbiAgICBzZWxmLnBsb3RSYW5nZSA9IGNoYXJ0LmdldCgncGxvdFJhbmdlJyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGVnZW5kQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIGxlZ2VuZHMgPSB0aGlzLmxlZ2VuZHM7XG4gICAgdGhpcy5iYWNrUmFuZ2UgPSBudWxsO1xuICAgIFV0aWwuZWFjaChsZWdlbmRzLCBmdW5jdGlvbiAobGVnZW5kSXRlbXMpIHtcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRJdGVtcywgZnVuY3Rpb24gKGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5sZWdlbmRzID0ge307XG4gIH07IC8vIOiOt+WPluWdkOagh+i9tOetieiDjOaZr+WFg+e0oOWNoOeahOiMg+WbtO+8jOmYsuatoumBruaMoeWdkOagh+i9tFxuXG5cbiAgX3Byb3RvLmdldEJhY2tSYW5nZSA9IGZ1bmN0aW9uIGdldEJhY2tSYW5nZSgpIHtcbiAgICB2YXIgYmFja1JhbmdlID0gdGhpcy5iYWNrUmFuZ2U7XG5cbiAgICBpZiAoIWJhY2tSYW5nZSkge1xuICAgICAgdmFyIGJhY2tQbG90ID0gdGhpcy5jaGFydC5nZXQoJ2JhY2tQbG90Jyk7XG4gICAgICBiYWNrUmFuZ2UgPSBiYm94T2ZCYWNrUGxvdChiYWNrUGxvdCwgcGxvdFJhbmdlMkJCb3godGhpcy5jaGFydC5nZXQoJ3Bsb3RSYW5nZScpKSk7XG4gICAgICB2YXIgcGxvdFJhbmdlID0gdGhpcy5wbG90UmFuZ2U7XG5cbiAgICAgIGlmIChiYWNrUmFuZ2UubWF4WCAtIGJhY2tSYW5nZS5taW5YIDwgcGxvdFJhbmdlLmJyLnggLSBwbG90UmFuZ2UudGwueCAmJiBiYWNrUmFuZ2UubWF4WSAtIGJhY2tSYW5nZS5taW5ZIDwgcGxvdFJhbmdlLmJyLnkgLSBwbG90UmFuZ2UudGwueSkge1xuICAgICAgICAvLyDlpoLmnpzog4zmma/lsI/kuo7liJnnm7TmjqXkvb/nlKggcGxvdFJhbmdlXG4gICAgICAgIGJhY2tSYW5nZSA9IHtcbiAgICAgICAgICBtaW5YOiBwbG90UmFuZ2UudGwueCxcbiAgICAgICAgICBtaW5ZOiBwbG90UmFuZ2UudGwueSxcbiAgICAgICAgICBtYXhYOiBwbG90UmFuZ2UuYnIueCxcbiAgICAgICAgICBtYXhZOiBwbG90UmFuZ2UuYnIueVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhY2tSYW5nZSA9IGJhY2tSYW5nZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFja1JhbmdlO1xuICB9O1xuXG4gIF9wcm90by5faXNGaWVsZEluVmlldyA9IGZ1bmN0aW9uIF9pc0ZpZWxkSW5WaWV3KGZpZWxkLCB2YWx1ZSwgdmlldykge1xuICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgdmFyIHNjYWxlcyA9IHZpZXcuZ2V0KCdzY2FsZXMnKTtcbiAgICB2YXIgZmllbGRTY2FsZSA9IHNjYWxlc1tmaWVsZF07XG5cbiAgICBpZiAoZmllbGRTY2FsZSAmJiBmaWVsZFNjYWxlLnZhbHVlcykge1xuICAgICAgZmxhZyA9IFV0aWwuaW5BcnJheShmaWVsZFNjYWxlLnZhbHVlcywgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmbGFnO1xuICB9O1xuXG4gIF9wcm90by5fYmluZENsaWNrRXZlbnQgPSBmdW5jdGlvbiBfYmluZENsaWNrRXZlbnQobGVnZW5kLCBzY2FsZSwgZmlsdGVyVmFscykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhcnQgPSBzZWxmLmNoYXJ0O1xuICAgIHZhciB2aWV3cyA9IGNoYXJ0LmdldCgndmlld3MnKTtcbiAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICBsZWdlbmQub24oJ2l0ZW1jbGljaycsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKG9wdGlvbnMub25DbGljayAmJiBvcHRpb25zLmRlZmF1bHRDbGlja0hhbmRsZXJFbmFibGVkICE9PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnMub25DbGljayhldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAnZGVmYXVsdENsaWNrSGFuZGxlckVuYWJsZWQnIGlzIHRydWUgdGhlIGRlZmF1bHQgY2xpY2sgYmVoYXZpb3Igd291bGQgYmUgd29ya2VkLlxuICAgICAgICB2YXIgaXRlbSA9IGV2Lml0ZW07XG4gICAgICAgIHZhciBjaGVja2VkID0gZXYuY2hlY2tlZDtcbiAgICAgICAgdmFyIGlzU2luZ2xlU2VsZWN0ZWQgPSBsZWdlbmQuZ2V0KCdzZWxlY3RlZE1vZGUnKSA9PT0gJ3NpbmdsZSc7IC8vIOWbvuS+i+eahOmAieS4reaooeW8j1xuXG4gICAgICAgIHZhciBjbGlja2VkVmFsdWUgPSBpdGVtLmRhdGFWYWx1ZTsgLy8gaW1wb3J0OiDpnIDopoHlj5bor6Xlm77kvovpobnljp/lp4vnmoTmlbDlgLxcblxuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgIFV0aWwuQXJyYXkucmVtb3ZlKGZpbHRlclZhbHMsIGNsaWNrZWRWYWx1ZSk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5faXNGaWVsZEluVmlldyhmaWVsZCwgY2xpY2tlZFZhbHVlLCBjaGFydCkpIHtcbiAgICAgICAgICAgIGNoYXJ0LmZpbHRlcihmaWVsZCwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1NpbmdsZVNlbGVjdGVkID8gZmllbGQgPT09IGNsaWNrZWRWYWx1ZSA6ICFVdGlsLmluQXJyYXkoZmlsdGVyVmFscywgZmllbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVXRpbC5lYWNoKHZpZXdzLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2lzRmllbGRJblZpZXcoZmllbGQsIGNsaWNrZWRWYWx1ZSwgdmlldykpIHtcbiAgICAgICAgICAgICAgdmlldy5maWx0ZXIoZmllbGQsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NpbmdsZVNlbGVjdGVkID8gZmllbGQgPT09IGNsaWNrZWRWYWx1ZSA6ICFVdGlsLmluQXJyYXkoZmlsdGVyVmFscywgZmllbGQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNTaW5nbGVTZWxlY3RlZCkge1xuICAgICAgICAgIGZpbHRlclZhbHMucHVzaChjbGlja2VkVmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuX2lzRmllbGRJblZpZXcoZmllbGQsIGNsaWNrZWRWYWx1ZSwgY2hhcnQpKSB7XG4gICAgICAgICAgICBjaGFydC5maWx0ZXIoZmllbGQsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gIVV0aWwuaW5BcnJheShmaWx0ZXJWYWxzLCBmaWVsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBVdGlsLmVhY2godmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5faXNGaWVsZEluVmlldyhmaWVsZCwgY2xpY2tlZFZhbHVlLCB2aWV3KSkge1xuICAgICAgICAgICAgICB2aWV3LmZpbHRlcihmaWVsZCwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFVdGlsLmluQXJyYXkoZmlsdGVyVmFscywgZmllbGQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm9uQ2xpY2spIHtcbiAgICAgICAgICBvcHRpb25zLm9uQ2xpY2soZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhcnQuc2V0KCdrZWVwTGVnZW5kJywgdHJ1ZSk7IC8vIOWbvuS+i+S4jemHjeaWsOa4suafk1xuXG4gICAgICAgIGNoYXJ0LnNldCgna2VlcFBhZGRpbmcnLCB0cnVlKTsgLy8g6L655qGG5LiN6YeN5paw6K6h566XXG5cbiAgICAgICAgY2hhcnQucmVwYWludCgpO1xuICAgICAgICBjaGFydC5zZXQoJ2tlZXBQYWRkaW5nJywgZmFsc2UpO1xuICAgICAgICBjaGFydC5zZXQoJ2tlZXBMZWdlbmQnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5kQ2xpY2tFdmVudEZvck1peCA9IGZ1bmN0aW9uIF9iaW5kQ2xpY2tFdmVudEZvck1peChsZWdlbmQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gc2VsZi5jaGFydDtcbiAgICB2YXIgZ2VvbXMgPSBjaGFydC5nZXRBbGxHZW9tcygpO1xuICAgIGxlZ2VuZC5vbignaXRlbWNsaWNrJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgdmFsdWUgPSBldi5pdGVtLnZhbHVlO1xuICAgICAgdmFyIGNoZWNrZWQgPSBldi5jaGVja2VkO1xuXG4gICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZ2VvbS5nZXRZU2NhbGUoKS5maWVsZDtcblxuICAgICAgICAgIGlmIChmaWVsZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGdlb20uc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZ2VvbS5nZXRZU2NhbGUoKS5maWVsZDtcblxuICAgICAgICAgIGlmIChmaWVsZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGdlb20uaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9maWx0ZXJMYWJlbHMgPSBmdW5jdGlvbiBfZmlsdGVyTGFiZWxzKHNoYXBlLCBnZW9tLCB2aXNpYmxlKSB7XG4gICAgaWYgKHNoYXBlLmdldCgnZ0xhYmVsJykpIHtcbiAgICAgIHNoYXBlLmdldCgnZ0xhYmVsJykuc2V0KCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsYWJlbENmZyA9IGdlb20uZ2V0KCdsYWJlbENmZycpO1xuXG4gICAgICBpZiAobGFiZWxDZmcgJiYgbGFiZWxDZmcuZmllbGRzICYmIGxhYmVsQ2ZnLmZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB4U2NhbGUgPSBnZW9tLmdldFhTY2FsZSgpO1xuICAgICAgICB2YXIgeVNjYWxlID0gZ2VvbS5nZXRZU2NhbGUoKTtcbiAgICAgICAgdmFyIHhGaWVsZCA9IHhTY2FsZS5maWVsZDtcbiAgICAgICAgdmFyIHlGaWVsZCA9IHlTY2FsZS5maWVsZDtcblxuICAgICAgICB2YXIgc2hhcGVEYXRhID0gc2hhcGUuZ2V0KCdvcmlnaW4nKS5fb3JpZ2luO1xuXG4gICAgICAgIHZhciBsYWJlbENvbnRhaW5lciA9IGdlb20uZ2V0KCdsYWJlbENvbnRhaW5lcicpO1xuICAgICAgICB2YXIgbGFiZWxzID0gbGFiZWxDb250YWluZXIuZ2V0KCdsYWJlbHNHcm91cCcpLmdldCgnY2hpbGRyZW4nKTtcbiAgICAgICAgVXRpbC5lYWNoKGxhYmVscywgZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgdmFyIGxhYmVsRGF0YSA9IGxhYmVsLmdldCgnb3JpZ2luJykgfHwgW107XG5cbiAgICAgICAgICBpZiAobGFiZWxEYXRhW3hGaWVsZF0gPT09IHNoYXBlRGF0YVt4RmllbGRdICYmIGxhYmVsRGF0YVt5RmllbGRdID09PSBzaGFwZURhdGFbeUZpZWxkXSkge1xuICAgICAgICAgICAgbGFiZWwuc2V0KCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgICAgICAgICBzaGFwZS5zZXQoJ2dMYWJlbCcsIGxhYmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2JpbmRGaWx0ZXJFdmVudCA9IGZ1bmN0aW9uIF9iaW5kRmlsdGVyRXZlbnQobGVnZW5kLCBzY2FsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgIGxlZ2VuZC5vbignaXRlbWZpbHRlcicsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHJhbmdlID0gZXYucmFuZ2U7XG4gICAgICBjaGFydC5maWx0ZXJTaGFwZShmdW5jdGlvbiAob2JqLCBzaGFwZSwgZ2VvbSkge1xuICAgICAgICAvLyBAMjAxOC0xMi0yMSBieSBibHVlLmxiIOeUseS6juaVsOWAvDDnm7TmjqXooqvnsbvlnovovazmjaLkuLpmYWxzZe+8jOi/memHjOmcgOimgeWBmuabtOeyvuehruS4gOeCueeahOWIpOaWrVxuICAgICAgICBpZiAoIVV0aWwuaXNOaWwob2JqW2ZpZWxkXSkpIHtcbiAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBvYmpbZmllbGRdID49IHJhbmdlWzBdICYmIG9ialtmaWVsZF0gPD0gcmFuZ2VbMV07IC8vIHNoYXBlIOW4piBsYWJlbO+8jOWImei/mOmcgOimgemakOiXjyBsYWJlbFxuXG4gICAgICAgICAgc2VsZi5fZmlsdGVyTGFiZWxzKHNoYXBlLCBnZW9tLCBmaWx0ZXJlZCk7XG5cbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGdlb21zID0gY2hhcnQuZ2V0QWxsR2VvbXMoKSB8fCBbXTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgZ2VvbSA9IGdlb21zW2ldO1xuXG4gICAgICAgIGlmIChnZW9tLmdldCgndHlwZScpID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICByZXF1aXJlQW5pbWF0aW9uRnJhbWVGbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnZW9tLmRyYXdXaXRoUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U2hhcGVEYXRhID0gZnVuY3Rpb24gX2dldFNoYXBlRGF0YShzaGFwZSkge1xuICAgIHZhciBvcmlnaW5EYXRhID0gc2hhcGUuZ2V0KCdvcmlnaW4nKTtcblxuICAgIGlmIChVdGlsLmlzQXJyYXkob3JpZ2luRGF0YSkpIHtcbiAgICAgIG9yaWdpbkRhdGEgPSBvcmlnaW5EYXRhWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5EYXRhW0ZJRUxEX09SSUdJTl07XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5kSG92ZXJFdmVudCA9IGZ1bmN0aW9uIF9iaW5kSG92ZXJFdmVudChsZWdlbmQsIGZpZWxkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIGdlb21zID0gY2hhcnQuZ2V0QWxsR2VvbXMoKTtcbiAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgICBsZWdlbmQub24oJ2l0ZW1ob3ZlcicsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHZhbHVlID0gZXYuaXRlbS52YWx1ZTtcbiAgICAgIHZhciBwcmUgPSBzZWxmLnByZTtcblxuICAgICAgaWYgKCFwcmUpIHtcbiAgICAgICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgICAgIHZhciBzaGFwZUNvbnRhaW5lciA9IGdlb20uZ2V0KCdzaGFwZUNvbnRhaW5lcicpO1xuICAgICAgICAgIHZhciBzaGFwZXMgPSBnZW9tLmdldFNoYXBlcygpO1xuICAgICAgICAgIHZhciBhY3RpdmVTaGFwZXMgPSBbXTtcblxuICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gZ2VvbS5nZXQoJ3NjYWxlcycpW2ZpZWxkXTtcbiAgICAgICAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gc2VsZi5fZ2V0U2hhcGVEYXRhKHNoYXBlKTtcblxuICAgICAgICAgICAgICBpZiAob3JpZ2luICYmIF9zbmFwRXF1YWwob3JpZ2luW2ZpZWxkXSwgdmFsdWUsIHNjYWxlKSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChnZW9tLmdldFlTY2FsZSgpLmZpZWxkID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgYWN0aXZlU2hhcGVzID0gc2hhcGVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghVXRpbC5pc0VtcHR5KGFjdGl2ZVNoYXBlcykpIHtcbiAgICAgICAgICAgIGV2LnNoYXBlcyA9IGFjdGl2ZVNoYXBlcztcbiAgICAgICAgICAgIGV2Lmdlb20gPSBnZW9tO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkhvdmVyKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMub25Ib3Zlcihldik7XG4gICAgICAgICAgICAgIHNoYXBlQ29udGFpbmVyLnNvcnQoKTtcbiAgICAgICAgICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdlb20uc2V0U2hhcGVzQWN0aXZlZChhY3RpdmVTaGFwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucHJlID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHByZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxlZ2VuZC5vbignaXRlbXVuaG92ZXInLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHNlbGYucHJlID0gbnVsbDtcblxuICAgICAgaWYgKG9wdGlvbnMub25VbmhvdmVyKSB7XG4gICAgICAgIG9wdGlvbnMub25VbmhvdmVyKGV2KTtcbiAgICAgIH1cblxuICAgICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgICBpZiAoZ2VvbS5nZXQoJ2FjdGl2ZVNoYXBlcycpKSB7XG4gICAgICAgICAgZ2VvbS5jbGVhckFjdGl2ZWRTaGFwZXMoKTtcbiAgICAgICAgICBjYW52YXMuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2lzRmlsdGVyZWQgPSBmdW5jdGlvbiBfaXNGaWx0ZXJlZChzY2FsZSwgZmlsdGVyVmFscywgc2NhbGVWYWx1ZSkge1xuICAgIGlmICghc2NhbGUuaXNDYXRlZ29yeSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJzdCA9IHRydWU7XG4gICAgc2NhbGVWYWx1ZSA9IHNjYWxlLmludmVydChzY2FsZVZhbHVlKTtcbiAgICBVdGlsLmVhY2goZmlsdGVyVmFscywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgaWYgKHNjYWxlLmdldFRleHQodmFsKSA9PT0gc2NhbGUuZ2V0VGV4dChzY2FsZVZhbHVlKSkge1xuICAgICAgICByc3QgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLl9hbGlnbkxlZ2VuZCA9IGZ1bmN0aW9uIF9hbGlnbkxlZ2VuZChsZWdlbmQsIHByZSwgcmVnaW9uLCBwb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdmlld1RoZW1lID0gc2VsZi52aWV3VGhlbWU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuY29udGFpbmVyO1xuICAgIHZhciBjYW52YXMgPSBjb250YWluZXIuZ2V0KCdjYW52YXMnKTtcbiAgICB2YXIgd2lkdGggPSBjYW52YXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuZ2V0KCdoZWlnaHQnKTtcbiAgICB2YXIgdG90YWxSZWdpb24gPSBzZWxmLnRvdGFsUmVnaW9uO1xuICAgIHZhciBwbG90UmFuZ2UgPSBzZWxmLnBsb3RSYW5nZTtcbiAgICB2YXIgYmFja1JhbmdlID0gc2VsZi5nZXRCYWNrUmFuZ2UoKTsgLy8g6IOM5pmv5Y2g5b6X6IyD5Zu0XG5cbiAgICB2YXIgb2Zmc2V0WCA9IGxlZ2VuZC5nZXQoJ29mZnNldCcpWzBdIHx8IDA7XG4gICAgdmFyIG9mZnNldFkgPSBsZWdlbmQuZ2V0KCdvZmZzZXQnKVsxXSB8fCAwOyAvLyBjb25zdCBvZmZzZXQgPSBVdGlsLmlzTmlsKGxlZ2VuZC5nZXQoJ29mZnNldCcpKSA/IE1BUkdJTiA6IGxlZ2VuZC5nZXQoJ29mZnNldCcpO1xuXG4gICAgdmFyIGxlZ2VuZEhlaWdodCA9IGxlZ2VuZC5nZXRIZWlnaHQoKTtcbiAgICB2YXIgbGVnZW5kV2lkdGggPSBsZWdlbmQuZ2V0V2lkdGgoKTtcbiAgICB2YXIgYm9yZGVyTWFyZ2luID0gdmlld1RoZW1lLmxlZ2VuZC5tYXJnaW47XG4gICAgdmFyIGlubmVyTWFyZ2luID0gdmlld1RoZW1lLmxlZ2VuZC5sZWdlbmRNYXJnaW47XG4gICAgdmFyIGxlZ2VuZE51bSA9IHNlbGYubGVnZW5kc1twb3NpdGlvbl0ubGVuZ3RoO1xuICAgIHZhciBwb3NBcnJheSA9IHBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgdGVtcG9SZWdpb24gPSBsZWdlbmROdW0gPiAxID8gdG90YWxSZWdpb24gOiByZWdpb247XG5cbiAgICBpZiAocG9zQXJyYXlbMF0gPT09ICdsZWZ0JyB8fCBwb3NBcnJheVswXSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgaGVpZ2h0ID0gcGxvdFJhbmdlLmJyLnk7XG4gICAgICB4ID0gc2VsZi5fZ2V0WEFsaWduKHBvc0FycmF5WzBdLCB3aWR0aCwgcmVnaW9uLCBiYWNrUmFuZ2UsIGxlZ2VuZFdpZHRoLCBib3JkZXJNYXJnaW4pO1xuXG4gICAgICBpZiAocHJlKSB7XG4gICAgICAgIC8vIEAyMDE4LTEwLTE5IGJ5IGJsdWUubGIg55Sx5LqObGVnZW5k5Lit5bm25LiN5a2Y5ZyoeeWxnuaAp++8jOi/memHjOmcgOimgeWFiOiOt+WPlmdyb3Vw5YaN6I635Y+WeeWAvFxuICAgICAgICB5ID0gcHJlLmdldCgnZ3JvdXAnKS5nZXQoJ3knKSArIHByZS5nZXRIZWlnaHQoKSArIGlubmVyTWFyZ2luO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHNlbGYuX2dldFlBbGlnblZlcnRpY2FsKHBvc0FycmF5WzFdLCBoZWlnaHQsIHRlbXBvUmVnaW9uLCBiYWNrUmFuZ2UsIDAsIGJvcmRlck1hcmdpbiwgY2FudmFzLmdldCgnaGVpZ2h0JykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zQXJyYXlbMF0gPT09ICd0b3AnIHx8IHBvc0FycmF5WzBdID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHNlbGYuX2dldFlBbGlnbkhvcml6b250YWwocG9zQXJyYXlbMF0sIGhlaWdodCwgcmVnaW9uLCBiYWNrUmFuZ2UsIGxlZ2VuZEhlaWdodCwgYm9yZGVyTWFyZ2luKTtcblxuICAgICAgaWYgKHByZSkge1xuICAgICAgICB2YXIgcHJlV2lkdGggPSBwcmUuZ2V0V2lkdGgoKTsgLy8gQDIwMTgtMTAtMTkgYnkgYmx1ZS5sYiDnlLHkuo5sZWdlbmTkuK3lubbkuI3lrZjlnKh45bGe5oCn77yM6L+Z6YeM6ZyA6KaB5YWI6I635Y+WZ3JvdXDlho3ojrflj5Z45YC8XG5cbiAgICAgICAgeCA9IHByZS5nZXQoJ2dyb3VwJykuZ2V0KCd4JykgKyBwcmVXaWR0aCArIGlubmVyTWFyZ2luO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHNlbGYuX2dldFhBbGlnbihwb3NBcnJheVsxXSwgd2lkdGgsIHRlbXBvUmVnaW9uLCBiYWNrUmFuZ2UsIDAsIGJvcmRlck1hcmdpbik7XG4gICAgICAgIGlmIChwb3NBcnJheVsxXSA9PT0gJ3JpZ2h0JykgeCA9IHBsb3RSYW5nZS5ici54IC0gdGVtcG9SZWdpb24udG90YWxXaWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZWdlbmQubW92ZSh4ICsgb2Zmc2V0WCwgeSArIG9mZnNldFkpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0WEFsaWduID0gZnVuY3Rpb24gX2dldFhBbGlnbihwb3MsIHdpZHRoLCByZWdpb24sIGJhY2tSYW5nZSwgbGVnZW5kV2lkdGgsIGJvcmRlck1hcmdpbikge1xuICAgIHZhciB4ID0gcG9zID09PSAnbGVmdCcgPyBiYWNrUmFuZ2UubWluWCAtIGxlZ2VuZFdpZHRoIC0gYm9yZGVyTWFyZ2luWzNdIDogYmFja1JhbmdlLm1heFggKyBib3JkZXJNYXJnaW5bMV07XG5cbiAgICBpZiAocG9zID09PSAnY2VudGVyJykge1xuICAgICAgeCA9ICh3aWR0aCAtIHJlZ2lvbi50b3RhbFdpZHRoKSAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRZQWxpZ25Ib3Jpem9udGFsID0gZnVuY3Rpb24gX2dldFlBbGlnbkhvcml6b250YWwocG9zLCBoZWlnaHQsIHJlZ2lvbiwgYmFja1JhbmdlLCBsZWdlbmRIZWlnaHQsIGJvcmRlck1hcmdpbikge1xuICAgIHZhciB5ID0gcG9zID09PSAndG9wJyA/IGJhY2tSYW5nZS5taW5ZIC0gbGVnZW5kSGVpZ2h0IC0gYm9yZGVyTWFyZ2luWzBdIDogYmFja1JhbmdlLm1heFkgKyBib3JkZXJNYXJnaW5bMl07XG4gICAgcmV0dXJuIHk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRZQWxpZ25WZXJ0aWNhbCA9IGZ1bmN0aW9uIF9nZXRZQWxpZ25WZXJ0aWNhbChwb3MsIGhlaWdodCwgcmVnaW9uLCBiYWNrUmFuZ2UsIGxlZ2VuZEhlaWdodCwgYm9yZGVyTWFyZ2luLCBjYW52YXNIZWlnaHQpIHtcbiAgICB2YXIgeSA9IHBvcyA9PT0gJ3RvcCcgPyBiYWNrUmFuZ2UubWluWSAtIGxlZ2VuZEhlaWdodCAtIGJvcmRlck1hcmdpblswXSA6IGhlaWdodCAtIHJlZ2lvbi50b3RhbEhlaWdodDtcblxuICAgIGlmIChwb3MgPT09ICdjZW50ZXInKSB7XG4gICAgICB5ID0gKGNhbnZhc0hlaWdodCAtIHJlZ2lvbi50b3RhbEhlaWdodCkgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiB5O1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U3ViUmVnaW9uID0gZnVuY3Rpb24gX2dldFN1YlJlZ2lvbihsZWdlbmRzKSB7XG4gICAgdmFyIG1heFdpZHRoID0gMDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcbiAgICB2YXIgdG90YWxXaWR0aCA9IDA7XG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcbiAgICBVdGlsLmVhY2gobGVnZW5kcywgZnVuY3Rpb24gKGxlZ2VuZCkge1xuICAgICAgdmFyIHdpZHRoID0gbGVnZW5kLmdldFdpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gbGVnZW5kLmdldEhlaWdodCgpO1xuXG4gICAgICBpZiAobWF4V2lkdGggPCB3aWR0aCkge1xuICAgICAgICBtYXhXaWR0aCA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFdpZHRoICs9IHdpZHRoO1xuXG4gICAgICBpZiAobWF4SGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICAgIG1heEhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXhXaWR0aDogbWF4V2lkdGgsXG4gICAgICB0b3RhbFdpZHRoOiB0b3RhbFdpZHRoLFxuICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgICB0b3RhbEhlaWdodDogdG90YWxIZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fZ2V0UmVnaW9uID0gZnVuY3Rpb24gX2dldFJlZ2lvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYudmlld1RoZW1lO1xuICAgIHZhciBsZWdlbmRzID0gc2VsZi5sZWdlbmRzO1xuICAgIHZhciBpbm5lck1hcmdpbiA9IHZpZXdUaGVtZS5sZWdlbmQubGVnZW5kTWFyZ2luO1xuICAgIHZhciBzdWJzID0gW107XG4gICAgdmFyIHRvdGFsV2lkdGggPSAwO1xuICAgIHZhciB0b3RhbEhlaWdodCA9IDA7XG4gICAgVXRpbC5lYWNoKGxlZ2VuZHMsIGZ1bmN0aW9uIChsZWdlbmRJdGVtcykge1xuICAgICAgdmFyIHN1YlJlZ2lvbiA9IHNlbGYuX2dldFN1YlJlZ2lvbihsZWdlbmRJdGVtcyk7XG5cbiAgICAgIHN1YnMucHVzaChzdWJSZWdpb24pO1xuICAgICAgdG90YWxXaWR0aCArPSBzdWJSZWdpb24udG90YWxXaWR0aCArIGlubmVyTWFyZ2luO1xuICAgICAgdG90YWxIZWlnaHQgKz0gc3ViUmVnaW9uLnRvdGFsSGVpZ2h0ICsgaW5uZXJNYXJnaW47XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsV2lkdGg6IHRvdGFsV2lkdGgsXG4gICAgICB0b3RhbEhlaWdodDogdG90YWxIZWlnaHQsXG4gICAgICBzdWJzOiBzdWJzXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZENhdGVnb3J5TGVnZW5kID0gZnVuY3Rpb24gX2FkZENhdGVnb3J5TGVnZW5kKHNjYWxlLCBhdHRyLCBnZW9tLCBmaWx0ZXJWYWxzLCBwb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICB2YXIgbGVnZW5kT3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICB2YXIgZmllbGRPcHRpb24gPSBsZWdlbmRPcHRpb25zW2ZpZWxkXTtcblxuICAgIGlmIChmaWVsZE9wdGlvbikge1xuICAgICAgbGVnZW5kT3B0aW9ucyA9IGZpZWxkT3B0aW9uO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmRzID0gc2VsZi5sZWdlbmRzO1xuICAgIGxlZ2VuZHNbcG9zaXRpb25dID0gbGVnZW5kc1twb3NpdGlvbl0gfHwgW107XG4gICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuY29udGFpbmVyO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG4gICAgdmFyIGlzQnlBdHRyID0gdHJ1ZTtcbiAgICB2YXIgc2hhcGVUeXBlID0gZ2VvbS5nZXQoJ3NoYXBlVHlwZScpIHx8ICdwb2ludCc7XG4gICAgdmFyIHNoYXBlID0gZ2VvbS5nZXREZWZhdWx0VmFsdWUoJ3NoYXBlJykgfHwgJ2NpcmNsZSc7XG5cbiAgICBpZiAobGVnZW5kT3B0aW9uc1tmaWVsZF0gJiYgbGVnZW5kT3B0aW9uc1tmaWVsZF0ubWFya2VyKSB7XG4gICAgICAvLyDnlKjmiLfkuLogZmllbGQg5a+55bqU55qE5Zu+5L6L5a6a5LmJ5LqGIG1hcmtlclxuICAgICAgc2hhcGUgPSBsZWdlbmRPcHRpb25zW2ZpZWxkXS5tYXJrZXI7XG4gICAgICBzaGFwZVR5cGUgPSAncG9pbnQnO1xuICAgICAgaXNCeUF0dHIgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxlZ2VuZE9wdGlvbnMubWFya2VyKSB7XG4gICAgICBzaGFwZSA9IGxlZ2VuZE9wdGlvbnMubWFya2VyO1xuICAgICAgc2hhcGVUeXBlID0gJ3BvaW50JztcbiAgICAgIGlzQnlBdHRyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJ0ID0gc2VsZi5jaGFydDtcbiAgICB2YXIgdmlld1RoZW1lID0gc2VsZi52aWV3VGhlbWU7XG4gICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHBsb3RSYW5nZSA9IHNlbGYucGxvdFJhbmdlO1xuICAgIHZhciBwb3NBcnJheSA9IHBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgdmFyIG1heExlbmd0aCA9IHBvc0FycmF5WzBdID09PSAncmlnaHQnIHx8IHBvc0FycmF5WzBdID09PSAnbGVmdCcgPyBwbG90UmFuZ2UuYmwueSAtIHBsb3RSYW5nZS50ci55IDogY2FudmFzLmdldCgnd2lkdGgnKTtcbiAgICBVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgdGV4dCA9IHRpY2sudGV4dDtcbiAgICAgIHZhciBuYW1lID0gdGV4dDtcbiAgICAgIHZhciBzY2FsZVZhbHVlID0gdGljay52YWx1ZTtcbiAgICAgIHZhciB2YWx1ZSA9IHNjYWxlLmludmVydChzY2FsZVZhbHVlKTtcbiAgICAgIHZhciBjZmcgPSB7XG4gICAgICAgIGlzSW5DaXJjbGU6IGdlb20uaXNJbkNpcmNsZSgpXG4gICAgICB9O1xuICAgICAgdmFyIGNoZWNrZWQgPSBmaWx0ZXJWYWxzID8gc2VsZi5faXNGaWx0ZXJlZChzY2FsZSwgZmlsdGVyVmFscywgc2NhbGVWYWx1ZSkgOiB0cnVlO1xuICAgICAgdmFyIGNvbG9yQXR0ciA9IGdlb20uZ2V0QXR0cignY29sb3InKTtcbiAgICAgIHZhciBzaGFwZUF0dHIgPSBnZW9tLmdldEF0dHIoJ3NoYXBlJyk7XG5cbiAgICAgIGlmIChjb2xvckF0dHIpIHtcbiAgICAgICAgLy8g5a2Y5Zyo6aKc6Imy5pig5bCEXG4gICAgICAgIGlmIChjb2xvckF0dHIuY2FsbGJhY2sgJiYgY29sb3JBdHRyLmNhbGxiYWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyDlpJrlj4LmlbDmmKDlsITvvIzpmLvmraLnqIvluo/miqXplJlcbiAgICAgICAgICB2YXIgcmVzdEFyZ3MgPSBBcnJheShjb2xvckF0dHIuY2FsbGJhY2subGVuZ3RoIC0gMSkuZmlsbCgnJyk7XG4gICAgICAgICAgY2ZnLmNvbG9yID0gY29sb3JBdHRyLm1hcHBpbmcuYXBwbHkoY29sb3JBdHRyLCBbdmFsdWVdLmNvbmNhdChyZXN0QXJncykpLmpvaW4oJycpIHx8IHZpZXdUaGVtZS5kZWZhdWx0Q29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2ZnLmNvbG9yID0gY29sb3JBdHRyLm1hcHBpbmcodmFsdWUpLmpvaW4oJycpIHx8IHZpZXdUaGVtZS5kZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQnlBdHRyICYmIHNoYXBlQXR0cikge1xuICAgICAgICAvLyDlrZjlnKjlvaLnirbmmKDlsIRcbiAgICAgICAgaWYgKHNoYXBlQXR0ci5jYWxsYmFjayAmJiBzaGFwZUF0dHIuY2FsbGJhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIOWkmuWPguaVsOaYoOWwhO+8jOmYu+atoueoi+W6j+aKpemUmVxuICAgICAgICAgIHZhciBfcmVzdEFyZ3MgPSBBcnJheShzaGFwZUF0dHIuY2FsbGJhY2subGVuZ3RoIC0gMSkuZmlsbCgnJyk7XG5cbiAgICAgICAgICBzaGFwZSA9IHNoYXBlQXR0ci5tYXBwaW5nLmFwcGx5KHNoYXBlQXR0ciwgW3ZhbHVlXS5jb25jYXQoX3Jlc3RBcmdzKSkuam9pbignJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGUgPSBzaGFwZUF0dHIubWFwcGluZyh2YWx1ZSkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlT2JqZWN0ID0gU2hhcGUuZ2V0U2hhcGVGYWN0b3J5KHNoYXBlVHlwZSk7XG4gICAgICB2YXIgbWFya2VyID0gc2hhcGVPYmplY3QuZ2V0TWFya2VyQ2ZnKHNoYXBlLCBjZmcpO1xuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHNoYXBlKSkge1xuICAgICAgICBtYXJrZXIuc3ltYm9sID0gc2hhcGU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgLy8g5Zu+5L6L6aG55pi+56S65paH5pys55qE5YaF5a65XG4gICAgICAgIGRhdGFWYWx1ZTogdmFsdWUsXG4gICAgICAgIC8vIOWbvuS+i+mhueWvueW6lOWOn+Wni+aVsOaNruS4reeahOaVsOWAvFxuICAgICAgICBjaGVja2VkOiBjaGVja2VkLFxuICAgICAgICBtYXJrZXI6IG1hcmtlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGxlZ2VuZENmZyA9IFV0aWwuZGVlcE1peCh7fSwgdmlld1RoZW1lLmxlZ2VuZFtwb3NBcnJheVswXV0sIGxlZ2VuZE9wdGlvbnNbZmllbGRdIHx8IGxlZ2VuZE9wdGlvbnMsIHtcbiAgICAgIHZpZXdJZDogY2hhcnQuZ2V0KCdfaWQnKSxcbiAgICAgIG1heExlbmd0aDogbWF4TGVuZ3RoLFxuICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICBwb3NpdGlvbjogWzAsIDBdXG4gICAgfSk7XG5cbiAgICBpZiAobGVnZW5kQ2ZnLnRpdGxlKSB7XG4gICAgICBVdGlsLmRlZXBNaXgobGVnZW5kQ2ZnLCB7XG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdGV4dDogc2NhbGUuYWxpYXMgfHwgc2NhbGUuZmllbGRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGxlZ2VuZDtcblxuICAgIGlmIChzZWxmLl9pc1RhaWxMZWdlbmQobGVnZW5kT3B0aW9ucywgZ2VvbSkpIHtcbiAgICAgIGxlZ2VuZENmZy5jaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgICBsZWdlbmRDZmcuZ2VvbSA9IGdlb207XG4gICAgICBsZWdlbmQgPSBuZXcgVGFpbChsZWdlbmRDZmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGVnZW5kT3B0aW9ucy51c2VIdG1sKSB7XG4gICAgICAgIHZhciBjYW52YXNFbGUgPSBjb250YWluZXIuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJyk7XG4gICAgICAgIGNvbnRhaW5lciA9IGxlZ2VuZE9wdGlvbnMuY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChVdGlsLmlzU3RyaW5nKGNvbnRhaW5lcikgJiYgL15cXCMvLnRlc3QoY29udGFpbmVyKSkge1xuICAgICAgICAgIC8vIOWmguaenOS8oOWFpSBkb20g6IqC54K555qEIGlkXG4gICAgICAgICAgdmFyIGlkID0gY29udGFpbmVyLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBjYW52YXNFbGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZ2VuZENmZy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIGlmIChsZWdlbmRDZmcubGVnZW5kU3R5bGUgPT09IHVuZGVmaW5lZCkgbGVnZW5kQ2ZnLmxlZ2VuZFN0eWxlID0ge307XG4gICAgICAgIGxlZ2VuZENmZy5sZWdlbmRTdHlsZS5DT05UQUlORVJfQ0xBU1MgPSB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgICAnei1pbmRleCc6IGNhbnZhc0VsZS5zdHlsZS56SW5kZXggPT09ICcnID8gMSA6IHBhcnNlSW50KGNhbnZhc0VsZS5zdHlsZS56SW5kZXgsIDEwKSArIDFcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobGVnZW5kT3B0aW9ucy5mbGlwUGFnZSkge1xuICAgICAgICAgIGxlZ2VuZENmZy5sZWdlbmRTdHlsZS5DT05UQUlORVJfQ0xBU1MuaGVpZ2h0ID0gcG9zQXJyYXlbMF0gPT09ICdyaWdodCcgfHwgcG9zQXJyYXlbMF0gPT09ICdsZWZ0JyA/IG1heExlbmd0aCArICdweCcgOiAnYXV0byc7XG4gICAgICAgICAgbGVnZW5kQ2ZnLmxlZ2VuZFN0eWxlLkNPTlRBSU5FUl9DTEFTUy53aWR0aCA9ICEocG9zQXJyYXlbMF0gPT09ICdyaWdodCcgfHwgcG9zQXJyYXlbMF0gPT09ICdsZWZ0JykgPyBtYXhMZW5ndGggKyAncHgnIDogJ2F1dG8nO1xuICAgICAgICAgIGxlZ2VuZCA9IG5ldyBMZWdlbmQuQ2F0UGFnZUh0bWwobGVnZW5kQ2ZnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWdlbmQgPSBuZXcgTGVnZW5kLkNhdEh0bWwobGVnZW5kQ2ZnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVnZW5kID0gbmV3IExlZ2VuZC5DYXRlZ29yeShsZWdlbmRDZmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX2JpbmRDbGlja0V2ZW50KGxlZ2VuZCwgc2NhbGUsIGZpbHRlclZhbHMpO1xuXG4gICAgbGVnZW5kc1twb3NpdGlvbl0ucHVzaChsZWdlbmQpO1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5kQ2hhcnRNb3ZlID0gZnVuY3Rpb24gX2JpbmRDaGFydE1vdmUoc2NhbGUpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHZhciBsZWdlbmRzID0gdGhpcy5sZWdlbmRzO1xuICAgIGNoYXJ0Lm9uKCdwbG90bW92ZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChldi50YXJnZXQpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGV2LnRhcmdldC5nZXQoJ29yaWdpbicpO1xuXG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IG9yaWdpbltGSUVMRF9PUklHSU5dIHx8IG9yaWdpblswXVtGSUVMRF9PUklHSU5dO1xuICAgICAgICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuXG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbZmllbGRdO1xuICAgICAgICAgICAgVXRpbC5lYWNoKGxlZ2VuZHMsIGZ1bmN0aW9uIChsZWdlbmRJdGVtcykge1xuICAgICAgICAgICAgICBVdGlsLmVhY2gobGVnZW5kSXRlbXMsIGZ1bmN0aW9uIChsZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgIWxlZ2VuZC5kZXN0cm95ZWQgJiYgbGVnZW5kLmFjdGl2YXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICBVdGlsLmVhY2gobGVnZW5kcywgZnVuY3Rpb24gKGxlZ2VuZEl0ZW1zKSB7XG4gICAgICAgICAgVXRpbC5lYWNoKGxlZ2VuZEl0ZW1zLCBmdW5jdGlvbiAobGVnZW5kKSB7XG4gICAgICAgICAgICAhbGVnZW5kLmRlc3Ryb3llZCAmJiBsZWdlbmQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZENvbnRpbnVvdXNMZWdlbmQgPSBmdW5jdGlvbiBfYWRkQ29udGludW91c0xlZ2VuZChzY2FsZSwgYXR0ciwgcG9zaXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlZ2VuZHMgPSBzZWxmLmxlZ2VuZHM7XG4gICAgbGVnZW5kc1twb3NpdGlvbl0gPSBsZWdlbmRzW3Bvc2l0aW9uXSB8fCBbXTtcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5jb250YWluZXI7XG4gICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgdmFyIHRpY2tzID0gc2NhbGUuZ2V0VGlja3MoKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgbGVnZW5kO1xuICAgIHZhciBtaW5WYWx1ZTtcbiAgICB2YXIgbWF4VmFsdWU7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYudmlld1RoZW1lO1xuICAgIFV0aWwuZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgIHZhciBzY2FsZVZhbHVlID0gdGljay52YWx1ZTtcbiAgICAgIHZhciBpbnZlcnRWYWx1ZSA9IHNjYWxlLmludmVydChzY2FsZVZhbHVlKTtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyLm1hcHBpbmcoaW52ZXJ0VmFsdWUpLmpvaW4oJycpO1xuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0aWNrLnRpY2tWYWx1ZSxcbiAgICAgICAgLy8gdGljay50ZXh0XG4gICAgICAgIGF0dHJWYWx1ZTogYXR0clZhbHVlLFxuICAgICAgICBjb2xvcjogYXR0clZhbHVlLFxuICAgICAgICBzY2FsZVZhbHVlOiBzY2FsZVZhbHVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNjYWxlVmFsdWUgPT09IDApIHtcbiAgICAgICAgbWluVmFsdWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NhbGVWYWx1ZSA9PT0gMSkge1xuICAgICAgICBtYXhWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW1pblZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHNjYWxlLm1pbixcbiAgICAgICAgYXR0clZhbHVlOiBhdHRyLm1hcHBpbmcoMCkuam9pbignJyksXG4gICAgICAgIGNvbG9yOiBhdHRyLm1hcHBpbmcoMCkuam9pbignJyksXG4gICAgICAgIHNjYWxlVmFsdWU6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghbWF4VmFsdWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB2YWx1ZTogc2NhbGUubWF4LFxuICAgICAgICBhdHRyVmFsdWU6IGF0dHIubWFwcGluZygxKS5qb2luKCcnKSxcbiAgICAgICAgY29sb3I6IGF0dHIubWFwcGluZygxKS5qb2luKCcnKSxcbiAgICAgICAgc2NhbGVWYWx1ZTogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgdmFyIHBvc0FycmF5ID0gcG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICB2YXIgZGVmYXVsdENmZyA9IHZpZXdUaGVtZS5sZWdlbmRbcG9zQXJyYXlbMF1dO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zbGlkYWJsZSA9PT0gZmFsc2UgfHwgb3B0aW9uc1tmaWVsZF0gJiYgb3B0aW9uc1tmaWVsZF0uc2xpZGFibGUgPT09IGZhbHNlKSB7XG4gICAgICBkZWZhdWx0Q2ZnID0gVXRpbC5taXgoe30sIGRlZmF1bHRDZmcsIHZpZXdUaGVtZS5sZWdlbmQuZ3JhZGllbnQpO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmRDZmcgPSBVdGlsLmRlZXBNaXgoe30sIGRlZmF1bHRDZmcsIG9wdGlvbnNbZmllbGRdIHx8IG9wdGlvbnMsIHtcbiAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgIGF0dHI6IGF0dHIsXG4gICAgICBmb3JtYXR0ZXI6IHNjYWxlLmZvcm1hdHRlcixcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgcG9zaXRpb246IFswLCAwXVxuICAgIH0pO1xuXG4gICAgaWYgKGxlZ2VuZENmZy50aXRsZSkge1xuICAgICAgVXRpbC5kZWVwTWl4KGxlZ2VuZENmZywge1xuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHRleHQ6IHNjYWxlLmFsaWFzIHx8IHNjYWxlLmZpZWxkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhdHRyLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgIGxlZ2VuZCA9IG5ldyBMZWdlbmQuQ29sb3IobGVnZW5kQ2ZnKTtcbiAgICB9IGVsc2UgaWYgKGF0dHIudHlwZSA9PT0gJ3NpemUnKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpemVUeXBlID09PSAnY2lyY2xlJykgbGVnZW5kID0gbmV3IExlZ2VuZC5DaXJjbGVTaXplKGxlZ2VuZENmZyk7ZWxzZSBsZWdlbmQgPSBuZXcgTGVnZW5kLlNpemUobGVnZW5kQ2ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX2JpbmRGaWx0ZXJFdmVudChsZWdlbmQsIHNjYWxlKTtcblxuICAgIGxlZ2VuZHNbcG9zaXRpb25dLnB1c2gobGVnZW5kKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIF9wcm90by5faXNUYWlsTGVnZW5kID0gZnVuY3Rpb24gX2lzVGFpbExlZ2VuZChvcHQsIGdlb20pIHtcbiAgICBpZiAob3B0Lmhhc093blByb3BlcnR5KCdhdHRhY2hMYXN0JykgJiYgb3B0LmF0dGFjaExhc3QpIHtcbiAgICAgIHZhciBnZW9tVHlwZSA9IGdlb20uZ2V0KCd0eXBlJyk7XG4gICAgICBpZiAoZ2VvbVR5cGUgPT09ICdsaW5lJyB8fCBnZW9tVHlwZSA9PT0gJ2xpbmVTdGFjaycgfHwgZ2VvbVR5cGUgPT09ICdhcmVhJyB8fCBnZW9tVHlwZSA9PT0gJ2FyZWFTdGFjaycpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uX2FkanVzdFBvc2l0aW9uID0gZnVuY3Rpb24gX2FkanVzdFBvc2l0aW9uKHBvc2l0aW9uLCBpc1RhaWxMZWdlbmQpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgaWYgKGlzVGFpbExlZ2VuZCkge1xuICAgICAgcG9zID0gJ3JpZ2h0LXRvcCc7XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzQXJyYXkocG9zaXRpb24pKSB7XG4gICAgICBwb3MgPSBTdHJpbmcocG9zaXRpb25bMF0pICsgJy0nICsgU3RyaW5nKHBvc2l0aW9uWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc0FyciA9IHBvc2l0aW9uLnNwbGl0KCctJyk7XG5cbiAgICAgIGlmIChwb3NBcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIOWPqueUqOS6hmxlZnQvcmlnaHQvYm90dG9tL3RvcOS4gOS4quS9jee9ruWumuS9jVxuICAgICAgICBpZiAocG9zQXJyWzBdID09PSAnbGVmdCcpIHBvcyA9ICdsZWZ0LWJvdHRvbSc7XG4gICAgICAgIGlmIChwb3NBcnJbMF0gPT09ICdyaWdodCcpIHBvcyA9ICdyaWdodC1ib3R0b20nO1xuICAgICAgICBpZiAocG9zQXJyWzBdID09PSAndG9wJykgcG9zID0gJ3RvcC1jZW50ZXInO1xuICAgICAgICBpZiAocG9zQXJyWzBdID09PSAnYm90dG9tJykgcG9zID0gJ2JvdHRvbS1jZW50ZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gcG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICBfcHJvdG8uYWRkTGVnZW5kID0gZnVuY3Rpb24gYWRkTGVnZW5kKHNjYWxlLCBhdHRyLCBnZW9tLCBmaWx0ZXJWYWxzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsZWdlbmRPcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgIHZhciBmaWVsZE9wdGlvbiA9IGxlZ2VuZE9wdGlvbnNbZmllbGRdO1xuICAgIHZhciB2aWV3VGhlbWUgPSBzZWxmLnZpZXdUaGVtZTtcblxuICAgIGlmIChmaWVsZE9wdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIOWmguaenOS4jeaYvuekuuatpOWbvuS+i1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkT3B0aW9uICYmIGZpZWxkT3B0aW9uLmN1c3RvbSkge1xuICAgICAgc2VsZi5hZGRDdXN0b21MZWdlbmQoZmllbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBsZWdlbmRPcHRpb25zLnBvc2l0aW9uIHx8IHZpZXdUaGVtZS5kZWZhdWx0TGVnZW5kUG9zaXRpb247XG4gICAgICBwb3NpdGlvbiA9IHNlbGYuX2FkanVzdFBvc2l0aW9uKHBvc2l0aW9uLCBzZWxmLl9pc1RhaWxMZWdlbmQobGVnZW5kT3B0aW9ucywgZ2VvbSkpO1xuXG4gICAgICBpZiAoZmllbGRPcHRpb24gJiYgZmllbGRPcHRpb24ucG9zaXRpb24pIHtcbiAgICAgICAgLy8g5aaC5p6c5a+55p+Q5Liq5Zu+5L6L5Y2V54us6K6+572uIHBvc2l0aW9u77yM5YiZ5a+5IHBvc2l0aW9uIOmHjeaWsOi1i+WAvFxuICAgICAgICBwb3NpdGlvbiA9IHNlbGYuX2FkanVzdFBvc2l0aW9uKGZpZWxkT3B0aW9uLnBvc2l0aW9uLCBzZWxmLl9pc1RhaWxMZWdlbmQoZmllbGRPcHRpb24sIGdlb20pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZ2VuZDtcblxuICAgICAgaWYgKHNjYWxlLmlzTGluZWFyKSB7XG4gICAgICAgIGxlZ2VuZCA9IHNlbGYuX2FkZENvbnRpbnVvdXNMZWdlbmQoc2NhbGUsIGF0dHIsIHBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZ2VuZCA9IHNlbGYuX2FkZENhdGVnb3J5TGVnZW5kKHNjYWxlLCBhdHRyLCBnZW9tLCBmaWx0ZXJWYWxzLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWdlbmQpIHtcbiAgICAgICAgc2VsZi5fYmluZEhvdmVyRXZlbnQobGVnZW5kLCBmaWVsZCk7XG5cbiAgICAgICAgbGVnZW5kT3B0aW9ucy5yZWFjdGl2ZSAmJiBzZWxmLl9iaW5kQ2hhcnRNb3ZlKHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiDoh6rlrprkuYnlm77kvotcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIOiHquWumuS5ieWbvuS+i+eahOaVsOaNruWtl+auteWQje+8jOWPr+S7peS4uuepulxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGxlZ2VuZCDoh6rlrprkuYnlm77kvovlrp7kvotcbiAgICovXG5cblxuICBfcHJvdG8uYWRkQ3VzdG9tTGVnZW5kID0gZnVuY3Rpb24gYWRkQ3VzdG9tTGVnZW5kKGZpZWxkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYudmlld1RoZW1lO1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmNvbnRhaW5lcjtcbiAgICB2YXIgbGVnZW5kT3B0aW9ucyA9IHNlbGYub3B0aW9ucztcblxuICAgIGlmIChmaWVsZCkge1xuICAgICAgbGVnZW5kT3B0aW9ucyA9IGxlZ2VuZE9wdGlvbnNbZmllbGRdO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbiA9IGxlZ2VuZE9wdGlvbnMucG9zaXRpb24gfHwgdmlld1RoZW1lLmRlZmF1bHRMZWdlbmRQb3NpdGlvbjtcbiAgICBwb3NpdGlvbiA9IHNlbGYuX2FkanVzdFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB2YXIgbGVnZW5kcyA9IHNlbGYubGVnZW5kcztcbiAgICBsZWdlbmRzW3Bvc2l0aW9uXSA9IGxlZ2VuZHNbcG9zaXRpb25dIHx8IFtdO1xuICAgIHZhciBpdGVtcyA9IGxlZ2VuZE9wdGlvbnMuaXRlbXM7XG5cbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdlb21zID0gY2hhcnQuZ2V0QWxsR2VvbXMoKTtcbiAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgZ2VvbSA9IGZpbmRHZW9tKGdlb21zLCBpdGVtLnZhbHVlKTtcblxuICAgICAgaWYgKCFVdGlsLmlzT2JqZWN0KGl0ZW0ubWFya2VyKSkge1xuICAgICAgICBpdGVtLm1hcmtlciA9IHtcbiAgICAgICAgICBzeW1ib2w6IGl0ZW0ubWFya2VyID8gaXRlbS5tYXJrZXIgOiAnY2lyY2xlJyxcbiAgICAgICAgICBmaWxsOiBpdGVtLmZpbGwsXG4gICAgICAgICAgcmFkaXVzOiBNQVJLRVJfU0laRVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbS5tYXJrZXIucmFkaXVzID0gaXRlbS5tYXJrZXIucmFkaXVzIHx8IE1BUktFUl9TSVpFO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmNoZWNrZWQgPSBVdGlsLmlzTmlsKGl0ZW0uY2hlY2tlZCkgPyB0cnVlIDogaXRlbS5jaGVja2VkO1xuICAgICAgaXRlbS5nZW9tID0gZ2VvbTtcbiAgICB9KTtcbiAgICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgICB2YXIgcGxvdFJhbmdlID0gc2VsZi5wbG90UmFuZ2U7XG4gICAgdmFyIHBvc0FycmF5ID0gcG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICB2YXIgbWF4TGVuZ3RoID0gcG9zQXJyYXlbMF0gPT09ICdyaWdodCcgfHwgcG9zQXJyYXlbMF0gPT09ICdsZWZ0JyA/IHBsb3RSYW5nZS5ibC55IC0gcGxvdFJhbmdlLnRyLnkgOiBjYW52YXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBsZWdlbmRDZmcgPSBVdGlsLmRlZXBNaXgoe30sIHZpZXdUaGVtZS5sZWdlbmRbcG9zQXJyYXlbMF1dLCBsZWdlbmRPcHRpb25zLCB7XG4gICAgICBtYXhMZW5ndGg6IG1heExlbmd0aCxcbiAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgcG9zaXRpb246IFswLCAwXVxuICAgIH0pO1xuICAgIHZhciBsZWdlbmQ7XG5cbiAgICBpZiAobGVnZW5kT3B0aW9ucy51c2VIdG1sKSB7XG4gICAgICB2YXIgaHRtbENvbnRhaW5lciA9IGxlZ2VuZE9wdGlvbnMuY29udGFpbmVyO1xuXG4gICAgICBpZiAoL15cXCMvLnRlc3QoY29udGFpbmVyKSkge1xuICAgICAgICAvLyDlpoLmnpzkvKDlhaUgZG9tIOiKgueCueeahCBpZFxuICAgICAgICB2YXIgaWQgPSBodG1sQ29udGFpbmVyLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICAgIGh0bWxDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICB9IGVsc2UgaWYgKCFodG1sQ29udGFpbmVyKSB7XG4gICAgICAgIGh0bWxDb250YWluZXIgPSBjb250YWluZXIuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJykucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgbGVnZW5kQ2ZnLmNvbnRhaW5lciA9IGh0bWxDb250YWluZXI7XG4gICAgICBpZiAobGVnZW5kQ2ZnLmxlZ2VuZFN0eWxlID09PSB1bmRlZmluZWQpIGxlZ2VuZENmZy5sZWdlbmRTdHlsZSA9IHt9O1xuXG4gICAgICBpZiAoIWxlZ2VuZENmZy5sZWdlbmRTdHlsZS5DT05UQUlORVJfQ0xBU1MpIHtcbiAgICAgICAgbGVnZW5kQ2ZnLmxlZ2VuZFN0eWxlLkNPTlRBSU5FUl9DTEFTUyA9IHtcbiAgICAgICAgICBoZWlnaHQ6IHBvc0FycmF5WzBdID09PSAncmlnaHQnIHx8IHBvc0FycmF5WzBdID09PSAnbGVmdCcgPyBtYXhMZW5ndGggKyAncHgnIDogJ2F1dG8nLFxuICAgICAgICAgIHdpZHRoOiAhKHBvc0FycmF5WzBdID09PSAncmlnaHQnIHx8IHBvc0FycmF5WzBdID09PSAnbGVmdCcpID8gbWF4TGVuZ3RoICsgJ3B4JyA6ICdhdXRvJyxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWdlbmRPcHRpb25zLmZsaXBQYWdlKSBsZWdlbmQgPSBuZXcgTGVnZW5kLkNhdFBhZ2VIdG1sKGxlZ2VuZENmZyk7ZWxzZSBsZWdlbmQgPSBuZXcgTGVnZW5kLkNhdEh0bWwobGVnZW5kQ2ZnKTtcbiAgICB9IGVsc2UgbGVnZW5kID0gbmV3IExlZ2VuZC5DYXRlZ29yeShsZWdlbmRDZmcpO1xuXG4gICAgbGVnZW5kc1twb3NpdGlvbl0ucHVzaChsZWdlbmQpO1xuICAgIGxlZ2VuZC5vbignaXRlbWNsaWNrJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAobGVnZW5kT3B0aW9ucy5vbkNsaWNrKSB7XG4gICAgICAgIC8vIOeUqOaIt+iHquWumuS5ieS6huWbvuS+i+eCueWHu+S6i+S7tlxuICAgICAgICBsZWdlbmRPcHRpb25zLm9uQ2xpY2soZXYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2VsZi5fYmluZEhvdmVyRXZlbnQobGVnZW5kKTtcblxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZE1peGVkTGVnZW5kID0gZnVuY3Rpb24gYWRkTWl4ZWRMZWdlbmQoc2NhbGVzLCBnZW9tcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBVdGlsLmVhY2goc2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHNjYWxlLmZpZWxkO1xuICAgICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgICBpZiAoZ2VvbS5nZXRZU2NhbGUoKSA9PT0gc2NhbGUgJiYgc2NhbGUudmFsdWVzICYmIHNjYWxlLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHNoYXBlVHlwZSA9IGdlb20uZ2V0KCdzaGFwZVR5cGUnKSB8fCAncG9pbnQnO1xuICAgICAgICAgIHZhciBzaGFwZSA9IGdlb20uZ2V0RGVmYXVsdFZhbHVlKCdzaGFwZScpIHx8ICdjaXJjbGUnO1xuICAgICAgICAgIHZhciBzaGFwZU9iamVjdCA9IFNoYXBlLmdldFNoYXBlRmFjdG9yeShzaGFwZVR5cGUpO1xuICAgICAgICAgIHZhciBjZmcgPSB7XG4gICAgICAgICAgICBjb2xvcjogZ2VvbS5nZXREZWZhdWx0VmFsdWUoJ2NvbG9yJylcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBtYXJrZXIgPSBzaGFwZU9iamVjdC5nZXRNYXJrZXJDZmcoc2hhcGUsIGNmZyk7XG4gICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtYXJrZXI6IG1hcmtlclxuICAgICAgICAgIH07XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGVuZCBvZiBnZW9tIGxvb3BcbiAgICB9KTsgLy8gZW5kIG9mIHNjYWxlIGxvb3BcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgY3VzdG9tOiB0cnVlLFxuICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgfTtcbiAgICBzZWxmLm9wdGlvbnMgPSBVdGlsLmRlZXBNaXgoe30sIG9wdGlvbnMsIHNlbGYub3B0aW9ucyk7XG4gICAgdmFyIGxlZ2VuZCA9IHNlbGYuYWRkQ3VzdG9tTGVnZW5kKCk7XG5cbiAgICBzZWxmLl9iaW5kQ2xpY2tFdmVudEZvck1peChsZWdlbmQpO1xuICB9O1xuXG4gIF9wcm90by5hbGlnbkxlZ2VuZHMgPSBmdW5jdGlvbiBhbGlnbkxlZ2VuZHMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsZWdlbmRzID0gc2VsZi5sZWdlbmRzO1xuXG4gICAgdmFyIHRvdGFsUmVnaW9uID0gc2VsZi5fZ2V0UmVnaW9uKGxlZ2VuZHMpO1xuXG4gICAgc2VsZi50b3RhbFJlZ2lvbiA9IHRvdGFsUmVnaW9uO1xuICAgIHZhciBpID0gMDtcbiAgICBVdGlsLmVhY2gobGVnZW5kcywgZnVuY3Rpb24gKGxlZ2VuZEl0ZW1zLCBwb3NpdGlvbikge1xuICAgICAgdmFyIHJlZ2lvbiA9XG4gICAgICAvKiBzZWxmLl9nZXRSZWdpb24obGVnZW5kSXRlbXMpKi9cbiAgICAgIHRvdGFsUmVnaW9uLnN1YnNbaV07XG4gICAgICBVdGlsLmVhY2gobGVnZW5kSXRlbXMsIGZ1bmN0aW9uIChsZWdlbmQsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcmUgPSBsZWdlbmRJdGVtc1tpbmRleCAtIDFdO1xuXG4gICAgICAgIGlmICghKGxlZ2VuZC5nZXQoJ3VzZUh0bWwnKSAmJiAhbGVnZW5kLmdldCgnYXV0b1Bvc2l0aW9uJykpKSB7XG4gICAgICAgICAgc2VsZi5fYWxpZ25MZWdlbmQobGVnZW5kLCBwcmUsIHJlZ2lvbiwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGkrKztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gTGVnZW5kQ29udHJvbGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmRDb250cm9sbGVyO1xuXG4vKioqLyB9KSxcbi8qIDM1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBjbGFzcyBvZiB0YWlsIGxlZ2VuZFxuICogQGF1dGhvciBZZSBMaXVcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApOyAvLyBjb25zdCBDYXRlZ29yeSA9IHJlcXVpcmUoJy4vY2F0ZWdvcnknKTtcblxuXG52YXIgQ29tcG9uZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIExlZ2VuZCA9IENvbXBvbmVudHMuTGVnZW5kO1xudmFyIENhdGVnb3J5ID0gTGVnZW5kLkNhdGVnb3J5O1xuXG52YXIgVGFpbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NhdGVnb3J5KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhaWwsIF9DYXRlZ29yeSk7XG5cbiAgZnVuY3Rpb24gVGFpbCgpIHtcbiAgICByZXR1cm4gX0NhdGVnb3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYWlsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9DYXRlZ29yeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIC8qKlxuICAgICAgICogdHlwZeagh+ivhlxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgdHlwZTogJ3RhaWwtbGVnZW5kJyxcblxuICAgICAgLyoqXG4gICAgICAgKiDluIPlsYDmlrnlvI9cbiAgICAgICAqIGhvcml6b250YWwg5rC05bmzXG4gICAgICAgKiB2ZXJ0aWNhbCDlnoLnm7RcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGxheW91dDogJ3ZlcnRpY2FsJyxcbiAgICAgIGF1dG9MYXlvdXQ6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZEl0ZW0gPSBmdW5jdGlvbiBfYWRkSXRlbShpdGVtKSB7XG4gICAgdmFyIGl0ZW1zR3JvdXAgPSB0aGlzLmdldCgnaXRlbXNHcm91cCcpO1xuXG4gICAgdmFyIHggPSB0aGlzLl9nZXROZXh0WCgpO1xuXG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciB1bkNoZWNrQ29sb3IgPSB0aGlzLmdldCgndW5DaGVja0NvbG9yJyk7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IGl0ZW1zR3JvdXAuYWRkR3JvdXAoe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICAgIHNjYWxlVmFsdWU6IGl0ZW0uc2NhbGVWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGl0ZW0uY2hlY2tlZFxuICAgIH0pO1xuICAgIGl0ZW1Hcm91cC50cmFuc2xhdGUoeCwgeSk7XG4gICAgaXRlbUdyb3VwLnNldCgndmlld0lkJywgaXRlbXNHcm91cC5nZXQoJ3ZpZXdJZCcpKTtcbiAgICB2YXIgdGV4dFN0eWxlID0gdGhpcy5nZXQoJ3RleHRTdHlsZScpO1xuICAgIHZhciB3b3JkU3BhY2UgPSB0aGlzLmdldCgnX3dvcmRTcGFjZWluZycpO1xuICAgIHZhciBzdGFydFggPSAwO1xuXG4gICAgaWYgKGl0ZW0ubWFya2VyKSB7XG4gICAgICAvLyDlpoLmnpzmnIltYXJrZXLmt7vliqBtYXJrZXJcbiAgICAgIHZhciBtYXJrZXJBdHRycyA9IFV0aWwubWl4KHt9LCBpdGVtLm1hcmtlciwge1xuICAgICAgICB4OiBpdGVtLm1hcmtlci5yYWRpdXMsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWl0ZW0uY2hlY2tlZCkge1xuICAgICAgICBpZiAobWFya2VyQXR0cnMuZmlsbCkge1xuICAgICAgICAgIG1hcmtlckF0dHJzLmZpbGwgPSB1bkNoZWNrQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya2VyQXR0cnMuc3Ryb2tlKSB7XG4gICAgICAgICAgbWFya2VyQXR0cnMuc3Ryb2tlID0gdW5DaGVja0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJrZXJTaGFwZSA9IGl0ZW1Hcm91cC5hZGRTaGFwZSgnbWFya2VyJywge1xuICAgICAgICB0eXBlOiAnbWFya2VyJyxcbiAgICAgICAgYXR0cnM6IG1hcmtlckF0dHJzXG4gICAgICB9KTtcbiAgICAgIG1hcmtlclNoYXBlLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgICBtYXJrZXJTaGFwZS5uYW1lID0gJ2xlZ2VuZC1tYXJrZXInO1xuICAgICAgc3RhcnRYICs9IG1hcmtlclNoYXBlLmdldEJCb3goKS53aWR0aCArIHdvcmRTcGFjZTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dEF0dHJzID0gVXRpbC5taXgoe30sIHRleHRTdHlsZSwge1xuICAgICAgeDogc3RhcnRYLFxuICAgICAgeTogMCxcbiAgICAgIHRleHQ6IHRoaXMuX2Zvcm1hdEl0ZW1WYWx1ZShpdGVtLnZhbHVlKVxuICAgIH0pO1xuXG4gICAgaWYgKCFpdGVtLmNoZWNrZWQpIHtcbiAgICAgIFV0aWwubWl4KHRleHRBdHRycywge1xuICAgICAgICBmaWxsOiB1bkNoZWNrQ29sb3JcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0ZXh0U2hhcGUgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICBhdHRyczogdGV4dEF0dHJzXG4gICAgfSk7XG4gICAgdGV4dFNoYXBlLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJyk7XG4gICAgdGV4dFNoYXBlLm5hbWUgPSAnbGVnZW5kLXRleHQnO1xuICAgIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykgJiYgdGV4dFNoYXBlLnNldFNpbGVudCgnYXBwZW5kSW5mbycsIHRoaXMuZ2V0KCdhcHBlbmRJbmZvJykpOyAvLyDmt7vliqDkuIDkuKrljIXlm7Tnn6nlvaLvvIznlKjkuo7kuovku7bmlK/mjIFcblxuICAgIHZhciBiYm94ID0gaXRlbUdyb3VwLmdldEJCb3goKTtcbiAgICB2YXIgaXRlbVdpZHRoID0gdGhpcy5nZXQoJ2l0ZW1XaWR0aCcpO1xuICAgIHZhciB3cmFwcGVyU2hhcGUgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5IC0gYmJveC5oZWlnaHQgLyAyLFxuICAgICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLFxuICAgICAgICB3aWR0aDogaXRlbVdpZHRoIHx8IGJib3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3cmFwcGVyU2hhcGUuYXR0cignY3Vyc29yJywgJ3BvaW50ZXInKTtcbiAgICB3cmFwcGVyU2hhcGUuc2V0U2lsZW50KCdvcmlnaW4nLCBpdGVtKTsgLy8g5L+d5a2Y5Zu+5L6L6aG555u45YWz55qE5pWw5o2u77yM5L6/5LqO5LqL5Lu25pON5L2cXG5cbiAgICB3cmFwcGVyU2hhcGUubmFtZSA9ICdsZWdlbmQtaXRlbSc7XG4gICAgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSAmJiB3cmFwcGVyU2hhcGUuc2V0U2lsZW50KCdhcHBlbmRJbmZvJywgdGhpcy5nZXQoJ2FwcGVuZEluZm8nKSk7XG4gICAgaXRlbUdyb3VwLm5hbWUgPSAnbGVnZW5kR3JvdXAnO1xuICAgIHJldHVybiBpdGVtR3JvdXA7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGp1c3QgPSBmdW5jdGlvbiBfYWRqdXN0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ2VvbSA9IHNlbGYuZ2V0KCdnZW9tJyk7XG5cbiAgICBpZiAoZ2VvbSkge1xuICAgICAgdmFyIGdyb3VwTWF0cml4ID0gc2VsZi5nZXQoJ2dyb3VwJykuYXR0cignbWF0cml4Jyk7XG4gICAgICBncm91cE1hdHJpeFs3XSA9IDA7XG4gICAgICB2YXIgZGF0YUFycmF5ID0gc2VsZi5nZXQoJ2dlb20nKS5nZXQoJ2RhdGFBcnJheScpO1xuICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ2V0KCdpdGVtc0dyb3VwJykuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIFV0aWwuZWFjaChncm91cHMsIGZ1bmN0aW9uIChncm91cEl0ZW0pIHtcbiAgICAgICAgdmFyIGRBcnJheSA9IGRhdGFBcnJheVtpbmRleF07XG4gICAgICAgIHZhciBsYXN0WSA9IGRBcnJheVtkQXJyYXkubGVuZ3RoIC0gMV0ueTtcblxuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KGxhc3RZKSkge1xuICAgICAgICAgIGxhc3RZID0gbGFzdFlbMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSBncm91cEl0ZW0uZ2V0QkJveCgpLmhlaWdodDtcbiAgICAgICAgdmFyIHggPSBncm91cEl0ZW0uZ2V0KCd4Jyk7XG4gICAgICAgIHZhciB5ID0gbGFzdFkgLSBncm91cEhlaWdodCAvIDI7XG4gICAgICAgIGdyb3VwSXRlbS50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGYuZ2V0KCdhdXRvTGF5b3V0JykpIHtcbiAgICAgICAgc2VsZi5fYW50aUNvbGxpc2lvbihncm91cHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfQ2F0ZWdvcnkucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5nZXQoJ2NoYXJ0Jyk7XG4gICAgY2hhcnQub25jZSgnYWZ0ZXJwYWludCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9hZGp1c3QoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFByZXZpb3VzWSA9IGZ1bmN0aW9uIF9nZXRQcmV2aW91c1koaXRlbSkge1xuICAgIHZhciB5ID0gaXRlbS5hdHRyKCdtYXRyaXgnKVs3XTtcbiAgICB2YXIgaGVpZ2h0ID0gaXRlbS5nZXRCQm94KCkuaGVpZ2h0O1xuICAgIHJldHVybiB5ICsgaGVpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5fYWRqdXN0RGVub3RlID0gZnVuY3Rpb24gX2FkanVzdERlbm90ZShncm91cCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBtYXJnaW4gPSBHbG9iYWwubGVnZW5kLmxlZ2VuZE1hcmdpbjtcbiAgICB2YXIgeDAgPSAtMjtcbiAgICB2YXIgeDIgPSAtbWFyZ2luICogMjtcbiAgICBncm91cC5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIHBhdGg6ICdNJyArIHgwICsgJywnICsgc3RhcnQgKyAnTCcgKyB4MiArICcsJyArIChlbmQgKyAzKSxcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBsaW5lRGFzaDogWzIsIDJdLFxuICAgICAgICBzdHJva2U6ICcjOTk5OTk5J1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fYW50aUNvbGxpc2lvbiA9IGZ1bmN0aW9uIF9hbnRpQ29sbGlzaW9uKGl0ZW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBheSA9IGEuYXR0cignbWF0cml4JylbN107XG4gICAgICB2YXIgYnkgPSBiLmF0dHIoJ21hdHJpeCcpWzddO1xuICAgICAgcmV0dXJuIGF5IC0gYnk7XG4gICAgfSk7XG4gICAgdmFyIG92ZXJsYXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgcGxvdFJhbmdlID0gc2VsZi5nZXQoJ2NoYXJ0JykuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICB2YXIgc3RhcnRZID0gcGxvdFJhbmdlLnRsLnk7XG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5hYnMoc3RhcnRZIC0gcGxvdFJhbmdlLmJsLnkpO1xuICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gaXRlbXNbMF0uZ2V0QkJveCgpLmhlaWdodDtcbiAgICB2YXIgbWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgdmFyIG1heFkgPSAwO1xuICAgIHZhciBib3hlcyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHkgPSBpdGVtLmF0dHIoJ21hdHJpeCcpWzddO1xuXG4gICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogaXRlbS5nZXRCQm94KCkuaGVpZ2h0LFxuICAgICAgICB0YXJnZXRzOiBbeSAtIHN0YXJ0WV1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWluWSAtPSBzdGFydFk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKG92ZXJsYXBwaW5nKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm94ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBib3ggPSBib3hlc1tfaV07XG4gICAgICAgIHZhciB0YXJnZXQgPSAoTWF0aC5taW4uYXBwbHkobWluWSwgYm94LnRhcmdldHMpICsgTWF0aC5tYXguYXBwbHkobWluWSwgYm94LnRhcmdldHMpKSAvIDI7XG4gICAgICAgIGJveC5wb3MgPSBNYXRoLm1pbihNYXRoLm1heChtaW5ZLCB0YXJnZXQgLSBib3guc2l6ZSAvIDIpLCB0b3RhbEhlaWdodCAtIGJveC5zaXplKTtcbiAgICAgIH1cblxuICAgICAgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcbiAgICAgIGkgPSBib3hlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gYm94ZXNbaSAtIDFdO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gYm94ZXNbaV07XG5cbiAgICAgICAgICBpZiAocHJldmlvdXMucG9zICsgcHJldmlvdXMuc2l6ZSA+IGN1cnJlbnQucG9zKSB7XG4gICAgICAgICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgICAgICAgcHJldmlvdXMuc2l6ZSArPSBjdXJyZW50LnNpemU7XG4gICAgICAgICAgICBwcmV2aW91cy50YXJnZXRzID0gcHJldmlvdXMudGFyZ2V0cy5jb25jYXQoY3VycmVudC50YXJnZXRzKTtcbiAgICAgICAgICAgIGJveGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIG9mIHdoaWxlIGlcblxuICAgIH0gLy8gZW5kIG9mIHdoaWxlXG4gICAgLy8gYWRqdXN0IHlcblxuXG4gICAgaSA9IDA7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5nZXQoJ2l0ZW1zR3JvdXAnKS5hZGRHcm91cCgpO1xuICAgIGJveGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBwb3NJbkNvbXBvc2l0ZUJveCA9IHN0YXJ0WSArIGVsZW1lbnRIZWlnaHQ7XG4gICAgICBiLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5feSA9IGl0ZW1zW2ldLmF0dHIoJ21hdHJpeCcpWzddO1xuICAgICAgICB2YXIgeSA9IGIucG9zICsgcG9zSW5Db21wb3NpdGVCb3ggLSBlbGVtZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhvcmlnaW5feSAtIHkpO1xuXG4gICAgICAgIGlmIChkaXN0ID4gZWxlbWVudEhlaWdodCAvIDIpIHtcbiAgICAgICAgICBzZWxmLl9hZGp1c3REZW5vdGUoZ3JvdXAsIHksIG9yaWdpbl95IC0gc2VsZi5nZXQoJ2dyb3VwJykuYXR0cignbWF0cml4JylbN10gLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zW2ldLnRyYW5zbGF0ZSgwLCAtb3JpZ2luX3kpO1xuICAgICAgICBpdGVtc1tpXS50cmFuc2xhdGUoMCwgeSk7XG4gICAgICAgIHBvc0luQ29tcG9zaXRlQm94ICs9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIGkrKztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9OyAvLyBlbmQgb2YgYW50aUNvbGxpc2lvblxuXG5cbiAgcmV0dXJuIFRhaWw7XG59KENhdGVnb3J5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWlsO1xuXG4vKioqLyB9KSxcbi8qIDM1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGNvbnRyb2xsZXIgb2YgdG9vbHRpcFxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpLFxuICAgIFRvb2x0aXAgPSBfcmVxdWlyZS5Ub29sdGlwO1xuXG52YXIgTWF0cml4VXRpbCA9IFV0aWwuTWF0cml4VXRpbDtcbnZhciBWZWN0b3IyID0gTWF0cml4VXRpbC52ZWMyO1xudmFyIFRZUEVfU0hPV19NQVJLRVJTID0gWydsaW5lJywgJ2FyZWEnLCAncGF0aCcsICdhcmVhU3RhY2snXTsgLy8g6buY6K6k5bGV56S6IHRvb2x0aXAgbWFya2VyIOeahOWHoOS9leWbvuW9olxuXG52YXIgVFlQRV9TSE9XX0NST1NTSEFJUlMgPSBbJ2xpbmUnLCAnYXJlYSddOyAvLyDpu5jorqTlsZXnpLrljYHlrZfnnoTlh4bnur/nmoTlh6DkvZXlm77lvaJcbi8vIFRPRE8gRklYTUUgdGhpcyBpcyBIQVJEIENPRElOR1xuXG52YXIgSUdOT1JFX1RPT0xUSVBfSVRFTV9QUk9QRVJUSUVTID0gWydtYXJrZXInLCAnc2hvd01hcmtlciddO1xuXG5mdW5jdGlvbiBfaW5kZXhPZkFycmF5KGl0ZW1zLCBpdGVtKSB7XG4gIHZhciByc3QgPSAtMTtcbiAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoc3ViLCBpbmRleCkge1xuICAgIHZhciBpc0VxdWFsID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIElHTk9SRV9UT09MVElQX0lURU1fUFJPUEVSVElFUy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIGlmICghVXRpbC5pc09iamVjdChpdGVtW2tleV0pICYmIGl0ZW1ba2V5XSAhPT0gc3ViW2tleV0pIHtcbiAgICAgICAgICBpc0VxdWFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFcXVhbCkge1xuICAgICAgcnN0ID0gaW5kZXg7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJzdDtcbn0gLy8g5Yik5pat5piv5ZCm5pyJ5qC35byPXG5cblxuZnVuY3Rpb24gX2hhc0NsYXNzKGRvbSwgY2xhc3NOYW1lKSB7XG4gIGlmICghZG9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGNscyA9ICcnO1xuICBpZiAoIWRvbS5jbGFzc05hbWUpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVV0aWwuaXNOaWwoZG9tLmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgIGNscyA9IGRvbS5jbGFzc05hbWUuYmFzZVZhbDtcbiAgfSBlbHNlIHtcbiAgICBjbHMgPSBkb20uY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGNscy5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfaXNQYXJlbnQoZG9tLCBjbHMpIHtcbiAgdmFyIHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICB2YXIgcnN0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAoX2hhc0NsYXNzKHBhcmVudCwgY2xzKSkge1xuICAgICAgcnN0ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHJzdDtcbn0gLy8g5Y676Zmk6YeN5aSN55qE5YC8LCDljrvpmaTkuI3lkIzlm77lvaLnm7jlkIzmlbDmja7vvIzlj6rlsZXnpLrkuIDku73ljbPlj69cblxuXG5mdW5jdGlvbiBfdW5pcUl0ZW1zKGl0ZW1zKSB7XG4gIHZhciB0bXAgPSBbXTtcbiAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBpbmRleCA9IF9pbmRleE9mQXJyYXkodG1wLCBpdGVtKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRtcC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBbaW5kZXhdID0gaXRlbTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdG1wO1xufVxuXG52YXIgVG9vbHRpcENvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb29sdGlwQ29udHJvbGxlcihjZmcpIHtcbiAgICBVdGlsLmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIHRoaXMudGltZVN0YW1wID0gMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb29sdGlwQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9ub3JtYWxpemVFdmVudCA9IGZ1bmN0aW9uIF9ub3JtYWxpemVFdmVudChldmVudCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5fZ2V0Q2FudmFzKCk7XG5cbiAgICB2YXIgcG9pbnQgPSBjYW52YXMuZ2V0UG9pbnRCeUNsaWVudChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGNhbnZhcy5nZXQoJ3BpeGVsUmF0aW8nKTtcbiAgICBwb2ludC54ID0gcG9pbnQueCAvIHBpeGVsUmF0aW87XG4gICAgcG9pbnQueSA9IHBvaW50LnkgLyBwaXhlbFJhdGlvO1xuICAgIHZhciB2aWV3cyA9IGNoYXJ0LmdldFZpZXdzQnlQb2ludChwb2ludCk7XG4gICAgcG9pbnQudmlld3MgPSB2aWV3cztcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRDYW52YXMgPSBmdW5jdGlvbiBfZ2V0Q2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldCgnY2FudmFzJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRUcmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiBfZ2V0VHJpZ2dlckV2ZW50KCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciB0cmlnZ2VyT24gPSBvcHRpb25zLnRyaWdnZXJPbjtcbiAgICB2YXIgZXZlbnROYW1lO1xuXG4gICAgaWYgKCF0cmlnZ2VyT24gfHwgdHJpZ2dlck9uID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgZXZlbnROYW1lID0gJ3Bsb3Rtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHRyaWdnZXJPbiA9PT0gJ2NsaWNrJykge1xuICAgICAgZXZlbnROYW1lID0gJ3Bsb3RjbGljayc7XG4gICAgfSBlbHNlIGlmICh0cmlnZ2VyT24gPT09ICdub25lJykge1xuICAgICAgZXZlbnROYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0RGVmYXVsdFRvb2x0aXBDZmcgPSBmdW5jdGlvbiBfZ2V0RGVmYXVsdFRvb2x0aXBDZmcoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHNlbGYudmlld1RoZW1lO1xuICAgIHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIHZhciBkZWZhdWx0Q2ZnID0gVXRpbC5taXgoe30sIHZpZXdUaGVtZS50b29sdGlwKTtcbiAgICB2YXIgZ2VvbXMgPSBjaGFydC5nZXRBbGxHZW9tcygpLmZpbHRlcihmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgcmV0dXJuIGdlb20uZ2V0KCd2aXNpYmxlJyk7XG4gICAgfSk7XG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgIHZhciB0eXBlID0gZ2VvbS5nZXQoJ3R5cGUnKTtcbiAgICAgIHZhciBhZGp1c3RzID0gZ2VvbS5nZXQoJ2FkanVzdHMnKTtcbiAgICAgIHZhciBpc1N5bW1ldHJpYyA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWRqdXN0cykge1xuICAgICAgICBVdGlsLmVhY2goYWRqdXN0cywgZnVuY3Rpb24gKGFkanVzdCkge1xuICAgICAgICAgIGlmIChhZGp1c3QudHlwZSA9PT0gJ3N5bW1ldHJpYycgfHwgYWRqdXN0LnR5cGUgPT09ICdTeW1tZXRyaWMnKSB7XG4gICAgICAgICAgICBpc1N5bW1ldHJpYyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWwuaW5kZXhPZihzaGFwZXMsIHR5cGUpID09PSAtMSAmJiAhaXNTeW1tZXRyaWMpIHtcbiAgICAgICAgc2hhcGVzLnB1c2godHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGlzVHJhbnNwb3NlZCA9IGdlb21zLmxlbmd0aCAmJiBnZW9tc1swXS5nZXQoJ2Nvb3JkJykgPyBnZW9tc1swXS5nZXQoJ2Nvb3JkJykuaXNUcmFuc3Bvc2VkIDogZmFsc2U7XG4gICAgdmFyIGNyb3NzaGFpcnNDZmc7XG5cbiAgICBpZiAoZ2VvbXMubGVuZ3RoICYmIGdlb21zWzBdLmdldCgnY29vcmQnKSAmJiBnZW9tc1swXS5nZXQoJ2Nvb3JkJykudHlwZSA9PT0gJ2NhcnRlc2lhbicpIHtcbiAgICAgIGlmIChzaGFwZXNbMF0gPT09ICdpbnRlcnZhbCcgJiYgb3B0aW9ucy5zaGFyZWQgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIOebtOinkuWdkOagh+ezu+S4iyBpbnRlcnZhbCDnmoQgY3Jvc3NoYWlyIOS4uuefqeW9ouiDjOaZr+ahhlxuICAgICAgICB2YXIgY3Jvc3NoYWlycyA9IFV0aWwubWl4KHt9LCB2aWV3VGhlbWUudG9vbHRpcENyb3NzaGFpcnNSZWN0KTtcbiAgICAgICAgY3Jvc3NoYWlycy5pc1RyYW5zcG9zZWQgPSBpc1RyYW5zcG9zZWQ7XG4gICAgICAgIGNyb3NzaGFpcnNDZmcgPSB7XG4gICAgICAgICAgekluZGV4OiAwLFxuICAgICAgICAgIC8vIOefqeW9ouiDjOaZr+ahhuS4jeWPr+imhuebliBnZW9tXG4gICAgICAgICAgY3Jvc3NoYWlyczogY3Jvc3NoYWlyc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChVdGlsLmluZGV4T2YoVFlQRV9TSE9XX0NST1NTSEFJUlMsIHNoYXBlc1swXSkgPiAtMSkge1xuICAgICAgICB2YXIgX2Nyb3NzaGFpcnMgPSBVdGlsLm1peCh7fSwgdmlld1RoZW1lLnRvb2x0aXBDcm9zc2hhaXJzTGluZSk7XG5cbiAgICAgICAgX2Nyb3NzaGFpcnMuaXNUcmFuc3Bvc2VkID0gaXNUcmFuc3Bvc2VkO1xuICAgICAgICBjcm9zc2hhaXJzQ2ZnID0ge1xuICAgICAgICAgIGNyb3NzaGFpcnM6IF9jcm9zc2hhaXJzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWwubWl4KGRlZmF1bHRDZmcsIGNyb3NzaGFpcnNDZmcsIHt9KTtcbiAgfTtcblxuICBfcHJvdG8uX2JpbmRFdmVudCA9IGZ1bmN0aW9uIF9iaW5kRXZlbnQoKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuICAgIHZhciB0cmlnZ2VyRXZlbnQgPSB0aGlzLl9nZXRUcmlnZ2VyRXZlbnQoKTtcblxuICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgIGNoYXJ0Lm9uKHRyaWdnZXJFdmVudCwgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ29uTW91c2VNb3ZlJykpO1xuICAgICAgY2hhcnQub24oJ3Bsb3RsZWF2ZScsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvbk1vdXNlT3V0JykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX29mZkV2ZW50ID0gZnVuY3Rpb24gX29mZkV2ZW50KCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICB2YXIgdHJpZ2dlckV2ZW50ID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50KCk7XG5cbiAgICBpZiAodHJpZ2dlckV2ZW50KSB7XG4gICAgICBjaGFydC5vZmYodHJpZ2dlckV2ZW50LCBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25Nb3VzZU1vdmUnKSk7XG4gICAgICBjaGFydC5vZmYoJ3Bsb3RsZWF2ZScsIFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdvbk1vdXNlT3V0JykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3NldFRvb2x0aXAgPSBmdW5jdGlvbiBfc2V0VG9vbHRpcChwb2ludCwgaXRlbXMsIG1hcmtlcnNJdGVtcywgdGFyZ2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0b29sdGlwID0gc2VsZi50b29sdGlwO1xuICAgIHZhciBwcmVQb2ludCA9IHNlbGYucHJlUG9pbnQ7XG5cbiAgICBpZiAoIXByZVBvaW50IHx8IHByZVBvaW50LnggIT09IHBvaW50LnggfHwgcHJlUG9pbnQueSAhPT0gcG9pbnQueSkge1xuICAgICAgaXRlbXMgPSBfdW5pcUl0ZW1zKGl0ZW1zKTtcbiAgICAgIHNlbGYucHJlUG9pbnQgPSBwb2ludDtcbiAgICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgICB2YXIgdmlld1RoZW1lID0gc2VsZi52aWV3VGhlbWU7XG4gICAgICB2YXIgeCA9IFV0aWwuaXNBcnJheShwb2ludC54KSA/IHBvaW50LnhbcG9pbnQueC5sZW5ndGggLSAxXSA6IHBvaW50Lng7XG4gICAgICB2YXIgeSA9IFV0aWwuaXNBcnJheShwb2ludC55KSA/IHBvaW50LnlbcG9pbnQueS5sZW5ndGggLSAxXSA6IHBvaW50Lnk7XG5cbiAgICAgIGlmICghdG9vbHRpcC5nZXQoJ3Zpc2libGUnKSkge1xuICAgICAgICBjaGFydC5lbWl0KCd0b29sdGlwOnNob3cnLCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRvb2x0aXA6IHRvb2x0aXBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdCA9IGl0ZW1zWzBdO1xuICAgICAgdmFyIHRpdGxlID0gZmlyc3QudGl0bGUgfHwgZmlyc3QubmFtZTtcblxuICAgICAgaWYgKHRvb2x0aXAuaXNDb250ZW50Q2hhbmdlKHRpdGxlLCBpdGVtcykpIHtcbiAgICAgICAgY2hhcnQuZW1pdCgndG9vbHRpcDpjaGFuZ2UnLCB7XG4gICAgICAgICAgdG9vbHRpcDogdG9vbHRpcCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgICAgIH0pOyAvLyBidWdmaXg6IHdoZW4gc2V0IHRoZSB0aXRsZSBpbiB0aGUgdG9vbHRpcDpjaGFuZ2UgZXZlbnQgZG9lcyBub3QgdGFrZSBlZmZlY3QuXG5cbiAgICAgICAgdGl0bGUgPSBpdGVtc1swXS50aXRsZSB8fCBpdGVtc1swXS5uYW1lO1xuICAgICAgICB0b29sdGlwLnNldENvbnRlbnQodGl0bGUsIGl0ZW1zKTtcblxuICAgICAgICBpZiAoIVV0aWwuaXNFbXB0eShtYXJrZXJzSXRlbXMpKSB7XG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5oaWRlTWFya2VycyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8g5LiN5bGV56S6IHRvb2x0aXAgbWFya2VyXG4gICAgICAgICAgICB0b29sdGlwLnNldCgnbWFya2VySXRlbXMnLCBtYXJrZXJzSXRlbXMpOyAvLyDnlKjkuo4gdG9vbHRpcCDovoXliqnnur/nmoTlrprkvY1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9vbHRpcC5zZXRNYXJrZXJzKG1hcmtlcnNJdGVtcywgdmlld1RoZW1lLnRvb2x0aXBNYXJrZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b29sdGlwLmNsZWFyTWFya2VycygpOyAvLyBjbGVhck1hcmtlcnMg5Y+q5Lya5bCGIG1hcmtlckl0ZW1zIOS7jiBtYXJrZXJHcm91cCDkuK3np7vpmaRcbiAgICAgICAgICAvLyDmiYDku6XmiJHku6zov5jopoHlsIYgbWFya2VySXRlbXMg5LuOIHRvb2x0aXAg5Lit56e76ZmkXG4gICAgICAgICAgLy8g6L+Z5LmI5YGa5piv5Li65LqG6Ziy5q2i5LiK5LiA5qyh6K6+572uIG1hcmtlciDml7bnmoQgbWFya2VySXRlbXMg5b2x5ZON5q2k5qyhIHRvb2x0aXAg6L6F5Yqp57q/55qE5a6a5L2NXG5cbiAgICAgICAgICB0b29sdGlwLnNldCgnbWFya2VySXRlbXMnLCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2dldENhbnZhcygpO1xuXG4gICAgICBpZiAodGFyZ2V0ID09PSBjYW52YXMgJiYgdG9vbHRpcC5nZXQoJ3R5cGUnKSA9PT0gJ21pbmknKSB7XG4gICAgICAgIC8vIGZpbHRlciBtaW5pIHRvb2x0aXBcbiAgICAgICAgdG9vbHRpcC5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b29sdGlwLnNldFBvc2l0aW9uKHgsIHksIHRhcmdldCk7XG4gICAgICAgIHRvb2x0aXAuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB2YXIgdG9vbHRpcCA9IHRoaXMudG9vbHRpcDtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2dldENhbnZhcygpO1xuXG4gICAgdGhpcy5wcmVQb2ludCA9IG51bGw7XG4gICAgdG9vbHRpcC5oaWRlKCk7XG4gICAgY2hhcnQuZW1pdCgndG9vbHRpcDpoaWRlJywge1xuICAgICAgdG9vbHRpcDogdG9vbHRpcFxuICAgIH0pO1xuICAgIGNhbnZhcy5kcmF3KCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXYpIHtcbiAgICBpZiAoVXRpbC5pc0VtcHR5KGV2LnZpZXdzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0VGltZVN0YW1wID0gdGhpcy50aW1lU3RhbXA7XG4gICAgdmFyIHRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBwb2ludCA9IHtcbiAgICAgIHg6IGV2LngsXG4gICAgICB5OiBldi55XG4gICAgfTtcblxuICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0VGltZVN0YW1wID4gMTYgJiYgIXRoaXMuY2hhcnQuZ2V0KCdzdG9wVG9vbHRpcCcpKSB7XG4gICAgICB0aGlzLnNob3dUb29sdGlwKHBvaW50LCBldi52aWV3cywgZXYuc2hhcGUpO1xuICAgICAgdGhpcy50aW1lU3RhbXAgPSB0aW1lU3RhbXA7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1vdXNlT3V0ID0gZnVuY3Rpb24gb25Nb3VzZU91dChldikge1xuICAgIHZhciB0b29sdGlwID0gdGhpcy50b29sdGlwOyAvLyBjb25zdCBjYW52YXMgPSB0aGlzLl9nZXRDYW52YXMoKTtcblxuICAgIGlmICghdG9vbHRpcC5nZXQoJ3Zpc2libGUnKSB8fCAhdG9vbHRpcC5nZXQoJ2ZvbGxvdycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDpmaTpnZ7nprvlvIAgcGxvdCDml7bpvKDmoIfkvp3nhLblnKjlm77lvaLkuIrvvIzov5nmrrXpgLvovpHmsqHmnInmhI/kuYlcbiAgICAvLyBpZiAoZXYgJiYgZXYudGFyZ2V0ICE9PSBjYW52YXMpIHtcbiAgICAvLyAgIHJldHVybjtcbiAgICAvLyB9XG5cblxuICAgIGlmIChldiAmJiBldi50b0VsZW1lbnQgJiYgKF9oYXNDbGFzcyhldi50b0VsZW1lbnQsICdnMi10b29sdGlwJykgfHwgX2lzUGFyZW50KGV2LnRvRWxlbWVudCwgJ2cyLXRvb2x0aXAnKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlclRvb2x0aXAgPSBmdW5jdGlvbiByZW5kZXJUb29sdGlwKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChzZWxmLnRvb2x0aXApIHtcbiAgICAgIC8vIHRvb2x0aXAg5a+56LGh5bey57uP5Yib5bu6XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoYXJ0ID0gc2VsZi5jaGFydDtcbiAgICB2YXIgdmlld1RoZW1lID0gc2VsZi52aWV3VGhlbWU7XG5cbiAgICB2YXIgY2FudmFzID0gc2VsZi5fZ2V0Q2FudmFzKCk7XG5cbiAgICB2YXIgZGVmYXVsdENmZyA9IHNlbGYuX2dldERlZmF1bHRUb29sdGlwQ2ZnKCk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICBvcHRpb25zID0gVXRpbC5kZWVwTWl4KHtcbiAgICAgIHBsb3RSYW5nZTogY2hhcnQuZ2V0KCdwbG90UmFuZ2UnKSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBmcm9udFBsb3Q6IGNoYXJ0LmdldCgnZnJvbnRQbG90JyksXG4gICAgICB2aWV3VGhlbWU6IHZpZXdUaGVtZS50b29sdGlwLFxuICAgICAgYmFja1Bsb3Q6IGNoYXJ0LmdldCgnYmFja1Bsb3QnKVxuICAgIH0sIGRlZmF1bHRDZmcsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuY3Jvc3NoYWlycyAmJiBvcHRpb25zLmNyb3NzaGFpcnMudHlwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICBvcHRpb25zLnpJbmRleCA9IDA7IC8vIHRvb2xpcCDog4zmma/moYbkuI3lj6/pga7nm5bkvY8gZ2Vvbe+8jOmYsuatoueUqOaIt+mFjee9ruS6hiBjcm9zc2hhaXJzXG4gICAgfVxuXG4gICAgb3B0aW9ucy52aXNpYmxlID0gZmFsc2U7IC8vIEAyMDE4LTA5LTEzIGJ5IGJsdWUubGIg5aaC5p6c6K6+572uc2hhcmVk5Li6ZmFsc2XkuI3pnIDopoHmjIflrppwb3NpdGlvblxuICAgIC8vIGlmIChvcHRpb25zLnNoYXJlZCA9PT0gZmFsc2UgJiYgVXRpbC5pc05pbChvcHRpb25zLnBvc2l0aW9uKSkge1xuICAgIC8vICAgb3B0aW9ucy5wb3NpdGlvbiA9ICd0b3AnO1xuICAgIC8vIH1cblxuICAgIHZhciB0b29sdGlwO1xuXG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ21pbmknKSB7XG4gICAgICBvcHRpb25zLmNyb3NzaGFpcnMgPSBmYWxzZTsgLy8gdGhpcy5vcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xuXG4gICAgICBvcHRpb25zLnBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICB0b29sdGlwID0gbmV3IFRvb2x0aXAuTWluaShvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudXNlSHRtbCkge1xuICAgICAgdG9vbHRpcCA9IG5ldyBUb29sdGlwLkh0bWwob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXAgPSBuZXcgVG9vbHRpcC5DYW52YXMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc2VsZi50b29sdGlwID0gdG9vbHRpcDtcblxuICAgIHZhciB0cmlnZ2VyRXZlbnQgPSBzZWxmLl9nZXRUcmlnZ2VyRXZlbnQoKTtcblxuICAgIGlmICghdG9vbHRpcC5nZXQoJ2VudGVyYWJsZScpICYmIHRyaWdnZXJFdmVudCA9PT0gJ3Bsb3Rtb3ZlJykge1xuICAgICAgLy8g6byg5qCH5LiN5YWB6K646L+b5YWlIHRvb2x0aXAg5a655ZmoXG4gICAgICB2YXIgdG9vbHRpcENvbnRhaW5lciA9IHRvb2x0aXAuZ2V0KCdjb250YWluZXInKTtcblxuICAgICAgaWYgKHRvb2x0aXBDb250YWluZXIpIHtcbiAgICAgICAgdG9vbHRpcENvbnRhaW5lci5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8g6YG/5YWNIHRvb2x0aXAg6aKR57mB6Zeq54OBXG4gICAgICAgICAgdmFyIGV2ZW50T2JqID0gc2VsZi5fbm9ybWFsaXplRXZlbnQoZSk7XG5cbiAgICAgICAgICBjaGFydC5lbWl0KHRyaWdnZXJFdmVudCwgZXZlbnRPYmopO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX2JpbmRFdmVudCgpO1xuICB9O1xuXG4gIF9wcm90by5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIHNob3dUb29sdGlwKHBvaW50LCB2aWV3cywgdGFyZ2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKFV0aWwuaXNFbXB0eSh2aWV3cykgfHwgIXBvaW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcbiAgICAgIHRoaXMucmVuZGVyVG9vbHRpcCgpOyAvLyDlpoLmnpzkuIDlvIDlp4sgdG9vbHRpcCDlhbPpl63vvIznlKjmiLfph43mlrDosIPnlKjnmoTml7blgJnpnIDopoHlhYjnlJ/miJAgdG9vbHRpcFxuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIHZhciBtYXJrZXJzSXRlbXMgPSBbXTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBVdGlsLmVhY2godmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICBpZiAoIXZpZXcuZ2V0KCd0b29sdGlwRW5hYmxlJykpIHtcbiAgICAgICAgLy8g5aaC5p6c5LiN5pi+56S6dG9vbHRpcO+8jOWImei3s+i/h1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21zID0gdmlldy5nZXQoJ2dlb21zJyk7XG4gICAgICB2YXIgY29vcmQgPSB2aWV3LmdldCgnY29vcmQnKTtcbiAgICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZW9tLmdldCgndHlwZScpO1xuXG4gICAgICAgIGlmIChnZW9tLmdldCgndmlzaWJsZScpICYmIGdlb20uZ2V0KCd0b29sdGlwQ2ZnJykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IGdlb20uZ2V0KCdkYXRhQXJyYXknKTtcblxuICAgICAgICAgIGlmIChnZW9tLmlzU2hhcmVUb29sdGlwKCkgfHwgb3B0aW9ucy5zaGFyZWQgPT09IGZhbHNlICYmIFV0aWwuaW5BcnJheShbJ2FyZWEnLCAnbGluZScsICdwYXRoJywgJ3BvbHlnb24nXSwgdHlwZSkpIHtcbiAgICAgICAgICAgIFV0aWwuZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgdmFyIHRtcFBvaW50ID0gZ2VvbS5maW5kUG9pbnQocG9pbnQsIG9iaik7XG5cbiAgICAgICAgICAgICAgaWYgKHRtcFBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Ykl0ZW1zID0gZ2VvbS5nZXRUaXBJdGVtcyh0bXBQb2ludCwgb3B0aW9ucy50aXRsZSk7XG4gICAgICAgICAgICAgICAgVXRpbC5lYWNoKHN1Ykl0ZW1zLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdi5wb2ludDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ICYmIHBvaW50LnggJiYgcG9pbnQueSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBob3RmaXg6IG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBudWxsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gVXRpbC5pc0FycmF5KHBvaW50LngpID8gcG9pbnQueFtwb2ludC54Lmxlbmd0aCAtIDFdIDogcG9pbnQueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBVdGlsLmlzQXJyYXkocG9pbnQueSkgPyBwb2ludC55W3BvaW50LnkubGVuZ3RoIC0gMV0gOiBwb2ludC55O1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGNvb3JkLmFwcGx5TWF0cml4KHgsIHksIDEpO1xuICAgICAgICAgICAgICAgICAgICB2LnggPSBwb2ludFswXTtcbiAgICAgICAgICAgICAgICAgICAgdi55ID0gcG9pbnRbMV07XG4gICAgICAgICAgICAgICAgICAgIHYuc2hvd01hcmtlciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1NYXJrZXIgPSBzZWxmLl9nZXRJdGVtTWFya2VyKGdlb20sIHYuY29sb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgIHYubWFya2VyID0gaXRlbU1hcmtlcjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5pbmRleE9mKFRZUEVfU0hPV19NQVJLRVJTLCB0eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJzSXRlbXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KHN1Ykl0ZW1zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBnZW9tQ29udGFpbmVyID0gZ2VvbS5nZXQoJ3NoYXBlQ29udGFpbmVyJyk7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZ2VvbUNvbnRhaW5lci5nZXQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBjYW52YXMuZ2V0KCdwaXhlbFJhdGlvJyk7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBnZW9tQ29udGFpbmVyLmdldFNoYXBlKHBvaW50LnggKiBwaXhlbFJhdGlvLCBwb2ludC55ICogcGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5nZXQoJ3Zpc2libGUnKSAmJiBzaGFwZS5nZXQoJ29yaWdpbicpKSB7XG4gICAgICAgICAgICAgIGl0ZW1zID0gZ2VvbS5nZXRUaXBJdGVtcyhzaGFwZS5nZXQoJ29yaWdpbicpLCBvcHRpb25zLnRpdGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgcG9pbnQgPSBpdGVtLnBvaW50O1xuICAgICAgICB2YXIgeCA9IFV0aWwuaXNBcnJheShwb2ludC54KSA/IHBvaW50LnhbcG9pbnQueC5sZW5ndGggLSAxXSA6IHBvaW50Lng7XG4gICAgICAgIHZhciB5ID0gVXRpbC5pc0FycmF5KHBvaW50LnkpID8gcG9pbnQueVtwb2ludC55Lmxlbmd0aCAtIDFdIDogcG9pbnQueTtcbiAgICAgICAgcG9pbnQgPSBjb29yZC5hcHBseU1hdHJpeCh4LCB5LCAxKTtcbiAgICAgICAgaXRlbS54ID0gcG9pbnRbMF07XG4gICAgICAgIGl0ZW0ueSA9IHBvaW50WzFdO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZmlyc3QgPSBpdGVtc1swXTsgLy8gYnVnZml4OiBtdWx0aXBsZSB0b29sdGlwIGl0ZW1zIHdpdGggZGlmZmVyZW50IHRpdGxlc1xuXG4gICAgICBpZiAoIWl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRpdGxlID09PSBmaXJzdC50aXRsZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBuZWFyZXN0SXRlbSA9IGZpcnN0O1xuICAgICAgICB2YXIgbmVhcmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBWZWN0b3IyLmRpc3RhbmNlKFtwb2ludC54LCBwb2ludC55XSwgW2l0ZW0ueCwgaXRlbS55XSk7XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBuZWFyZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgbmVhcmVzdEl0ZW0gPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0udGl0bGUgPT09IG5lYXJlc3RJdGVtLnRpdGxlO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFya2Vyc0l0ZW1zID0gbWFya2Vyc0l0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLnRpdGxlID09PSBuZWFyZXN0SXRlbS50aXRsZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZCA9PT0gZmFsc2UgJiYgaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgc25hcEl0ZW0gPSBpdGVtc1swXTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGguYWJzKHBvaW50LnkgLSBzbmFwSXRlbS55KTtcbiAgICAgICAgVXRpbC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoYUl0ZW0pIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMocG9pbnQueSAtIGFJdGVtLnkpIDw9IG1pbikge1xuICAgICAgICAgICAgc25hcEl0ZW0gPSBhSXRlbTtcbiAgICAgICAgICAgIG1pbiA9IE1hdGguYWJzKHBvaW50LnkgLSBhSXRlbS55KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzbmFwSXRlbSAmJiBzbmFwSXRlbS54ICYmIHNuYXBJdGVtLnkpIHtcbiAgICAgICAgICBtYXJrZXJzSXRlbXMgPSBbc25hcEl0ZW1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMgPSBbc25hcEl0ZW1dO1xuICAgICAgfSAvLyAzLjAg6YeH55So5b2T5YmN6byg5qCH5L2N572u5L2c5Li6IHRvb2x0aXAg55qE5Y+C6ICD54K5XG4gICAgICAvLyBpZiAoIVV0aWwuaXNFbXB0eShtYXJrZXJzSXRlbXMpKSB7XG4gICAgICAvLyAgIHBvaW50ID0gbWFya2Vyc0l0ZW1zWzBdO1xuICAgICAgLy8gfVxuXG5cbiAgICAgIHNlbGYuX3NldFRvb2x0aXAocG9pbnQsIGl0ZW1zLCBtYXJrZXJzSXRlbXMsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuaGlkZVRvb2x0aXAoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIHRvb2x0aXAgPSB0aGlzLnRvb2x0aXA7XG4gICAgdG9vbHRpcCAmJiB0b29sdGlwLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMucHJlUG9pbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fb2ZmRXZlbnQoKTtcbiAgfTtcblxuICBfcHJvdG8uX2dldEl0ZW1NYXJrZXIgPSBmdW5jdGlvbiBfZ2V0SXRlbU1hcmtlcihnZW9tLCBjb2xvcikge1xuICAgIHZhciBzaGFwZVR5cGUgPSBnZW9tLmdldCgnc2hhcGVUeXBlJykgfHwgJ3BvaW50JztcbiAgICB2YXIgc2hhcGUgPSBnZW9tLmdldERlZmF1bHRWYWx1ZSgnc2hhcGUnKSB8fCAnY2lyY2xlJztcbiAgICB2YXIgc2hhcGVPYmplY3QgPSBTaGFwZS5nZXRTaGFwZUZhY3Rvcnkoc2hhcGVUeXBlKTtcbiAgICB2YXIgY2ZnID0ge1xuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfTtcbiAgICB2YXIgbWFya2VyID0gc2hhcGVPYmplY3QuZ2V0TWFya2VyQ2ZnKHNoYXBlLCBjZmcpO1xuICAgIHJldHVybiBtYXJrZXI7XG4gIH07XG5cbiAgcmV0dXJuIFRvb2x0aXBDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXBDb250cm9sbGVyO1xuXG4vKioqLyB9KSxcbi8qIDM1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGNvbnRyb2xsZXIgb2YgY2hhcnQncyBldmVudHNcbiAqIEBhdXRob3Igc2ltYS56aGFuZ1xuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIGlzU2FtZVNoYXBlKHNoYXBlMSwgc2hhcGUyKSB7XG4gIGlmIChVdGlsLmlzTmlsKHNoYXBlMSkgfHwgVXRpbC5pc05pbChzaGFwZTIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHNoYXBlMU9yaWdpbiA9IHNoYXBlMS5nZXQoJ29yaWdpbicpO1xuICB2YXIgc2hhcGUyT3JpZ2luID0gc2hhcGUyLmdldCgnb3JpZ2luJyk7IC8vIGhvdGZpeDogaWYgYm90aCBzaGFwZXMgaGF2ZSBubyBkYXRh77yManVzdCBjb21wYXJlIHNoYXBlcy5cblxuICBpZiAoVXRpbC5pc05pbChzaGFwZTFPcmlnaW4pICYmIFV0aWwuaXNOaWwoc2hhcGUyT3JpZ2luKSkge1xuICAgIHJldHVybiBVdGlsLmlzRXF1YWwoc2hhcGUxLCBzaGFwZTIpO1xuICB9XG5cbiAgcmV0dXJuIFV0aWwuaXNFcXVhbChzaGFwZTFPcmlnaW4sIHNoYXBlMk9yaWdpbik7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGF0YShldmVudE9iaikge1xuICBpZiAoZXZlbnRPYmouc2hhcGUgJiYgZXZlbnRPYmouc2hhcGUuZ2V0KCdvcmlnaW4nKSkge1xuICAgIGV2ZW50T2JqLmRhdGEgPSBldmVudE9iai5zaGFwZS5nZXQoJ29yaWdpbicpO1xuICB9XG59XG5cbnZhciBFdmVudENvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudENvbnRyb2xsZXIoY2ZnKSB7XG4gICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgVXRpbC5hc3NpZ24odGhpcywgY2ZnKTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFdmVudENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHRoaXMuY2FudmFzLmdldCgncGl4ZWxSYXRpbycpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0U2hhcGVFdmVudE9iaiA9IGZ1bmN0aW9uIF9nZXRTaGFwZUV2ZW50T2JqKGV2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2LnggLyB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICB5OiBldi55IC8gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXG4gICAgICAvLyBjYW52YXMg5YWD57SgXG4gICAgICB0b0VsZW1lbnQ6IGV2LmV2ZW50LnRvRWxlbWVudCB8fCBldi5ldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFNoYXBlID0gZnVuY3Rpb24gX2dldFNoYXBlKHgsIHkpIHtcbiAgICB2YXIgdmlldyA9IHRoaXMudmlldztcbiAgICB2YXIgY29udGFpbmVyID0gdmlldy5nZXQoJ2NhbnZhcycpO1xuICAgIHJldHVybiBjb250YWluZXIuZ2V0U2hhcGUoeCwgeSk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRQb2ludEluZm8gPSBmdW5jdGlvbiBfZ2V0UG9pbnRJbmZvKGV2KSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgdmFyIHBvaW50ID0ge1xuICAgICAgeDogZXYueCAvIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgIHk6IGV2LnkgLyB0aGlzLnBpeGVsUmF0aW9cbiAgICB9O1xuICAgIHZhciB2aWV3cyA9IHZpZXcuZ2V0Vmlld3NCeVBvaW50KHBvaW50KTtcbiAgICBwb2ludC52aWV3cyA9IHZpZXdzO1xuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBfcHJvdG8uX2dldEV2ZW50T2JqID0gZnVuY3Rpb24gX2dldEV2ZW50T2JqKGV2LCBwb2ludCwgdmlld3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIC8vIGNhbnZhcyDlhYPntKBcbiAgICAgIHRvRWxlbWVudDogZXYuZXZlbnQudG9FbGVtZW50IHx8IGV2LmV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAvLyDnm67moIflhYPntKBcbiAgICAgIHZpZXdzOiB2aWV3c1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmJpbmRFdmVudHMgPSBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjYW52YXMub24oJ21vdXNlZG93bicsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvbkRvd24nKSk7XG4gICAgY2FudmFzLm9uKCdtb3VzZW1vdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnb25Nb3ZlJykpO1xuICAgIGNhbnZhcy5vbignbW91c2VsZWF2ZScsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvbk91dCcpKTtcbiAgICBjYW52YXMub24oJ21vdXNldXAnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnb25VcCcpKTtcbiAgICBjYW52YXMub24oJ2NsaWNrJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ29uQ2xpY2snKSk7XG4gICAgY2FudmFzLm9uKCdkYmxjbGljaycsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvbkNsaWNrJykpO1xuICAgIGNhbnZhcy5vbigndG91Y2hzdGFydCcsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvblRvdWNoc3RhcnQnKSk7XG4gICAgY2FudmFzLm9uKCd0b3VjaG1vdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnb25Ub3VjaG1vdmUnKSk7XG4gICAgY2FudmFzLm9uKCd0b3VjaGVuZCcsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdvblRvdWNoZW5kJykpO1xuICB9O1xuXG4gIF9wcm90by5fdHJpZ2dlclNoYXBlRXZlbnQgPSBmdW5jdGlvbiBfdHJpZ2dlclNoYXBlRXZlbnQoc2hhcGUsIGV2ZW50TmFtZSwgZXZlbnRPYmopIHtcbiAgICBpZiAoc2hhcGUgJiYgc2hhcGUubmFtZSAmJiAhc2hhcGUuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cbiAgICAgIGlmICh2aWV3LmlzU2hhcGVJblZpZXcoc2hhcGUpKSB7XG4gICAgICAgIHZhciBuYW1lID0gc2hhcGUubmFtZSArICc6JyArIGV2ZW50TmFtZTtcbiAgICAgICAgZXZlbnRPYmoudmlldyA9IHZpZXc7XG4gICAgICAgIGV2ZW50T2JqLmFwcGVuZEluZm8gPSBzaGFwZS5nZXQoJ2FwcGVuZEluZm8nKTsgLy8gYXBwZW5kSW5mbyBpcyBkZWZpbmVkIGJ5IHVzZXJcblxuICAgICAgICB2aWV3LmVtaXQobmFtZSwgZXZlbnRPYmopO1xuICAgICAgICB2YXIgcGFyZW50ID0gdmlldy5nZXQoJ3BhcmVudCcpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAvLyBjaGFydCDkuIrkuZ/pnIDopoHmipvlh7ror6Xkuovku7bvvIzmnKzmnJ/lhYjkuI3mipvlh7pcbiAgICAgICAgICBwYXJlbnQuZW1pdChuYW1lLCBldmVudE9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRG93biA9IGZ1bmN0aW9uIG9uRG93bihldikge1xuICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG4gICAgdmFyIGV2ZW50T2JqID0gdGhpcy5fZ2V0U2hhcGVFdmVudE9iaihldik7XG5cbiAgICBldmVudE9iai5zaGFwZSA9IHRoaXMuY3VycmVudFNoYXBlO1xuICAgIHJlZ2lzdGVyRGF0YShldmVudE9iaik7XG4gICAgdmlldy5lbWl0KCdtb3VzZWRvd24nLCBldmVudE9iaik7XG5cbiAgICB0aGlzLl90cmlnZ2VyU2hhcGVFdmVudCh0aGlzLmN1cnJlbnRTaGFwZSwgJ21vdXNlZG93bicsIGV2ZW50T2JqKTtcbiAgfTtcblxuICBfcHJvdG8ub25Nb3ZlID0gZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi52aWV3O1xuICAgIHZhciBjdXJyZW50U2hhcGUgPSBzZWxmLmN1cnJlbnRTaGFwZTsgLy8g5aaC5p6c5Zu+5b2i6KKr6ZSA5q+B77yM5YiZ6K6+572u5b2T5YmNIHNoYXBlIOS4uuepulxuXG4gICAgaWYgKGN1cnJlbnRTaGFwZSAmJiBjdXJyZW50U2hhcGUuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgY3VycmVudFNoYXBlID0gbnVsbDtcbiAgICAgIHNlbGYuY3VycmVudFNoYXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBzZWxmLl9nZXRTaGFwZShldi54LCBldi55KSB8fCBldi5jdXJyZW50VGFyZ2V0O1xuXG4gICAgdmFyIGV2ZW50T2JqID0gc2VsZi5fZ2V0U2hhcGVFdmVudE9iaihldik7XG5cbiAgICBldmVudE9iai5zaGFwZSA9IHNoYXBlO1xuICAgIHJlZ2lzdGVyRGF0YShldmVudE9iaik7XG4gICAgdmlldy5lbWl0KCdtb3VzZW1vdmUnLCBldmVudE9iaik7XG5cbiAgICBzZWxmLl90cmlnZ2VyU2hhcGVFdmVudChzaGFwZSwgJ21vdXNlbW92ZScsIGV2ZW50T2JqKTtcblxuICAgIGlmIChjdXJyZW50U2hhcGUgJiYgIWlzU2FtZVNoYXBlKGN1cnJlbnRTaGFwZSwgc2hhcGUpKSB7XG4gICAgICB2YXIgbGVhdmVPYmogPSBzZWxmLl9nZXRTaGFwZUV2ZW50T2JqKGV2KTtcblxuICAgICAgbGVhdmVPYmouc2hhcGUgPSBjdXJyZW50U2hhcGU7XG4gICAgICBsZWF2ZU9iai50b1NoYXBlID0gc2hhcGU7XG4gICAgICByZWdpc3RlckRhdGEobGVhdmVPYmopO1xuXG4gICAgICBzZWxmLl90cmlnZ2VyU2hhcGVFdmVudChjdXJyZW50U2hhcGUsICdtb3VzZWxlYXZlJywgbGVhdmVPYmopO1xuICAgIH1cblxuICAgIGlmIChzaGFwZSAmJiAhaXNTYW1lU2hhcGUoY3VycmVudFNoYXBlLCBzaGFwZSkpIHtcbiAgICAgIHZhciBlbnRlck9iaiA9IHNlbGYuX2dldFNoYXBlRXZlbnRPYmooZXYpO1xuXG4gICAgICBlbnRlck9iai5zaGFwZSA9IHNoYXBlO1xuICAgICAgZW50ZXJPYmouZnJvbVNoYXBlID0gY3VycmVudFNoYXBlO1xuICAgICAgcmVnaXN0ZXJEYXRhKGVudGVyT2JqKTtcblxuICAgICAgc2VsZi5fdHJpZ2dlclNoYXBlRXZlbnQoc2hhcGUsICdtb3VzZWVudGVyJywgZW50ZXJPYmopO1xuICAgIH1cblxuICAgIHNlbGYuY3VycmVudFNoYXBlID0gc2hhcGU7XG5cbiAgICB2YXIgcG9pbnQgPSBzZWxmLl9nZXRQb2ludEluZm8oZXYpO1xuXG4gICAgdmFyIHByZVZpZXdzID0gc2VsZi5jdXJWaWV3cyB8fCBbXTtcblxuICAgIGlmIChwcmVWaWV3cy5sZW5ndGggPT09IDAgJiYgcG9pbnQudmlld3MubGVuZ3RoKSB7XG4gICAgICB2aWV3LmVtaXQoJ3Bsb3RlbnRlcicsIHNlbGYuX2dldEV2ZW50T2JqKGV2LCBwb2ludCwgcG9pbnQudmlld3MpKTtcbiAgICB9IC8vIHBvaW50LnZpZXdzIOaYr+aMh+W9k+WJjSB2aWV3IOaIluiAheWtkCB2aWV377yM5LiN5Lya5Y+W6Lef5b2T5YmNIHZpZXcg5ZCM5LiA5bGC57qn55qE5YWE5byf5YWD57Sg77yIdmlldylcblxuXG4gICAgaWYgKHByZVZpZXdzLmxlbmd0aCAmJiBwb2ludC52aWV3cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZpZXcuZW1pdCgncGxvdGxlYXZlJywgc2VsZi5fZ2V0RXZlbnRPYmooZXYsIHBvaW50LCBwcmVWaWV3cykpO1xuICAgIH1cblxuICAgIGlmIChwb2ludC52aWV3cy5sZW5ndGgpIHtcbiAgICAgIGV2ZW50T2JqID0gc2VsZi5fZ2V0RXZlbnRPYmooZXYsIHBvaW50LCBwb2ludC52aWV3cyk7XG4gICAgICBldmVudE9iai5zaGFwZSA9IHNoYXBlO1xuICAgICAgcmVnaXN0ZXJEYXRhKGV2ZW50T2JqKTtcbiAgICAgIHZpZXcuZW1pdCgncGxvdG1vdmUnLCBldmVudE9iaik7XG4gICAgfVxuXG4gICAgc2VsZi5jdXJWaWV3cyA9IHBvaW50LnZpZXdzO1xuICB9O1xuXG4gIF9wcm90by5vbk91dCA9IGZ1bmN0aW9uIG9uT3V0KGV2KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gc2VsZi52aWV3O1xuXG4gICAgdmFyIHBvaW50ID0gc2VsZi5fZ2V0UG9pbnRJbmZvKGV2KTtcblxuICAgIHZhciBwcmVWaWV3cyA9IHNlbGYuY3VyVmlld3MgfHwgW107XG5cbiAgICB2YXIgZXZ0T2JqID0gc2VsZi5fZ2V0RXZlbnRPYmooZXYsIHBvaW50LCBwcmVWaWV3cyk7IC8vIOWPquacieayoeaciXBhZGRpbmcg5pe277yM5b2T5YmN5L6d54S25ZyoIHZpZXcg55qEIHBsb3RSYW5nZSDmg4XlhrXkuIvmiY3kvJrlh7rnjrDov5nkuKrmg4XlhrXvvIzkv53or4EgcGxvdGxlYXZlIOinpuWPkVxuXG5cbiAgICBpZiAoc2VsZi5jdXJWaWV3cyAmJiBzZWxmLmN1clZpZXdzLmxlbmd0aCAhPT0gMCAmJiAoIWV2dE9iai50b0VsZW1lbnQgfHwgZXZ0T2JqLnRvRWxlbWVudC50YWdOYW1lICE9PSAnQ0FOVkFTJykpIHtcbiAgICAgIHZpZXcuZW1pdCgncGxvdGxlYXZlJywgZXZ0T2JqKTtcbiAgICAgIHNlbGYuY3VyVmlld3MgPSBbXTsgLy8g5riF56m6XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vblVwID0gZnVuY3Rpb24gb25VcChldikge1xuICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG4gICAgdmFyIGV2ZW50T2JqID0gdGhpcy5fZ2V0U2hhcGVFdmVudE9iaihldik7XG5cbiAgICBldmVudE9iai5zaGFwZSA9IHRoaXMuY3VycmVudFNoYXBlO1xuICAgIHZpZXcuZW1pdCgnbW91c2V1cCcsIGV2ZW50T2JqKTtcblxuICAgIHRoaXMuX3RyaWdnZXJTaGFwZUV2ZW50KHRoaXMuY3VycmVudFNoYXBlLCAnbW91c2V1cCcsIGV2ZW50T2JqKTtcbiAgfTtcblxuICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZpZXcgPSBzZWxmLnZpZXc7XG4gICAgdmFyIHNoYXBlID0gc2VsZi5fZ2V0U2hhcGUoZXYueCwgZXYueSkgfHwgZXYuY3VycmVudFRhcmdldDtcblxuICAgIHZhciBzaGFwZUV2ZW50T2JqID0gc2VsZi5fZ2V0U2hhcGVFdmVudE9iaihldik7XG5cbiAgICBzaGFwZUV2ZW50T2JqLnNoYXBlID0gc2hhcGU7XG4gICAgcmVnaXN0ZXJEYXRhKHNoYXBlRXZlbnRPYmopO1xuICAgIHZpZXcuZW1pdCgnY2xpY2snLCBzaGFwZUV2ZW50T2JqKTtcblxuICAgIHNlbGYuX3RyaWdnZXJTaGFwZUV2ZW50KHNoYXBlLCBldi50eXBlLCBzaGFwZUV2ZW50T2JqKTtcblxuICAgIHNlbGYuY3VycmVudFNoYXBlID0gc2hhcGU7XG5cbiAgICB2YXIgcG9pbnQgPSBzZWxmLl9nZXRQb2ludEluZm8oZXYpO1xuXG4gICAgdmFyIHZpZXdzID0gcG9pbnQudmlld3M7XG5cbiAgICBpZiAoIVV0aWwuaXNFbXB0eSh2aWV3cykpIHtcbiAgICAgIHZhciBldmVudE9iaiA9IHNlbGYuX2dldEV2ZW50T2JqKGV2LCBwb2ludCwgdmlld3MpO1xuXG4gICAgICBpZiAoc2VsZi5jdXJyZW50U2hhcGUpIHtcbiAgICAgICAgdmFyIF9zaGFwZSA9IHNlbGYuY3VycmVudFNoYXBlO1xuICAgICAgICBldmVudE9iai5zaGFwZSA9IF9zaGFwZTtcbiAgICAgICAgcmVnaXN0ZXJEYXRhKGV2ZW50T2JqKTsgLy8gZXZlbnRPYmouZGF0YSA9IHNoYXBlLmdldCgnb3JpZ2luJyk7XG4gICAgICB9XG5cbiAgICAgIHZpZXcuZW1pdCgncGxvdGNsaWNrJywgZXZlbnRPYmopO1xuXG4gICAgICBpZiAoZXYudHlwZSA9PT0gJ2RibGNsaWNrJykge1xuICAgICAgICB2aWV3LmVtaXQoJ3Bsb3RkYmxjbGljaycsIGV2ZW50T2JqKTtcbiAgICAgICAgdmlldy5lbWl0KCdkYmxjbGljaycsIHNoYXBlRXZlbnRPYmopO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25Ub3VjaHN0YXJ0ID0gZnVuY3Rpb24gb25Ub3VjaHN0YXJ0KGV2KSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5fZ2V0U2hhcGUoZXYueCwgZXYueSkgfHwgZXYuY3VycmVudFRhcmdldDtcblxuICAgIHZhciBldmVudE9iaiA9IHRoaXMuX2dldFNoYXBlRXZlbnRPYmooZXYpO1xuXG4gICAgZXZlbnRPYmouc2hhcGUgPSBzaGFwZTtcbiAgICByZWdpc3RlckRhdGEoZXZlbnRPYmopO1xuICAgIHZpZXcuZW1pdCgndG91Y2hzdGFydCcsIGV2ZW50T2JqKTtcblxuICAgIHRoaXMuX3RyaWdnZXJTaGFwZUV2ZW50KHNoYXBlLCAndG91Y2hzdGFydCcsIGV2ZW50T2JqKTtcblxuICAgIHRoaXMuY3VycmVudFNoYXBlID0gc2hhcGU7XG4gIH07XG5cbiAgX3Byb3RvLm9uVG91Y2htb3ZlID0gZnVuY3Rpb24gb25Ub3VjaG1vdmUoZXYpIHtcbiAgICB2YXIgdmlldyA9IHRoaXMudmlldztcbiAgICB2YXIgc2hhcGUgPSB0aGlzLl9nZXRTaGFwZShldi54LCBldi55KSB8fCBldi5jdXJyZW50VGFyZ2V0O1xuXG4gICAgdmFyIGV2ZW50T2JqID0gdGhpcy5fZ2V0U2hhcGVFdmVudE9iaihldik7XG5cbiAgICBldmVudE9iai5zaGFwZSA9IHNoYXBlO1xuICAgIHJlZ2lzdGVyRGF0YShldmVudE9iaik7XG4gICAgdmlldy5lbWl0KCd0b3VjaG1vdmUnLCBldmVudE9iaik7XG5cbiAgICB0aGlzLl90cmlnZ2VyU2hhcGVFdmVudChzaGFwZSwgJ3RvdWNobW92ZScsIGV2ZW50T2JqKTtcblxuICAgIHRoaXMuY3VycmVudFNoYXBlID0gc2hhcGU7XG4gIH07XG5cbiAgX3Byb3RvLm9uVG91Y2hlbmQgPSBmdW5jdGlvbiBvblRvdWNoZW5kKGV2KSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cbiAgICB2YXIgZXZlbnRPYmogPSB0aGlzLl9nZXRTaGFwZUV2ZW50T2JqKGV2KTtcblxuICAgIGV2ZW50T2JqLnNoYXBlID0gdGhpcy5jdXJyZW50U2hhcGU7XG4gICAgcmVnaXN0ZXJEYXRhKGV2ZW50T2JqKTtcbiAgICB2aWV3LmVtaXQoJ3RvdWNoZW5kJywgZXZlbnRPYmopO1xuXG4gICAgdGhpcy5fdHJpZ2dlclNoYXBlRXZlbnQodGhpcy5jdXJyZW50U2hhcGUsICd0b3VjaGVuZCcsIGV2ZW50T2JqKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJFdmVudHMgPSBmdW5jdGlvbiBjbGVhckV2ZW50cygpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY2FudmFzLm9mZignbW91c2Vtb3ZlJywgVXRpbC5nZXRXcmFwQmVoYXZpb3IodGhpcywgJ29uTW92ZScpKTtcbiAgICBjYW52YXMub2ZmKCdtb3VzZWxlYXZlJywgVXRpbC5nZXRXcmFwQmVoYXZpb3IodGhpcywgJ29uT3V0JykpO1xuICAgIGNhbnZhcy5vZmYoJ21vdXNlZG93bicsIFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdvbkRvd24nKSk7XG4gICAgY2FudmFzLm9mZignbW91c2V1cCcsIFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdvblVwJykpO1xuICAgIGNhbnZhcy5vZmYoJ2NsaWNrJywgVXRpbC5nZXRXcmFwQmVoYXZpb3IodGhpcywgJ29uQ2xpY2snKSk7XG4gICAgY2FudmFzLm9mZignZGJsY2xpY2snLCBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25DbGljaycpKTtcbiAgICBjYW52YXMub2ZmKCd0b3VjaHN0YXJ0JywgVXRpbC5nZXRXcmFwQmVoYXZpb3IodGhpcywgJ29uVG91Y2hzdGFydCcpKTtcbiAgICBjYW52YXMub2ZmKCd0b3VjaG1vdmUnLCBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25Ub3VjaG1vdmUnKSk7XG4gICAgY2FudmFzLm9mZigndG91Y2hlbmQnLCBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25Ub3VjaGVuZCcpKTtcbiAgfTtcblxuICByZXR1cm4gRXZlbnRDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Q29udHJvbGxlcjtcblxuLyoqKi8gfSksXG4vKiAzNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBlbnRyeSBvZiBjaGFydCdzIGFuaW1hdGlvblxuICogQGF1dGhvciBzaW1hLnpoYW5nXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEFuaW1hdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG5cbnZhciBNYXRyaXhVdGlsID0gVXRpbC5NYXRyaXhVdGlsO1xudmFyIG1hdDMgPSBNYXRyaXhVdGlsLm1hdDM7IC8vIOiOt+WPluWbvue7hOWGheaJgOacieeahHNoYXBlc1xuXG5mdW5jdGlvbiBnZXRTaGFwZXMoY29udGFpbmVyLCB2aWV3SWQpIHtcbiAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gIGlmIChjb250YWluZXIuZ2V0KCdhbmltYXRlJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmdldCgnY2hpbGRyZW4nKTtcbiAgVXRpbC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuaXNHcm91cCkge1xuICAgICAgc2hhcGVzID0gc2hhcGVzLmNvbmNhdChnZXRTaGFwZXMoY2hpbGQsIHZpZXdJZCkpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNTaGFwZSAmJiBjaGlsZC5faWQpIHtcbiAgICAgIHZhciBpZCA9IGNoaWxkLl9pZDtcbiAgICAgIGlkID0gaWQuc3BsaXQoJy0nKVswXTtcblxuICAgICAgaWYgKGlkID09PSB2aWV3SWQpIHtcbiAgICAgICAgc2hhcGVzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaGFwZXM7XG59XG5cbmZ1bmN0aW9uIGNhY2hlKHNoYXBlcykge1xuICB2YXIgcnN0ID0ge307XG4gIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICghc2hhcGUuX2lkIHx8IHNoYXBlLmlzQ2xpcCkgcmV0dXJuO1xuICAgIHZhciBpZCA9IHNoYXBlLl9pZDtcbiAgICByc3RbaWRdID0ge1xuICAgICAgX2lkOiBpZCxcbiAgICAgIHR5cGU6IHNoYXBlLmdldCgndHlwZScpLFxuICAgICAgYXR0cnM6IFV0aWwuY2xvbmVEZWVwKHNoYXBlLmF0dHIoKSksXG4gICAgICAvLyDljp/lp4vlsZ7mgKdcbiAgICAgIG5hbWU6IHNoYXBlLm5hbWUsXG4gICAgICBpbmRleDogc2hhcGUuZ2V0KCdpbmRleCcpLFxuICAgICAgYW5pbWF0ZUNmZzogc2hhcGUuZ2V0KCdhbmltYXRlQ2ZnJyksXG4gICAgICBjb29yZDogc2hhcGUuZ2V0KCdjb29yZCcpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGUoZ2VvbVR5cGUsIGNvb3JkLCBhbmltYXRpb25UeXBlLCBhbmltYXRpb25OYW1lKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKGFuaW1hdGlvbk5hbWUpIHtcbiAgICByZXN1bHQgPSBBbmltYXRlLkFjdGlvblthbmltYXRpb25UeXBlXVthbmltYXRpb25OYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBBbmltYXRlLmdldEFuaW1hdGlvbihnZW9tVHlwZSwgY29vcmQsIGFuaW1hdGlvblR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0ZUNmZyhnZW9tVHlwZSwgYW5pbWF0aW9uVHlwZSwgYW5pbWF0ZUNmZykge1xuICB2YXIgZGVmYXVsdENmZyA9IEFuaW1hdGUuZ2V0QW5pbWF0ZUNmZyhnZW9tVHlwZSwgYW5pbWF0aW9uVHlwZSk7XG5cbiAgaWYgKGFuaW1hdGVDZmcgJiYgYW5pbWF0ZUNmZ1thbmltYXRpb25UeXBlXSkge1xuICAgIHJldHVybiBVdGlsLmRlZXBNaXgoe30sIGRlZmF1bHRDZmcsIGFuaW1hdGVDZmdbYW5pbWF0aW9uVHlwZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRDZmc7XG59XG5cbmZ1bmN0aW9uIGFkZEFuaW1hdGUoY2FjaGUsIHNoYXBlcywgY2FudmFzLCBpc1VwZGF0ZSkge1xuICB2YXIgYW5pbWF0ZTtcbiAgdmFyIGFuaW1hdGVDZmc7XG4gIHZhciBjYW52YXNEcmF3biA9IGZhbHNlO1xuXG4gIGlmIChpc1VwZGF0ZSkge1xuICAgIC8vIFN0ZXA6IGxlYXZlIC0+IHVwZGF0ZSAtPiBlbnRlclxuICAgIHZhciB1cGRhdGVTaGFwZXMgPSBbXTsgLy8g5a2Y5YKo55qE5pivIHNoYXBlc1xuXG4gICAgdmFyIG5ld1NoYXBlcyA9IFtdOyAvLyDlrZjlgqjnmoTmmK8gc2hhcGVzXG5cbiAgICBVdGlsLmVhY2goc2hhcGVzLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjYWNoZVtzaGFwZS5faWRdO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBuZXdTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5zZXRTaWxlbnQoJ2NhY2hlU2hhcGUnLCByZXN1bHQpO1xuICAgICAgICB1cGRhdGVTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtzaGFwZS5faWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFV0aWwuZWFjaChjYWNoZSwgZnVuY3Rpb24gKGRlbGV0ZWRTaGFwZSkge1xuICAgICAgdmFyIG5hbWUgPSBkZWxldGVkU2hhcGUubmFtZSxcbiAgICAgICAgICBjb29yZCA9IGRlbGV0ZWRTaGFwZS5jb29yZCxcbiAgICAgICAgICBfaWQgPSBkZWxldGVkU2hhcGUuX2lkLFxuICAgICAgICAgIGF0dHJzID0gZGVsZXRlZFNoYXBlLmF0dHJzLFxuICAgICAgICAgIGluZGV4ID0gZGVsZXRlZFNoYXBlLmluZGV4LFxuICAgICAgICAgIHR5cGUgPSBkZWxldGVkU2hhcGUudHlwZTtcbiAgICAgIGFuaW1hdGVDZmcgPSBnZXRBbmltYXRlQ2ZnKG5hbWUsICdsZWF2ZScsIGRlbGV0ZWRTaGFwZS5hbmltYXRlQ2ZnKTtcbiAgICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKG5hbWUsIGNvb3JkLCAnbGVhdmUnLCBhbmltYXRlQ2ZnLmFuaW1hdGlvbik7XG5cbiAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZSkpIHtcbiAgICAgICAgdmFyIHRlbXBTaGFwZSA9IGNhbnZhcy5hZGRTaGFwZSh0eXBlLCB7XG4gICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgdGVtcFNoYXBlLl9pZCA9IF9pZDtcbiAgICAgICAgdGVtcFNoYXBlLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChjb29yZCAmJiBuYW1lICE9PSAnbGFiZWwnKSB7XG4gICAgICAgICAgdmFyIHRlbXBTaGFwZU1hdHJpeCA9IHRlbXBTaGFwZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICB2YXIgZmluYWxNYXRyaXggPSBtYXQzLm11bHRpcGx5KFtdLCB0ZW1wU2hhcGVNYXRyaXgsIGNvb3JkLm1hdHJpeCk7XG4gICAgICAgICAgdGVtcFNoYXBlLnNldE1hdHJpeChmaW5hbE1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXNEcmF3biA9IHRydWU7XG4gICAgICAgIGFuaW1hdGUodGVtcFNoYXBlLCBhbmltYXRlQ2ZnLCBjb29yZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgVXRpbC5lYWNoKHVwZGF0ZVNoYXBlcywgZnVuY3Rpb24gKHVwZGF0ZVNoYXBlKSB7XG4gICAgICB2YXIgbmFtZSA9IHVwZGF0ZVNoYXBlLm5hbWU7XG4gICAgICB2YXIgY29vcmQgPSB1cGRhdGVTaGFwZS5nZXQoJ2Nvb3JkJyk7XG4gICAgICB2YXIgY2FjaGVBdHRycyA9IHVwZGF0ZVNoYXBlLmdldCgnY2FjaGVTaGFwZScpLmF0dHJzOyAvLyDliKTmlq3lpoLmnpzlsZ7mgKfnm7jlkIznmoTor53lsLHkuI3ov5vooYzlj5jmjaJcblxuICAgICAgaWYgKCFVdGlsLmlzRXF1YWwoY2FjaGVBdHRycywgdXBkYXRlU2hhcGUuYXR0cigpKSkge1xuICAgICAgICBhbmltYXRlQ2ZnID0gZ2V0QW5pbWF0ZUNmZyhuYW1lLCAndXBkYXRlJywgdXBkYXRlU2hhcGUuZ2V0KCdhbmltYXRlQ2ZnJykpO1xuICAgICAgICBhbmltYXRlID0gZ2V0QW5pbWF0ZShuYW1lLCBjb29yZCwgJ3VwZGF0ZScsIGFuaW1hdGVDZmcuYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGFuaW1hdGUpKSB7XG4gICAgICAgICAgYW5pbWF0ZSh1cGRhdGVTaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmRTdGF0ZSA9IFV0aWwuY2xvbmVEZWVwKHVwZGF0ZVNoYXBlLmF0dHIoKSk7XG4gICAgICAgICAgdXBkYXRlU2hhcGUuYXR0cihjYWNoZUF0dHJzKTtcbiAgICAgICAgICB1cGRhdGVTaGFwZS5hbmltYXRlKGVuZFN0YXRlLCBhbmltYXRlQ2ZnLmR1cmF0aW9uLCBhbmltYXRlQ2ZnLmVhc2luZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXBkYXRlU2hhcGUuc2V0U2lsZW50KCdjYWNoZVNoYXBlJywgbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXNEcmF3biA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgVXRpbC5lYWNoKG5ld1NoYXBlcywgZnVuY3Rpb24gKG5ld1NoYXBlKSB7XG4gICAgICB2YXIgbmFtZSA9IG5ld1NoYXBlLm5hbWU7XG4gICAgICB2YXIgY29vcmQgPSBuZXdTaGFwZS5nZXQoJ2Nvb3JkJyk7XG4gICAgICBhbmltYXRlQ2ZnID0gZ2V0QW5pbWF0ZUNmZyhuYW1lLCAnZW50ZXInLCBuZXdTaGFwZS5nZXQoJ2FuaW1hdGVDZmcnKSk7XG4gICAgICBhbmltYXRlID0gZ2V0QW5pbWF0ZShuYW1lLCBjb29yZCwgJ2VudGVyJywgYW5pbWF0ZUNmZy5hbmltYXRpb24pO1xuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGFuaW1hdGUpKSB7XG4gICAgICAgIGFuaW1hdGUobmV3U2hhcGUsIGFuaW1hdGVDZmcsIGNvb3JkKTtcbiAgICAgICAgY2FudmFzRHJhd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIG5hbWUgPSBzaGFwZS5uYW1lO1xuICAgICAgdmFyIGNvb3JkID0gc2hhcGUuZ2V0KCdjb29yZCcpO1xuICAgICAgYW5pbWF0ZUNmZyA9IGdldEFuaW1hdGVDZmcobmFtZSwgJ2FwcGVhcicsIHNoYXBlLmdldCgnYW5pbWF0ZUNmZycpKTtcbiAgICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKG5hbWUsIGNvb3JkLCAnYXBwZWFyJywgYW5pbWF0ZUNmZy5hbmltYXRpb24pO1xuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGFuaW1hdGUpKSB7XG4gICAgICAgIGFuaW1hdGUoc2hhcGUsIGFuaW1hdGVDZmcsIGNvb3JkKTtcbiAgICAgICAgY2FudmFzRHJhd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNhbnZhc0RyYXduO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXhlY0FuaW1hdGlvbjogZnVuY3Rpb24gZXhlY0FuaW1hdGlvbih2aWV3LCBpc1VwZGF0ZSkge1xuICAgIHZhciB2aWV3Q29udGFpbmVyID0gdmlldy5nZXQoJ21pZGRsZVBsb3QnKTtcbiAgICB2YXIgYXhpc0NvbnRhaW5lciA9IHZpZXcuZ2V0KCdiYWNrUGxvdCcpO1xuICAgIHZhciB2aWV3SWQgPSB2aWV3LmdldCgnX2lkJyk7XG4gICAgdmFyIGNhbnZhcyA9IHZpZXcuZ2V0KCdjYW52YXMnKTtcbiAgICB2YXIgY2FjaGVzID0gY2FudmFzLmdldCh2aWV3SWQgKyAnY2FjaGVzJykgfHwgW107XG5cbiAgICBpZiAoY2FjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaXNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVzID0gZ2V0U2hhcGVzKHZpZXdDb250YWluZXIsIHZpZXdJZCk7XG4gICAgdmFyIGF4aXNTaGFwZXMgPSBnZXRTaGFwZXMoYXhpc0NvbnRhaW5lciwgdmlld0lkKTtcbiAgICB2YXIgY2FjaGVTaGFwZXMgPSBzaGFwZXMuY29uY2F0KGF4aXNTaGFwZXMpO1xuICAgIGNhbnZhcy5zZXRTaWxlbnQodmlld0lkICsgJ2NhY2hlcycsIGNhY2hlKGNhY2hlU2hhcGVzKSk7XG4gICAgdmFyIGRyYXduO1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICBkcmF3biA9IGFkZEFuaW1hdGUoY2FjaGVzLCBjYWNoZVNoYXBlcywgY2FudmFzLCBpc1VwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXduID0gYWRkQW5pbWF0ZShjYWNoZXMsIHNoYXBlcywgY2FudmFzLCBpc1VwZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3bikge1xuICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGNsYXNzIG9mIGNhbnZhcyBwbG90XG4gKiBAYXV0aG9yIHNpbWEuemhhbmdcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcbiAgICBHcm91cCA9IF9yZXF1aXJlLkdyb3VwO1xuXG52YXIgQVVUT19TVFIgPSAnYXV0byc7XG5cbnZhciBQbG90QmFjayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dyb3VwKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBsb3RCYWNrLCBfR3JvdXApO1xuXG4gIGZ1bmN0aW9uIFBsb3RCYWNrKCkge1xuICAgIHJldHVybiBfR3JvdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsb3RCYWNrLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICog57G75Z6LXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICB0eXBlOiAncGxvdEJhY2snLFxuXG4gICAgICAvKipcbiAgICAgICAqIOeUu+W4g+i+uei3nVxuICAgICAgICogQHR5cGUge051bWJlciB8IEFycmF5IHwgT2JqZWN0IHwgXCJhdXRvXCJ9XG4gICAgICAgKi9cbiAgICAgIHBhZGRpbmc6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5aSn6IOM5pmvXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBiYWNrZ3JvdW5kOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOe7mOWbvuWMuuWfn+iMg+WbtFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgcGxvdFJhbmdlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOe7mOWbvuWMuuWfn+iDjOaZr1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgcGxvdEJhY2tncm91bmQ6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fYmVmb3JlUmVuZGVyVUkgPSBmdW5jdGlvbiBfYmVmb3JlUmVuZGVyVUkoKSB7XG4gICAgdGhpcy5fY2FsY3VsYXRlUmFuZ2UoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlclVJID0gZnVuY3Rpb24gX3JlbmRlclVJKCkge1xuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlclBsb3RCYWNrZ3JvdW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJCYWNrZ3JvdW5kID0gZnVuY3Rpb24gX3JlbmRlckJhY2tncm91bmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gc2VsZi5nZXQoJ2JhY2tncm91bmQnKTtcblxuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgICAgdmFyIHdpZHRoID0gc2VsZi5nZXQoJ3dpZHRoJykgfHwgY2FudmFzLmdldCgnd2lkdGgnKTtcbiAgICAgIHZhciBoZWlnaHQgPSBzZWxmLmdldCgnaGVpZ2h0JykgfHwgY2FudmFzLmdldCgnaGVpZ2h0Jyk7XG4gICAgICB2YXIgY2ZnID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgICAgdmFyIHJlY3QgPSBzZWxmLmdldCgnYmFja2dyb3VuZFNoYXBlJyk7XG5cbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICByZWN0ID0gdGhpcy5hZGRTaGFwZSgncmVjdCcsIHtcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoY2ZnLCBiYWNrZ3JvdW5kKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXQoJ2JhY2tncm91bmRTaGFwZScsIHJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdC5hdHRyKGNmZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJQbG90QmFja2dyb3VuZCA9IGZ1bmN0aW9uIF9yZW5kZXJQbG90QmFja2dyb3VuZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBsb3RCYWNrZ3JvdW5kID0gc2VsZi5nZXQoJ3Bsb3RCYWNrZ3JvdW5kJyk7XG5cbiAgICBpZiAocGxvdEJhY2tncm91bmQpIHtcbiAgICAgIHZhciBwbG90UmFuZ2UgPSBzZWxmLmdldCgncGxvdFJhbmdlJyk7XG4gICAgICB2YXIgd2lkdGggPSBwbG90UmFuZ2UuYnIueCAtIHBsb3RSYW5nZS5ibC54O1xuICAgICAgdmFyIGhlaWdodCA9IHBsb3RSYW5nZS5ici55IC0gcGxvdFJhbmdlLnRyLnk7XG4gICAgICB2YXIgdGwgPSBwbG90UmFuZ2UudGw7XG4gICAgICB2YXIgY2ZnID0ge1xuICAgICAgICB4OiB0bC54LFxuICAgICAgICB5OiB0bC55LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgICAgdmFyIHBsb3RCYWNrU2hhcGUgPSBzZWxmLmdldCgncGxvdEJhY2tTaGFwZScpO1xuXG4gICAgICBpZiAoIXBsb3RCYWNrU2hhcGUpIHtcbiAgICAgICAgaWYgKHBsb3RCYWNrZ3JvdW5kLmltYWdlKSB7XG4gICAgICAgICAgY2ZnLmltZyA9IHBsb3RCYWNrZ3JvdW5kLmltYWdlO1xuICAgICAgICAgIHBsb3RCYWNrU2hhcGUgPSBzZWxmLmFkZFNoYXBlKCdpbWFnZScsIHtcbiAgICAgICAgICAgIGF0dHJzOiBjZmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnn6nlvaJcbiAgICAgICAgICBVdGlsLm1peChjZmcsIHBsb3RCYWNrZ3JvdW5kKTtcbiAgICAgICAgICBwbG90QmFja1NoYXBlID0gc2VsZi5hZGRTaGFwZSgncmVjdCcsIHtcbiAgICAgICAgICAgIGF0dHJzOiBjZmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc2V0KCdwbG90QmFja1NoYXBlJywgcGxvdEJhY2tTaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbG90QmFja1NoYXBlLmF0dHIoY2ZnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NvbnZlcnQgPSBmdW5jdGlvbiBfY29udmVydCh2YWwsIGlzSG9yaXpvbnRhbCkge1xuICAgIGlmIChVdGlsLmlzU3RyaW5nKHZhbCkpIHtcbiAgICAgIGlmICh2YWwgPT09IEFVVE9fU1RSKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCd3aWR0aCcpIHx8IGNhbnZhcy5nZXQoJ3dpZHRoJyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldCgnaGVpZ2h0JykgfHwgY2FudmFzLmdldCgnaGVpZ2h0Jyk7XG4gICAgICAgIHZhbCA9IHBhcnNlSW50KHZhbCwgMTApIC8gMTAwO1xuICAgICAgICB2YWwgPSBpc0hvcml6b250YWwgPyB2YWwgKiB3aWR0aCA6IHZhbCAqIGhlaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIF9wcm90by5fY2FsY3VsYXRlUmFuZ2UgPSBmdW5jdGlvbiBfY2FsY3VsYXRlUmFuZ2UoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwbG90UmFuZ2UgPSBzZWxmLmdldCgncGxvdFJhbmdlJyk7XG5cbiAgICBpZiAoVXRpbC5pc05pbChwbG90UmFuZ2UpKSB7XG4gICAgICBwbG90UmFuZ2UgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IHNlbGYuZ2V0KCdwYWRkaW5nJyk7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0KCdjYW52YXMnKTtcbiAgICB2YXIgd2lkdGggPSBzZWxmLmdldCgnd2lkdGgnKSB8fCBjYW52YXMuZ2V0KCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHQgPSBzZWxmLmdldCgnaGVpZ2h0JykgfHwgY2FudmFzLmdldCgnaGVpZ2h0Jyk7XG4gICAgdmFyIGFsbFBhZGRpbmcgPSBVdGlsLnRvQWxsUGFkZGluZyhwYWRkaW5nKTtcblxuICAgIHZhciB0b3AgPSBzZWxmLl9jb252ZXJ0KGFsbFBhZGRpbmdbMF0sIGZhbHNlKTtcblxuICAgIHZhciByaWdodCA9IHNlbGYuX2NvbnZlcnQoYWxsUGFkZGluZ1sxXSwgdHJ1ZSk7XG5cbiAgICB2YXIgYm90dG9tID0gc2VsZi5fY29udmVydChhbGxQYWRkaW5nWzJdLCBmYWxzZSk7XG5cbiAgICB2YXIgbGVmdCA9IHNlbGYuX2NvbnZlcnQoYWxsUGFkZGluZ1szXSwgdHJ1ZSk7XG5cbiAgICB2YXIgbWluWCA9IE1hdGgubWluKGxlZnQsIHdpZHRoIC0gcmlnaHQpO1xuICAgIHZhciBtYXhYID0gTWF0aC5tYXgobGVmdCwgd2lkdGggLSByaWdodCk7XG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbihoZWlnaHQgLSBib3R0b20sIHRvcCk7XG4gICAgdmFyIG1heFkgPSBNYXRoLm1heChoZWlnaHQgLSBib3R0b20sIHRvcCk7XG4gICAgcGxvdFJhbmdlLnRsID0ge1xuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1pbllcbiAgICB9OyAvLyB0b3AtbGVmdFxuXG4gICAgcGxvdFJhbmdlLnRyID0ge1xuICAgICAgeDogbWF4WCxcbiAgICAgIHk6IG1pbllcbiAgICB9OyAvLyB0b3AtcmlnaHRcblxuICAgIHBsb3RSYW5nZS5ibCA9IHtcbiAgICAgIHg6IG1pblgsXG4gICAgICB5OiBtYXhZXG4gICAgfTsgLy8gYm90dG9tLWxlZnRcblxuICAgIHBsb3RSYW5nZS5iciA9IHtcbiAgICAgIHg6IG1heFgsXG4gICAgICB5OiBtYXhZXG4gICAgfTsgLy8gYm90dG9tLXJpZ2h0XG5cbiAgICBwbG90UmFuZ2UuY2MgPSB7XG4gICAgICB4OiAobWF4WCArIG1pblgpIC8gMixcbiAgICAgIHk6IChtYXhZICsgbWluWSkgLyAyXG4gICAgfTtcbiAgICB0aGlzLnNldCgncGxvdFJhbmdlJywgcGxvdFJhbmdlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVwYWludCA9IGZ1bmN0aW9uIHJlcGFpbnQoKSB7XG4gICAgdGhpcy5fY2FsY3VsYXRlUmFuZ2UoKTtcblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcblxuICAgIHRoaXMuX3JlbmRlclBsb3RCYWNrZ3JvdW5kKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gUGxvdEJhY2s7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbG90QmFjaztcblxuLyoqKi8gfSksXG4vKiAzNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOmcgOimgeiuoeeul+aJgOWNoHjovbTkuIrnmoTlrr3luqbnmoTovoXliqnnsbtcbiAqIEBhdXRob3Igc2ltYS56aGFuZzE5OTBAZ21haWwuY29tXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTsgLy8g5bey57uP5o6S5bqP5ZCO55qE5pWw5o2u5p+l5om+6Led56a75pyA5bCP55qEXG5cblxuZnVuY3Rpb24gZmluZE1pbkRpc3RhbmNlKGFyciwgc2NhbGUpIHtcbiAgdmFyIGNvdW50ID0gYXJyLmxlbmd0aDsgLy8g5pel5pyf57G75Z6L55qEIHZhbHVlcyDnu4/luLjkuIrmlofmnKznsbvlnovvvIzmiYDku6XpnIDopoHovazmjaLkuIDkuItcblxuICBpZiAoVXRpbC5pc1N0cmluZyhhcnJbMF0pKSB7XG4gICAgYXJyID0gYXJyLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHNjYWxlLnRyYW5zbGF0ZSh2KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkaXN0YW5jZSA9IGFyclsxXSAtIGFyclswXTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGNvdW50OyBpKyspIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldIC0gYXJyW2kgLSAxXTtcblxuICAgIGlmIChkaXN0YW5jZSA+IHRtcCkge1xuICAgICAgZGlzdGFuY2UgPSB0bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG52YXIgU2l6ZU1peGluID0ge1xuICBnZXREZWZhdWx0U2l6ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdFNpemUoKSB7XG4gICAgdmFyIGRlZmF1bHRTaXplID0gdGhpcy5nZXQoJ2RlZmF1bHRTaXplJyk7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHRoaXMuZ2V0KCd2aWV3VGhlbWUnKSB8fCBHbG9iYWw7XG5cbiAgICBpZiAoIWRlZmF1bHRTaXplKSB7XG4gICAgICB2YXIgY29vcmQgPSB0aGlzLmdldCgnY29vcmQnKTtcbiAgICAgIHZhciB4U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgICAgdmFyIHhWYWx1ZXMgPSB4U2NhbGUudmFsdWVzO1xuICAgICAgdmFyIGRhdGFBcnJheSA9IHRoaXMuZ2V0KCdkYXRhQXJyYXknKTtcbiAgICAgIHZhciBjb3VudDtcblxuICAgICAgaWYgKHhTY2FsZS5pc0xpbmVhciAmJiB4VmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgeFZhbHVlcy5zb3J0KCk7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IGZpbmRNaW5EaXN0YW5jZSh4VmFsdWVzLCB4U2NhbGUpO1xuICAgICAgICBjb3VudCA9ICh4U2NhbGUubWF4IC0geFNjYWxlLm1pbikgLyBpbnRlcnZhbDtcblxuICAgICAgICBpZiAoeFZhbHVlcy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgICAgIGNvdW50ID0geFZhbHVlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0geFZhbHVlcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHhTY2FsZS5yYW5nZTtcbiAgICAgIHZhciBub3JtYWxpemVTaXplID0gMSAvIGNvdW50O1xuICAgICAgdmFyIHdpZHRoUmF0aW8gPSAxO1xuXG4gICAgICBpZiAodGhpcy5pc0luQ2lyY2xlKCkpIHtcbiAgICAgICAgaWYgKGNvb3JkLmlzVHJhbnNwb3NlZCAmJiBjb3VudCA+IDEpIHtcbiAgICAgICAgICAvLyDmnoHlnZDmoIfkuIvlpJrlsYLnjq/lm75cbiAgICAgICAgICB3aWR0aFJhdGlvID0gdmlld1RoZW1lLndpZHRoUmF0aW8ubXVsdGlwbGVQaWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGhSYXRpbyA9IHZpZXdUaGVtZS53aWR0aFJhdGlvLnJvc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgKGRhdGFBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbm9ybWFsaXplU2l6ZSAqPSAocmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgIH0gKi9cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHhTY2FsZS5pc0xpbmVhcikge1xuICAgICAgICAgIG5vcm1hbGl6ZVNpemUgKj0gcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoUmF0aW8gPSB2aWV3VGhlbWUud2lkdGhSYXRpby5jb2x1bW47IC8vIOafseeKtuWbvuimgemZpOS7pTJcbiAgICAgIH1cblxuICAgICAgbm9ybWFsaXplU2l6ZSAqPSB3aWR0aFJhdGlvO1xuXG4gICAgICBpZiAodGhpcy5oYXNBZGp1c3QoJ2RvZGdlJykpIHtcbiAgICAgICAgdmFyIGRvZGdlQ291bnQgPSB0aGlzLl9nZXREb2RnZUNvdW50KGRhdGFBcnJheSk7XG5cbiAgICAgICAgbm9ybWFsaXplU2l6ZSA9IG5vcm1hbGl6ZVNpemUgLyBkb2RnZUNvdW50O1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0U2l6ZSA9IG5vcm1hbGl6ZVNpemU7XG4gICAgICB0aGlzLnNldCgnZGVmYXVsdFNpemUnLCBkZWZhdWx0U2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRTaXplO1xuICB9LFxuICBfZ2V0RG9kZ2VDb3VudDogZnVuY3Rpb24gX2dldERvZGdlQ291bnQoZGF0YUFycmF5KSB7XG4gICAgdmFyIGFkanVzdHMgPSB0aGlzLmdldCgnYWRqdXN0cycpO1xuICAgIHZhciBkb2RnZUJ5O1xuICAgIHZhciBjb3VudCA9IGRhdGFBcnJheS5sZW5ndGg7XG4gICAgVXRpbC5lYWNoKGFkanVzdHMsIGZ1bmN0aW9uIChhZGp1c3QpIHtcbiAgICAgIGlmIChhZGp1c3QudHlwZSA9PT0gJ2RvZGdlJykge1xuICAgICAgICBkb2RnZUJ5ID0gYWRqdXN0LmRvZGdlQnk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZG9kZ2VCeSkge1xuICAgICAgdmFyIG1lcmdlRGF0YSA9IFV0aWwuQXJyYXkubWVyZ2UoZGF0YUFycmF5KTtcbiAgICAgIHZhciB2YWx1ZXMgPSBVdGlsLkFycmF5LnZhbHVlcyhtZXJnZURhdGEsIGRvZGdlQnkpO1xuICAgICAgY291bnQgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSxcbiAgZ2V0RGltV2lkdGg6IGZ1bmN0aW9uIGdldERpbVdpZHRoKGRpbU5hbWUpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLmdldCgnY29vcmQnKTtcbiAgICB2YXIgc3RhcnQgPSBjb29yZC5jb252ZXJ0UG9pbnQoe1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9KTtcbiAgICB2YXIgZW5kID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgIHg6IGRpbU5hbWUgPT09ICd4JyA/IDEgOiAwLFxuICAgICAgeTogZGltTmFtZSA9PT0gJ3gnID8gMCA6IDFcbiAgICB9KTtcbiAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgd2lkdGggPSBNYXRoLnNxcnQoTWF0aC5wb3coZW5kLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KGVuZC55IC0gc3RhcnQueSwgMikpO1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbiAgfSxcbiAgX2dldFdpZHRoOiBmdW5jdGlvbiBfZ2V0V2lkdGgoKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHdpZHRoOyAvLyB46L2055qE6ZW/5bqmXG5cbiAgICBpZiAodGhpcy5pc0luQ2lyY2xlKCkgJiYgIWNvb3JkLmlzVHJhbnNwb3NlZCkge1xuICAgICAgLy8g5p6B5Z2Q5qCH5LiLIHdpZHRoIOS4uuW8p+mVv1xuICAgICAgd2lkdGggPSAoY29vcmQuZW5kQW5nbGUgLSBjb29yZC5zdGFydEFuZ2xlKSAqIGNvb3JkLnJhZGl1cztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSB0aGlzLmdldERpbVdpZHRoKCd4Jyk7IC8vIOS4jemcgOimgeWIpOaWrXRyYW5zcG9zZVxuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbiAgfSxcbiAgX3RvTm9ybWFsaXplZFNpemU6IGZ1bmN0aW9uIF90b05vcm1hbGl6ZWRTaXplKHNpemUpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl9nZXRXaWR0aCgpO1xuXG4gICAgcmV0dXJuIHNpemUgLyB3aWR0aDtcbiAgfSxcbiAgX3RvQ29vcmRTaXplOiBmdW5jdGlvbiBfdG9Db29yZFNpemUobm9ybWFsaXplU2l6ZSkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFdpZHRoKCk7XG5cbiAgICByZXR1cm4gd2lkdGggKiBub3JtYWxpemVTaXplO1xuICB9LFxuICBnZXROb3JtYWxpemVkU2l6ZTogZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFNpemUob2JqKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldEF0dHJWYWx1ZSgnc2l6ZScsIG9iaik7XG5cbiAgICBpZiAoVXRpbC5pc05pbChzaXplKSkge1xuICAgICAgc2l6ZSA9IHRoaXMuZ2V0RGVmYXVsdFNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IHRoaXMuX3RvTm9ybWFsaXplZFNpemUoc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG4gIH0sXG4gIGdldFNpemU6IGZ1bmN0aW9uIGdldFNpemUob2JqKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldEF0dHJWYWx1ZSgnc2l6ZScsIG9iaik7XG5cbiAgICBpZiAoVXRpbC5pc05pbChzaXplKSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZVNpemUgPSB0aGlzLmdldERlZmF1bHRTaXplKCk7XG4gICAgICBzaXplID0gdGhpcy5fdG9Db29yZFNpemUobm9ybWFsaXplU2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFNpemVNaXhpbjtcblxuLyoqKi8gfSksXG4vKiAzNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOWIhuWJsuaVsOaNrueUqOS6juWkhOeQhuWtmOWcqCBudWxsIOWAvOeahOaKmOe6v+WbvuOAgeWMuuWfn+WbvlxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzcGxpdERhdGE6IGZ1bmN0aW9uIHNwbGl0RGF0YShkYXRhKSB7XG4gICAgdmFyIHZpZXdUaGVtZSA9IHRoaXMuZ2V0KCd2aWV3VGhlbWUnKSB8fCBHbG9iYWw7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIHlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIHlEaW0gPSB5U2NhbGUuZmllbGQ7XG4gICAgdmFyIHlWYWx1ZTtcbiAgICBVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgeVZhbHVlID0gb2JqLl9vcmlnaW4gPyBvYmouX29yaWdpblt5RGltXSA6IG9ialt5RGltXTtcblxuICAgICAgaWYgKHZpZXdUaGVtZS5jb25uZWN0TnVsbHMpIHtcbiAgICAgICAgLy8g5aaC5p6c5b+96KeGIE51bGwg55u05o6l6L+e5o6l6IqC54K577yM5YiZ5bCGIHZhbHVlID0gbnVsbCDnmoTmlbDmja7ov4fmu6TmjolcbiAgICAgICAgaWYgKCFVdGlsLmlzTmlsKHlWYWx1ZSkpIHtcbiAgICAgICAgICB0bXAucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KHlWYWx1ZSkgJiYgVXRpbC5pc05pbCh5VmFsdWVbMF0pIHx8IFV0aWwuaXNOaWwoeVZhbHVlKSkge1xuICAgICAgICAgIGlmICh0bXAubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh0bXApO1xuICAgICAgICAgICAgdG1wID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcC5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0bXAubGVuZ3RoKSB7XG4gICAgICBhcnIucHVzaCh0bXApO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOi3r+W+hOWbvu+8jOaXoOW6j+eahOe6v+WbvlxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBHZW9tQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgU3BsaXRNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzU4KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgUGF0aCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dlb21CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhdGgsIF9HZW9tQmFzZSk7XG5cbiAgdmFyIF9wcm90byA9IFBhdGgucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbUJhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ3BhdGgnO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAnbGluZSc7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBmdW5jdGlvbiBQYXRoKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0dlb21CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIFV0aWwuYXNzaWduKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBTcGxpdE1peGluKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfcHJvdG8uZ2V0RHJhd0NmZyA9IGZ1bmN0aW9uIGdldERyYXdDZmcob2JqKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuZ2V0RHJhd0NmZy5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICBjZmcuaXNTdGFjayA9IHRoaXMuaGFzU3RhY2soKTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5kcmF3ID0gZnVuY3Rpb24gZHJhdyhkYXRhLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSwgaW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNwbGl0QXJyYXkgPSB0aGlzLnNwbGl0RGF0YShkYXRhKTtcbiAgICB2YXIgY2ZnID0gdGhpcy5nZXREcmF3Q2ZnKGRhdGFbMF0pO1xuXG4gICAgc2VsZi5fYXBwbHlWaWV3VGhlbWVTaGFwZVN0eWxlKGNmZywgY2ZnLnNoYXBlLCBzaGFwZUZhY3RvcnkpO1xuXG4gICAgY2ZnLm9yaWdpbiA9IGRhdGE7IC8vIHBhdGgsbGluZSDnrYnlm77nmoRvcmlnaW4g5piv5pW05Liq5bqP5YiXXG5cbiAgICBVdGlsLmVhY2goc3BsaXRBcnJheSwgZnVuY3Rpb24gKHN1YkRhdGEsIHNwbGl0ZWRJbmRleCkge1xuICAgICAgaWYgKCFVdGlsLmlzRW1wdHkoc3ViRGF0YSkpIHtcbiAgICAgICAgY2ZnLnNwbGl0ZWRJbmRleCA9IHNwbGl0ZWRJbmRleDsgLy8g5Lyg5YWl5YiG5Ymy54mH5q6157Si5byVIOeUqOS6jueUn+aIkGlkXG5cbiAgICAgICAgY2ZnLnBvaW50cyA9IHN1YkRhdGE7XG4gICAgICAgIHZhciBnZW9tU2hhcGUgPSBzaGFwZUZhY3RvcnkuZHJhd1NoYXBlKGNmZy5zaGFwZSwgY2ZnLCBjb250YWluZXIpO1xuICAgICAgICBzZWxmLmFwcGVuZFNoYXBlSW5mbyhnZW9tU2hhcGUsIGluZGV4ICsgc3BsaXRlZEluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGF0aDtcbn0oR2VvbUJhc2UpO1xuXG5HZW9tQmFzZS5QYXRoID0gUGF0aDtcbm1vZHVsZS5leHBvcnRzID0gUGF0aDtcblxuLyoqKi8gfSksXG4vKiAzNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19uYW1lc3BhY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX25hbWVzcGFjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxKTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbmFtZXNwYWNlc19fW1wiYlwiIC8qIHhodG1sICovXSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX25hbWVzcGFjZXNfX1tcImJcIiAvKiB4aHRtbCAqL10gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbmFtZXNwYWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsID8gY3JlYXRvckZpeGVkIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMzYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSB0d2VlblZhbHVlO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zY2hlZHVsZV9fW1wiaFwiIC8qIHNldCAqL10pKHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjsgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cblxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcigpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX19bXCJoXCIgLyogc2V0ICovXSkodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuOyAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcblxuICAgICAgZm9yICh2YXIgdCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuICBuYW1lICs9IFwiXCI7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIHR3ZWVuID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImZcIiAvKiBnZXQgKi9dKSh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59KTtcbmZ1bmN0aW9uIHR3ZWVuVmFsdWUodHJhbnNpdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdHJhbnNpdGlvbi5faWQ7XG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImhcIiAvKiBzZXQgKi9dKSh0aGlzLCBpZCk7XG4gICAgKHNjaGVkdWxlLnZhbHVlIHx8IChzY2hlZHVsZS52YWx1ZSA9IHt9KSlbbmFtZV0gPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDM2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgZmFjZXRzIG9mIGNoYXJ0XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGFzc2lnbiA9IFV0aWwuYXNzaWduO1xudmFyIGlzTmlsID0gVXRpbC5pc05pbDtcbnZhciBpc0FycmF5ID0gVXRpbC5pc0FycmF5O1xudmFyIGNsb25lRGVlcCA9IFV0aWwuY2xvbmVEZWVwOyAvLyDnu5Hlrprkuovku7ZcblxudmFyIHdyYXBCZWhhdmlvciA9IFV0aWwud3JhcEJlaGF2aW9yOyAvLyDojrflj5bnu5HlrprnmoTkuovku7ZcblxudmFyIGdldFdyYXBCZWhhdmlvciA9IFV0aWwuZ2V0V3JhcEJlaGF2aW9yO1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJ0OiBudWxsLFxuICAgICAgZ3JvdXA6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5piv5ZCm6buY6K6k5pi+56S65q+P5Liq5YiG6Z2i55qEdGl0bGVcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBzaG93VGl0bGU6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICog5piv5ZCm6Ieq5Yqo5L+u5pS55Z2Q5qCH6L2055qE5L+h5oGvXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgYXV0b1NldEF4aXM6IHRydWUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVmlldyDnmoTlhoXovrnmoYZcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ8QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHBhZGRpbmc6IDEwLFxuXG4gICAgICAvKipcbiAgICAgICAqIOmBjeWOhuavj+S4qnZpZXcg55qE5Zue6LCD5Ye95pWwXG4gICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIGVhY2hWaWV3OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWIhumdoueahOWtl+auteWQjeWIl+ihqFxuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBmaWVsZHM6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWIl+WAvOeahOeahOagh+mimFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgY29sVGl0bGU6IHtcbiAgICAgICAgb2Zmc2V0WTogLTE1LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGZpbGw6ICcjNjY2JyxcbiAgICAgICAgICBmb250RmFtaWx5OiBHbG9iYWwuZm9udEZhbWlseVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm93VGl0bGU6IHtcbiAgICAgICAgb2Zmc2V0WDogMTUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgcm90YXRlOiA5MCxcbiAgICAgICAgICBmaWxsOiAnIzY2NicsXG4gICAgICAgICAgZm9udEZhbWlseTogR2xvYmFsLmZvbnRGYW1pbHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQmFzZShjZmcpIHtcbiAgICB2YXIgZGVmYXVsdENmZyA9IHRoaXMuZ2V0RGVmYXVsdENmZygpO1xuICAgIGFzc2lnbih0aGlzLCBkZWZhdWx0Q2ZnLCBjZmcpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIGlmICghdGhpcy5jaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNldHMgRXJyb3I6IHBsZWFzZSBzcGVjaWZ5IHRoZSBjaGFydCEnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iaW5kRXZlbnQoKTtcblxuICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuXG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0KCdkYXRhJykpIHtcbiAgICAgIHRoaXMuaW5pdFZpZXdzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pbml0Q29udGFpbmVyID0gZnVuY3Rpb24gaW5pdENvbnRhaW5lcigpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHZhciBmcm9udFBsb3QgPSBjaGFydC5nZXQoJ2Zyb250UGxvdCcpO1xuICAgIHZhciBncm91cCA9IGZyb250UGxvdC5hZGRHcm91cCgpO1xuICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgfTtcblxuICBfcHJvdG8uaW5pdFZpZXdzID0gZnVuY3Rpb24gaW5pdFZpZXdzKCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdmFyIGRhdGEgPSBjaGFydC5nZXQoJ2RhdGEnKTtcbiAgICB2YXIgZWFjaFZpZXcgPSB0aGlzLmVhY2hWaWV3O1xuICAgIHZhciBmYWNldHMgPSB0aGlzLmdlbmVyYXRlRmFjZXRzKGRhdGEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmYWNldCA9IGZhY2V0c1tpXTtcbiAgICAgIHZhciByZWdpb24gPSBmYWNldC5yZWdpb247XG4gICAgICB2YXIgdmlldyA9IGNoYXJ0LnZpZXcoe1xuICAgICAgICBzdGFydDogcmVnaW9uLnN0YXJ0LFxuICAgICAgICBlbmQ6IHJlZ2lvbi5lbmQsXG4gICAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZ1xuICAgICAgfSk7XG4gICAgICB2aWV3LnNvdXJjZShmYWNldC5kYXRhKTtcbiAgICAgIHRoaXMuYmVmb3JlUHJvY2Vzc1ZpZXcodmlldywgZmFjZXQpO1xuXG4gICAgICBpZiAoZWFjaFZpZXcpIHtcbiAgICAgICAgZWFjaFZpZXcodmlldywgZmFjZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFmdGVyUHJvY2Vzc1ZpZXcodmlldywgZmFjZXQpO1xuICAgICAgZmFjZXQudmlldyA9IHZpZXc7XG4gICAgfVxuXG4gICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gIH07XG4gIC8qKlxuICAgKiDlpITnkIYgdmlldyDliY1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIF9wcm90by5iZWZvcmVQcm9jZXNzVmlldyA9IGZ1bmN0aW9uIGJlZm9yZVByb2Nlc3NWaWV3KClcbiAgLyogdmlldywgZmFjZXQgKi9cbiAge307XG4gIC8qKlxuICAgKiDlpITnkIZ2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3IOinhuWbvlxuICAgKiBAcGFyYW0ge09iamVjdH0gZmFjZXQg5YiG6Z2i5L+h5oGvXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBfcHJvdG8uYWZ0ZXJQcm9jZXNzVmlldyA9IGZ1bmN0aW9uIGFmdGVyUHJvY2Vzc1ZpZXcodmlldywgZmFjZXQpIHtcbiAgICBpZiAodGhpcy5hdXRvU2V0QXhpcykge1xuICAgICAgdGhpcy5wcm9jZXNzQXhpcyh2aWV3LCBmYWNldCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzQXhpcyA9IGZ1bmN0aW9uIHByb2Nlc3NBeGlzKHZpZXcsIGZhY2V0KSB7XG4gICAgdmFyIHZpZXdPcHRpb25zID0gdmlldy5nZXQoJ29wdGlvbnMnKTtcbiAgICB2YXIgZ2VvbXMgPSB2aWV3LmdldCgnZ2VvbXMnKTtcblxuICAgIGlmICgoIXZpZXdPcHRpb25zLmNvb3JkLnR5cGUgfHwgdmlld09wdGlvbnMuY29vcmQudHlwZSA9PT0gJ3JlY3QnKSAmJiBnZW9tcy5sZW5ndGgpIHtcbiAgICAgIHZhciBmaWVsZCA9IGdlb21zWzBdLmdldCgnYXR0ck9wdGlvbnMnKS5wb3NpdGlvbi5maWVsZDtcbiAgICAgIHZhciBmaWVsZHMgPSBpc0FycmF5KGZpZWxkKSA/IGZpZWxkIDogZmllbGQuc3BsaXQoJyonKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHhGaWVsZCA9IGZpZWxkc1swXTtcbiAgICAgIHZhciB5RmllbGQgPSBmaWVsZHNbMV07XG5cbiAgICAgIGlmIChpc05pbCh2aWV3T3B0aW9ucy5heGVzKSkge1xuICAgICAgICB2aWV3T3B0aW9ucy5heGVzID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBheGVzID0gdmlld09wdGlvbnMuYXhlcztcblxuICAgICAgaWYgKGF4ZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh4RmllbGQgJiYgYXhlc1t4RmllbGRdICE9PSBmYWxzZSkge1xuICAgICAgICAgIGF4ZXNbeEZpZWxkXSA9IGF4ZXNbeEZpZWxkXSB8fCB7fTtcbiAgICAgICAgICB0aGlzLnNldFhBeGlzKHhGaWVsZCwgYXhlcywgZmFjZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlGaWVsZCAmJiBheGVzW3lGaWVsZF0gIT09IGZhbHNlKSB7XG4gICAgICAgICAgYXhlc1t5RmllbGRdID0gYXhlc1t5RmllbGRdIHx8IHt9O1xuICAgICAgICAgIHRoaXMuc2V0WUF4aXMoeUZpZWxkLCBheGVzLCBmYWNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNldFhBeGlzID0gZnVuY3Rpb24gc2V0WEF4aXMoKVxuICAvKiB4RmllbGQsIGF4ZXMsIGZhY2V0ICovXG4gIHt9O1xuXG4gIF9wcm90by5zZXRZQXhpcyA9IGZ1bmN0aW9uIHNldFlBeGlzKClcbiAgLyogeUZpZWxkLCBheGVzLCBmYWNldCAqL1xuICB7fTsgLy8g6buY6K6k5pi+56S65ZCE5YiX55qE5qCH6aKYXG5cblxuICBfcHJvdG8ucmVuZGVyVGl0bGUgPSBmdW5jdGlvbiByZW5kZXJUaXRsZSh2aWV3LCBmYWNldCkge1xuICAgIHRoaXMuZHJhd0NvbFRpdGxlKHZpZXcsIGZhY2V0KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2NhbGVUZXh0ID0gZnVuY3Rpb24gZ2V0U2NhbGVUZXh0KGZpZWxkLCB2YWx1ZSwgdmlldykge1xuICAgIHZhciByc3Q7XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIHZhciBzY2FsZXMgPSB2aWV3LmdldCgnc2NhbGVzJyk7XG4gICAgICB2YXIgc2NhbGUgPSBzY2FsZXNbZmllbGRdO1xuXG4gICAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgIHNjYWxlID0gdmlldy5jcmVhdGVTY2FsZShmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHJzdCA9IHNjYWxlLmdldFRleHQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIF9wcm90by5kcmF3Q29sVGl0bGUgPSBmdW5jdGlvbiBkcmF3Q29sVGl0bGUodmlldywgZmFjZXQpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0U2NhbGVUZXh0KGZhY2V0LmNvbEZpZWxkLCBmYWNldC5jb2xWYWx1ZSwgdmlldyk7XG4gICAgdmFyIGNvbFRleHRDZmcgPSBhc3NpZ24oe1xuICAgICAgcG9zaXRpb246IFsnNTAlJywgJzAlJ10sXG4gICAgICBjb250ZW50OiB0ZXh0XG4gICAgfSwgdGhpcy5jb2xUaXRsZSk7XG4gICAgdmlldy5ndWlkZSgpLnRleHQoY29sVGV4dENmZyk7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXdSb3dUaXRsZSA9IGZ1bmN0aW9uIGRyYXdSb3dUaXRsZSh2aWV3LCBmYWNldCkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRTY2FsZVRleHQoZmFjZXQucm93RmllbGQsIGZhY2V0LnJvd1ZhbHVlLCB2aWV3KTtcbiAgICB2YXIgcm93VGV4dENmZyA9IGFzc2lnbih7XG4gICAgICBwb3NpdGlvbjogWycxMDAlJywgJzUwJSddLFxuICAgICAgY29udGVudDogdGV4dFxuICAgIH0sIGNsb25lRGVlcCh0aGlzLnJvd1RpdGxlKSk7XG4gICAgdmlldy5ndWlkZSgpLnRleHQocm93VGV4dENmZyk7XG4gIH07XG4gIC8qKlxuICAgKiDmlbDmja7ov4fmu6TlmahcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25kaXRpb25zIOi/h+a7pOadoeS7tlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0g6L+H5ruk5Ye95pWwXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldEZpbHRlciA9IGZ1bmN0aW9uIGdldEZpbHRlcihjb25kaXRpb25zKSB7XG4gICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihvYmopIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IHRydWU7XG4gICAgICBjb25kaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbmQpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gY29uZC5maWVsZDtcbiAgICAgICAgdmFyIHZhbHVlID0gY29uZC52YWx1ZTsgLy8gY29uc3QgdmFsdWVzID0gY29uZC52YWx1ZXM7XG5cbiAgICAgICAgdmFyIHRtcCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc05pbCh2YWx1ZSkgJiYgZmllbGQpIHtcbiAgICAgICAgICB0bXAgPSBvYmpbZmllbGRdID09PSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQgJiYgdG1wO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfTtcblxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH07XG4gIC8qKlxuICAgKiDojrflj5blrZfmrrXlr7nlupTnmoTlgLxcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkIOWtl+auteWQjVxuICAgKiBAcGFyYW0gIHtBcnJheX0gZGF0YSDmlbDmja5cbiAgICogQHJldHVybiB7QXJyYXl9IOWtl+auteWvueW6lOeahOWAvFxuICAgKi9cblxuXG4gIF9wcm90by5nZXRGaWVsZFZhbHVlcyA9IGZ1bmN0aW9uIGdldEZpZWxkVmFsdWVzKGZpZWxkLCBkYXRhKSB7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIHZhciB0bXBNYXAgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbZmllbGRdO1xuXG4gICAgICBpZiAoIWlzTmlsKHZhbHVlKSAmJiAhdG1wTWFwW3ZhbHVlXSkge1xuICAgICAgICByc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRtcE1hcFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLmdldFJlZ2lvbiA9IGZ1bmN0aW9uIGdldFJlZ2lvbihyb3dzLCBjb2xzLCB4SW5kZXgsIHlJbmRleCkge1xuICAgIHZhciB4V2lkdGggPSAxIC8gY29sczsgLy8geOi9tOaWueWQkeeahOavj+S4quWIhumdoueahOWBj+enu1xuXG4gICAgdmFyIHlXaWR0aCA9IDEgLyByb3dzOyAvLyB56L205pa55ZCR55qE5q+P5Liq5YiG6Z2i55qE5YGP56e7XG5cbiAgICB2YXIgc3RhcnQgPSB7XG4gICAgICB4OiB4V2lkdGggKiB4SW5kZXgsXG4gICAgICB5OiB5V2lkdGggKiB5SW5kZXhcbiAgICB9O1xuICAgIHZhciBlbmQgPSB7XG4gICAgICB4OiBzdGFydC54ICsgeFdpZHRoLFxuICAgICAgeTogc3RhcnQueSArIHlXaWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIOeUn+aIkOWIhumdolxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge0FycmF5fSDlpJrkuKrliIbpnaLpm4blkIhcbiAgICovXG5cblxuICBfcHJvdG8uZ2VuZXJhdGVGYWNldHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUZhY2V0cygpXG4gIC8qIGRhdGEgKi9cbiAge1xuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBfcHJvdG8uX2JpbmRFdmVudCA9IGZ1bmN0aW9uIF9iaW5kRXZlbnQoKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjaGFydC5vbignYWZ0ZXJjaGFuZ2VkYXRhJywgd3JhcEJlaGF2aW9yKHRoaXMsICdvbkRhdGFDaGFuZ2UnKSk7XG4gICAgY2hhcnQub24oJ2JlZm9yZWNsZWFyJywgd3JhcEJlaGF2aW9yKHRoaXMsICdvbkNsZWFyJykpO1xuICAgIGNoYXJ0Lm9uKCdiZWZvcmVkZXN0cm95Jywgd3JhcEJlaGF2aW9yKHRoaXMsICdkZXN0cm95JykpO1xuICAgIGNoYXJ0Lm9uKCdiZWZvcmVwYWludCcsIHdyYXBCZWhhdmlvcih0aGlzLCAnb25QYWludCcpKTtcbiAgICBjaGFydC5vbignc2V0ZGF0YScsIHdyYXBCZWhhdmlvcih0aGlzLCAnb25EYXRhQ2hhbmdlJykpO1xuICB9O1xuXG4gIF9wcm90by5fY2xlYXJFdmVudCA9IGZ1bmN0aW9uIF9jbGVhckV2ZW50KCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICBpZiAoY2hhcnQpIHtcbiAgICAgIGNoYXJ0Lm9mZignYWZ0ZXJjaGFuZ2VkYXRhJywgZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdvbkRhdGFDaGFuZ2UnKSk7XG4gICAgICBjaGFydC5vZmYoJ2JlZm9yZWNsZWFyJywgZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdvbkNsZWFyJykpO1xuICAgICAgY2hhcnQub2ZmKCdiZWZvcmVkZXN0cm95JywgZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdkZXN0cm95JykpO1xuICAgICAgY2hhcnQub2ZmKCdiZWZvcmVwYWludCcsIGdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25QYWludCcpKTtcbiAgICAgIGNoYXJ0Lm9mZignc2V0ZGF0YScsIGdldFdyYXBCZWhhdmlvcih0aGlzLCAnb25EYXRhQ2hhbmdlJykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NsZWFyRmFjZXRzID0gZnVuY3Rpb24gX2NsZWFyRmFjZXRzKCkge1xuICAgIHZhciBmYWNldHMgPSB0aGlzLmZhY2V0cztcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG4gICAgaWYgKGZhY2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZhY2V0ID0gZmFjZXRzW2ldO1xuICAgICAgICBjaGFydC5yZW1vdmVWaWV3KGZhY2V0LnZpZXcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmFjZXRzID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25DbGVhciA9IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgdGhpcy5vblJlbW92ZSgpO1xuICB9O1xuXG4gIF9wcm90by5vblBhaW50ID0gZnVuY3Rpb24gb25QYWludCgpIHtcbiAgICBpZiAodGhpcy5zaG93VGl0bGUpIHtcbiAgICAgIHZhciBmYWNldHMgPSB0aGlzLmZhY2V0cztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZhY2V0ID0gZmFjZXRzW2ldO1xuICAgICAgICB2YXIgdmlldyA9IGZhY2V0LnZpZXc7XG4gICAgICAgIHRoaXMucmVuZGVyVGl0bGUodmlldywgZmFjZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25EYXRhQ2hhbmdlID0gZnVuY3Rpb24gb25EYXRhQ2hhbmdlKCkge1xuICAgIHRoaXMuX2NsZWFyRmFjZXRzKCk7XG5cbiAgICB0aGlzLmluaXRWaWV3cygpO1xuICB9O1xuXG4gIF9wcm90by5vblJlbW92ZSA9IGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuICAgIHRoaXMuX2NsZWFyRmFjZXRzKCk7XG5cbiAgICB0aGlzLl9jbGVhckV2ZW50KCk7XG5cbiAgICB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAucmVtb3ZlKCk7XG4gICAgdGhpcy5jaGFydCA9IG51bGw7XG4gICAgdGhpcy5mYWNldHMgPSBudWxsO1xuICAgIHRoaXMuZ3JvdXAgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLm9uUmVtb3ZlKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMzY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IGludGVydmFsIGdlb21ldHJ5XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNpemVNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzU3KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzNjUpO1xuXG52YXIgSW50ZXJ2YWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShJbnRlcnZhbCwgX0dlb21CYXNlKTtcblxuICB2YXIgX3Byb3RvID0gSW50ZXJ2YWwucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbUJhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ2ludGVydmFsJztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ2ludGVydmFsJztcbiAgICBjZmcuZ2VuZXJhdGVQb2ludHMgPSB0cnVlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgZnVuY3Rpb24gSW50ZXJ2YWwoY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfR2VvbUJhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFNpemVNaXhpbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLmNyZWF0ZVNoYXBlUG9pbnRzQ2ZnID0gZnVuY3Rpb24gY3JlYXRlU2hhcGVQb2ludHNDZmcob2JqKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgY2ZnLnNpemUgPSB0aGlzLmdldE5vcm1hbGl6ZWRTaXplKG9iaik7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJJbm5lciA9IGZ1bmN0aW9uIGNsZWFySW5uZXIoKSB7XG4gICAgX0dlb21CYXNlLnByb3RvdHlwZS5jbGVhcklubmVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnNldCgnZGVmYXVsdFNpemUnLCBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gSW50ZXJ2YWw7XG59KEdlb21CYXNlKTtcblxudmFyIEludGVydmFsU3RhY2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnRlcnZhbCkge1xuICBfaW5oZXJpdHNMb29zZShJbnRlcnZhbFN0YWNrLCBfSW50ZXJ2YWwpO1xuXG4gIGZ1bmN0aW9uIEludGVydmFsU3RhY2soKSB7XG4gICAgcmV0dXJuIF9JbnRlcnZhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEludGVydmFsU3RhY2sucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9JbnRlcnZhbC5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLmhhc0RlZmF1bHRBZGp1c3QgPSB0cnVlO1xuICAgIGNmZy5hZGp1c3RzID0gW3tcbiAgICAgIHR5cGU6ICdzdGFjaydcbiAgICB9XTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbFN0YWNrO1xufShJbnRlcnZhbCk7XG5cbnZhciBJbnRlcnZhbERvZGdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW50ZXJ2YWwyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludGVydmFsRG9kZ2UsIF9JbnRlcnZhbDIpO1xuXG4gIGZ1bmN0aW9uIEludGVydmFsRG9kZ2UoKSB7XG4gICAgcmV0dXJuIF9JbnRlcnZhbDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBJbnRlcnZhbERvZGdlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfSW50ZXJ2YWwyLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcuaGFzRGVmYXVsdEFkanVzdCA9IHRydWU7XG4gICAgY2ZnLmFkanVzdHMgPSBbe1xuICAgICAgdHlwZTogJ2RvZGdlJ1xuICAgIH1dO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIEludGVydmFsRG9kZ2U7XG59KEludGVydmFsKTtcblxudmFyIEludGVydmFsU3ltbWV0cmljID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW50ZXJ2YWwzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludGVydmFsU3ltbWV0cmljLCBfSW50ZXJ2YWwzKTtcblxuICBmdW5jdGlvbiBJbnRlcnZhbFN5bW1ldHJpYygpIHtcbiAgICByZXR1cm4gX0ludGVydmFsMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IEludGVydmFsU3ltbWV0cmljLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfSW50ZXJ2YWwzLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcuaGFzRGVmYXVsdEFkanVzdCA9IHRydWU7XG4gICAgY2ZnLmFkanVzdHMgPSBbe1xuICAgICAgdHlwZTogJ3N5bW1ldHJpYydcbiAgICB9XTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbFN5bW1ldHJpYztcbn0oSW50ZXJ2YWwpO1xuXG5JbnRlcnZhbC5TdGFjayA9IEludGVydmFsU3RhY2s7XG5JbnRlcnZhbC5Eb2RnZSA9IEludGVydmFsRG9kZ2U7XG5JbnRlcnZhbC5TeW1tZXRyaWMgPSBJbnRlcnZhbFN5bW1ldHJpYztcbkdlb21CYXNlLkludGVydmFsID0gSW50ZXJ2YWw7XG5HZW9tQmFzZS5JbnRlcnZhbFN0YWNrID0gSW50ZXJ2YWxTdGFjaztcbkdlb21CYXNlLkludGVydmFsRG9kZ2UgPSBJbnRlcnZhbERvZGdlO1xuR2VvbUJhc2UuSW50ZXJ2YWxTeW1tZXRyaWMgPSBJbnRlcnZhbFN5bW1ldHJpYztcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWw7XG5cbi8qKiovIH0pLFxuLyogMzY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBpbnRlcnZhbCBzaGFwZXNcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqIEBhdXRob3IgaHVhbmd0b25nZXJAYWxpeXVuLmNvbVxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgUGF0aFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIEcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIEdQYXRoVXRpbCA9IFV0aWwuUGF0aFV0aWw7IC8vIOiOt+WPluafseeKtuWbvueahOWHoOS4queCuVxuXG5mdW5jdGlvbiBnZXRSZWN0UG9pbnRzKGNmZywgaXNQeXJhbWlkKSB7XG4gIHZhciB4ID0gY2ZnLng7XG4gIHZhciB5ID0gY2ZnLnk7XG4gIHZhciB5MCA9IGNmZy55MDsgLy8gMCDngrnnmoTkvY3nva5cblxuICB2YXIgd2lkdGggPSBjZmcuc2l6ZTsgLy8g5pyJM+enjeaDheWGte+8jFxuICAvLyAxLiB577yMeOmDveS4jeaYr+aVsOe7hFxuICAvLyAyLiB55piv5pWw57uE77yMeOS4jeaYr1xuICAvLyAzLiB45piv5pWw57uE77yMeeS4jeaYr1xuXG4gIHZhciB5bWluID0geTA7XG4gIHZhciB5bWF4ID0geTtcblxuICBpZiAoVXRpbC5pc0FycmF5KHkpKSB7XG4gICAgeW1heCA9IHlbMV07XG4gICAgeW1pbiA9IHlbMF07XG4gIH1cblxuICB2YXIgeG1pbjtcbiAgdmFyIHhtYXg7XG5cbiAgaWYgKFV0aWwuaXNBcnJheSh4KSkge1xuICAgIHhtaW4gPSB4WzBdO1xuICAgIHhtYXggPSB4WzFdO1xuICB9IGVsc2Uge1xuICAgIHhtaW4gPSB4IC0gd2lkdGggLyAyO1xuICAgIHhtYXggPSB4ICsgd2lkdGggLyAyO1xuICB9XG5cbiAgdmFyIHBvaW50cyA9IFtdO1xuICBwb2ludHMucHVzaCh7XG4gICAgeDogeG1pbixcbiAgICB5OiB5bWluXG4gIH0sIHtcbiAgICB4OiB4bWluLFxuICAgIHk6IHltYXhcbiAgfSk7XG5cbiAgaWYgKGlzUHlyYW1pZCkge1xuICAgIHBvaW50cy5wdXNoKHtcbiAgICAgIHg6IHhtYXgsXG4gICAgICB5OiAoeW1heCArIHltaW4pIC8gMlxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cy5wdXNoKHtcbiAgICAgIHg6IHhtYXgsXG4gICAgICB5OiB5bWF4XG4gICAgfSwge1xuICAgICAgeDogeG1heCxcbiAgICAgIHk6IHltaW5cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RQYXRoKHBvaW50cykge1xuICB2YXIgcGF0aCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKHBvaW50KSB7XG4gICAgICB2YXIgYWN0aW9uID0gaSA9PT0gMCA/ICdNJyA6ICdMJztcbiAgICAgIHBhdGgucHVzaChbYWN0aW9uLCBwb2ludC54LCBwb2ludC55XSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpcnN0ID0gcG9pbnRzWzBdO1xuICBwYXRoLnB1c2goWydMJywgZmlyc3QueCwgZmlyc3QueV0pO1xuICBwYXRoLnB1c2goWyd6J10pO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZVBvaW50cyhjZmcpIHtcbiAgdmFyIHggPSBjZmcueDtcbiAgdmFyIHkgPSBjZmcueTtcbiAgdmFyIHkwID0gY2ZnLnkwOyAvLyAwIOeCueeahOS9jee9rlxuXG4gIHZhciBwb2ludHMgPSBbXTtcblxuICBpZiAoVXRpbC5pc0FycmF5KHkpKSB7XG4gICAgVXRpbC5lYWNoKHksIGZ1bmN0aW9uICh5SXRlbSwgaWR4KSB7XG4gICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgIHg6IFV0aWwuaXNBcnJheSh4KSA/IHhbaWR4XSA6IHgsXG4gICAgICAgIHk6IHlJdGVtXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMucHVzaCh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5MFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VGlja1BvaW50cyhjZmcpIHtcbiAgdmFyIHggPSBjZmcueDtcbiAgdmFyIHkgPSBVdGlsLmlzQXJyYXkoY2ZnLnkpID8gY2ZnLnlbMV0gOiBjZmcueTtcbiAgdmFyIHkwID0gVXRpbC5pc0FycmF5KGNmZy55KSA/IGNmZy55WzBdIDogY2ZnLnkwO1xuICB2YXIgYmFyV2lkdGggPSBjZmcuc2l6ZTtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICBwb2ludHMucHVzaCh7XG4gICAgeDogeCAtIGJhcldpZHRoIC8gMixcbiAgICB5OiB5XG4gIH0sIHtcbiAgICB4OiB4ICsgYmFyV2lkdGggLyAyLFxuICAgIHk6IHlcbiAgfSwge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCB7XG4gICAgeDogeCxcbiAgICB5OiB5MFxuICB9LCB7XG4gICAgeDogeCAtIGJhcldpZHRoIC8gMixcbiAgICB5OiB5MFxuICB9LCB7XG4gICAgeDogeCArIGJhcldpZHRoIC8gMixcbiAgICB5OiB5MFxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VGlja1BhdGgocG9pbnRzKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHBhdGgucHVzaChbJ00nLCBwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnldLCBbJ0wnLCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnldLCBbJ00nLCBwb2ludHNbMl0ueCwgcG9pbnRzWzJdLnldLCBbJ0wnLCBwb2ludHNbM10ueCwgcG9pbnRzWzNdLnldLCBbJ00nLCBwb2ludHNbNF0ueCwgcG9pbnRzWzRdLnldLCBbJ0wnLCBwb2ludHNbNV0ueCwgcG9pbnRzWzVdLnldKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGxBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRBdHRycyA9IEdsb2JhbC5zaGFwZS5pbnRlcnZhbDtcbiAgdmFyIGF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRBdHRycywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZEZpbGxBdHRycyhhdHRycywgY2ZnKTtcblxuICBpZiAoY2ZnLmNvbG9yKSB7XG4gICAgYXR0cnMuc3Ryb2tlID0gYXR0cnMuc3Ryb2tlIHx8IGNmZy5jb2xvcjtcbiAgfVxuXG4gIHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUF0dHJzKGNmZykge1xuICB2YXIgZGVmYXVsdEF0dHJzID0gR2xvYmFsLnNoYXBlLmhvbGxvd0ludGVydmFsO1xuICB2YXIgYXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdEF0dHJzLCBjZmcuc3R5bGUpO1xuICBTaGFwZVV0aWwuYWRkU3Ryb2tlQXR0cnMoYXR0cnMsIGNmZyk7XG4gIHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gZ2V0RnVubmVsUGF0aChjZmcsIGlzRnVubmVsKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciBwb2ludHMgPSBjZmcucG9pbnRzO1xuICB2YXIgbmV4dFBvaW50cyA9IGNmZy5uZXh0UG9pbnRzO1xuXG4gIGlmICghVXRpbC5pc05pbChuZXh0UG9pbnRzKSkge1xuICAgIHBhdGgucHVzaChbJ00nLCBwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnldLCBbJ0wnLCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnldLCBbJ0wnLCBuZXh0UG9pbnRzWzFdLngsIG5leHRQb2ludHNbMV0ueV0sIFsnTCcsIG5leHRQb2ludHNbMF0ueCwgbmV4dFBvaW50c1swXS55XSwgWydaJ10pO1xuICB9IGVsc2UgaWYgKGlzRnVubmVsKSB7XG4gICAgcGF0aC5wdXNoKFsnTScsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV0sIFsnTCcsIHBvaW50c1sxXS54LCBwb2ludHNbMV0ueV0sIFsnTCcsIHBvaW50c1syXS54LCBwb2ludHNbMl0ueV0sIFsnTCcsIHBvaW50c1szXS54LCBwb2ludHNbM10ueV0sIFsnWiddKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLnB1c2goWydNJywgcG9pbnRzWzBdLngsIHBvaW50c1swXS55XSwgWydMJywgcG9pbnRzWzFdLngsIHBvaW50c1sxXS55XSwgWydMJywgcG9pbnRzWzJdLngsIHBvaW50c1syXS55XSwgWydMJywgcG9pbnRzWzJdLngsIHBvaW50c1syXS55XSwgWydaJ10pO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldFRoZXRhQ2ZnKHBvaW50LCBjb29yZCkge1xuICB2YXIgciA9IGNvb3JkLmdldFJhZGl1cygpO1xuICB2YXIgaW5uZXIgPSBjb29yZC5pbm5lclJhZGl1cztcbiAgdmFyIHN0YXJ0QW5nbGU7XG4gIHZhciBlbmRBbmdsZTtcbiAgdmFyIGlyID0gciAqIGlubmVyO1xuICB2YXIgc3RhcnRQb2ludDtcbiAgdmFyIGVuZFBvaW50O1xuXG4gIGlmICghVXRpbC5pc0FycmF5KHBvaW50LngpICYmIFV0aWwuaXNBcnJheShwb2ludC55KSkge1xuICAgIHBvaW50LnggPSBbcG9pbnQueCwgcG9pbnQueF07IC8vIOWmguaenHjmmK/kuIDkuKrlgLzvvIx55piv5pWw57uE77yM5bCGeOi9rOaIkOaVsOe7hFxuICB9XG5cbiAgaWYgKFV0aWwuaXNBcnJheShwb2ludC54KSkge1xuICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54WzBdLFxuICAgICAgeTogcG9pbnQueVswXVxuICAgIH07XG4gICAgZW5kUG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54WzFdLFxuICAgICAgeTogcG9pbnQueVsxXVxuICAgIH07XG4gICAgc3RhcnRBbmdsZSA9IFBhdGhVdGlsLmdldFBvaW50QW5nbGUoY29vcmQsIHN0YXJ0UG9pbnQpO1xuICAgIGVuZEFuZ2xlID0gUGF0aFV0aWwuZ2V0UG9pbnRBbmdsZShjb29yZCwgZW5kUG9pbnQpO1xuXG4gICAgaWYgKGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUpIHtcbiAgICAgIC8vIOiAg+iZkeWNoOavlOeZvuWIhueZvueahOaDheW9olxuICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIE1hdGguUEkgKiAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbmRQb2ludCA9IHBvaW50O1xuICAgIHN0YXJ0QW5nbGUgPSBjb29yZC5zdGFydEFuZ2xlO1xuICAgIGVuZEFuZ2xlID0gUGF0aFV0aWwuZ2V0UG9pbnRBbmdsZShjb29yZCwgZW5kUG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGlyOiBpcixcbiAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICB9O1xufSAvLyDojrflj5bpgInkuK3ml7bnmoTmoLflvI/vvIzlvZPliY3ku4XmlK/mjIHppbzlm75cblxuXG5mdW5jdGlvbiBfZ2V0U2VsZWN0ZWRDZmcodHlwZSwgY2ZnKSB7XG4gIHZhciBnZW9tID0gY2ZnLmdlb207XG4gIHZhciBjb29yZCA9IGdlb20uZ2V0KCdjb29yZCcpO1xuICB2YXIgcG9pbnQgPSBjZmcucG9pbnQ7XG4gIHZhciByID0gNy41O1xuICB2YXIgc2VsZWN0ZWRDZmc7XG5cbiAgaWYgKGNvb3JkICYmIGNvb3JkLnR5cGUgPT09ICd0aGV0YScpIHtcbiAgICB2YXIgdGhldGFDZmcgPSBnZXRUaGV0YUNmZyhwb2ludCwgY29vcmQpO1xuICAgIHZhciBtaWRkbGVBbmdsZSA9ICh0aGV0YUNmZy5lbmRBbmdsZSAtIHRoZXRhQ2ZnLnN0YXJ0QW5nbGUpIC8gMiArIHRoZXRhQ2ZnLnN0YXJ0QW5nbGU7XG4gICAgdmFyIHggPSByICogTWF0aC5jb3MobWlkZGxlQW5nbGUpO1xuICAgIHZhciB5ID0gciAqIE1hdGguc2luKG1pZGRsZUFuZ2xlKTtcbiAgICBzZWxlY3RlZENmZyA9IHtcbiAgICAgIHRyYW5zZm9ybTogW1sndCcsIHgsIHldXVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gVXRpbC5taXgoe30sIHNlbGVjdGVkQ2ZnKTtcbn1cblxudmFyIEludGVydmFsID0gU2hhcGUucmVnaXN0ZXJGYWN0b3J5KCdpbnRlcnZhbCcsIHtcbiAgZGVmYXVsdFNoYXBlVHlwZTogJ3JlY3QnLFxuICBnZXRBY3RpdmVDZmc6IGZ1bmN0aW9uIGdldEFjdGl2ZUNmZyh0eXBlLCBjZmcpIHtcbiAgICBpZiAoIXR5cGUgfHwgVXRpbC5pbkFycmF5KFsncmVjdCcsICdmdW5uZWwnLCAncHlyYW1pZCddLCB0eXBlKSkge1xuICAgICAgLy8g6YCP5piO5bqm6ZmN5L2OIDAuMTVcbiAgICAgIHZhciBmaWxsT3BhY2l0eSA9IGNmZy5maWxsT3BhY2l0eSB8fCBjZmcub3BhY2l0eSB8fCAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5IC0gMC4xNVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gY2ZnLmxpbmVXaWR0aCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCArIDFcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0UG9pbnRzOiBmdW5jdGlvbiBnZXREZWZhdWx0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHJldHVybiBnZXRSZWN0UG9pbnRzKHBvaW50SW5mbyk7XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2ZnOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENmZyh0eXBlLCBjZmcpIHtcbiAgICByZXR1cm4gX2dldFNlbGVjdGVkQ2ZnKHR5cGUsIGNmZyk7XG4gIH1cbn0pOyAvLyDpu5jorqTmn7Hnirblm75cblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgnaW50ZXJ2YWwnLCAncmVjdCcsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gZ2V0UmVjdFBhdGgoY2ZnLnBvaW50cyk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIHJlY3RDZmcgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgaXNJbkNpcmNsZSA9IGNmZy5pc0luQ2lyY2xlO1xuICAgIHJldHVybiBVdGlsLm1peCh7XG4gICAgICBzeW1ib2w6IGlzSW5DaXJjbGUgPyAnY2lyY2xlJyA6ICdzcXVhcmUnLFxuICAgICAgcmFkaXVzOiBpc0luQ2lyY2xlID8gNC41IDogNFxuICAgIH0sIHJlY3RDZmcpO1xuICB9XG59KTsgLy8g56m65b+D5p+x54q25Zu+XG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2ludGVydmFsJywgJ2hvbGxvd1JlY3QnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRMaW5lQXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFJlY3RQYXRoKGNmZy5wb2ludHMpO1xuICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHZhciByZWN0Q2ZnID0gZ2V0TGluZUF0dHJzKGNmZyk7XG4gICAgdmFyIGlzSW5DaXJjbGUgPSBjZmcuaXNJbkNpcmNsZTtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiBpc0luQ2lyY2xlID8gJ2NpcmNsZScgOiAnc3F1YXJlJyxcbiAgICAgIHJhZGl1czogaXNJbkNpcmNsZSA/IDQuNSA6IDRcbiAgICB9LCByZWN0Q2ZnKTtcbiAgfVxufSk7IC8vIOe6v+W9ouafseeKtuWbvlxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdpbnRlcnZhbCcsICdsaW5lJywge1xuICBnZXRQb2ludHM6IGZ1bmN0aW9uIGdldFBvaW50cyhwb2ludEluZm8pIHtcbiAgICByZXR1cm4gZ2V0TGluZVBvaW50cyhwb2ludEluZm8pO1xuICB9LFxuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0TGluZUF0dHJzKGNmZyk7XG4gICAgYXR0cnMubGluZVdpZHRoID0gY2ZnLnNpemUgfHwgMTsgLy8gc2l6ZSDlsLHmmK/nur/nmoTlrr3luqZcblxuICAgIHZhciBwYXRoID0gZ2V0UmVjdFBhdGgoY2ZnLnBvaW50cyk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIGxpbmVDZmcgPSBnZXRMaW5lQXR0cnMoY2ZnKTtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAnbGluZScsXG4gICAgICByYWRpdXM6IDVcbiAgICB9LCBsaW5lQ2ZnKTtcbiAgfVxufSk7IC8vIOmSieWtkOW9oueahOafseeKtuWbvlxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdpbnRlcnZhbCcsICd0aWNrJywge1xuICBnZXRQb2ludHM6IGZ1bmN0aW9uIGdldFBvaW50cyhwb2ludEluZm8pIHtcbiAgICByZXR1cm4gZ2V0VGlja1BvaW50cyhwb2ludEluZm8pO1xuICB9LFxuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0TGluZUF0dHJzKGNmZyk7IC8vIEAyMDE4LTEyLTI1IGJ5IGJsdWUubGIg57uP6L+H5rWL6K+V5Y+R546wc2l6ZeS7o+ihqOeahOaYr+WuveW6pu+8jOiAjHN0eWxl5Lit55qEbGluZVdpZHRo5omN5piv6K6+572u57q/5a6977yM5pS+5ZyoaW50ZXJ2YWzmmoLml7blhYjnibnmrorlpITnkIZcblxuICAgIGlmICghYXR0cnMubGluZVdpZHRoKSB7XG4gICAgICBhdHRycy5saW5lV2lkdGggPSAyO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gZ2V0VGlja1BhdGgoY2ZnLnBvaW50cyk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIGxpbmVDZmcgPSBnZXRMaW5lQXR0cnMoY2ZnKTtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAndGljaycsXG4gICAgICByYWRpdXM6IDVcbiAgICB9LCBsaW5lQ2ZnKTtcbiAgfVxufSk7IC8vIOa8j+aWl+WbvlxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdpbnRlcnZhbCcsICdmdW5uZWwnLCB7XG4gIGdldFBvaW50czogZnVuY3Rpb24gZ2V0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHBvaW50SW5mby5zaXplID0gcG9pbnRJbmZvLnNpemUgKiAyOyAvLyDmvI/mlpflm77nmoQgc2l6ZSDmmK/mn7Hnirblm77nmoTkuKTlgI1cblxuICAgIHJldHVybiBnZXRSZWN0UG9pbnRzKHBvaW50SW5mbyk7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldEZ1bm5lbFBhdGgoY2ZnLCB0cnVlKTtcbiAgICBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICB2YXIgZnVubmVsQ2ZnID0gZ2V0RmlsbEF0dHJzKGNmZyk7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ3NxdWFyZScsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LCBmdW5uZWxDZmcpO1xuICB9XG59KTsgLy8g6YeR5a2X5aGU5Zu+XG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2ludGVydmFsJywgJ3B5cmFtaWQnLCB7XG4gIGdldFBvaW50czogZnVuY3Rpb24gZ2V0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHBvaW50SW5mby5zaXplID0gcG9pbnRJbmZvLnNpemUgKiAyOyAvLyDmvI/mlpflm77nmoQgc2l6ZSDmmK/mn7Hnirblm77nmoTkuKTlgI1cblxuICAgIHJldHVybiBnZXRSZWN0UG9pbnRzKHBvaW50SW5mbywgdHJ1ZSk7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldEZ1bm5lbFBhdGgoY2ZnLCBmYWxzZSk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIGZ1bm5lbENmZyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgIHJldHVybiBVdGlsLm1peCh7XG4gICAgICBzeW1ib2w6ICdzcXVhcmUnLFxuICAgICAgcmFkaXVzOiA0XG4gICAgfSwgZnVubmVsQ2ZnKTtcbiAgfVxufSk7IC8vIOawtOazouWbvlxuXG4vKipcbiAqIOeUqOi0neWhnuWwlOabsue6v+aooeaLn+ato+W8puazolxuICogVXNpbmcgQmV6aWVyIGN1cnZlcyB0byBmaXQgc2luZSB3YXZlLlxuICogVGhlcmUgaXMgNCBjb250cm9sIHBvaW50cyBmb3IgZWFjaCBjdXJ2ZSBvZiB3YXZlLFxuICogd2hpY2ggaXMgYXQgMS80IHdhdmUgbGVuZ3RoIG9mIHRoZSBzaW5lIHdhdmUuXG4gKlxuICogVGhlIGNvbnRyb2wgcG9pbnRzIGZvciBhIHdhdmUgZnJvbSAoYSkgdG8gKGQpIGFyZSBhLWItYy1kOlxuICogICAgICAgICAgYyAqLS0tLSogZFxuICogICAgIGIgKlxuICogICAgICAgfFxuICogLi4uIGEgKiAuLi4uLi4uLi4uLi4uLi4uLi5cbiAqXG4gKiB3aG9zZSBwb3NpdGlvbnMgYXJlIGE6ICgwLCAwKSwgYjogKDAuNSwgMC41KSwgYzogKDEsIDEpLCBkOiAoUEkgLyAyLCAxKVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgICAgIHggcG9zaXRpb24gb2YgdGhlIGxlZnQtbW9zdCBwb2ludCAoYSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFnZSAgICAgIDAtMywgc3RhdGluZyB3aGljaCBwYXJ0IG9mIHRoZSB3YXZlIGl0IGlzXG4gKiBAcGFyYW0ge251bWJlcn0gd2F2ZUxlbmd0aCB3YXZlIGxlbmd0aCBvZiB0aGUgc2luZSB3YXZlXG4gKiBAcGFyYW0ge251bWJlcn0gYW1wbGl0dWRlICB3YXZlIGFtcGxpdHVkZVxuICogQHJldHVybiB7QXJyYXl9IOato+W8pueJh+auteabsue6v1xuICovXG5cbmZ1bmN0aW9uIGdldFdhdGVyV2F2ZVBvc2l0aW9ucyh4LCBzdGFnZSwgd2F2ZUxlbmd0aCwgYW1wbGl0dWRlKSB7XG4gIGlmIChzdGFnZSA9PT0gMCkge1xuICAgIHJldHVybiBbW3ggKyAxIC8gMiAqIHdhdmVMZW5ndGggLyBNYXRoLlBJIC8gMiwgYW1wbGl0dWRlIC8gMl0sIFt4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSwgYW1wbGl0dWRlXSwgW3ggKyB3YXZlTGVuZ3RoIC8gNCwgYW1wbGl0dWRlXV07XG4gIH0gZWxzZSBpZiAoc3RhZ2UgPT09IDEpIHtcbiAgICByZXR1cm4gW1t4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSAvIDIgKiAoTWF0aC5QSSAtIDIpLCBhbXBsaXR1ZGVdLCBbeCArIDEgLyAyICogd2F2ZUxlbmd0aCAvIE1hdGguUEkgLyAyICogKE1hdGguUEkgLSAxKSwgYW1wbGl0dWRlIC8gMl0sIFt4ICsgd2F2ZUxlbmd0aCAvIDQsIDBdXTtcbiAgfSBlbHNlIGlmIChzdGFnZSA9PT0gMikge1xuICAgIHJldHVybiBbW3ggKyAxIC8gMiAqIHdhdmVMZW5ndGggLyBNYXRoLlBJIC8gMiwgLWFtcGxpdHVkZSAvIDJdLCBbeCArIDEgLyAyICogd2F2ZUxlbmd0aCAvIE1hdGguUEksIC1hbXBsaXR1ZGVdLCBbeCArIHdhdmVMZW5ndGggLyA0LCAtYW1wbGl0dWRlXV07XG4gIH1cblxuICByZXR1cm4gW1t4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSAvIDIgKiAoTWF0aC5QSSAtIDIpLCAtYW1wbGl0dWRlXSwgW3ggKyAxIC8gMiAqIHdhdmVMZW5ndGggLyBNYXRoLlBJIC8gMiAqIChNYXRoLlBJIC0gMSksIC1hbXBsaXR1ZGUgLyAyXSwgW3ggKyB3YXZlTGVuZ3RoIC8gNCwgMF1dO1xufVxuLyoqXG4gKiDojrflj5bmsLTms6Lot6/lvoRcbiAqIEBwYXJhbSAge251bWJlcn0gcmFkaXVzICAgICAgICAgIOWNiuW+hFxuICogQHBhcmFtICB7bnVtYmVyfSB3YXRlckxldmVsICAgICAg5rC05L2NXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHdhdmVMZW5ndGggICAgICDms6Lplb9cbiAqIEBwYXJhbSAge251bWJlcn0gcGhhc2UgICAgICAgICAgIOebuOS9jVxuICogQHBhcmFtICB7bnVtYmVyfSBhbXBsaXR1ZGUgICAgICAg6ZyH5bmFXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGN4ICAgICAgICAgICAgICDlnIblv4N4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGN5ICAgICAgICAgICAgICDlnIblv4N5XG4gKiBAcmV0dXJuIHtBcnJheX0gIHBhdGggICAgICAgICAgICDot6/lvoRcbiAqIEByZWZlcmVuY2UgaHR0cDovL2dpdGxhYi5hbGlwYXktaW5jLmNvbS9kYXRhdmlzL2c2L2Jsb2IvMS4yLjAvc3JjL2dyYXBoL3V0aWxzL3BhdGguanMjTDEzNVxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2F0ZXJXYXZlUGF0aChyYWRpdXMsIHdhdGVyTGV2ZWwsIHdhdmVMZW5ndGgsIHBoYXNlLCBhbXBsaXR1ZGUsIGN4LCBjeSkge1xuICB2YXIgY3VydmVzID0gTWF0aC5jZWlsKDIgKiByYWRpdXMgLyB3YXZlTGVuZ3RoICogNCkgKiAyO1xuICB2YXIgcGF0aCA9IFtdOyAvLyBtYXAgcGhhc2UgdG8gWy1NYXRoLlBJICogMiwgMF1cblxuICB3aGlsZSAocGhhc2UgPCAtTWF0aC5QSSAqIDIpIHtcbiAgICBwaGFzZSArPSBNYXRoLlBJICogMjtcbiAgfVxuXG4gIHdoaWxlIChwaGFzZSA+IDApIHtcbiAgICBwaGFzZSAtPSBNYXRoLlBJICogMjtcbiAgfVxuXG4gIHBoYXNlID0gcGhhc2UgLyBNYXRoLlBJIC8gMiAqIHdhdmVMZW5ndGg7XG4gIHZhciBsZWZ0ID0gY3ggLSByYWRpdXMgKyBwaGFzZSAtIHJhZGl1cyAqIDI7XG4gIC8qKlxuICAgKiB0b3AtbGVmdCBjb3JuZXIgYXMgc3RhcnQgcG9pbnRcbiAgICpcbiAgICogZHJhd3MgdGhpcyBwb2ludFxuICAgKiAgfFxuICAgKiBcXHwvXG4gICAqICB+fn5+fn5+flxuICAgKiAgfCAgICAgIHxcbiAgICogICstLS0tLS0rXG4gICAqL1xuXG4gIHBhdGgucHVzaChbJ00nLCBsZWZ0LCB3YXRlckxldmVsXSk7XG4gIC8qKlxuICAgKiB0b3Agd2F2ZVxuICAgKlxuICAgKiB+fn5+fn5+fiA8LSBkcmF3cyB0aGlzIHNpbmUgd2F2ZVxuICAgKiB8ICAgICAgfFxuICAgKiArLS0tLS0tK1xuICAgKi9cblxuICB2YXIgd2F2ZVJpZ2h0ID0gMDtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGN1cnZlczsgKytjKSB7XG4gICAgdmFyIHN0YWdlID0gYyAlIDQ7XG4gICAgdmFyIHBvcyA9IGdldFdhdGVyV2F2ZVBvc2l0aW9ucyhjICogd2F2ZUxlbmd0aCAvIDQsIHN0YWdlLCB3YXZlTGVuZ3RoLCBhbXBsaXR1ZGUpO1xuICAgIHBhdGgucHVzaChbJ0MnLCBwb3NbMF1bMF0gKyBsZWZ0LCAtcG9zWzBdWzFdICsgd2F0ZXJMZXZlbCwgcG9zWzFdWzBdICsgbGVmdCwgLXBvc1sxXVsxXSArIHdhdGVyTGV2ZWwsIHBvc1syXVswXSArIGxlZnQsIC1wb3NbMl1bMV0gKyB3YXRlckxldmVsXSk7XG5cbiAgICBpZiAoYyA9PT0gY3VydmVzIC0gMSkge1xuICAgICAgd2F2ZVJpZ2h0ID0gcG9zWzJdWzBdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogdG9wLXJpZ2h0IGNvcm5lclxuICAgKlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbiAgICogMy4gZHJhd3MgdGhpcyBsaW5lIC0+IHwgICAgICB8IDwtIDEuIGRyYXdzIHRoaXMgbGluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLStcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgICAyLiBkcmF3cyB0aGlzIGxpbmVcbiAgICovXG5cblxuICBwYXRoLnB1c2goWydMJywgd2F2ZVJpZ2h0ICsgbGVmdCwgY3kgKyByYWRpdXNdKTtcbiAgcGF0aC5wdXNoKFsnTCcsIGxlZnQsIGN5ICsgcmFkaXVzXSk7XG4gIHBhdGgucHVzaChbJ0wnLCBsZWZ0LCB3YXRlckxldmVsXSk7XG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiDmt7vliqDmsLTms6JcbiAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgICAgICDkuK3lv4N4XG4gKiBAcGFyYW0ge251bWJlcn0geSAgICAgICAgICAg5Lit5b+DeVxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsICAgICAgIOawtOS9jeetiee6pyAw772eMVxuICogQHBhcmFtIHtudW1iZXJ9IHdhdmVDb3VudCAgIOawtOazouaVsFxuICogQHBhcmFtIHtudW1iZXJ9IGNvbG9ycyAgICAgIOiJsuWAvFxuICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwICAgICAgIOWbvue7hFxuICogQHBhcmFtIHtudW1iZXJ9IGNsaXAgICAgICAgIOeUqOS6juWJquWIh+eahOWbvuW9olxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAgICAgIOe7mOWItuWbvuW9oueahOmrmOW6plxuICovXG5cblxuZnVuY3Rpb24gYWRkV2F0ZXJXYXZlKHgsIHksIGxldmVsLCB3YXZlQ291bnQsIGNvbG9ycywgZ3JvdXAsIGNsaXAsIHJhZGl1cykge1xuICB2YXIgYmJveCA9IGNsaXAuZ2V0QkJveCgpO1xuICB2YXIgd2lkdGggPSBiYm94Lm1heFggLSBiYm94Lm1pblg7XG4gIHZhciBoZWlnaHQgPSBiYm94Lm1heFkgLSBiYm94Lm1pblk7XG4gIHZhciBkdXJhdGlvbiA9IDUwMDA7XG4gIHZhciBkZWxheURpZmYgPSAzMDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3YXZlQ291bnQ7IGkrKykge1xuICAgIHZhciB3YXZlID0gZ3JvdXAuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBwYXRoOiBnZXRXYXRlcldhdmVQYXRoKHJhZGl1cywgYmJveC5taW5ZICsgaGVpZ2h0ICogbGV2ZWwsIHdpZHRoIC8gNCwgMCwgd2lkdGggLyA2NCwgeCwgeSksXG4gICAgICAgIGZpbGw6IGNvbG9yc1tpXSxcbiAgICAgICAgY2xpcDogY2xpcFxuICAgICAgfVxuICAgIH0pOyAvLyBGSVhNRSB3YXZlIGFuaW1hdGlvbiBlcnJvciBpbiBzdmdcblxuICAgIGlmIChHbG9iYWwucmVuZGVyZXIgPT09ICdjYW52YXMnKSB7XG4gICAgICB3YXZlLmFuaW1hdGUoe1xuICAgICAgICB0cmFuc2Zvcm06IFtbJ3QnLCB3aWR0aCAvIDIsIDBdXSxcbiAgICAgICAgcmVwZWF0OiB0cnVlXG4gICAgICB9LCBkdXJhdGlvbiAtIGkgKiBkZWxheURpZmYpO1xuICAgIH1cbiAgfVxufVxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdpbnRlcnZhbCcsICdsaXF1aWQtZmlsbC1nYXVnZScsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSAwLjU7XG4gICAgdmFyIHN1bVggPSAwO1xuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgVXRpbC5lYWNoKGNmZy5wb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocC54IDwgbWluWCkge1xuICAgICAgICBtaW5YID0gcC54O1xuICAgICAgfVxuXG4gICAgICBzdW1YICs9IHAueDtcbiAgICB9KTtcbiAgICB2YXIgY3ggPSBzdW1YIC8gY2ZnLnBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGNwID0gc2VsZi5wYXJzZVBvaW50KHtcbiAgICAgIHg6IGN4LFxuICAgICAgeTogY3lcbiAgICB9KTtcbiAgICB2YXIgbWluUCA9IHNlbGYucGFyc2VQb2ludCh7XG4gICAgICB4OiBtaW5YLFxuICAgICAgeTogMC41XG4gICAgfSk7XG4gICAgdmFyIHhXaWR0aCA9IGNwLnggLSBtaW5QLng7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHhXaWR0aCwgbWluUC55KTtcbiAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgY2xpcENpcmNsZSA9IG5ldyBHLkNpcmNsZSh7XG4gICAgICBhdHRyczoge1xuICAgICAgICB4OiBjcC54LFxuICAgICAgICB5OiBjcC55LFxuICAgICAgICByOiByYWRpdXNcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhZGRXYXRlcldhdmUoY3AueCwgY3AueSwgY2ZnLnkgLyAoMiAqIGNwLnkpLCAxLCBbYXR0cnMuZmlsbF0sIGNvbnRhaW5lciwgY2xpcENpcmNsZSwgcmFkaXVzICogNCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnY2lyY2xlJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGdldExpbmVBdHRycyhjZmcpLCB7XG4gICAgICAgIHg6IGNwLngsXG4gICAgICAgIHk6IGNwLnksXG4gICAgICAgIHI6IHJhZGl1cyArIHJhZGl1cyAvIDhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIHBhdGhNZXRhQ2FjaGUgPSB7fTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2ludGVydmFsJywgJ2xpcXVpZC1maWxsLXBhdGgnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gVXRpbC5taXgoe30sIGdldEZpbGxBdHRycyhjZmcpKTtcbiAgICB2YXIgcGF0aCA9IGNmZy5zaGFwZVsxXTtcbiAgICB2YXIgY3kgPSAwLjU7XG4gICAgdmFyIHN1bVggPSAwO1xuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgVXRpbC5lYWNoKGNmZy5wb2ludHMsIGZ1bmN0aW9uIChwKSB7XG4gICAgICBpZiAocC54IDwgbWluWCkge1xuICAgICAgICBtaW5YID0gcC54O1xuICAgICAgfVxuXG4gICAgICBzdW1YICs9IHAueDtcbiAgICB9KTtcbiAgICB2YXIgY3ggPSBzdW1YIC8gY2ZnLnBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGNwID0gc2VsZi5wYXJzZVBvaW50KHtcbiAgICAgIHg6IGN4LFxuICAgICAgeTogY3lcbiAgICB9KTtcbiAgICB2YXIgbWluUCA9IHNlbGYucGFyc2VQb2ludCh7XG4gICAgICB4OiBtaW5YLFxuICAgICAgeTogMC41XG4gICAgfSk7XG4gICAgdmFyIHhXaWR0aCA9IGNwLnggLSBtaW5QLng7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHhXaWR0aCwgbWluUC55KTtcbiAgICB2YXIgcGF0aE1ldGE7XG5cbiAgICBpZiAocGF0aE1ldGFDYWNoZVtwYXRoXSkge1xuICAgICAgcGF0aE1ldGEgPSBwYXRoTWV0YUNhY2hlW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBHUGF0aFV0aWwucGFyc2VQYXRoU3RyaW5nKHBhdGgpO1xuICAgICAgcGF0aE1ldGFDYWNoZVtwYXRoXSA9IHBhdGhNZXRhID0ge1xuICAgICAgICBzZWdtZW50czogc2VnbWVudHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IFtdO1xuXG4gICAgaWYgKGF0dHJzLnJvdGF0ZSkge1xuICAgICAgdHJhbnNmb3JtLnB1c2goWydyJywgYXR0cnMucm90YXRlIC8gMTgwICogTWF0aC5QSV0pO1xuICAgICAgZGVsZXRlIGF0dHJzLnJvdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICAgIHBhdGg6IHBhdGhNZXRhLnNlZ21lbnRzXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHZhciBiYm94ID0gVXRpbC5jbG9uZURlZXAoc2hhcGUuZ2V0QkJveCgpKTtcbiAgICB2YXIgcmFuZ2VYID0gYmJveC5tYXhYIC0gYmJveC5taW5YO1xuICAgIHZhciByYW5nZVkgPSBiYm94Lm1heFkgLSBiYm94Lm1pblk7XG4gICAgdmFyIHJhbmdlID0gTWF0aC5tYXgocmFuZ2VYLCByYW5nZVkpO1xuICAgIHZhciBzY2FsZSA9IHJhZGl1cyAqIDIgLyByYW5nZTtcbiAgICBzaGFwZS50cmFuc2Zvcm0odHJhbnNmb3JtLmNvbmNhdChbWydzJywgc2NhbGUsIHNjYWxlXV0pKTtcbiAgICB2YXIgZHcgPSBzY2FsZSAqIHJhbmdlWCAvIDI7IC8vIChiYm94Lm1heFggLSBiYm94Lm1pblgpIC8gMjtcblxuICAgIHZhciBkaCA9IHNjYWxlICogcmFuZ2VZIC8gMjsgLy8gKGJib3gubWF4WSAtIGJib3gubWluWSkgLyAyO1xuXG4gICAgc2hhcGUudHJhbnNmb3JtKFtbJ3QnLCBjcC54IC0gZHcsIGNwLnkgLSBkaF1dKTtcbiAgICBhZGRXYXRlcldhdmUoY3AueCwgY3AueSwgY2ZnLnkgLyAoMiAqIGNwLnkpLCAxLCBbYXR0cnMuZmlsbF0sIGNvbnRhaW5lciwgc2hhcGUsIG1pblAueSAqIDQpO1xuICAgIHZhciBrZXlTaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChnZXRMaW5lQXR0cnMoY2ZnKSwge1xuICAgICAgICBwYXRoOiBwYXRoTWV0YS5zZWdtZW50c1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBrZXlTaGFwZS50cmFuc2Zvcm0odHJhbnNmb3JtLmNvbmNhdChbWydzJywgc2NhbGUsIHNjYWxlXSwgWyd0JywgY3AueCAtIGR3LCBjcC55IC0gZGhdXSkpO1xuICAgIHJldHVybiBrZXlTaGFwZTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdpbnRlcnZhbCcsICd0b3AtbGluZScsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgIHZhciBzdHlsZSA9IGNmZy5zdHlsZSB8fCB7fTtcbiAgICB2YXIgbGluZVBhdGggPSBbWydNJywgY2ZnLnBvaW50c1sxXS54LCBjZmcucG9pbnRzWzFdLnldLCBbJ0wnLCBjZmcucG9pbnRzWzJdLngsIGNmZy5wb2ludHNbMl0ueV1dO1xuICAgIHZhciBsaW5lQXR0cnMgPSB7XG4gICAgICBzdHJva2U6IHN0eWxlLnN0cm9rZSB8fCAnd2hpdGUnLFxuICAgICAgbGluZVdpZHRoOiBzdHlsZS5saW5lV2lkdGggfHwgMSxcbiAgICAgIHBhdGg6IHRoaXMucGFyc2VQYXRoKGxpbmVQYXRoKVxuICAgIH07XG4gICAgdmFyIHBhdGggPSBnZXRSZWN0UGF0aChjZmcucG9pbnRzKTtcbiAgICBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCk7XG4gICAgZGVsZXRlIGF0dHJzLnN0cm9rZTsgLy8g5LiN5Zyo5p+x5a2Q5LiK57uY5Yi257q/XG5cbiAgICB2YXIgcmVjdFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHpJbmRleDogMCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBhdHRyczogbGluZUF0dHJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlY3RTaGFwZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIHJlY3RDZmcgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgaXNJbkNpcmNsZSA9IGNmZy5pc0luQ2lyY2xlO1xuICAgIHJldHVybiBVdGlsLm1peCh7XG4gICAgICBzeW1ib2w6IGlzSW5DaXJjbGUgPyAnY2lyY2xlJyA6ICdzcXVhcmUnLFxuICAgICAgcmFkaXVzOiBpc0luQ2lyY2xlID8gNC41IDogNFxuICAgIH0sIHJlY3RDZmcpO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWw7XG5cbi8qKiovIH0pLFxuLyogMzY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg57q/5Zu+XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTkpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM2Nyk7XG5cbnZhciBMaW5lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHNMb29zZShMaW5lLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gTGluZSgpIHtcbiAgICByZXR1cm4gX1BhdGguYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExpbmUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfUGF0aC5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnbGluZSc7XG4gICAgY2ZnLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIHJldHVybiBMaW5lO1xufShQYXRoKTtcblxudmFyIExpbmVTdGFjayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0xpbmUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGluZVN0YWNrLCBfTGluZSk7XG5cbiAgZnVuY3Rpb24gTGluZVN0YWNrKCkge1xuICAgIHJldHVybiBfTGluZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IExpbmVTdGFjay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0xpbmUucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy5oYXNEZWZhdWx0QWRqdXN0ID0gdHJ1ZTtcbiAgICBjZmcuYWRqdXN0cyA9IFt7XG4gICAgICB0eXBlOiAnc3RhY2snXG4gICAgfV07XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICByZXR1cm4gTGluZVN0YWNrO1xufShMaW5lKTtcblxuTGluZS5TdGFjayA9IExpbmVTdGFjaztcbkdlb21CYXNlLkxpbmUgPSBMaW5lO1xuR2VvbUJhc2UuTGluZVN0YWNrID0gTGluZVN0YWNrO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKioqLyB9KSxcbi8qIDM2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgbGluZSBzaGFwZXNcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqIEBhdXRob3IgaHVhbmd0b25nZXJAYWxpeXVuLmNvbVxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBQYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG52YXIgU2hhcGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIERPVF9BUlIgPSBbMSwgMV07XG52YXIgREFTSF9BUlIgPSBbNS41LCAxXTtcblxuZnVuY3Rpb24gZ2V0QXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0Q2ZnID0gR2xvYmFsLnNoYXBlLmxpbmU7XG4gIHZhciBsaW5lQXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdENmZywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZFN0cm9rZUF0dHJzKGxpbmVBdHRycywgY2ZnKTtcblxuICBpZiAoY2ZnLnNpemUpIHtcbiAgICBsaW5lQXR0cnMubGluZVdpZHRoID0gY2ZnLnNpemU7XG4gIH1cblxuICByZXR1cm4gbGluZUF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrZXJBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRDZmcgPSBHbG9iYWwuc2hhcGUubGluZTtcbiAgdmFyIGxpbmVBdHRycyA9IFV0aWwubWl4KHtcbiAgICBsaW5lV2lkdGg6IDIsXG4gICAgcmFkaXVzOiA2XG4gIH0sIGRlZmF1bHRDZmcsIGNmZy5zdHlsZSk7XG4gIFNoYXBlVXRpbC5hZGRTdHJva2VBdHRycyhsaW5lQXR0cnMsIGNmZyk7XG4gIHJldHVybiBsaW5lQXR0cnM7XG59IC8vIOiOt+WPluW4puacieS4iuS4i+WMuumXtOeahCBwYXRoXG5cblxuZnVuY3Rpb24gZ2V0UmFuZ2VQYXRoKHBvaW50cywgc21vb3RoLCBpc0luQ2lyY2xlLCBjZmcpIHtcbiAgdmFyIHRvcFBvaW50cyA9IFtdO1xuICB2YXIgaXNTdGFjayA9IGNmZy5pc1N0YWNrO1xuICB2YXIgYm90dG9tUG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgdmFyIHRtcCA9IFNoYXBlVXRpbC5zcGxpdFBvaW50cyhwb2ludCk7XG4gICAgYm90dG9tUG9pbnRzLnB1c2godG1wWzBdKTtcbiAgICB0b3BQb2ludHMucHVzaCh0bXBbMV0pO1xuICB9XG5cbiAgdmFyIHRvcFBhdGggPSBnZXRTaW5nbGVQYXRoKHRvcFBvaW50cywgc21vb3RoLCBpc0luQ2lyY2xlLCBjZmcpO1xuICB2YXIgYm90dG9tUGF0aCA9IGdldFNpbmdsZVBhdGgoYm90dG9tUG9pbnRzLCBzbW9vdGgsIGlzSW5DaXJjbGUsIGNmZyk7XG5cbiAgaWYgKGlzU3RhY2spIHtcbiAgICByZXR1cm4gdG9wUGF0aDtcbiAgfVxuXG4gIHJldHVybiB0b3BQYXRoLmNvbmNhdChib3R0b21QYXRoKTtcbn0gLy8g5Y2V5p2hIHBhdGhcblxuXG5mdW5jdGlvbiBnZXRTaW5nbGVQYXRoKHBvaW50cywgc21vb3RoLCBpc0luQ2lyY2xlLCBjZmcpIHtcbiAgdmFyIHBhdGg7XG5cbiAgaWYgKCFzbW9vdGgpIHtcbiAgICBwYXRoID0gUGF0aFV0aWwuZ2V0TGluZVBhdGgocG9pbnRzLCBmYWxzZSk7XG5cbiAgICBpZiAoaXNJbkNpcmNsZSkge1xuICAgICAgcGF0aC5wdXNoKFsnWiddKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8g55u06KeS5Z2Q5qCH57O75LiL57uY5Yi25puy57q/5pe26ZmQ5Yi25pyA5aSn5YC844CB5pyA5bCP5YC8XG4gICAgdmFyIGNvbnN0cmFpbnQgPSBjZmcuY29uc3RyYWludDtcblxuICAgIGlmIChpc0luQ2lyY2xlICYmIHBvaW50cy5sZW5ndGgpIHtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogcG9pbnRzWzBdLngsXG4gICAgICAgIHk6IHBvaW50c1swXS55XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwYXRoID0gUGF0aFV0aWwuZ2V0U3BsaW5lUGF0aChwb2ludHMsIGZhbHNlLCBjb25zdHJhaW50KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSAvLyBnZXQgbGluZSBwYXRoXG5cblxuZnVuY3Rpb24gZ2V0UGF0aChjZmcsIHNtb290aCkge1xuICB2YXIgcGF0aDtcbiAgdmFyIHBvaW50cyA9IGNmZy5wb2ludHM7XG4gIHZhciBpc0luQ2lyY2xlID0gY2ZnLmlzSW5DaXJjbGU7XG4gIHZhciBmaXJzdCA9IHBvaW50c1swXTtcblxuICBpZiAoVXRpbC5pc0FycmF5KGZpcnN0LnkpKSB7XG4gICAgcGF0aCA9IGdldFJhbmdlUGF0aChwb2ludHMsIHNtb290aCwgaXNJbkNpcmNsZSwgY2ZnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gZ2V0U2luZ2xlUGF0aChwb2ludHMsIHNtb290aCwgaXNJbkNpcmNsZSwgY2ZnKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJwUG9pbnRzKHBvaW50cywgZm4pIHtcbiAgdmFyIHRtcFBvaW50cyA9IFtdO1xuICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgdmFyIG5leHRQb2ludCA9IHBvaW50c1tpbmRleCArIDFdO1xuICAgIHRtcFBvaW50cy5wdXNoKHBvaW50KTtcblxuICAgIGlmIChuZXh0UG9pbnQpIHtcbiAgICAgIHRtcFBvaW50cyA9IHRtcFBvaW50cy5jb25jYXQoZm4ocG9pbnQsIG5leHRQb2ludCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0bXBQb2ludHM7XG59IC8vIOaPkuWAvOeahOWbvuW9onBhdGjvvIzkuI3ogIPomZFudWxsXG5cblxuZnVuY3Rpb24gX2dldEludGVyUGF0aChwb2ludHMpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50LCBpbmRleCkge1xuICAgIHZhciBzdWJQYXRoID0gaW5kZXggPT09IDAgPyBbJ00nLCBwb2ludC54LCBwb2ludC55XSA6IFsnTCcsIHBvaW50LngsIHBvaW50LnldO1xuICAgIHBhdGgucHVzaChzdWJQYXRoKTtcbiAgfSk7XG4gIHJldHVybiBwYXRoO1xufSAvLyDmj5LlgLznmoTlm77lvaJcblxuXG5mdW5jdGlvbiBfZ2V0SW50ZXJQb2ludFNoYXBlQ2ZnKGNmZywgZm4pIHtcbiAgdmFyIHBvaW50cyA9IF9pbnRlcnBQb2ludHMoY2ZnLnBvaW50cywgZm4pO1xuXG4gIHJldHVybiBfZ2V0SW50ZXJQYXRoKHBvaW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYXJrZXJGbih4LCB5LCByKSB7XG4gIHJldHVybiBbWydNJywgeCAtIHIsIHldLCBbJ0wnLCB4ICsgciwgeV1dO1xufVxuXG5mdW5jdGlvbiBfc21vb3RoTWFya2VyRm4oeCwgeSwgcikge1xuICByZXR1cm4gW1snTScsIHggLSByLCB5XSwgWydBJywgciAvIDIsIHIgLyAyLCAwLCAxLCAxLCB4LCB5XSwgWydBJywgciAvIDIsIHIgLyAyLCAwLCAxLCAwLCB4ICsgciwgeV1dO1xufSAvLyBnZXQgbWFya2VyIGNmZ1xuXG5cbmZ1bmN0aW9uIF9nZXRNYXJrZXJDZmcoY2ZnLCBzbW9vdGgpIHtcbiAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICBzeW1ib2w6IHNtb290aCA/IF9zbW9vdGhNYXJrZXJGbiA6IF9tYXJrZXJGblxuICB9LCBnZXRNYXJrZXJBdHRycyhjZmcpKTtcbn1cblxuZnVuY3Rpb24gX2dldEludGVyTWFya2VyQ2ZnKGNmZywgZm4pIHtcbiAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICBzeW1ib2w6IGZuXG4gIH0sIGdldE1hcmtlckF0dHJzKGNmZykpO1xufSAvLyDlvZPlj6rmnInkuIDkuKrmlbDmja7ml7bnu5jliLbngrlcblxuXG5mdW5jdGlvbiBkcmF3UG9pbnRTaGFwZShzaGFwZU9iaiwgY2ZnLCBjb250YWluZXIpIHtcbiAgdmFyIHBvaW50ID0gY2ZnLnBvaW50c1swXTtcbiAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnY2lyY2xlJywge1xuICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICB4OiBwb2ludC54LFxuICAgICAgeTogcG9pbnQueSxcbiAgICAgIHI6IDIsXG4gICAgICBmaWxsOiBjZmcuY29sb3JcbiAgICB9LCBjZmcuc3R5bGUpXG4gIH0pO1xufSAvLyByZWdpc3QgbGluZSBnZW9tXG5cblxudmFyIExpbmUgPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ2xpbmUnLCB7XG4gIC8vIOm7mOiupOeahHNoYXBlXG4gIGRlZmF1bHRTaGFwZVR5cGU6ICdsaW5lJyxcblxuICAvKiBnZXRNYXJrZXJDZmcodHlwZSwgY2ZnKSB7XG4gICAgY29uc3QgbGluZU9iaiA9IExpbmVbdHlwZV0gfHwgTGluZS5saW5lO1xuICAgIHJldHVybiBsaW5lT2JqLmdldE1hcmtlckNmZyhjZmcpO1xuICB9LCAqL1xuICBnZXRBY3RpdmVDZmc6IGZ1bmN0aW9uIGdldEFjdGl2ZUNmZyh0eXBlLCBjZmcpIHtcbiAgICB2YXIgbGluZVdpZHRoID0gY2ZnLmxpbmVXaWR0aCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCArIDFcbiAgICB9O1xuICB9LFxuICAvLyDorqHnrpfngrkg5aaC5p6c5a2Y5Zyo5aSa5Liq54K577yM5YiG5Ymy5oiQ5Y2V5Liq55qE54K5LCDkuI3ogIPomZHlpJrkuKp45a+55bqU5LiA5LiqeeeahOaDheWGtVxuICBnZXREZWZhdWx0UG9pbnRzOiBmdW5jdGlvbiBnZXREZWZhdWx0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHJldHVybiBTaGFwZVV0aWwuc3BsaXRQb2ludHMocG9pbnRJbmZvKTtcbiAgfSxcbiAgZHJhd1NoYXBlOiBmdW5jdGlvbiBkcmF3U2hhcGUodHlwZSwgY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLmdldFNoYXBlKHR5cGUpO1xuICAgIHZhciBnU2hhcGU7XG5cbiAgICBpZiAoY2ZnLnBvaW50cy5sZW5ndGggPT09IDEgJiYgR2xvYmFsLnNob3dTaW5nbGVQb2ludCkge1xuICAgICAgZ1NoYXBlID0gZHJhd1BvaW50U2hhcGUodGhpcywgY2ZnLCBjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnU2hhcGUgPSBzaGFwZS5kcmF3KGNmZywgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZ1NoYXBlKSB7XG4gICAgICBnU2hhcGUuc2V0KCdvcmlnaW4nLCBjZmcub3JpZ2luKTtcbiAgICAgIGdTaGFwZS5faWQgPSBjZmcuc3BsaXRlZEluZGV4ID8gY2ZnLl9pZCArIGNmZy5zcGxpdGVkSW5kZXggOiBjZmcuX2lkO1xuICAgICAgZ1NoYXBlLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdTaGFwZTtcbiAgfVxufSk7IC8vIGRyYXcgbGluZSBzaGFwZVxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdsaW5lJywgJ2xpbmUnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gZ2V0UGF0aChjZmcsIGZhbHNlKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBfZ2V0TWFya2VyQ2ZnKGNmZyk7XG4gIH1cbn0pOyAvLyDngrnnur8gwrfCt8K3XG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2xpbmUnLCAnZG90Jywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBsaW5lRGFzaDogRE9UX0FSUlxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgdmFyIHRtcCA9IF9nZXRNYXJrZXJDZmcoY2ZnLCBmYWxzZSk7XG5cbiAgICB0bXAubGluZURhc2ggPSBET1RfQVJSO1xuICAgIHJldHVybiB0bXA7XG4gIH1cbn0pOyAvLyDmlq3nur8gLSAtIC1cblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgnbGluZScsICdkYXNoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGxpbmVEYXNoOiBEQVNIX0FSUlxuICAgICAgfSwgYXR0cnMpXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHZhciB0bXAgPSBfZ2V0TWFya2VyQ2ZnKGNmZywgZmFsc2UpO1xuXG4gICAgdG1wLmxpbmVEYXNoID0gdG1wLmxpbmVEYXNoIHx8IERBU0hfQVJSO1xuICAgIHJldHVybiB0bXA7XG4gIH1cbn0pOyAvLyBkcmF3IHNtb290aCBsaW5lIHNoYXBlXG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2xpbmUnLCAnc21vb3RoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgY29vcmQgPSB0aGlzLl9jb29yZDsgLy8g5puy57q/55qE6ZmQ5Yi2XG5cbiAgICBjZmcuY29uc3RyYWludCA9IFtbY29vcmQuc3RhcnQueCwgY29vcmQuZW5kLnldLCBbY29vcmQuZW5kLngsIGNvb3JkLnN0YXJ0LnldXTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCB0cnVlKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBfZ2V0TWFya2VyQ2ZnKGNmZywgdHJ1ZSk7XG4gIH1cbn0pO1xuU2hhcGUucmVnaXN0ZXJTaGFwZSgnbGluZScsICdodicsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEF0dHJzKGNmZyk7XG5cbiAgICB2YXIgcGF0aCA9IF9nZXRJbnRlclBvaW50U2hhcGVDZmcoY2ZnLCBmdW5jdGlvbiAocG9pbnQsIG5leHRQb2ludCkge1xuICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgdG1wLnB1c2goe1xuICAgICAgICB4OiBuZXh0UG9pbnQueCxcbiAgICAgICAgeTogcG9pbnQueVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG1wO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gX2dldEludGVyTWFya2VyQ2ZnKGNmZywgZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIHJldHVybiBbWydNJywgeCAtIHIgLSAxLCB5IC0gMi41XSwgWydMJywgeCwgeSAtIDIuNV0sIFsnTCcsIHgsIHkgKyAyLjVdLCBbJ0wnLCB4ICsgciArIDEsIHkgKyAyLjVdXTtcbiAgICB9KTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdsaW5lJywgJ3ZoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcblxuICAgIHZhciBwYXRoID0gX2dldEludGVyUG9pbnRTaGFwZUNmZyhjZmcsIGZ1bmN0aW9uIChwb2ludCwgbmV4dFBvaW50KSB7XG4gICAgICB2YXIgdG1wID0gW107XG4gICAgICB0bXAucHVzaCh7XG4gICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgIHk6IG5leHRQb2ludC55XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0bXA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBfZ2V0SW50ZXJNYXJrZXJDZmcoY2ZnLCBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgcmV0dXJuIFtbJ00nLCB4IC0gciAtIDEsIHkgKyAyLjVdLCBbJ0wnLCB4LCB5ICsgMi41XSwgWydMJywgeCwgeSAtIDIuNV0sIFsnTCcsIHggKyByICsgMSwgeSAtIDIuNV1dO1xuICAgIH0pO1xuICB9XG59KTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2xpbmUnLCAnaHZoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcblxuICAgIHZhciBwYXRoID0gX2dldEludGVyUG9pbnRTaGFwZUNmZyhjZmcsIGZ1bmN0aW9uIChwb2ludCwgbmV4dFBvaW50KSB7XG4gICAgICB2YXIgdG1wID0gW107XG4gICAgICB2YXIgbWlkZGxleCA9IChuZXh0UG9pbnQueCAtIHBvaW50LngpIC8gMiArIHBvaW50Lng7XG4gICAgICB0bXAucHVzaCh7XG4gICAgICAgIHg6IG1pZGRsZXgsXG4gICAgICAgIHk6IHBvaW50LnlcbiAgICAgIH0pO1xuICAgICAgdG1wLnB1c2goe1xuICAgICAgICB4OiBtaWRkbGV4LFxuICAgICAgICB5OiBuZXh0UG9pbnQueVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG1wO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gX2dldEludGVyTWFya2VyQ2ZnKGNmZywgZnVuY3Rpb24gKHgsIHksIHIpIHtcbiAgICAgIHJldHVybiBbWydNJywgeCAtIChyICsgMSksIHkgKyAyLjVdLCBbJ0wnLCB4IC0gciAvIDIsIHkgKyAyLjVdLCBbJ0wnLCB4IC0gciAvIDIsIHkgLSAyLjVdLCBbJ0wnLCB4ICsgciAvIDIsIHkgLSAyLjVdLCBbJ0wnLCB4ICsgciAvIDIsIHkgKyAyLjVdLCBbJ0wnLCB4ICsgciArIDEsIHkgKyAyLjVdXTtcbiAgICB9KTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdsaW5lJywgJ3ZodicsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEF0dHJzKGNmZyk7XG5cbiAgICB2YXIgcGF0aCA9IF9nZXRJbnRlclBvaW50U2hhcGVDZmcoY2ZnLCBmdW5jdGlvbiAocG9pbnQsIG5leHRQb2ludCkge1xuICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgdmFyIG1pZGRsZXkgPSAobmV4dFBvaW50LnkgLSBwb2ludC55KSAvIDIgKyBwb2ludC55O1xuICAgICAgdG1wLnB1c2goe1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiBtaWRkbGV5XG4gICAgICB9KTtcbiAgICAgIHRtcC5wdXNoKHtcbiAgICAgICAgeDogbmV4dFBvaW50LngsXG4gICAgICAgIHk6IG1pZGRsZXlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRtcDtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIF9nZXRJbnRlck1hcmtlckNmZyhjZmcsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAvLyDlrr0gMTNweO+8jOmrmCA4cHhcbiAgICAgIHJldHVybiBbWydNJywgeCAtIDUsIHkgKyAyLjVdLCBbJ0wnLCB4IC0gNSwgeV0sIFsnTCcsIHgsIHldLCBbJ0wnLCB4LCB5IC0gM10sIFsnTCcsIHgsIHkgKyAzXSwgWydMJywgeCArIDYuNSwgeSArIDNdXTtcbiAgICB9KTtcbiAgfVxufSk7XG5MaW5lLnNwbGluZSA9IExpbmUuc21vb3RoO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKioqLyB9KSxcbi8qIDM2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOeCueWbvlxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBHZW9tQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzY5KTtcblxudmFyIFBvaW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9pbnQsIF9HZW9tQmFzZSk7XG5cbiAgZnVuY3Rpb24gUG9pbnQoKSB7XG4gICAgcmV0dXJuIF9HZW9tQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9pbnQucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbUJhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ3BvaW50JztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ3BvaW50JztcbiAgICBjZmcuZ2VuZXJhdGVQb2ludHMgPSB0cnVlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXdQb2ludCA9IGZ1bmN0aW9uIGRyYXdQb2ludChvYmosIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2hhcGUgPSBvYmouc2hhcGU7XG4gICAgdmFyIGNmZyA9IHNlbGYuZ2V0RHJhd0NmZyhvYmopO1xuXG4gICAgc2VsZi5fYXBwbHlWaWV3VGhlbWVTaGFwZVN0eWxlKGNmZywgc2hhcGUsIHNoYXBlRmFjdG9yeSk7XG5cbiAgICB2YXIgZ2VvbVNoYXBlO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheShvYmoueSkpIHtcbiAgICAgIHZhciBoYXNBZGp1c3QgPSBzZWxmLmhhc1N0YWNrKCk7XG4gICAgICBVdGlsLmVhY2gob2JqLnksIGZ1bmN0aW9uICh5LCBpZHgpIHtcbiAgICAgICAgY2ZnLnkgPSB5O1xuICAgICAgICBjZmcueUluZGV4ID0gaWR4O1xuXG4gICAgICAgIGlmICghaGFzQWRqdXN0IHx8IGlkeCAhPT0gMCkge1xuICAgICAgICAgIGdlb21TaGFwZSA9IHNoYXBlRmFjdG9yeS5kcmF3U2hhcGUoc2hhcGUsIGNmZywgY29udGFpbmVyKTtcbiAgICAgICAgICBzZWxmLmFwcGVuZFNoYXBlSW5mbyhnZW9tU2hhcGUsIGluZGV4ICsgaWR4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghVXRpbC5pc05pbChvYmoueSkpIHtcbiAgICAgIGdlb21TaGFwZSA9IHNoYXBlRmFjdG9yeS5kcmF3U2hhcGUoc2hhcGUsIGNmZywgY29udGFpbmVyKTtcbiAgICAgIHNlbGYuYXBwZW5kU2hhcGVJbmZvKGdlb21TaGFwZSwgaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9pbnQ7XG59KEdlb21CYXNlKTtcblxudmFyIFBvaW50Sml0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUG9pbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9pbnRKaXR0ZXIsIF9Qb2ludCk7XG5cbiAgZnVuY3Rpb24gUG9pbnRKaXR0ZXIoKSB7XG4gICAgcmV0dXJuIF9Qb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFBvaW50Sml0dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfUG9pbnQucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy5oYXNEZWZhdWx0QWRqdXN0ID0gdHJ1ZTtcbiAgICBjZmcuYWRqdXN0cyA9IFt7XG4gICAgICB0eXBlOiAnaml0dGVyJ1xuICAgIH1dO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50Sml0dGVyO1xufShQb2ludCk7XG5cbnZhciBQb2ludFN0YWNrID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUG9pbnQyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50U3RhY2ssIF9Qb2ludDIpO1xuXG4gIGZ1bmN0aW9uIFBvaW50U3RhY2soKSB7XG4gICAgcmV0dXJuIF9Qb2ludDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBQb2ludFN0YWNrLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfUG9pbnQyLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcuaGFzRGVmYXVsdEFkanVzdCA9IHRydWU7XG4gICAgY2ZnLmFkanVzdHMgPSBbe1xuICAgICAgdHlwZTogJ3N0YWNrJ1xuICAgIH1dO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50U3RhY2s7XG59KFBvaW50KTtcblxuUG9pbnQuSml0dGVyID0gUG9pbnRKaXR0ZXI7XG5Qb2ludC5TdGFjayA9IFBvaW50U3RhY2s7XG5HZW9tQmFzZS5Qb2ludCA9IFBvaW50O1xuR2VvbUJhc2UuUG9pbnRKaXR0ZXIgPSBQb2ludEppdHRlcjtcbkdlb21CYXNlLlBvaW50U3RhY2sgPSBQb2ludFN0YWNrO1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAzNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHBvaW50IHNoYXBlc1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKiBAYXV0aG9yIHNpbWEuemhhbmcxOTkwQGdtYWlsLmNvbVxuICogQGF1dGhvciBodWFuZ3RvbmdlckBhbGl5dW4uY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7IC8vIGNvbnN0IHN2Z3BhdGggPSByZXF1aXJlKCdzdmdwYXRoJyk7XG5cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gICAgTWFya2VyID0gX3JlcXVpcmUuTWFya2VyO1xuXG52YXIgUGF0aFV0aWwgPSBVdGlsLlBhdGhVdGlsO1xudmFyIFNIQVBFUyA9IFsnY2lyY2xlJywgJ3NxdWFyZScsICdib3d0aWUnLCAnZGlhbW9uZCcsICdoZXhhZ29uJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLWRvd24nXTtcbnZhciBIT0xMT1dfU0hBUEVTID0gWydjcm9zcycsICd0aWNrJywgJ3BsdXMnLCAnaHlwaGVuJywgJ2xpbmUnLCAncG9pbnRlckxpbmUnLCAncG9pbnRlckFycm93J107XG52YXIgU1FSVF8zID0gTWF0aC5zcXJ0KDMpOyAvLyDlop7liqBtYXJrZXJcblxuVXRpbC5taXgoTWFya2VyLlN5bWJvbHMsIHtcbiAgaGV4YWdvbjogZnVuY3Rpb24gaGV4YWdvbih4LCB5LCByKSB7XG4gICAgdmFyIGRpZmZYID0gciAvIDIgKiBTUVJUXzM7XG4gICAgcmV0dXJuIFtbJ00nLCB4LCB5IC0gcl0sIFsnTCcsIHggKyBkaWZmWCwgeSAtIHIgLyAyXSwgWydMJywgeCArIGRpZmZYLCB5ICsgciAvIDJdLCBbJ0wnLCB4LCB5ICsgcl0sIFsnTCcsIHggLSBkaWZmWCwgeSArIHIgLyAyXSwgWydMJywgeCAtIGRpZmZYLCB5IC0gciAvIDJdLCBbJ1onXV07XG4gIH0sXG4gIGJvd3RpZTogZnVuY3Rpb24gYm93dGllKHgsIHksIHIpIHtcbiAgICB2YXIgZGlmZlkgPSByIC0gMS41O1xuICAgIHJldHVybiBbWydNJywgeCAtIHIsIHkgLSBkaWZmWV0sIFsnTCcsIHggKyByLCB5ICsgZGlmZlldLCBbJ0wnLCB4ICsgciwgeSAtIGRpZmZZXSwgWydMJywgeCAtIHIsIHkgKyBkaWZmWV0sIFsnWiddXTtcbiAgfSxcbiAgY3Jvc3M6IGZ1bmN0aW9uIGNyb3NzKHgsIHksIHIpIHtcbiAgICByZXR1cm4gW1snTScsIHggLSByLCB5IC0gcl0sIFsnTCcsIHggKyByLCB5ICsgcl0sIFsnTScsIHggKyByLCB5IC0gcl0sIFsnTCcsIHggLSByLCB5ICsgcl1dO1xuICB9LFxuICB0aWNrOiBmdW5jdGlvbiB0aWNrKHgsIHksIHIpIHtcbiAgICByZXR1cm4gW1snTScsIHggLSByIC8gMiwgeSAtIHJdLCBbJ0wnLCB4ICsgciAvIDIsIHkgLSByXSwgWydNJywgeCwgeSAtIHJdLCBbJ0wnLCB4LCB5ICsgcl0sIFsnTScsIHggLSByIC8gMiwgeSArIHJdLCBbJ0wnLCB4ICsgciAvIDIsIHkgKyByXV07XG4gIH0sXG4gIHBsdXM6IGZ1bmN0aW9uIHBsdXMoeCwgeSwgcikge1xuICAgIHJldHVybiBbWydNJywgeCAtIHIsIHldLCBbJ0wnLCB4ICsgciwgeV0sIFsnTScsIHgsIHkgLSByXSwgWydMJywgeCwgeSArIHJdXTtcbiAgfSxcbiAgaHlwaGVuOiBmdW5jdGlvbiBoeXBoZW4oeCwgeSwgcikge1xuICAgIHJldHVybiBbWydNJywgeCAtIHIsIHldLCBbJ0wnLCB4ICsgciwgeV1dO1xuICB9LFxuICBsaW5lOiBmdW5jdGlvbiBsaW5lKHgsIHksIHIpIHtcbiAgICByZXR1cm4gW1snTScsIHgsIHkgLSByXSwgWydMJywgeCwgeSArIHJdXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldEZpbGxBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRBdHRycyA9IEdsb2JhbC5zaGFwZS5wb2ludDtcbiAgdmFyIHBvaW50QXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdEF0dHJzLCBjZmcuc3R5bGUpO1xuICBTaGFwZVV0aWwuYWRkRmlsbEF0dHJzKHBvaW50QXR0cnMsIGNmZyk7XG5cbiAgaWYgKFV0aWwuaXNOdW1iZXIoY2ZnLnNpemUpKSB7XG4gICAgcG9pbnRBdHRycy5yYWRpdXMgPSBjZmcuc2l6ZTtcbiAgfVxuXG4gIHJldHVybiBwb2ludEF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lQXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0QXR0cnMgPSBHbG9iYWwuc2hhcGUuaG9sbG93UG9pbnQ7XG4gIHZhciBwb2ludEF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRBdHRycywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZFN0cm9rZUF0dHJzKHBvaW50QXR0cnMsIGNmZyk7XG5cbiAgaWYgKFV0aWwuaXNOdW1iZXIoY2ZnLnNpemUpKSB7XG4gICAgcG9pbnRBdHRycy5yYWRpdXMgPSBjZmcuc2l6ZTtcbiAgfVxuXG4gIHJldHVybiBwb2ludEF0dHJzO1xufVxuXG52YXIgUG9pbnQgPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ3BvaW50Jywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAnaG9sbG93Q2lyY2xlJyxcbiAgZ2V0QWN0aXZlQ2ZnOiBmdW5jdGlvbiBnZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gICAgLy8g54K55pS+5aSnICsg6aKc6Imy5Yqg5LquXG4gICAgdmFyIHJhZGl1cyA9IGNmZy5yYWRpdXM7XG4gICAgdmFyIGNvbG9yO1xuXG4gICAgaWYgKHR5cGUgJiYgKHR5cGUuaW5kZXhPZignaG9sbG93JykgPT09IDAgfHwgVXRpbC5pbmRleE9mKEhPTExPV19TSEFQRVMsIHR5cGUpICE9PSAtMSkgfHwgIXR5cGUpIHtcbiAgICAgIGNvbG9yID0gY2ZnLnN0cm9rZSB8fCBjZmcuc3Ryb2tlU3R5bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gY2ZnLmZpbGwgfHwgY2ZnLmZpbGxTdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmFkaXVzOiByYWRpdXMgKyAxLFxuICAgICAgc2hhZG93Qmx1cjogcmFkaXVzLFxuICAgICAgc2hhZG93Q29sb3I6IGNvbG9yLFxuICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICBsaW5lV2lkdGg6IDFcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0UG9pbnRzOiBmdW5jdGlvbiBnZXREZWZhdWx0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHJldHVybiBTaGFwZVV0aWwuc3BsaXRQb2ludHMocG9pbnRJbmZvKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFJlY3RQYXRoKGNmZykge1xuICB2YXIgeCA9IGNmZy5wb2ludHNbMF0ueDtcbiAgdmFyIHkgPSBjZmcucG9pbnRzWzBdLnk7XG4gIHZhciB3ID0gY2ZnLnNpemVbMF07XG4gIHZhciBoID0gY2ZnLnNpemVbMV07XG4gIHZhciBwYXRoID0gW1snTScsIHggLSAwLjUgKiB3LCB5IC0gMC41ICogaF0sIFsnTCcsIHggKyAwLjUgKiB3LCB5IC0gMC41ICogaF0sIFsnTCcsIHggKyAwLjUgKiB3LCB5ICsgMC41ICogaF0sIFsnTCcsIHggLSAwLjUgKiB3LCB5ICsgMC41ICogaF0sIFsneiddXTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIOeUqOS6juahkeWfuuWbvueahOiKgueCuVxuXG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3BvaW50JywgJ3JlY3QnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmVjdEF0dHJzID0gZ2V0RmlsbEF0dHJzKGNmZyk7XG4gICAgdmFyIHBhdGggPSBnZXRSZWN0UGF0aChjZmcpO1xuICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICB2YXIgZ1NoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KHJlY3RBdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBnU2hhcGU7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHZhciBhdHRycyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgIGF0dHJzLnN5bWJvbCA9ICdyZWN0JztcbiAgICBhdHRycy5yYWRpdXMgPSA0LjU7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG59KTsgLy8g5re75Yqgc2hhcGVzXG5cblV0aWwuZWFjaChTSEFQRVMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICBTaGFwZS5yZWdpc3RlclNoYXBlKCdwb2ludCcsIHNoYXBlLCB7XG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgICAgLy8gY2ZnLnBvaW50cyA9IHRoaXMucGFyc2VQb2ludHMoY2ZnLnBvaW50cyk7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ01hcmtlcicsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgICAgc3ltYm9sOiBzaGFwZSxcbiAgICAgICAgICB4OiBjZmcueCxcbiAgICAgICAgICB5OiBjZmcueVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgICAgYXR0cnMuc3ltYm9sID0gc2hhcGU7XG4gICAgICBhdHRycy5yYWRpdXMgPSA0LjU7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICB9KTsgLy8g5re75Yqg6K+lIHNoYXBlIOWvueW6lOeahCBob2xsb3dTaGFwZVxuXG4gIFNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3BvaW50JywgJ2hvbGxvdycgKyBVdGlsLnVwcGVyRmlyc3Qoc2hhcGUpLCB7XG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgICAgLy8gY2ZnLnBvaW50cyA9IHRoaXMucGFyc2VQb2ludHMoY2ZnLnBvaW50cyk7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRMaW5lQXR0cnMoY2ZnKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ01hcmtlcicsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgICAgc3ltYm9sOiBzaGFwZSxcbiAgICAgICAgICB4OiBjZmcueCxcbiAgICAgICAgICB5OiBjZmcueVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldExpbmVBdHRycyhjZmcpO1xuICAgICAgYXR0cnMuc3ltYm9sID0gc2hhcGU7XG4gICAgICBhdHRycy5yYWRpdXMgPSA0LjU7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuICB9KTtcbn0pOyAvLyDmt7vliqAgaG9sbG93U2hhcGVzXG5cblV0aWwuZWFjaChIT0xMT1dfU0hBUEVTLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgU2hhcGUucmVnaXN0ZXJTaGFwZSgncG9pbnQnLCBzaGFwZSwge1xuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBhdHRycyA9IGdldExpbmVBdHRycyhjZmcpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnTWFya2VyJywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgICBzeW1ib2w6IHNoYXBlLFxuICAgICAgICAgIHg6IGNmZy54LFxuICAgICAgICAgIHk6IGNmZy55XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0TGluZUF0dHJzKGNmZyk7XG4gICAgICBhdHRycy5zeW1ib2wgPSBzaGFwZTtcbiAgICAgIGF0dHJzLnJhZGl1cyA9IDQuNTtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gIH0pO1xufSk7IC8vIGltYWdlXG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3BvaW50JywgJ2ltYWdlJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgY2ZnLnBvaW50cyA9IHRoaXMucGFyc2VQb2ludHMoY2ZnLnBvaW50cyk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnaW1hZ2UnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB4OiBjZmcucG9pbnRzWzBdLnggLSBjZmcuc2l6ZSAvIDIsXG4gICAgICAgIHk6IGNmZy5wb2ludHNbMF0ueSAtIGNmZy5zaXplLFxuICAgICAgICB3aWR0aDogY2ZnLnNpemUsXG4gICAgICAgIGhlaWdodDogY2ZnLnNpemUsXG4gICAgICAgIGltZzogY2ZnLnNoYXBlWzFdXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pOyAvLyBwYXRoXG5cbnZhciBwYXRoTWV0YUNhY2hlID0ge307XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdwb2ludCcsICdwYXRoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gVXRpbC5taXgoe30sIGdldExpbmVBdHRycyhjZmcpLCBnZXRGaWxsQXR0cnMoY2ZnKSk7XG4gICAgdmFyIHBhdGggPSBjZmcuc2hhcGVbMV07XG4gICAgdmFyIHNpemUgPSBjZmcuc2l6ZSB8fCAxMDtcbiAgICB2YXIgcGF0aE1ldGE7XG5cbiAgICBpZiAocGF0aE1ldGFDYWNoZVtwYXRoXSkge1xuICAgICAgcGF0aE1ldGEgPSBwYXRoTWV0YUNhY2hlW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBQYXRoVXRpbC5wYXJzZVBhdGhTdHJpbmcocGF0aCk7XG4gICAgICB2YXIgbnVtcyA9IFV0aWwuZmxhdHRlbihzZWdtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgcmV0dXJuIFV0aWwuaXNOdW1iZXIobnVtKTtcbiAgICAgIH0pO1xuICAgICAgcGF0aE1ldGFDYWNoZVtwYXRoXSA9IHBhdGhNZXRhID0ge1xuICAgICAgICByYW5nZTogTWF0aC5tYXguYXBwbHkobnVsbCwgbnVtcykgLSBNYXRoLm1pbi5hcHBseShudWxsLCBudW1zKSxcbiAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IHNpemUgLyBwYXRoTWV0YS5yYW5nZTtcbiAgICB2YXIgdHJhbnNmb3JtID0gW107XG5cbiAgICBpZiAoYXR0cnMucm90YXRlKSB7XG4gICAgICB0cmFuc2Zvcm0ucHVzaChbJ3InLCBhdHRycy5yb3RhdGUgLyAxODAgKiBNYXRoLlBJXSk7XG4gICAgICBkZWxldGUgYXR0cnMucm90YXRlO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoTWV0YS5zZWdtZW50c1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB0cmFuc2Zvcm0ucHVzaChbJ3MnLCBzY2FsZSwgc2NhbGVdLCBbJ3QnLCBjZmcueCwgY2ZnLnldKTtcbiAgICBzaGFwZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAzNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19uYW1lc3BhY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIixcbiAgICAgIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbmFtZXNwYWNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7XG4gICAgc3BhY2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbmFtZXNwYWNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dW3ByZWZpeF0sXG4gICAgbG9jYWw6IG5hbWVcbiAgfSA6IG5hbWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAzNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHhodG1sOyB9KTtcbnZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9ICh7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59KTtcblxuLyoqKi8gfSksXG4vKiAzNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBub25lKCkge31cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMzczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCAvLyBub2RlIGlzIGEgTm9kZVxuICBub2RlLmRvY3VtZW50ICYmIG5vZGUgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXZlbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBjdXN0b21FdmVudDtcbnZhciBmaWx0ZXJFdmVudHMgPSB7fTtcbnZhciBldmVudCA9IG51bGw7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHtcbiAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudDEpIHtcbiAgICB2YXIgZXZlbnQwID0gZXZlbnQ7IC8vIEV2ZW50cyBjYW4gYmUgcmVlbnRyYW50IChlLmcuLCBmb2N1cykuXG5cbiAgICBldmVudCA9IGV2ZW50MTtcblxuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsXG4gICAgICAgIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHQsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcblxuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpLCBncm91cCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbixcbiAgICAgICAgbyxcbiAgICAgICAgbGlzdGVuZXIgPSB3cmFwKHZhbHVlLCBpLCBncm91cCk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5jYXB0dXJlID0gY2FwdHVyZSk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIG8gPSB7XG4gICAgICB0eXBlOiB0eXBlbmFtZS50eXBlLFxuICAgICAgbmFtZTogdHlwZW5hbWUubmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgICB9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImJcIl0gPSAoZnVuY3Rpb24gKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSxcbiAgICAgIGksXG4gICAgICBuID0gdHlwZW5hbWVzLmxlbmd0aCxcbiAgICAgIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcblxuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIGNhcHR1cmUpKTtcblxuICByZXR1cm4gdGhpcztcbn0pO1xuZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV2ZW50O1xuICBldmVudCA9IGV2ZW50MTtcblxuICB0cnkge1xuICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBldmVudCA9IGV2ZW50MDtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDM3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NlbGVjdGlvbl9vbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzQpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN1cnJlbnQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NlbGVjdGlvbl9vbl9fW1wiY1wiIC8qIGV2ZW50ICovXSxcbiAgICAgIHNvdXJjZTtcblxuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcblxuICByZXR1cm4gY3VycmVudDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFydCkge1xuICB2YXIgc2NhbGVDb250cm9sbGVyID0gY2hhcnQuZ2V0KCdzY2FsZUNvbnRyb2xsZXInKSB8fCB7fTtcbiAgcmV0dXJuIHNjYWxlQ29udHJvbGxlci5kZWZzO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldENvbERlZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Nik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYXJ0LCBmaWVsZCkge1xuICB2YXIgY29sRGVmcyA9IGdldENvbERlZnMoY2hhcnQpO1xuXG4gIGlmIChjb2xEZWZzICYmIGNvbERlZnNbZmllbGRdKSB7XG4gICAgcmV0dXJuIGNvbERlZnNbZmllbGRdO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBUaW1lVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBzY2FsZSkge1xuICB2YXIgcmVzdWx0O1xuICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZCxcbiAgICAgIHR5cGUgPSBzY2FsZS50eXBlO1xuICB2YXIgdmFsdWVzID0gVXRpbC5BcnJheS52YWx1ZXMoZGF0YSwgZmllbGQpO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJykge1xuICAgIHJlc3VsdCA9IFV0aWwuQXJyYXkuZ2V0UmFuZ2UodmFsdWVzKTtcblxuICAgIGlmIChzY2FsZS5taW4gPCByZXN1bHQubWluKSB7XG4gICAgICByZXN1bHQubWluID0gc2NhbGUubWluO1xuICAgIH1cblxuICAgIGlmIChzY2FsZS5tYXggPiByZXN1bHQubWF4KSB7XG4gICAgICByZXN1bHQubWF4ID0gc2NhbGUubWF4O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAndGltZUNhdCcpIHtcbiAgICBVdGlsLmVhY2godmFsdWVzLCBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgdmFsdWVzW2ldID0gVGltZVV0aWwudG9UaW1lU3RhbXAodik7XG4gICAgfSk7XG4gICAgdmFsdWVzLnNvcnQoZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIHYxIC0gdjI7XG4gICAgfSk7XG4gICAgcmVzdWx0ID0gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHZhbHVlcztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NlbGVjdGlvbl9pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgPyBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zZWxlY3Rpb25faW5kZXhfX1tcImFcIiAvKiBTZWxlY3Rpb24gKi9dKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pIDogbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0aW9uX2luZGV4X19bXCJhXCIgLyogU2VsZWN0aW9uICovXShbW3NlbGVjdG9yXV0sIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0aW9uX2luZGV4X19bXCJjXCIgLyogcm9vdCAqL10pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMzgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBtYXRjaGVyID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIH07XG59O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIGlmICghZWxlbWVudC5tYXRjaGVzKSB7XG4gICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcblxuICAgIG1hdGNoZXIgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2ZW5kb3JNYXRjaGVzLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAobWF0Y2hlcik7XG5cbi8qKiovIH0pLFxuLyogMzgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBFbnRlck5vZGU7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcGFyc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJiXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2luZGV4X19bXCJhXCIgLyogU2VsZWN0aW9uICovXSh0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3BhcnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pLCB0aGlzLl9wYXJlbnRzKTtcbn0pO1xuZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTtcbiAgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAodXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAzODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYlwiXSA9IHN0eWxlVmFsdWU7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX193aW5kb3dfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzczKTtcblxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7ZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZUZ1bmN0aW9uIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKSA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufSk7XG5mdW5jdGlvbiBzdHlsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX193aW5kb3dfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufVxuXG4vKioqLyB9KSxcbi8qIDM4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RyYW5zaXRpb25fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190cmFuc2l0aW9uX3NjaGVkdWxlX19bXCJkXCIgLyogU1RBUlRJTkcgKi9dICYmIHNjaGVkdWxlLnN0YXRlIDwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190cmFuc2l0aW9uX3NjaGVkdWxlX19bXCJiXCIgLyogRU5ESU5HICovXTtcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fdHJhbnNpdGlvbl9zY2hlZHVsZV9fW1wiYVwiIC8qIEVOREVEICovXTtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgaWYgKGFjdGl2ZSkgc2NoZWR1bGUub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kM19pbnRlcnBvbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfaW50ZXJwb2xhdGVfX1tcImludGVycG9sYXRlTnVtYmVyXCJdIDogYiBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19jb2xvcl9fW1wiYVwiIC8qIGNvbG9yICovXSA/IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kM19pbnRlcnBvbGF0ZV9fW1wiaW50ZXJwb2xhdGVSZ2JcIl0gOiAoYyA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfY29sb3JfX1tcImFcIiAvKiBjb2xvciAqL10pKGIpKSA/IChiID0gYywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2QzX2ludGVycG9sYXRlX19bXCJpbnRlcnBvbGF0ZVJnYlwiXSkgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfaW50ZXJwb2xhdGVfX1tcImludGVycG9sYXRlU3RyaW5nXCJdKShhLCBiKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOWIhumdoueahOWfuuexu1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjMpO1xuLyoqXG4gKiDnn6nlvaLnmoQgZmFjZXQg5pyJ5Lul5LiL5bGe5oCn77yaXG4gKiAtIGNvbEZpZWxkIOWIl+eahOWtl+autVxuICogLSByb3dGaWVsZCDooYznmoTlrZfmrrVcbiAqIC0gY29sVmFsdWUg5YiX5a2X5q6155qE5YC8XG4gKiAtIHJvd1ZhbHVlIOihjOWtl+auteeahOWAvFxuICogLSBjb2xzIOWIl+aVsFxuICogLSByb3dzIOihjOaVsFxuICogLSBjb2xJbmRleCDliJfnmoTluo/lj7dcbiAqIC0gcm93SW5kZXgg6KGM55qE5bqP5Y+3XG4gKi9cblxuLyoqXG4gKiDnlKjkuo7nlJ/miJDliIbpnaLnmoTnsbtcbiAqIEBjbGFzcyBGYWNldHMuUmVjdFxuICovXG5cblxudmFyIFJlY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlY3QsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBSZWN0KCkge1xuICAgIHJldHVybiBfQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVjdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAncmVjdCc7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uZ2VuZXJhdGVGYWNldHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUZhY2V0cyhkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaWVsZHMgPSBzZWxmLmZpZWxkczsgLy8gdmFyIGRlZnMgPSBzZWxmLmRlZnM7XG5cbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIHJvd3MgPSAxO1xuICAgIHZhciBjb2xzID0gMTtcbiAgICB2YXIgY29sRmllbGQgPSBmaWVsZHNbMF07XG4gICAgdmFyIHJvd0ZpZWxkID0gZmllbGRzWzFdO1xuICAgIHZhciBjb2xWYWx1ZXMgPSBbJyddO1xuICAgIHZhciByb3dWYWx1ZXMgPSBbJyddO1xuXG4gICAgaWYgKGNvbEZpZWxkKSB7XG4gICAgICBjb2xWYWx1ZXMgPSBzZWxmLmdldEZpZWxkVmFsdWVzKGNvbEZpZWxkLCBkYXRhKTtcbiAgICAgIGNvbHMgPSBjb2xWYWx1ZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyb3dGaWVsZCkge1xuICAgICAgcm93VmFsdWVzID0gc2VsZi5nZXRGaWVsZFZhbHVlcyhyb3dGaWVsZCwgZGF0YSk7XG4gICAgICByb3dzID0gcm93VmFsdWVzLmxlbmd0aDtcbiAgICB9IC8vIOiOt+WPluavj+S4que7tOW6puWvueW6lOeahGZyYW1lXG5cblxuICAgIGNvbFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh4VmFsLCB4SW5kZXgpIHtcbiAgICAgIHJvd1ZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh5VmFsLCB5SW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbe1xuICAgICAgICAgIGZpZWxkOiBjb2xGaWVsZCxcbiAgICAgICAgICB2YWx1ZTogeFZhbCxcbiAgICAgICAgICB2YWx1ZXM6IGNvbFZhbHVlc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZmllbGQ6IHJvd0ZpZWxkLFxuICAgICAgICAgIHZhbHVlOiB5VmFsLFxuICAgICAgICAgIHZhbHVlczogcm93VmFsdWVzXG4gICAgICAgIH1dO1xuICAgICAgICB2YXIgZmlsdGVyID0gc2VsZi5nZXRGaWx0ZXIoY29uZGl0aW9ucyk7XG4gICAgICAgIHZhciBzdWJEYXRhID0gZGF0YS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgdmFyIGZhY2V0ID0ge1xuICAgICAgICAgIHR5cGU6IHNlbGYudHlwZSxcbiAgICAgICAgICBjb2xWYWx1ZTogeFZhbCxcbiAgICAgICAgICByb3dWYWx1ZTogeVZhbCxcbiAgICAgICAgICBjb2xGaWVsZDogY29sRmllbGQsXG4gICAgICAgICAgcm93RmllbGQ6IHJvd0ZpZWxkLFxuICAgICAgICAgIGNvbEluZGV4OiB4SW5kZXgsXG4gICAgICAgICAgcm93SW5kZXg6IHlJbmRleCxcbiAgICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICAgIHJvd3M6IHJvd3MsXG4gICAgICAgICAgZGF0YTogc3ViRGF0YSxcbiAgICAgICAgICByZWdpb246IHNlbGYuZ2V0UmVnaW9uKHJvd3MsIGNvbHMsIHhJbmRleCwgeUluZGV4KVxuICAgICAgICB9O1xuICAgICAgICByc3QucHVzaChmYWNldCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9OyAvLyDorr7nva4geCDlnZDmoIfovbTnmoTmlofmnKzjgIF0aXRsZSDmmK/lkKbmmL7npLpcblxuXG4gIF9wcm90by5zZXRYQXhpcyA9IGZ1bmN0aW9uIHNldFhBeGlzKHhGaWVsZCwgYXhlcywgZmFjZXQpIHtcbiAgICBpZiAoZmFjZXQucm93SW5kZXggIT09IGZhY2V0LnJvd3MgLSAxKSB7XG4gICAgICBheGVzW3hGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgICAgYXhlc1t4RmllbGRdLmxhYmVsID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGZhY2V0LmNvbEluZGV4ICE9PSBwYXJzZUludCgoZmFjZXQuY29scyAtIDEpIC8gMikpIHtcbiAgICAgIGF4ZXNbeEZpZWxkXS50aXRsZSA9IG51bGw7XG4gICAgfVxuICB9OyAvLyDorr7nva4geSDlnZDmoIfovbTnmoTmlofmnKzjgIF0aXRsZSDmmK/lkKbmmL7npLpcblxuXG4gIF9wcm90by5zZXRZQXhpcyA9IGZ1bmN0aW9uIHNldFlBeGlzKHlGaWVsZCwgYXhlcywgZmFjZXQpIHtcbiAgICBpZiAoZmFjZXQuY29sSW5kZXggIT09IDApIHtcbiAgICAgIGF4ZXNbeUZpZWxkXS50aXRsZSA9IG51bGw7XG4gICAgICBheGVzW3lGaWVsZF0ubGFiZWwgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZmFjZXQucm93SW5kZXggIT09IHBhcnNlSW50KChmYWNldC5yb3dzIC0gMSkgLyAyKSkge1xuICAgICAgYXhlc1t5RmllbGRdLnRpdGxlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlclRpdGxlID0gZnVuY3Rpb24gcmVuZGVyVGl0bGUodmlldywgZmFjZXQpIHtcbiAgICBpZiAoZmFjZXQucm93SW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMuZHJhd0NvbFRpdGxlKHZpZXcsIGZhY2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZmFjZXQuY29sSW5kZXggPT09IGZhY2V0LmNvbHMgLSAxKSB7XG4gICAgICB0aGlzLmRyYXdSb3dUaXRsZSh2aWV3LCBmYWNldCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWN0O1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0O1xuXG4vKioqLyB9KSxcbi8qIDM4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IGxpc3QgZmFjZXRzLCBzdXBwb3J0IGNvbHNcbiAqL1xudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Myk7XG4vKipcbiAqIOeUqOS6jueUn+aIkOWIhumdoueahOexu1xuICogQGNsYXNzIEZhY2V0cy5MaXN0XG4gKi9cblxuXG52YXIgTGlzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGlzdCwgX0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIExpc3QoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9CYXNlLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcudHlwZSA9ICdsaXN0JztcbiAgICBjZmcuY29scyA9IG51bGw7IC8vIOeUqOaIt+S4jeiuvue9ruaXtuWwseaYvuekuuS4gOihjFxuXG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uZ2VuZXJhdGVGYWNldHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUZhY2V0cyhkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaWVsZHMgPSBzZWxmLmZpZWxkcztcbiAgICB2YXIgY29sRmllbGQgPSBmaWVsZHNbMF07XG5cbiAgICBpZiAoIWNvbEZpZWxkKSB7XG4gICAgICB0aHJvdyAnUGxlYXNlIHNwZWNpZnkgZm9yIHRoZSBmaWVsZCBmb3IgZmFjZXQhJztcbiAgICB9XG5cbiAgICB2YXIgY29sVmFsdWVzID0gc2VsZi5nZXRGaWVsZFZhbHVlcyhjb2xGaWVsZCwgZGF0YSk7XG4gICAgdmFyIGNvdW50ID0gY29sVmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgY29scyA9IHNlbGYuY29scyB8fCBjb3VudDtcbiAgICB2YXIgcm93cyA9IHBhcnNlSW50KChjb3VudCArIGNvbHMgLSAxKSAvIGNvbHMpO1xuICAgIHZhciByc3QgPSBbXTtcbiAgICBjb2xWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoeFZhbCwgaW5kZXgpIHtcbiAgICAgIHZhciByb3cgPSBwYXJzZUludChpbmRleCAvIGNvbHMpO1xuICAgICAgdmFyIGNvbCA9IGluZGV4ICUgY29scztcbiAgICAgIHZhciBjb25kaXRpb25zID0gW3tcbiAgICAgICAgZmllbGQ6IGNvbEZpZWxkLFxuICAgICAgICB2YWx1ZTogeFZhbCxcbiAgICAgICAgdmFsdWVzOiBjb2xWYWx1ZXNcbiAgICAgIH1dO1xuICAgICAgdmFyIGZpbHRlciA9IHNlbGYuZ2V0RmlsdGVyKGNvbmRpdGlvbnMpO1xuICAgICAgdmFyIHN1YkRhdGEgPSBkYXRhLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgdmFyIGZhY2V0ID0ge1xuICAgICAgICB0eXBlOiBzZWxmLnR5cGUsXG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgY29sVmFsdWU6IHhWYWwsXG4gICAgICAgIGNvbEZpZWxkOiBjb2xGaWVsZCxcbiAgICAgICAgcm93RmllbGQ6IG51bGwsXG4gICAgICAgIHJvd1ZhbHVlOiB4VmFsLFxuICAgICAgICBjb2xJbmRleDogY29sLFxuICAgICAgICByb3dJbmRleDogcm93LFxuICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICBkYXRhOiBzdWJEYXRhLFxuICAgICAgICByZWdpb246IHNlbGYuZ2V0UmVnaW9uKHJvd3MsIGNvbHMsIGNvbCwgcm93KVxuICAgICAgfTtcbiAgICAgIHJzdC5wdXNoKGZhY2V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9OyAvLyDorr7nva4geCDlnZDmoIfovbTnmoTmlofmnKzjgIF0aXRsZSDmmK/lkKbmmL7npLpcblxuXG4gIF9wcm90by5zZXRYQXhpcyA9IGZ1bmN0aW9uIHNldFhBeGlzKHhGaWVsZCwgYXhlcywgZmFjZXQpIHtcbiAgICAvLyDlvZPmmK/mnIDlkI7kuIDooYzmiJbogIXkuIvpnaLmsqHmnIkgdmlldyDml7bmlofmnKzkuI3mmL7npLpcbiAgICBpZiAoZmFjZXQucm93SW5kZXggIT09IGZhY2V0LnJvd3MgLSAxICYmIGZhY2V0LmNvbHMgKiBmYWNldC5yb3dJbmRleCArIGZhY2V0LmNvbEluZGV4ICsgMSArIGZhY2V0LmNvbHMgPD0gZmFjZXQuY291bnQpIHtcbiAgICAgIGF4ZXNbeEZpZWxkXS5sYWJlbCA9IG51bGw7XG4gICAgICBheGVzW3hGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgIH1cbiAgfTsgLy8g6K6+572uIHkg5Z2Q5qCH6L2055qE5paH5pys44CBdGl0bGUg5piv5ZCm5pi+56S6XG5cblxuICBfcHJvdG8uc2V0WUF4aXMgPSBmdW5jdGlvbiBzZXRZQXhpcyh5RmllbGQsIGF4ZXMsIGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0LmNvbEluZGV4ICE9PSAwKSB7XG4gICAgICBheGVzW3lGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgICAgYXhlc1t5RmllbGRdLmxhYmVsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExpc3Q7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cbi8qKiovIH0pLFxuLyogMzg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBHMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcyKTsgLy8gZ2VvbXNcblxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM5MCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzkyKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzOTQpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM2NCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzY2KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzNTkpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM2OCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzk1KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzOTcpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM5OSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNDU5KTsgLy8gZmFjZXRzXG5cblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0NjEpOyAvLyBpbnRlcmFjdGlvblxuXG5cbl9fd2VicGFja19yZXF1aXJlX18oNDY2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHMjtcblxuLyoqKi8gfSksXG4vKiAzOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg6Z2i56ev5Zu+XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBTcGxpdE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTgpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzkxKTtcblxudmFyIEFyZWEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShBcmVhLCBfR2VvbUJhc2UpO1xuXG4gIHZhciBfcHJvdG8gPSBBcmVhLnByb3RvdHlwZTtcblxuICAvKipcbiAgICog6I635Y+W6buY6K6k55qE6YWN572u5bGe5oCnXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSDpu5jorqTlsZ7mgKdcbiAgICovXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0dlb21CYXNlLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcudHlwZSA9ICdhcmVhJztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ2FyZWEnO1xuICAgIGNmZy5nZW5lcmF0ZVBvaW50cyA9IHRydWU7XG4gICAgY2ZnLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFyZWEoY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfR2VvbUJhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFNwbGl0TWl4aW4pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9wcm90by5kcmF3ID0gZnVuY3Rpb24gZHJhdyhkYXRhLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSwgaW5kZXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNmZyA9IHRoaXMuZ2V0RHJhd0NmZyhkYXRhWzBdKTtcblxuICAgIHNlbGYuX2FwcGx5Vmlld1RoZW1lU2hhcGVTdHlsZShjZmcsIGNmZy5zaGFwZSwgc2hhcGVGYWN0b3J5KTtcblxuICAgIHZhciBzcGxpdEFycmF5ID0gdGhpcy5zcGxpdERhdGEoZGF0YSk7XG4gICAgY2ZnLm9yaWdpbiA9IGRhdGE7IC8vIHBhdGgsbGluZSxhcmVhIOetieWbvueahG9yaWdpbiDmmK/mlbTkuKrluo/liJdcblxuICAgIFV0aWwuZWFjaChzcGxpdEFycmF5LCBmdW5jdGlvbiAoc3ViRGF0YSwgc3BsaXRlZEluZGV4KSB7XG4gICAgICBjZmcuc3BsaXRlZEluZGV4ID0gc3BsaXRlZEluZGV4OyAvLyDkvKDlhaXliIblibLniYfmrrXntKLlvJUg55So5LqO55Sf5oiQaWRcblxuICAgICAgdmFyIHBvaW50cyA9IHN1YkRhdGEubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5wb2ludHM7XG4gICAgICB9KTtcbiAgICAgIGNmZy5wb2ludHMgPSBwb2ludHM7XG4gICAgICB2YXIgZ2VvbVNoYXBlID0gc2hhcGVGYWN0b3J5LmRyYXdTaGFwZShjZmcuc2hhcGUsIGNmZywgY29udGFpbmVyKTtcbiAgICAgIHNlbGYuYXBwZW5kU2hhcGVJbmZvKGdlb21TaGFwZSwgaW5kZXggKyBzcGxpdGVkSW5kZXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBcmVhO1xufShHZW9tQmFzZSk7XG5cbnZhciBBcmVhU3RhY2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BcmVhKSB7XG4gIF9pbmhlcml0c0xvb3NlKEFyZWFTdGFjaywgX0FyZWEpO1xuXG4gIGZ1bmN0aW9uIEFyZWFTdGFjaygpIHtcbiAgICByZXR1cm4gX0FyZWEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBBcmVhU3RhY2sucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9BcmVhLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcuaGFzRGVmYXVsdEFkanVzdCA9IHRydWU7XG4gICAgY2ZnLmFkanVzdHMgPSBbe1xuICAgICAgdHlwZTogJ3N0YWNrJ1xuICAgIH1dO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIEFyZWFTdGFjaztcbn0oQXJlYSk7XG5cbkFyZWEuU3RhY2sgPSBBcmVhU3RhY2s7XG5HZW9tQmFzZS5BcmVhID0gQXJlYTtcbkdlb21CYXNlLkFyZWFTdGFjayA9IEFyZWFTdGFjaztcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcblxuLyoqKi8gfSksXG4vKiAzOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IGFyZWEgc2hhcGVcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIFBhdGhVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBTaGFwZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbmZ1bmN0aW9uIGdldExpbmVBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRBdHRycyA9IEdsb2JhbC5zaGFwZS5ob2xsb3dBcmVhO1xuICB2YXIgbGluZUF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRBdHRycywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZFN0cm9rZUF0dHJzKGxpbmVBdHRycywgY2ZnKTtcblxuICBpZiAoVXRpbC5pc051bWJlcihjZmcuc2l6ZSkpIHtcbiAgICBsaW5lQXR0cnMubGluZVdpZHRoID0gY2ZnLnNpemU7XG4gIH1cblxuICByZXR1cm4gbGluZUF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsQXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0QXR0cnMgPSBHbG9iYWwuc2hhcGUuYXJlYTtcbiAgdmFyIGFyZWFBdHRycyA9IFV0aWwubWl4KHt9LCBkZWZhdWx0QXR0cnMsIGNmZy5zdHlsZSk7XG4gIFNoYXBlVXRpbC5hZGRGaWxsQXR0cnMoYXJlYUF0dHJzLCBjZmcpO1xuXG4gIGlmIChjZmcuY29sb3IpIHtcbiAgICBhcmVhQXR0cnMuc3Ryb2tlID0gYXJlYUF0dHJzLnN0cm9rZSB8fCBjZmcuY29sb3I7XG4gIH1cblxuICBpZiAoVXRpbC5pc051bWJlcihjZmcuc2l6ZSkpIHtcbiAgICBhcmVhQXR0cnMubGluZVdpZHRoID0gY2ZnLnNpemU7XG4gIH1cblxuICByZXR1cm4gYXJlYUF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoKGNmZywgc21vb3RoLCBzaGFwZSkge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgcG9pbnRzQXJyID0gW107XG4gIHZhciB0b3BMaW5lUG9pbnRzID0gW107IC8vIGFyZWEg5Yy65Z+f5LiK6YOo5YiGXG5cbiAgdmFyIGJvdHRvbUxpbmVQb2ludHMgPSBbXTsgLy8gYXJlYSDljLrln5/kuIvpg6jliIZcblxuICB2YXIgaXNJbkNpcmNsZSA9IGNmZy5pc0luQ2lyY2xlO1xuICBVdGlsLmVhY2goY2ZnLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdG9wTGluZVBvaW50cy5wdXNoKHBvaW50WzFdKTtcbiAgICBib3R0b21MaW5lUG9pbnRzLnB1c2gocG9pbnRbMF0pO1xuICB9KTsgLy8gaWYgKCFpc0luQ2lyY2xlKSB7XG5cbiAgYm90dG9tTGluZVBvaW50cyA9IGJvdHRvbUxpbmVQb2ludHMucmV2ZXJzZSgpOyAvLyB9XG5cbiAgcG9pbnRzQXJyLnB1c2godG9wTGluZVBvaW50cywgYm90dG9tTGluZVBvaW50cyk7XG4gIFV0aWwuZWFjaChwb2ludHNBcnIsIGZ1bmN0aW9uIChwb2ludHMsIGluZGV4KSB7XG4gICAgdmFyIHN1YlBhdGggPSBbXTtcbiAgICBwb2ludHMgPSBzaGFwZS5wYXJzZVBvaW50cyhwb2ludHMpO1xuICAgIHZhciBwMSA9IHBvaW50c1swXTtcblxuICAgIGlmIChpc0luQ2lyY2xlKSB7XG4gICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgIHg6IHAxLngsXG4gICAgICAgIHk6IHAxLnlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzbW9vdGgpIHtcbiAgICAgIHN1YlBhdGggPSBQYXRoVXRpbC5nZXRTcGxpbmVQYXRoKHBvaW50cywgZmFsc2UsIGNmZy5jb25zdHJhaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViUGF0aCA9IFBhdGhVdGlsLmdldExpbmVQYXRoKHBvaW50cywgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHN1YlBhdGhbMF1bMF0gPSAnTCc7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGguY29uY2F0KHN1YlBhdGgpO1xuICB9KTtcbiAgcGF0aC5wdXNoKFsnWiddKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIGdldCBtYXJrZXIgY2ZnXG5cblxuZnVuY3Rpb24gX2dldE1hcmtlckNmZyhjZmcpIHtcbiAgcmV0dXJuIHtcbiAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbCh4LCB5KSB7XG4gICAgICByZXR1cm4gW1snTScsIHggLSA1LjUsIHkgLSA0XSwgWydMJywgeCArIDUuNSwgeSAtIDRdLCBbJ0wnLCB4ICsgNS41LCB5ICsgNF0sIFsnTCcsIHggLSA1LjUsIHkgKyA0XSwgWydaJ11dO1xuICAgIH0sXG4gICAgcmFkaXVzOiA1LFxuICAgIGZpbGw6IGNmZy5jb2xvcixcbiAgICBmaWxsT3BhY2l0eTogMC42XG4gIH07XG59IC8vIOm8oOagh+aCrOa1ruinpuWPkWFjdGl2ZeeKtuaAgVxuXG5cbmZ1bmN0aW9uIF9nZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gIGlmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ3Ntb290aExpbmUnKSB7XG4gICAgLy8g57q/5Yqg57KXXG4gICAgdmFyIGxpbmVXaWR0aCA9IGNmZy5saW5lV2lkdGggfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGggKyAxXG4gICAgfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gY2ZnLmZpbGxPcGFjaXR5IHx8IGNmZy5vcGFjaXR5IHx8IDE7XG4gIHJldHVybiB7XG4gICAgZmlsbE9wYWNpdHk6IG9wYWNpdHkgLSAwLjE1LFxuICAgIHN0cm9rZU9wYWNpdHk6IG9wYWNpdHkgLSAwLjE1XG4gIH07XG59IC8vIOW9k+WPquacieS4gOS4quaVsOaNruaXtue7mOWItueCuVxuXG5cbmZ1bmN0aW9uIGRyYXdQb2ludFNoYXBlKHNoYXBlT2JqLCBjZmcsIGNvbnRhaW5lcikge1xuICB2YXIgY29vcmQgPSBzaGFwZU9iai5fY29vcmQ7XG4gIHZhciBwb2ludCA9IGNvb3JkLmNvbnZlcnRQb2ludChjZmcucG9pbnRzWzBdWzFdKTtcbiAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnY2lyY2xlJywge1xuICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICB4OiBwb2ludC54LFxuICAgICAgeTogcG9pbnQueSxcbiAgICAgIHI6IDIsXG4gICAgICBmaWxsOiBjZmcuY29sb3JcbiAgICB9LCBjZmcuc3R5bGUpXG4gIH0pO1xufVxuXG52YXIgQXJlYSA9IFNoYXBlLnJlZ2lzdGVyRmFjdG9yeSgnYXJlYScsIHtcbiAgZGVmYXVsdFNoYXBlVHlwZTogJ2FyZWEnLFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByb3RlY3RlZFxuICAgKiDorqHnrpfngrkg5aaC5p6c5a2Y5Zyo5aSa5Liq54K577yM5YiG5Ymy5oiQ5Y2V5Liq55qE54K5LCDkuI3ogIPomZHlpJrkuKp45a+55bqU5LiA5LiqeeeahOaDheWGtVxuICAgKiDljZXngrnliJnooaXkuIp5MOeCuVxuICAgKi9cbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cyhwb2ludEluZm8pIHtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHggPSBwb2ludEluZm8ueDtcbiAgICB2YXIgeSA9IHBvaW50SW5mby55O1xuICAgIHZhciB5MCA9IHBvaW50SW5mby55MDtcbiAgICB5ID0gVXRpbC5pc0FycmF5KHkpID8geSA6IFt5MCwgeV07XG4gICAgVXRpbC5lYWNoKHksIGZ1bmN0aW9uICh5SXRlbSkge1xuICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5SXRlbVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgLy8g6I635Y+W5r+A5rS755qE5Zu+5b2i5bGe5oCnXG4gIGdldEFjdGl2ZUNmZzogZnVuY3Rpb24gZ2V0QWN0aXZlQ2ZnKHR5cGUsIGNmZykge1xuICAgIHJldHVybiBfZ2V0QWN0aXZlQ2ZnKHR5cGUsIGNmZyk7XG4gIH0sXG4gIGRyYXdTaGFwZTogZnVuY3Rpb24gZHJhd1NoYXBlKHR5cGUsIGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5nZXRTaGFwZSh0eXBlKTtcbiAgICB2YXIgZ1NoYXBlO1xuXG4gICAgaWYgKGNmZy5wb2ludHMubGVuZ3RoID09PSAxICYmIEdsb2JhbC5zaG93U2luZ2xlUG9pbnQpIHtcbiAgICAgIGdTaGFwZSA9IGRyYXdQb2ludFNoYXBlKHRoaXMsIGNmZywgY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ1NoYXBlID0gc2hhcGUuZHJhdyhjZmcsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgaWYgKGdTaGFwZSkge1xuICAgICAgZ1NoYXBlLnNldCgnb3JpZ2luJywgY2ZnLm9yaWdpbik7XG4gICAgICBnU2hhcGUuX2lkID0gY2ZnLnNwbGl0ZWRJbmRleCA/IGNmZy5faWQgKyBjZmcuc3BsaXRlZEluZGV4IDogY2ZnLl9pZDtcbiAgICAgIGdTaGFwZS5uYW1lID0gdGhpcy5uYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBnU2hhcGU7XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2ZnOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENmZyh0eXBlLCBjZmcpIHtcbiAgICBpZiAoY2ZnICYmIGNmZy5zdHlsZSkge1xuICAgICAgcmV0dXJuIGNmZy5zdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDZmcodHlwZSwgY2ZnKTtcbiAgfVxufSk7IC8vIOm7mOiupO+8muWhq+WFheWMuuWfn+WbvlxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdhcmVhJywgJ2FyZWEnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCBmYWxzZSwgdGhpcyk7IC8vIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoLCBmYWxzZSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBfZ2V0TWFya2VyQ2ZnKGNmZyk7XG4gIH1cbn0pOyAvLyDloavlhYXlubPmu5HljLrln5/lm75cblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgnYXJlYScsICdzbW9vdGgnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRGaWxsQXR0cnMoY2ZnKTtcbiAgICB2YXIgY29vcmQgPSB0aGlzLl9jb29yZDsgLy8g5puy57q/55qE6ZmQ5Yi2XG5cbiAgICBjZmcuY29uc3RyYWludCA9IFtbY29vcmQuc3RhcnQueCwgY29vcmQuZW5kLnldLCBbY29vcmQuZW5kLngsIGNvb3JkLnN0YXJ0LnldXTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCB0cnVlLCB0aGlzKTsgLy8gcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgsIGZhbHNlKTtcblxuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIF9nZXRNYXJrZXJDZmcoY2ZnKTtcbiAgfVxufSk7IC8vIOWwgemXreeahOaKmOe6v1xuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdhcmVhJywgJ2xpbmUnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRMaW5lQXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFBhdGgoY2ZnLCBmYWxzZSwgdGhpcyk7IC8vIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoLCBmYWxzZSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBfZ2V0TWFya2VyQ2ZnKGNmZyk7XG4gIH1cbn0pOyAvLyDlsIHpl63nmoTlubPmu5Hnur9cblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgnYXJlYScsICdzbW9vdGhMaW5lJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0TGluZUF0dHJzKGNmZyk7XG4gICAgdmFyIHBhdGggPSBnZXRQYXRoKGNmZywgdHJ1ZSwgdGhpcyk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gX2dldE1hcmtlckNmZyhjZmcpO1xuICB9XG59KTtcbkFyZWEuc3BsaW5lID0gQXJlYS5zbW9vdGg7XG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XG5cbi8qKiovIH0pLFxuLyogMzkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg6L6577yM55So5LqO5YWz57O75Zu+55qE6L65XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzkzKTtcblxudmFyIEVkZ2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShFZGdlLCBfR2VvbUJhc2UpO1xuXG4gIGZ1bmN0aW9uIEVkZ2UoKSB7XG4gICAgcmV0dXJuIF9HZW9tQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRWRnZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIOiOt+WPlum7mOiupOeahOmFjee9ruWxnuaAp1xuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0g6buY6K6k5bGe5oCnXG4gICAqL1xuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnZWRnZSc7XG4gICAgY2ZnLnNoYXBlVHlwZSA9ICdlZGdlJztcbiAgICBjZmcuZ2VuZXJhdGVQb2ludHMgPSB0cnVlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIEVkZ2U7XG59KEdlb21CYXNlKTtcblxuR2VvbUJhc2UuRWRnZSA9IEVkZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMzkzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDovrnnmoQgc2hhcGVcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgU2hhcGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgUGF0aFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIENPUk5FUl9QRVJDRU5UID0gMSAvIDM7XG5cbmZ1bmN0aW9uIGdldEF0dHJzKGNmZykge1xuICB2YXIgZGVmYXVsdENmZyA9IEdsb2JhbC5zaGFwZS5lZGdlO1xuICB2YXIgbGluZUF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRDZmcsIGNmZy5zdHlsZSk7XG4gIFNoYXBlVXRpbC5hZGRTdHJva2VBdHRycyhsaW5lQXR0cnMsIGNmZyk7XG4gIHJldHVybiBsaW5lQXR0cnM7XG59XG5cbnZhciBFZGdlID0gU2hhcGUucmVnaXN0ZXJGYWN0b3J5KCdlZGdlJywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAnbGluZScsXG4gIGdldERlZmF1bHRQb2ludHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQb2ludHMocG9pbnRJbmZvKSB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5zcGxpdFBvaW50cyhwb2ludEluZm8pO1xuICB9LFxuICBnZXRBY3RpdmVDZmc6IGZ1bmN0aW9uIGdldEFjdGl2ZUNmZyh0eXBlLCBjZmcpIHtcbiAgICB2YXIgbGluZVdpZHRoID0gY2ZnLmxpbmVXaWR0aCB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IGxpbmVXaWR0aCArIDFcbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0Q1BhdGgoZnJvbSwgdG8pIHtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICBwb2ludHMucHVzaCh7XG4gICAgeDogZnJvbS54LFxuICAgIHk6IGZyb20ueSAqICgxIC0gMSAvIDIpICsgdG8ueSAqIDEgLyAyXG4gIH0pO1xuICBwb2ludHMucHVzaCh7XG4gICAgeTogZnJvbS55ICogKDEgLSAxIC8gMikgKyB0by55ICogMSAvIDIsXG4gICAgeDogdG8ueFxuICB9KTtcbiAgcG9pbnRzLnB1c2godG8pO1xuICB2YXIgc3ViID0gWydDJ107XG4gIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHN1Yi5wdXNoKHBvaW50LngsIHBvaW50LnkpO1xuICB9KTtcbiAgcmV0dXJuIHN1Yjtcbn1cblxuZnVuY3Rpb24gZ2V0UVBhdGgodG8sIGNlbnRlcikge1xuICB2YXIgcG9pbnRzID0gW107XG4gIHBvaW50cy5wdXNoKHtcbiAgICB4OiBjZW50ZXIueCxcbiAgICB5OiBjZW50ZXIueVxuICB9KTtcbiAgcG9pbnRzLnB1c2godG8pO1xuICB2YXIgc3ViID0gWydRJ107XG4gIFV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHN1Yi5wdXNoKHBvaW50LngsIHBvaW50LnkpO1xuICB9KTtcbiAgcmV0dXJuIHN1Yjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU21vb3RoUGF0aChmcm9tLCB0bykge1xuICB2YXIgc3ViID0gZ2V0Q1BhdGgoZnJvbSwgdG8pO1xuICB2YXIgcGF0aCA9IFtbJ00nLCBmcm9tLngsIGZyb20ueV1dO1xuICBwYXRoLnB1c2goc3ViKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFyY1BhdGgoZnJvbSwgdG8sIGNlbnRlcikge1xuICB2YXIgc3ViID0gZ2V0UVBhdGgodG8sIGNlbnRlcik7XG4gIHZhciBwYXRoID0gW1snTScsIGZyb20ueCwgZnJvbS55XV07XG4gIHBhdGgucHVzaChzdWIpO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJjV2VpZ2h0UGF0aChwb2ludHMsIGNlbnRlcikge1xuICB2YXIgYXJjMSA9IGdldFFQYXRoKHBvaW50c1sxXSwgY2VudGVyKTtcbiAgdmFyIGFyYzIgPSBnZXRRUGF0aChwb2ludHNbM10sIGNlbnRlcik7XG4gIHZhciBwYXRoID0gW1snTScsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV1dO1xuICBwYXRoLnB1c2goYXJjMik7XG4gIHBhdGgucHVzaChbJ0wnLCBwb2ludHNbM10ueCwgcG9pbnRzWzNdLnldKTtcbiAgcGF0aC5wdXNoKFsnTCcsIHBvaW50c1syXS54LCBwb2ludHNbMl0ueV0pO1xuICBwYXRoLnB1c2goYXJjMSk7XG4gIHBhdGgucHVzaChbJ0wnLCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnldKTtcbiAgcGF0aC5wdXNoKFsnTCcsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV0pO1xuICBwYXRoLnB1c2goWydaJ10pO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVjdFBhdGgoZnJvbSwgdG8pIHtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICBwb2ludHMucHVzaCh7XG4gICAgeTogZnJvbS55ICogKDEgLSBDT1JORVJfUEVSQ0VOVCkgKyB0by55ICogQ09STkVSX1BFUkNFTlQsXG4gICAgeDogZnJvbS54XG4gIH0pO1xuICBwb2ludHMucHVzaCh7XG4gICAgeTogZnJvbS55ICogKDEgLSBDT1JORVJfUEVSQ0VOVCkgKyB0by55ICogQ09STkVSX1BFUkNFTlQsXG4gICAgeDogdG8ueFxuICB9KTtcbiAgcG9pbnRzLnB1c2godG8pO1xuICB2YXIgcGF0aCA9IFtbJ00nLCBmcm9tLngsIGZyb20ueV1dO1xuICBVdGlsLmVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwYXRoLnB1c2goWydMJywgcG9pbnQueCwgcG9pbnQueV0pO1xuICB9KTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2VkZ2UnLCAnbGluZScsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBhcnNlUG9pbnRzKGNmZy5wb2ludHMpO1xuICAgIHZhciBhdHRyQ2ZnID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IFBhdGhVdGlsLmdldExpbmVQYXRoKHBvaW50cyk7XG4gICAgdmFyIGxpbmUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0ckNmZywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5lO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICAgIHJhZGl1czogNC41XG4gICAgfSwgZ2V0QXR0cnMoY2ZnKSk7XG4gIH1cbn0pO1xuU2hhcGUucmVnaXN0ZXJTaGFwZSgnZWRnZScsICd2aHYnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgcG9pbnRzID0gY2ZnLnBvaW50cztcbiAgICB2YXIgYXR0ckNmZyA9IGdldEF0dHJzKGNmZyk7XG4gICAgdmFyIHBhdGggPSBjcmVhdGVSZWN0UGF0aChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHZhciBsaW5lID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJDZmcsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDQuNVxuICAgIH0sIGdldEF0dHJzKGNmZykpO1xuICB9XG59KTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2VkZ2UnLCAnc21vb3RoJywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIHBvaW50cyA9IGNmZy5wb2ludHM7XG4gICAgdmFyIGF0dHJDZmcgPSBnZXRBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gY3JlYXRlU21vb3RoUGF0aChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHZhciBsaW5lID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJDZmcsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDQuNVxuICAgIH0sIGdldEF0dHJzKGNmZykpO1xuICB9XG59KTsgLy8gIOW8p+e6v+WMheaLrOesm+WNoeWwlOWdkOagh+ezu+S4i+eahOWNiuWchuW8p+e6v+OAgeaegeWdkOagh+ezu+S4i+S7peWchuW/g+S4uuaOp+WItueCueeahOS6jOmYtuabsue6v+OAgeesm+WNoeWwlOWdkOagh+ezu+S4i+W4puadg+mHjeeahOS4iemYtuabsue6v+OAgeaegeWdkOagh+ezu+S4i+W4puadg+mHjeeahOS7peWchuW/g+S4uuaOp+WItueCueeahOS6jOmYtuabsue6v1xuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCdlZGdlJywgJ2FyYycsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBwb2ludHMgPSBjZmcucG9pbnRzO1xuICAgIHZhciB0eXBlID0gcG9pbnRzLmxlbmd0aCA+IDIgPyAnd2VpZ2h0JyA6ICdub3JtYWwnO1xuICAgIHZhciBhdHRyQ2ZnID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgbGluZTtcbiAgICB2YXIgcGF0aDtcblxuICAgIGlmIChjZmcuaXNJbkNpcmNsZSkge1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMVxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdub3JtYWwnKSB7XG4gICAgICAgIHBhdGggPSBjcmVhdGVBcmNQYXRoKHBvaW50c1swXSwgcG9pbnRzWzFdLCBjZW50ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0ckNmZy5maWxsID0gYXR0ckNmZy5zdHJva2U7XG4gICAgICAgIHBhdGggPSBjcmVhdGVBcmNXZWlnaHRQYXRoKHBvaW50cywgY2VudGVyKTtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgICAgbGluZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJDZmcsIHtcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdub3JtYWwnKSB7XG4gICAgICAgIHBvaW50cyA9IHRoaXMucGFyc2VQb2ludHMocG9pbnRzKTtcbiAgICAgICAgbGluZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnYXJjJywge1xuICAgICAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRyQ2ZnLCB7XG4gICAgICAgICAgICB4OiAocG9pbnRzWzFdLnggKyBwb2ludHNbMF0ueCkgLyAyLFxuICAgICAgICAgICAgeTogcG9pbnRzWzBdLnksXG4gICAgICAgICAgICByOiBNYXRoLmFicyhwb2ludHNbMV0ueCAtIHBvaW50c1swXS54KSAvIDIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBNYXRoLlBJLFxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gW1snTScsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV0sIFsnTCcsIHBvaW50c1sxXS54LCBwb2ludHNbMV0ueV1dO1xuICAgICAgICB2YXIgYzEgPSBnZXRDUGF0aChwb2ludHNbMV0sIHBvaW50c1szXSk7XG4gICAgICAgIHZhciBjMiA9IGdldENQYXRoKHBvaW50c1syXSwgcG9pbnRzWzBdKTtcbiAgICAgICAgcGF0aC5wdXNoKGMxKTtcbiAgICAgICAgcGF0aC5wdXNoKFsnTCcsIHBvaW50c1szXS54LCBwb2ludHNbM10ueV0pO1xuICAgICAgICBwYXRoLnB1c2goWydMJywgcG9pbnRzWzJdLngsIHBvaW50c1syXS55XSk7XG4gICAgICAgIHBhdGgucHVzaChjMik7XG4gICAgICAgIHBhdGgucHVzaChbJ1onXSk7XG4gICAgICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICAgICAgYXR0ckNmZy5maWxsID0gYXR0ckNmZy5zdHJva2U7XG4gICAgICAgIGxpbmUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJDZmcsIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDQuNVxuICAgIH0sIGdldEF0dHJzKGNmZykpO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gRWRnZTtcblxuLyoqKi8gfSksXG4vKiAzOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBoZWF0bWFwXG4gKiBAYXV0aG9yIGxldW5nd2Vuc2VuQGdtYWlsLmNvbVxuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKSxcbiAgICBDb2xvclV0aWwgPSBfcmVxdWlyZS5Db2xvclV0aWw7IC8vIFRPRE86IENvbG9yVXRpbCDni6znq4vmiJDljIXvvIzku44gYXR0ciDljIXkuK3mir3nprtcblxuXG52YXIgR2VvbUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgT1JJR0lOX0ZJRUxEID0gJ19vcmlnaW4nO1xudmFyIFNIQURPV19DQU5WQVMgPSAnc2hhZG93Q2FudmFzJztcbnZhciBWQUxVRV9SQU5HRSA9ICd2YWx1ZVJhbmdlJztcbnZhciBJTUFHRV9TSEFQRSA9ICdpbWFnZVNoYXBlJztcbnZhciBNQVBQRURfREFUQSA9ICdtYXBwZWREYXRhJztcbnZhciBHUkFZX1NDQUxFX0JMVVJSRURfQ0FOVkFTID0gJ2dyYXlTY2FsZUJsdXJyZWRDYW52YXMnO1xudmFyIEhFQVRNQVBfU0laRSA9ICdoZWF0bWFwU2l6ZSc7XG5cbnZhciBIZWF0bWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoSGVhdG1hcCwgX0dlb21CYXNlKTtcblxuICBmdW5jdGlvbiBIZWF0bWFwKCkge1xuICAgIHJldHVybiBfR2VvbUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhlYXRtYXAucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBnZXQgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnaGVhdG1hcCc7XG4gICAgY2ZnLnBhbGV0dGVDYWNoZSA9IHt9OyAvLyBjZmcuc2hhcGVUeXBlID0gJ2hlYXRtYXAnO1xuXG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uX3ByZXBhcmVSYW5nZSA9IGZ1bmN0aW9uIF9wcmVwYXJlUmFuZ2UoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gc2VsZi5nZXQoTUFQUEVEX0RBVEEpO1xuICAgIHZhciBjb2xvckF0dHIgPSBzZWxmLmdldEF0dHIoJ2NvbG9yJyk7XG4gICAgdmFyIGNvbG9yRmllbGQgPSBjb2xvckF0dHIuZmllbGQ7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJvd1tPUklHSU5fRklFTERdW2NvbG9yRmllbGRdO1xuXG4gICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbWluID0gbWF4IC0gMTtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBbbWluLCBtYXhdO1xuICAgIHNlbGYuc2V0KFZBTFVFX1JBTkdFLCByYW5nZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wcmVwYXJlU2l6ZSA9IGZ1bmN0aW9uIF9wcmVwYXJlU2l6ZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJhZGl1cyA9IHNlbGYuZ2V0RGVmYXVsdFZhbHVlKCdzaXplJyk7XG5cbiAgICBpZiAoIVV0aWwuaXNOdW1iZXIocmFkaXVzKSkge1xuICAgICAgcmFkaXVzID0gc2VsZi5fZ2V0RGVmYXVsdFNpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVPcHRpb25zID0gc2VsZi5nZXQoJ3N0eWxlT3B0aW9ucycpO1xuICAgIHZhciBibHVyID0gc3R5bGVPcHRpb25zICYmIFV0aWwuaXNPYmplY3Qoc3R5bGVPcHRpb25zLnN0eWxlKSA/IHN0eWxlT3B0aW9ucy5zdHlsZS5ibHVyIDogbnVsbDtcblxuICAgIGlmICghVXRpbC5pc0Zpbml0ZShibHVyKSB8fCBibHVyID09PSBudWxsKSB7XG4gICAgICBibHVyID0gcmFkaXVzIC8gMjtcbiAgICB9XG5cbiAgICBzZWxmLnNldChIRUFUTUFQX1NJWkUsIHtcbiAgICAgIGJsdXI6IGJsdXIsXG4gICAgICByYWRpdXM6IHJhZGl1c1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0RGVmYXVsdFNpemUgPSBmdW5jdGlvbiBfZ2V0RGVmYXVsdFNpemUoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwb3NpdGlvbiA9IHNlbGYuZ2V0QXR0cigncG9zaXRpb24nKTtcbiAgICB2YXIgY29vcmQgPSBzZWxmLmdldCgnY29vcmQnKTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4oY29vcmQud2lkdGggLyAocG9zaXRpb24uc2NhbGVzWzBdLnRpY2tzLmxlbmd0aCAqIDQpLCBjb29yZC5oZWlnaHQgLyAocG9zaXRpb24uc2NhbGVzWzFdLnRpY2tzLmxlbmd0aCAqIDQpKTtcbiAgICByZXR1cm4gcmFkaXVzO1xuICB9O1xuXG4gIF9wcm90by5fY29sb3JpemUgPSBmdW5jdGlvbiBfY29sb3JpemUoaW1nKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb2xvckF0dHIgPSBzZWxmLmdldEF0dHIoJ2NvbG9yJyk7XG4gICAgdmFyIHBpeGVscyA9IGltZy5kYXRhO1xuICAgIHZhciBwYWxldHRlQ2FjaGUgPSBzZWxmLmdldCgncGFsZXR0ZUNhY2hlJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMzsgaSA8IHBpeGVscy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIGFscGhhID0gcGl4ZWxzW2ldOyAvLyBnZXQgZ3JhZGllbnQgY29sb3IgZnJvbSBvcGFjaXR5IHZhbHVlXG5cbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICB2YXIgcGFsZXR0ZSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAocGFsZXR0ZUNhY2hlW2FscGhhXSkge1xuICAgICAgICAgIHBhbGV0dGUgPSBwYWxldHRlQ2FjaGVbYWxwaGFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhbGV0dGUgPSBDb2xvclV0aWwucmdiMmFycihjb2xvckF0dHIuZ3JhZGllbnQoYWxwaGEgLyAyNTYpKTtcbiAgICAgICAgICBwYWxldHRlQ2FjaGVbYWxwaGFdID0gcGFsZXR0ZTtcbiAgICAgICAgfSAvLyBjb25zdCBwYWxldHRlID0gY29sb3JVdGlsLnJnYjJhcnIoY29sb3JBdHRyLmdyYWRpZW50KGFscGhhIC8gMjU2KSk7XG5cblxuICAgICAgICBwaXhlbHNbaSAtIDNdID0gcGFsZXR0ZVswXTtcbiAgICAgICAgcGl4ZWxzW2kgLSAyXSA9IHBhbGV0dGVbMV07XG4gICAgICAgIHBpeGVsc1tpIC0gMV0gPSBwYWxldHRlWzJdO1xuICAgICAgICBwaXhlbHNbaV0gPSBhbHBoYTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9wcmVwYXJlR3JleVNjYWxlQmx1cnJlZENpcmNsZSA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JleVNjYWxlQmx1cnJlZENpcmNsZShyLCBibHVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaXJjbGVDYW52YXMgPSBzZWxmLmdldChHUkFZX1NDQUxFX0JMVVJSRURfQ0FOVkFTKTtcblxuICAgIGlmICghY2lyY2xlQ2FudmFzKSB7XG4gICAgICBjaXJjbGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHNlbGYuc2V0KEdSQVlfU0NBTEVfQkxVUlJFRF9DQU5WQVMsIGNpcmNsZUNhbnZhcyk7XG4gICAgfVxuXG4gICAgdmFyIHIyID0gciArIGJsdXI7XG4gICAgdmFyIGN0eCA9IGNpcmNsZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNpcmNsZUNhbnZhcy53aWR0aCA9IGNpcmNsZUNhbnZhcy5oZWlnaHQgPSByMiAqIDI7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjaXJjbGVDYW52YXMud2lkdGgsIGNpcmNsZUNhbnZhcy5oZWlnaHQpOyAvLyBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gcjIgKiAyO1xuXG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IHIyICogMjtcbiAgICBjdHguc2hhZG93Qmx1ciA9IGJsdXI7XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJ2JsYWNrJztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYygtcjIsIC1yMiwgciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICB9O1xuXG4gIF9wcm90by5fZHJhd0dyYXlTY2FsZUJsdXJyZWRDaXJjbGUgPSBmdW5jdGlvbiBfZHJhd0dyYXlTY2FsZUJsdXJyZWRDaXJjbGUoeCwgeSwgciwgYWxwaGEsIGN0eCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2lyY2xlQ2FudmFzID0gc2VsZi5nZXQoR1JBWV9TQ0FMRV9CTFVSUkVEX0NBTlZBUyk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgY3R4LmRyYXdJbWFnZShjaXJjbGVDYW52YXMsIHggLSByLCB5IC0gcik7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRTaGFkb3dDYW52YXNDdHggPSBmdW5jdGlvbiBfZ2V0U2hhZG93Q2FudmFzQ3R4KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FudmFzID0gc2VsZi5nZXQoU0hBRE9XX0NBTlZBUyk7XG5cbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBzZWxmLnNldChTSEFET1dfQ0FOVkFTLCBjYW52YXMpO1xuICAgIH1cblxuICAgIHZhciBfc2VsZiRnZXQgPSBzZWxmLmdldCgnY29vcmQnKSxcbiAgICAgICAgd2lkdGggPSBfc2VsZiRnZXQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9zZWxmJGdldC5oZWlnaHQ7XG5cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfTtcblxuICBfcHJvdG8uX2NsZWFyU2hhZG93Q2FudmFzQ3R4ID0gZnVuY3Rpb24gX2NsZWFyU2hhZG93Q2FudmFzQ3R4KCkge1xuICAgIHZhciBjdHggPSB0aGlzLl9nZXRTaGFkb3dDYW52YXNDdHgoKTtcblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY3R4LmNhbnZhcy53aWR0aCwgY3R4LmNhbnZhcy5oZWlnaHQpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0SW1hZ2VTaGFwZSA9IGZ1bmN0aW9uIF9nZXRJbWFnZVNoYXBlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaW1hZ2VTaGFwZSA9IHNlbGYuZ2V0KElNQUdFX1NIQVBFKTtcblxuICAgIGlmIChpbWFnZVNoYXBlKSB7XG4gICAgICByZXR1cm4gaW1hZ2VTaGFwZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIGltYWdlU2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ0ltYWdlJywge30pO1xuICAgIHNlbGYuc2V0KElNQUdFX1NIQVBFLCBpbWFnZVNoYXBlKTtcbiAgICByZXR1cm4gaW1hZ2VTaGFwZTtcbiAgfTtcblxuICBfcHJvdG8uZHJhd1dpdGhSYW5nZSA9IGZ1bmN0aW9uIGRyYXdXaXRoUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGNhbnZhcyBzaXplXG5cbiAgICB2YXIgX3NlbGYkZ2V0MiA9IHNlbGYuZ2V0KCdjb29yZCcpLFxuICAgICAgICBzdGFydCA9IF9zZWxmJGdldDIuc3RhcnQsXG4gICAgICAgIGVuZCA9IF9zZWxmJGdldDIuZW5kLFxuICAgICAgICB3aWR0aCA9IF9zZWxmJGdldDIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9zZWxmJGdldDIuaGVpZ2h0OyAvLyB2YWx1ZSwgcmFuZ2UsIGV0Y1xuXG5cbiAgICB2YXIgdmFsdWVGaWVsZCA9IHNlbGYuZ2V0QXR0cignY29sb3InKS5maWVsZDtcbiAgICB2YXIgc2l6ZSA9IHNlbGYuZ2V0KEhFQVRNQVBfU0laRSk7IC8vIHByZXBhcmUgc2hhZG93IGNhbnZhcyBjb250ZXh0XG5cbiAgICBzZWxmLl9jbGVhclNoYWRvd0NhbnZhc0N0eCgpO1xuXG4gICAgdmFyIGN0eCA9IHNlbGYuX2dldFNoYWRvd0NhbnZhc0N0eCgpOyAvLyBmaWx0ZXIgZGF0YVxuXG5cbiAgICB2YXIgZGF0YSA9IHNlbGYuZ2V0KE1BUFBFRF9EQVRBKTtcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvd1tPUklHSU5fRklFTERdW3ZhbHVlRmllbGRdIDw9IHJhbmdlWzFdICYmIHJvd1tPUklHSU5fRklFTERdW3ZhbHVlRmllbGRdID49IHJhbmdlWzBdO1xuICAgICAgfSk7XG4gICAgfSAvLyBzdGVwMS4gZHJhdyBwb2ludHMgd2l0aCBzaGFkb3dcblxuXG4gICAgdmFyIHNjYWxlID0gc2VsZi5fZ2V0U2NhbGUodmFsdWVGaWVsZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBkYXRhW2ldO1xuICAgICAgdmFyIGNmZyA9IHNlbGYuZ2V0RHJhd0NmZyhvYmopO1xuICAgICAgdmFyIGFscGhhID0gc2NhbGUuc2NhbGUob2JqW09SSUdJTl9GSUVMRF1bdmFsdWVGaWVsZF0pO1xuXG4gICAgICBzZWxmLl9kcmF3R3JheVNjYWxlQmx1cnJlZENpcmNsZShjZmcueCAtIHN0YXJ0LngsIGNmZy55IC0gZW5kLnksIHNpemUucmFkaXVzICsgc2l6ZS5ibHVyLCBhbHBoYSwgY3R4KTtcbiAgICB9IC8vIHN0ZXAyLiBjb252ZXJ0IHBpeGVsc1xuXG5cbiAgICB2YXIgY29sb3JlZCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBzZWxmLl9jbGVhclNoYWRvd0NhbnZhc0N0eCgpO1xuXG4gICAgc2VsZi5fY29sb3JpemUoY29sb3JlZCk7XG5cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNvbG9yZWQsIDAsIDApO1xuXG4gICAgdmFyIGltYWdlU2hhcGUgPSBzZWxmLl9nZXRJbWFnZVNoYXBlKCk7XG5cbiAgICBpbWFnZVNoYXBlLmF0dHIoJ3gnLCBzdGFydC54KTtcbiAgICBpbWFnZVNoYXBlLmF0dHIoJ3knLCBlbmQueSk7XG4gICAgaW1hZ2VTaGFwZS5hdHRyKCd3aWR0aCcsIHdpZHRoKTtcbiAgICBpbWFnZVNoYXBlLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgaW1hZ2VTaGFwZS5hdHRyKCdpbWcnLCBjdHguY2FudmFzKTtcbiAgfTtcblxuICBfcHJvdG8uZHJhdyA9IGZ1bmN0aW9uIGRyYXcoZGF0YVxuICAvKiAsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5LCBpbmRleCAqL1xuICApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5zZXQoTUFQUEVEX0RBVEEsIGRhdGEpO1xuXG4gICAgc2VsZi5fcHJlcGFyZVJhbmdlKCk7XG5cbiAgICBzZWxmLl9wcmVwYXJlU2l6ZSgpO1xuXG4gICAgdmFyIHNpemUgPSBzZWxmLmdldChIRUFUTUFQX1NJWkUpO1xuXG4gICAgc2VsZi5fcHJlcGFyZUdyZXlTY2FsZUJsdXJyZWRDaXJjbGUoc2l6ZS5yYWRpdXMsIHNpemUuYmx1cik7XG5cbiAgICB2YXIgcmFuZ2UgPSBzZWxmLmdldChWQUxVRV9SQU5HRSk7XG4gICAgc2VsZi5kcmF3V2l0aFJhbmdlKHJhbmdlKTsgLy8gc3VwZXIuZHJhdyhkYXRhLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSwgaW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBIZWF0bWFwO1xufShHZW9tQmFzZSk7XG5cbkdlb21CYXNlLkhlYXRtYXAgPSBIZWF0bWFwO1xubW9kdWxlLmV4cG9ydHMgPSBIZWF0bWFwO1xuXG4vKioqLyB9KSxcbi8qIDM5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOWkmui+ueW9olxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBHZW9tQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzk2KTtcblxudmFyIFBvbHlnb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShQb2x5Z29uLCBfR2VvbUJhc2UpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgcmV0dXJuIF9HZW9tQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9seWdvbi5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIOiOt+WPlum7mOiupOeahOmFjee9ruWxnuaAp1xuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0g6buY6K6k5bGe5oCnXG4gICAqL1xuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAncG9seWdvbic7XG4gICAgY2ZnLnNoYXBlVHlwZSA9ICdwb2x5Z29uJztcbiAgICBjZmcuZ2VuZXJhdGVQb2ludHMgPSB0cnVlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZVNoYXBlUG9pbnRzQ2ZnID0gZnVuY3Rpb24gY3JlYXRlU2hhcGVQb2ludHNDZmcob2JqKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB4ID0gY2ZnLng7XG4gICAgdmFyIHkgPSBjZmcueTtcbiAgICB2YXIgdGVtcDtcblxuICAgIGlmICghKFV0aWwuaXNBcnJheSh4KSAmJiBVdGlsLmlzQXJyYXkoeSkpKSB7XG4gICAgICAvLyB4IHkg6YO95piv5pWw57uE5pe277yM5LiN5YGa5aSE55CGXG4gICAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZSgpO1xuICAgICAgdmFyIHhDb3VudCA9IHhTY2FsZS52YWx1ZXMgPyB4U2NhbGUudmFsdWVzLmxlbmd0aCA6IHhTY2FsZS50aWNrcy5sZW5ndGg7XG4gICAgICB2YXIgeUNvdW50ID0geVNjYWxlLnZhbHVlcyA/IHlTY2FsZS52YWx1ZXMubGVuZ3RoIDogeVNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgICAgIHZhciB4T2Zmc2V0ID0gMC41ICogMSAvIHhDb3VudDtcbiAgICAgIHZhciB5T2Zmc2V0ID0gMC41ICogMSAvIHlDb3VudDtcblxuICAgICAgaWYgKHhTY2FsZS5pc0NhdGVnb3J5ICYmIHlTY2FsZS5pc0NhdGVnb3J5KSB7XG4gICAgICAgIC8vIOWmguaenHgseemDveaYr+WIhuexu1xuICAgICAgICB4ID0gW3ggLSB4T2Zmc2V0LCB4IC0geE9mZnNldCwgeCArIHhPZmZzZXQsIHggKyB4T2Zmc2V0XTtcbiAgICAgICAgeSA9IFt5IC0geU9mZnNldCwgeSArIHlPZmZzZXQsIHkgKyB5T2Zmc2V0LCB5IC0geU9mZnNldF07XG4gICAgICB9IGVsc2UgaWYgKFV0aWwuaXNBcnJheSh4KSkge1xuICAgICAgICAvLyB4IOaYr+aVsOe7hFxuICAgICAgICB0ZW1wID0geDtcbiAgICAgICAgeCA9IFt0ZW1wWzBdLCB0ZW1wWzBdLCB0ZW1wWzFdLCB0ZW1wWzFdXTtcbiAgICAgICAgeSA9IFt5IC0geU9mZnNldCAvIDIsIHkgKyB5T2Zmc2V0IC8gMiwgeSArIHlPZmZzZXQgLyAyLCB5IC0geU9mZnNldCAvIDJdO1xuICAgICAgfSBlbHNlIGlmIChVdGlsLmlzQXJyYXkoeSkpIHtcbiAgICAgICAgLy8geSDmmK/mlbDnu4RcbiAgICAgICAgdGVtcCA9IHk7XG4gICAgICAgIHkgPSBbdGVtcFswXSwgdGVtcFsxXSwgdGVtcFsxXSwgdGVtcFswXV07XG4gICAgICAgIHggPSBbeCAtIHhPZmZzZXQgLyAyLCB4IC0geE9mZnNldCAvIDIsIHggKyB4T2Zmc2V0IC8gMiwgeCArIHhPZmZzZXQgLyAyXTtcbiAgICAgIH1cblxuICAgICAgY2ZnLnggPSB4O1xuICAgICAgY2ZnLnkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgcmV0dXJuIFBvbHlnb247XG59KEdlb21CYXNlKTtcblxuR2VvbUJhc2UuUG9seWdvbiA9IFBvbHlnb247XG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG5cbi8qKiovIH0pLFxuLyogMzk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBsaW5lIHNoYXBlc1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKiBAYXV0aG9yIHNpbWEuemhhbmcxOTkwQGdtYWlsLmNvbVxuICogQGF1dGhvciBodWFuZ3RvbmdlckBhbGl5dW4uY29tXG4gIyBAYXV0aG9yIGxpdXllMTBAeWFob28uY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBTaGFwZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbmZ1bmN0aW9uIGdldEF0dHJzKGNmZykge1xuICB2YXIgZGVmYXVsdENmZyA9IEdsb2JhbC5zaGFwZS5wb2x5Z29uO1xuICB2YXIgcGF0aEF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRDZmcsIGNmZy5zdHlsZSk7XG4gIFNoYXBlVXRpbC5hZGRGaWxsQXR0cnMocGF0aEF0dHJzLCBjZmcpO1xuICByZXR1cm4gcGF0aEF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRIb2xsb3dBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRDZmcgPSBHbG9iYWwuc2hhcGUuaG9sbG93UG9seWdvbjtcbiAgdmFyIHBhdGhBdHRycyA9IFV0aWwubWl4KHt9LCBkZWZhdWx0Q2ZnLCBjZmcuc3R5bGUpO1xuICBTaGFwZVV0aWwuYWRkU3Ryb2tlQXR0cnMocGF0aEF0dHJzLCBjZmcpO1xuICByZXR1cm4gcGF0aEF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoKHBvaW50cykge1xuICB2YXIgZmxhZyA9IHBvaW50c1swXTtcbiAgdmFyIGkgPSAxO1xuICB2YXIgcGF0aCA9IFtbJ00nLCBmbGFnLngsIGZsYWcueV1dO1xuXG4gIHdoaWxlIChpIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgIHZhciBjID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGMueCAhPT0gcG9pbnRzW2kgLSAxXS54IHx8IGMueSAhPT0gcG9pbnRzW2kgLSAxXS55KSB7XG4gICAgICBwYXRoLnB1c2goWydMJywgYy54LCBjLnldKTtcblxuICAgICAgaWYgKGMueCA9PT0gZmxhZy54ICYmIGMueSA9PT0gZmxhZy55ICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBmbGFnID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgcGF0aC5wdXNoKFsnWiddKTtcbiAgICAgICAgcGF0aC5wdXNoKFsnTScsIGZsYWcueCwgZmxhZy55XSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICBpZiAoIVV0aWwuaXNFcXVhbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIGZsYWcpKSB7XG4gICAgcGF0aC5wdXNoKFsnTCcsIGZsYWcueCwgZmxhZy55XSk7XG4gIH1cblxuICBwYXRoLnB1c2goWydaJ10pO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gcmVnaXN0IGxpbmUgZ2VvbVxuXG5cbnZhciBQb2x5Z29uID0gU2hhcGUucmVnaXN0ZXJGYWN0b3J5KCdwb2x5Z29uJywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAncG9seWdvbicsXG4gIGdldERlZmF1bHRQb2ludHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQb2ludHMocG9pbnRJbmZvKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIFV0aWwuZWFjaChwb2ludEluZm8ueCwgZnVuY3Rpb24gKHN1YlgsIGluZGV4KSB7XG4gICAgICB2YXIgc3ViWSA9IHBvaW50SW5mby55W2luZGV4XTtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogc3ViWCxcbiAgICAgICAgeTogc3ViWVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgZ2V0QWN0aXZlQ2ZnOiBmdW5jdGlvbiBnZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGNmZy5saW5lV2lkdGggfHwgMTtcblxuICAgIGlmICh0eXBlID09PSAnaG9sbG93Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGggKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gY2ZnLmZpbGxPcGFjaXR5IHx8IGNmZy5vcGFjaXR5IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGxpbmVXaWR0aCxcbiAgICAgIGZpbGxPcGFjaXR5OiBvcGFjaXR5IC0gMC4wOFxuICAgIH07XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2ZnOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENmZyh0eXBlLCBjZmcpIHtcbiAgICBpZiAoY2ZnICYmIGNmZy5zdHlsZSkge1xuICAgICAgcmV0dXJuIGNmZy5zdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDZmcodHlwZSwgY2ZnKTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdwb2x5Z29uJywgJ3BvbHlnb24nLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICBpZiAoIVV0aWwuaXNFbXB0eShjZmcucG9pbnRzKSkge1xuICAgICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICAgIHZhciBwYXRoID0gZ2V0UGF0aChjZmcucG9pbnRzKTtcbiAgICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ3NxdWFyZScsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LCBnZXRBdHRycyhjZmcpKTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdwb2x5Z29uJywgJ2hvbGxvdycsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIGlmICghVXRpbC5pc0VtcHR5KGNmZy5wb2ludHMpKSB7XG4gICAgICB2YXIgYXR0cnMgPSBnZXRIb2xsb3dBdHRycyhjZmcpO1xuICAgICAgdmFyIHBhdGggPSBnZXRQYXRoKGNmZy5wb2ludHMpO1xuICAgICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAnc3F1YXJlJyxcbiAgICAgIHJhZGl1czogNFxuICAgIH0sIGdldEF0dHJzKGNmZykpO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqKi8gfSksXG4vKiAzOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg6Ieq5a6a5LmJ5Zu+5b2iXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNpemVNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzU3KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzOTgpO1xuXG52YXIgU2NoZW1hID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2NoZW1hLCBfR2VvbUJhc2UpO1xuXG4gIHZhciBfcHJvdG8gPSBTY2hlbWEucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiDojrflj5bpu5jorqTnmoTphY3nva7lsZ7mgKdcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOm7mOiupOWxnuaAp1xuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbUJhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ3NjaGVtYSc7XG4gICAgY2ZnLnNoYXBlVHlwZSA9ICdzY2hlbWEnO1xuICAgIGNmZy5nZW5lcmF0ZVBvaW50cyA9IHRydWU7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBmdW5jdGlvbiBTY2hlbWEoY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfR2VvbUJhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFNpemVNaXhpbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLmNyZWF0ZVNoYXBlUG9pbnRzQ2ZnID0gZnVuY3Rpb24gY3JlYXRlU2hhcGVQb2ludHNDZmcob2JqKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgY2ZnLnNpemUgPSB0aGlzLmdldE5vcm1hbGl6ZWRTaXplKG9iaik7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICByZXR1cm4gU2NoZW1hO1xufShHZW9tQmFzZSk7XG5cbnZhciBTY2hlbWFEb2RnZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1NjaGVtYSkge1xuICBfaW5oZXJpdHNMb29zZShTY2hlbWFEb2RnZSwgX1NjaGVtYSk7XG5cbiAgZnVuY3Rpb24gU2NoZW1hRG9kZ2UoKSB7XG4gICAgcmV0dXJuIF9TY2hlbWEuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBTY2hlbWFEb2RnZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX1NjaGVtYS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLmhhc0RlZmF1bHRBZGp1c3QgPSB0cnVlO1xuICAgIGNmZy5hZGp1c3RzID0gW3tcbiAgICAgIHR5cGU6ICdkb2RnZSdcbiAgICB9XTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIHJldHVybiBTY2hlbWFEb2RnZTtcbn0oU2NoZW1hKTtcblxuU2NoZW1hLkRvZGdlID0gU2NoZW1hRG9kZ2U7XG5HZW9tQmFzZS5TY2hlbWEgPSBTY2hlbWE7XG5HZW9tQmFzZS5TY2hlbWFEb2RnZSA9IFNjaGVtYURvZGdlO1xubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogMzk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyDoh6rlrprkuYnnmoQgc2hhcGVcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuZnVuY3Rpb24gX3BhcnNlVmFsdWUodmFsdWUpIHtcbiAgaWYgKCFVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBbdmFsdWVdO1xuICB9XG5cbiAgdmFyIG1pbiA9IHZhbHVlWzBdOyAvLyDmnIDlsI/lgLxcblxuICB2YXIgbWF4ID0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV07IC8vIOacgOWkp+WAvFxuXG4gIHZhciBtaW4xID0gdmFsdWUubGVuZ3RoID4gMSA/IHZhbHVlWzFdIDogbWluO1xuICB2YXIgbWF4MSA9IHZhbHVlLmxlbmd0aCA+IDMgPyB2YWx1ZVszXSA6IG1heDtcbiAgdmFyIG1lZGlhbiA9IHZhbHVlLmxlbmd0aCA+IDIgPyB2YWx1ZVsyXSA6IG1pbjE7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgLy8g5pyA5bCP5YC8XG4gICAgbWF4OiBtYXgsXG4gICAgLy8g5pyA5aSn5YC8XG4gICAgbWluMTogbWluMSxcbiAgICBtYXgxOiBtYXgxLFxuICAgIG1lZGlhbjogbWVkaWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZFBvaW50cyhmcm9tLCB0bykge1xuICBVdGlsLmVhY2goZnJvbSwgZnVuY3Rpb24gKHN1YkFycikge1xuICAgIHRvLnB1c2goe1xuICAgICAgeDogc3ViQXJyWzBdLFxuICAgICAgeTogc3ViQXJyWzFdXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRBdHRycyA9IEdsb2JhbC5zaGFwZS5zY2hlbWE7XG4gIHZhciBsaW5lQXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdEF0dHJzLCBjZmcuc3R5bGUpO1xuICBTaGFwZVV0aWwuYWRkU3Ryb2tlQXR0cnMobGluZUF0dHJzLCBjZmcpO1xuICByZXR1cm4gbGluZUF0dHJzO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsQXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0QXR0cnMgPSBHbG9iYWwuc2hhcGUuc2NoZW1hO1xuICB2YXIgbGluZUF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRBdHRycywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZEZpbGxBdHRycyhsaW5lQXR0cnMsIGNmZyk7XG5cbiAgaWYgKGNmZy5jb2xvcikge1xuICAgIGxpbmVBdHRycy5zdHJva2UgPSBsaW5lQXR0cnMuc3Ryb2tlIHx8IGNmZy5jb2xvcjtcbiAgfVxuXG4gIHJldHVybiBsaW5lQXR0cnM7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvaW50cyh4LCB5LCB3aWR0aCkge1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBwb2ludHNBcnJheTtcbiAgdmFyIG9iajtcblxuICBpZiAoVXRpbC5pc0FycmF5KHkpKSB7XG4gICAgLy8gMue7tFxuICAgIG9iaiA9IF9wYXJzZVZhbHVlKHkpO1xuICAgIHBvaW50c0FycmF5ID0gW1t4IC0gd2lkdGggLyAyLCBvYmoubWF4XSwgW3ggKyB3aWR0aCAvIDIsIG9iai5tYXhdLCBbeCwgb2JqLm1heF0sIFt4LCBvYmoubWF4MV0sIFt4IC0gd2lkdGggLyAyLCBvYmoubWluMV0sIFt4IC0gd2lkdGggLyAyLCBvYmoubWF4MV0sIFt4ICsgd2lkdGggLyAyLCBvYmoubWF4MV0sIFt4ICsgd2lkdGggLyAyLCBvYmoubWluMV0sIFt4LCBvYmoubWluMV0sIFt4LCBvYmoubWluXSwgW3ggLSB3aWR0aCAvIDIsIG9iai5taW5dLCBbeCArIHdpZHRoIC8gMiwgb2JqLm1pbl0sIFt4IC0gd2lkdGggLyAyLCBvYmoubWVkaWFuXSwgW3ggKyB3aWR0aCAvIDIsIG9iai5tZWRpYW5dXTtcbiAgfSBlbHNlIHtcbiAgICAvLyDlj6rmnInkuIDkuKrnu7TluqZcbiAgICB5ID0geSB8fCAwLjU7XG4gICAgb2JqID0gX3BhcnNlVmFsdWUoeCk7XG4gICAgcG9pbnRzQXJyYXkgPSBbW29iai5taW4sIHkgLSB3aWR0aCAvIDJdLCBbb2JqLm1pbiwgeSArIHdpZHRoIC8gMl0sIFtvYmoubWluLCB5XSwgW29iai5taW4xLCB5XSwgW29iai5taW4xLCB5IC0gd2lkdGggLyAyXSwgW29iai5taW4xLCB5ICsgd2lkdGggLyAyXSwgW29iai5tYXgxLCB5ICsgd2lkdGggLyAyXSwgW29iai5tYXgxLCB5IC0gd2lkdGggLyAyXSwgW29iai5tYXgxLCB5XSwgW29iai5tYXgsIHldLCBbb2JqLm1heCwgeSAtIHdpZHRoIC8gMl0sIFtvYmoubWF4LCB5ICsgd2lkdGggLyAyXSwgW29iai5tZWRpYW4sIHkgLSB3aWR0aCAvIDJdLCBbb2JqLm1lZGlhbiwgeSArIHdpZHRoIC8gMl1dO1xuICB9XG5cbiAgYWRkUG9pbnRzKHBvaW50c0FycmF5LCBwb2ludHMpO1xuICByZXR1cm4gcG9pbnRzO1xufVxuXG5mdW5jdGlvbiBfc29ydFZhbHVlKHZhbHVlKSB7XG4gIGlmICghVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgfSAvLyDku47lpKfliLDlsI/mjpLluo9cblxuXG4gIHZhciBzb3J0ZWQgPSB2YWx1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gMSA6IC0xO1xuICB9KTtcbiAgdmFyIGxlbmd0aCA9IHNvcnRlZC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDQpIHtcbiAgICB2YXIgbWluID0gc29ydGVkW2xlbmd0aCAtIDFdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0IC0gbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvcnRlZC5wdXNoKG1pbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvcnRlZDtcbn0gLy8g6I635Y+WS+e6v+WbvueahHBvaW50c1xuXG5cbmZ1bmN0aW9uIGdldENhbmRsZVBvaW50cyh4LCB5LCB3aWR0aCkge1xuICB2YXIgeVZhbHVlcyA9IF9zb3J0VmFsdWUoeSk7XG5cbiAgdmFyIHBvaW50cyA9IFt7XG4gICAgeDogeCxcbiAgICB5OiB5VmFsdWVzWzBdXG4gIH0sIHtcbiAgICB4OiB4LFxuICAgIHk6IHlWYWx1ZXNbMV1cbiAgfSwge1xuICAgIHg6IHggLSB3aWR0aCAvIDIsXG4gICAgeTogeVZhbHVlc1syXVxuICB9LCB7XG4gICAgeDogeCAtIHdpZHRoIC8gMixcbiAgICB5OiB5VmFsdWVzWzFdXG4gIH0sIHtcbiAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgIHk6IHlWYWx1ZXNbMV1cbiAgfSwge1xuICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgeTogeVZhbHVlc1syXVxuICB9LCB7XG4gICAgeDogeCxcbiAgICB5OiB5VmFsdWVzWzJdXG4gIH0sIHtcbiAgICB4OiB4LFxuICAgIHk6IHlWYWx1ZXNbM11cbiAgfV07IC8vIOaMieeFp+mhuuaXtumSiOi/nuaOpVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBhdGgocG9pbnRzKSB7XG4gIHZhciBwYXRoID0gW1snTScsIHBvaW50c1swXS54LCBwb2ludHNbMF0ueV0sIFsnTCcsIHBvaW50c1sxXS54LCBwb2ludHNbMV0ueV0sIFsnTScsIHBvaW50c1syXS54LCBwb2ludHNbMl0ueV0sIFsnTCcsIHBvaW50c1szXS54LCBwb2ludHNbM10ueV0sIFsnTScsIHBvaW50c1s0XS54LCBwb2ludHNbNF0ueV0sIFsnTCcsIHBvaW50c1s1XS54LCBwb2ludHNbNV0ueV0sIFsnTCcsIHBvaW50c1s2XS54LCBwb2ludHNbNl0ueV0sIFsnTCcsIHBvaW50c1s3XS54LCBwb2ludHNbN10ueV0sIFsnTCcsIHBvaW50c1s0XS54LCBwb2ludHNbNF0ueV0sIC8vIOWwgemXrSB6XG4gIFsnWiddLCBbJ00nLCBwb2ludHNbOF0ueCwgcG9pbnRzWzhdLnldLCBbJ0wnLCBwb2ludHNbOV0ueCwgcG9pbnRzWzldLnldLCBbJ00nLCBwb2ludHNbMTBdLngsIHBvaW50c1sxMF0ueV0sIFsnTCcsIHBvaW50c1sxMV0ueCwgcG9pbnRzWzExXS55XSwgWydNJywgcG9pbnRzWzEyXS54LCBwb2ludHNbMTJdLnldLCBbJ0wnLCBwb2ludHNbMTNdLngsIHBvaW50c1sxM10ueV1dO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FuZGxlUGF0aChwb2ludHMpIHtcbiAgdmFyIHBhdGggPSBbWydNJywgcG9pbnRzWzBdLngsIHBvaW50c1swXS55XSwgWydMJywgcG9pbnRzWzFdLngsIHBvaW50c1sxXS55XSwgWydNJywgcG9pbnRzWzJdLngsIHBvaW50c1syXS55XSwgWydMJywgcG9pbnRzWzNdLngsIHBvaW50c1szXS55XSwgWydMJywgcG9pbnRzWzRdLngsIHBvaW50c1s0XS55XSwgWydMJywgcG9pbnRzWzVdLngsIHBvaW50c1s1XS55XSwgWydaJ10sIFsnTScsIHBvaW50c1s2XS54LCBwb2ludHNbNl0ueV0sIFsnTCcsIHBvaW50c1s3XS54LCBwb2ludHNbN10ueV1dO1xuICByZXR1cm4gcGF0aDtcbn1cblxudmFyIFNjaGVtYSA9IFNoYXBlLnJlZ2lzdGVyRmFjdG9yeSgnc2NoZW1hJywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAnJyxcbiAgZ2V0QWN0aXZlQ2ZnOiBmdW5jdGlvbiBnZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gICAgaWYgKHR5cGUgPT09ICdib3gnKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gY2ZnLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGggKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gY2ZnLmZpbGxPcGFjaXR5IHx8IGNmZy5vcGFjaXR5IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxPcGFjaXR5OiBvcGFjaXR5IC0gMC4xNSxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IG9wYWNpdHkgLSAwLjE1XG4gICAgfTtcbiAgfSxcbiAgZ2V0U2VsZWN0ZWRDZmc6IGZ1bmN0aW9uIGdldFNlbGVjdGVkQ2ZnKHR5cGUsIGNmZykge1xuICAgIGlmIChjZmcgJiYgY2ZnLnN0eWxlKSB7XG4gICAgICByZXR1cm4gY2ZnLnN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZUNmZyh0eXBlLCBjZmcpO1xuICB9XG59KTsgLy8g566x57q/5Zu+XG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3NjaGVtYScsICdib3gnLCB7XG4gIGdldFBvaW50czogZnVuY3Rpb24gZ2V0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHJldHVybiBnZXRCb3hQb2ludHMocG9pbnRJbmZvLngsIHBvaW50SW5mby55LCBwb2ludEluZm8uc2l6ZSk7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gZ2V0Qm94UGF0aChjZmcucG9pbnRzKTtcbiAgICBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3ltYm9sOiBmdW5jdGlvbiBzeW1ib2woeCwgeSwgcikge1xuICAgICAgICB2YXIgeVZhbHVlcyA9IFt5IC0gNiwgeSAtIDMsIHksIHkgKyAzLCB5ICsgNl07XG4gICAgICAgIHZhciBwb2ludHMgPSBnZXRCb3hQb2ludHMoeCwgeVZhbHVlcywgcik7XG4gICAgICAgIHJldHVybiBbWydNJywgcG9pbnRzWzBdLnggKyAxLCBwb2ludHNbMF0ueV0sIFsnTCcsIHBvaW50c1sxXS54IC0gMSwgcG9pbnRzWzFdLnldLCBbJ00nLCBwb2ludHNbMl0ueCwgcG9pbnRzWzJdLnldLCBbJ0wnLCBwb2ludHNbM10ueCwgcG9pbnRzWzNdLnldLCBbJ00nLCBwb2ludHNbNF0ueCwgcG9pbnRzWzRdLnldLCBbJ0wnLCBwb2ludHNbNV0ueCwgcG9pbnRzWzVdLnldLCBbJ0wnLCBwb2ludHNbNl0ueCwgcG9pbnRzWzZdLnldLCBbJ0wnLCBwb2ludHNbN10ueCwgcG9pbnRzWzddLnldLCBbJ0wnLCBwb2ludHNbNF0ueCwgcG9pbnRzWzRdLnldLCBbJ1onXSwgWydNJywgcG9pbnRzWzhdLngsIHBvaW50c1s4XS55XSwgWydMJywgcG9pbnRzWzldLngsIHBvaW50c1s5XS55XSwgWydNJywgcG9pbnRzWzEwXS54ICsgMSwgcG9pbnRzWzEwXS55XSwgWydMJywgcG9pbnRzWzExXS54IC0gMSwgcG9pbnRzWzExXS55XSwgWydNJywgcG9pbnRzWzEyXS54LCBwb2ludHNbMTJdLnldLCBbJ0wnLCBwb2ludHNbMTNdLngsIHBvaW50c1sxM10ueV1dO1xuICAgICAgfSxcbiAgICAgIHJhZGl1czogNixcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIHN0cm9rZTogY2ZnLmNvbG9yXG4gICAgfTtcbiAgfVxufSk7IC8vIEvnur9cblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgnc2NoZW1hJywgJ2NhbmRsZScsIHtcbiAgZ2V0UG9pbnRzOiBmdW5jdGlvbiBnZXRQb2ludHMocG9pbnRJbmZvKSB7XG4gICAgcmV0dXJuIGdldENhbmRsZVBvaW50cyhwb2ludEluZm8ueCwgcG9pbnRJbmZvLnksIHBvaW50SW5mby5zaXplKTtcbiAgfSxcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEZpbGxBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gZ2V0Q2FuZGxlUGF0aChjZmcucG9pbnRzKTtcbiAgICBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3ltYm9sOiBmdW5jdGlvbiBzeW1ib2woeCwgeSwgcikge1xuICAgICAgICB5ID0gW3kgKyA3LjUsIHkgKyAzLCB5IC0gMywgeSAtIDcuNV07XG4gICAgICAgIHZhciBwb2ludHMgPSBnZXRDYW5kbGVQb2ludHMoeCwgeSwgcik7XG4gICAgICAgIHJldHVybiBbWydNJywgcG9pbnRzWzBdLngsIHBvaW50c1swXS55XSwgWydMJywgcG9pbnRzWzFdLngsIHBvaW50c1sxXS55XSwgWydNJywgcG9pbnRzWzJdLngsIHBvaW50c1syXS55XSwgWydMJywgcG9pbnRzWzNdLngsIHBvaW50c1szXS55XSwgWydMJywgcG9pbnRzWzRdLngsIHBvaW50c1s0XS55XSwgWydMJywgcG9pbnRzWzVdLngsIHBvaW50c1s1XS55XSwgWydaJ10sIFsnTScsIHBvaW50c1s2XS54LCBwb2ludHNbNl0ueV0sIFsnTCcsIHBvaW50c1s3XS54LCBwb2ludHNbN10ueV1dO1xuICAgICAgfSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIHN0cm9rZTogY2ZnLmNvbG9yLFxuICAgICAgZmlsbDogY2ZnLmNvbG9yLFxuICAgICAgcmFkaXVzOiA2XG4gICAgfTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiAzOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBWZW5uIERpYWdyYW1cbiAqIEBhdXRob3IgbGV1bmd3ZW5zZW5AZ21haWwuY29tXG4gKi9cbnZhciBHZW9tQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDAwKSxcbiAgICB2ZW5uID0gX3JlcXVpcmUudmVubixcbiAgICBzY2FsZVNvbHV0aW9uID0gX3JlcXVpcmUuc2NhbGVTb2x1dGlvbixcbiAgICBjaXJjbGVQYXRoID0gX3JlcXVpcmUuY2lyY2xlUGF0aCxcbiAgICBpbnRlcnNlY3Rpb25BcmVhUGF0aCA9IF9yZXF1aXJlLmludGVyc2VjdGlvbkFyZWFQYXRoLFxuICAgIGNvbXB1dGVUZXh0Q2VudHJlcyA9IF9yZXF1aXJlLmNvbXB1dGVUZXh0Q2VudHJlcztcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0NTgpO1xuXG52YXIgVmVubiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dlb21CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFZlbm4sIF9HZW9tQmFzZSk7XG5cbiAgZnVuY3Rpb24gVmVubigpIHtcbiAgICByZXR1cm4gX0dlb21CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBWZW5uLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogZ2V0IGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gY29uZmlndXJhdGlvblxuICAgKi9cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbUJhc2UucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ3Zlbm4nO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAndmVubic7XG4gICAgY2ZnLmdlbmVyYXRlUG9pbnRzID0gdHJ1ZTsgLy8gc3VwZXIuZHJhdyhkYXRhLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uX2luaXRBdHRycyA9IGZ1bmN0aW9uIF9pbml0QXR0cnMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRyT3B0aW9ucyA9IHNlbGYuZ2V0KCdhdHRyT3B0aW9ucycpO1xuICAgIHZhciBsYWJlbENmZyA9IHNlbGYuZ2V0KCdsYWJlbENmZycpO1xuICAgIHZhciBkYXRhID0gc2VsZi5nZXQoJ2RhdGEnKTtcbiAgICB2YXIgc2l6ZUZpZWxkID0gYXR0ck9wdGlvbnMuc2l6ZSA/IGF0dHJPcHRpb25zLnNpemUuZmllbGQgOiAnc2l6ZSc7XG4gICAgdmFyIGxhYmVsRmllbGQgPSBsYWJlbENmZyA/IGxhYmVsQ2ZnLmZpZWxkc1swXSA6ICdzZXRzJztcbiAgICBzZWxmLnNldCgnbGFiZWxDZmcnLCBudWxsKTsgLy8gcHJlcGFyZSBkYXRhXG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgcm93LnNldHMgPSByb3dbbGFiZWxGaWVsZF07XG4gICAgICByb3cuc2l6ZSA9IHJvd1tzaXplRmllbGRdO1xuICAgIH0pO1xuICAgIHZhciBzb2x1dGlvbiA9IHZlbm4oZGF0YSk7IC8vIHNjYWxpbmdcblxuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB4UmFuZ2UgPSBbTWF0aC5taW4oY29vcmQueC5lbmQsIGNvb3JkLnguc3RhcnQpLCBNYXRoLm1heChjb29yZC54LmVuZCwgY29vcmQueC5zdGFydCldO1xuICAgIHZhciB5UmFuZ2UgPSBbTWF0aC5taW4oY29vcmQueS5lbmQsIGNvb3JkLnkuc3RhcnQpLCBNYXRoLm1heChjb29yZC55LmVuZCwgY29vcmQueS5zdGFydCldO1xuICAgIHZhciB3aWR0aCA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTtcbiAgICB2YXIgaGVpZ2h0ID0geVJhbmdlWzFdIC0geVJhbmdlWzBdO1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSBzZWxmLmdldCgnc3R5bGVPcHRpb25zJyk7XG4gICAgdmFyIHBhZGRpbmcgPSBzdHlsZU9wdGlvbnMgJiYgVXRpbC5pc09iamVjdChzdHlsZU9wdGlvbnMuc3R5bGUpID8gc3R5bGVPcHRpb25zLnN0eWxlLnBhZGRpbmcgOiAwO1xuXG4gICAgaWYgKCFVdGlsLmlzRmluaXRlKHBhZGRpbmcpKSB7XG4gICAgICBwYWRkaW5nID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY2lyY2xlcyA9IHNjYWxlU29sdXRpb24oc29sdXRpb24sIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgIHZhciB0ZXh0Q2VudGVycyA9IGNvbXB1dGVUZXh0Q2VudHJlcyhjaXJjbGVzLCBkYXRhKTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIHNldHMgPSByb3cuc2V0cztcbiAgICAgIHZhciBpZCA9IHNldHMuam9pbignLCcpO1xuICAgICAgcm93LmlkID0gaWQ7XG5cbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgY2lyY2xlID0gY2lyY2xlc1tpZF07XG4gICAgICAgIHJvdy5wYXRoID0gY2lyY2xlUGF0aChjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xuICAgICAgICBVdGlsLmFzc2lnbihyb3csIGNpcmNsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2V0Q2lyY2xlcyA9IHNldHMubWFwKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY2xlc1tzZXRdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBpbnRlcnNlY3Rpb25BcmVhUGF0aChzZXRDaXJjbGVzKTtcblxuICAgICAgICBpZiAoIS9belpdJC8udGVzdChwYXRoKSkge1xuICAgICAgICAgIHBhdGggKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcm93LnBhdGggPSBwYXRoO1xuICAgICAgICB2YXIgY2VudGVyID0gdGV4dENlbnRlcnNbaWRdIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgVXRpbC5hc3NpZ24ocm93LCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH0pOyAvLyB4LCB5IHNjYWxlc1xuXG4gICAgc2VsZi5wb3NpdGlvbigneCp5Jyk7XG5cbiAgICBfR2VvbUJhc2UucHJvdG90eXBlLl9pbml0QXR0cnMuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGFpbnQgPSBmdW5jdGlvbiBwYWludCgpIHtcbiAgICBfR2VvbUJhc2UucHJvdG90eXBlLnBhaW50LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGFBcnJheSA9IHNlbGYuZ2V0KCdkYXRhQXJyYXknKTtcbiAgICB2YXIgc2hhcGVDb250YWluZXIgPSBzZWxmLmdldCgnc2hhcGVDb250YWluZXInKTsgLy8gYWRkIGxhYmVsc1xuXG4gICAgZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIGNmZyA9IHNlbGYuZ2V0RHJhd0NmZyhyb3dbMF0pO1xuICAgICAgdmFyIG9yaWdpbiA9IGNmZy5vcmlnaW4uX29yaWdpbjtcbiAgICAgIHNoYXBlQ29udGFpbmVyLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe30sIHtcbiAgICAgICAgICB4OiBvcmlnaW4ueCxcbiAgICAgICAgICB5OiBvcmlnaW4ueSxcbiAgICAgICAgICB0ZXh0OiBvcmlnaW4ubGFiZWwgfHwgJycsXG4gICAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICAgIGZpbGw6IGNmZy5zaGFwZSA9PT0gJ2hvbGxvdycgPyBjZmcuY29sb3IgOiAnIzY2NicsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICAgIH0sIGNmZy5zdHlsZSA/IGNmZy5zdHlsZS50ZXh0U3R5bGUgOiB7fSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWZW5uO1xufShHZW9tQmFzZSk7XG5cbkdlb21CYXNlLlZlbm4gPSBWZW5uO1xubW9kdWxlLmV4cG9ydHMgPSBWZW5uO1xuXG4vKioqLyB9KSxcbi8qIDQwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg3MiksIF9fd2VicGFja19yZXF1aXJlX18oNDM1KSkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXNlbGVjdGlvbicsICdkMy10cmFuc2l0aW9uJ10sIGZhY3RvcnkpIDogZmFjdG9yeShnbG9iYWwudmVubiA9IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMyk7XG59KSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNTZWxlY3Rpb24sIGQzVHJhbnNpdGlvbikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFNNQUxMID0gMWUtMTA7XG4gIC8qKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gYXJlYSBvZiBhIGJ1bmNoIG9mIGNpcmNsZXMgKHdoZXJlIGVhY2ggY2lyY2xlXG4gICBpcyBhbiBvYmplY3QgaGF2aW5nIGFuIHgseSBhbmQgcmFkaXVzIHByb3BlcnR5KSAqL1xuXG4gIGZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoY2lyY2xlcywgc3RhdHMpIHtcbiAgICAvLyBnZXQgYWxsIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIHRoZSBjaXJjbGVzXG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IGdldEludGVyc2VjdGlvblBvaW50cyhjaXJjbGVzKTsgLy8gZmlsdGVyIG91dCBwb2ludHMgdGhhdCBhcmVuJ3QgaW5jbHVkZWQgaW4gYWxsIHRoZSBjaXJjbGVzXG5cbiAgICB2YXIgaW5uZXJQb2ludHMgPSBpbnRlcnNlY3Rpb25Qb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gY29udGFpbmVkSW5DaXJjbGVzKHAsIGNpcmNsZXMpO1xuICAgIH0pO1xuICAgIHZhciBhcmNBcmVhID0gMCxcbiAgICAgICAgcG9seWdvbkFyZWEgPSAwLFxuICAgICAgICBhcmNzID0gW10sXG4gICAgICAgIGk7IC8vIGlmIHdlIGhhdmUgaW50ZXJzZWN0aW9uIHBvaW50cyB0aGF0IGFyZSB3aXRoaW4gYWxsIHRoZSBjaXJjbGVzLFxuICAgIC8vIHRoZW4gZmlndXJlIG91dCB0aGUgYXJlYSBjb250YWluZWQgYnkgdGhlbVxuXG4gICAgaWYgKGlubmVyUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIHNvcnQgdGhlIHBvaW50cyBieSBhbmdsZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHBvbHlnb24sIHdoaWNoIGxldHNcbiAgICAgIC8vIHVzIGp1c3QgaXRlcmF0ZSBvdmVyIHBvaW50cyB0byBnZXQgdGhlIGVkZ2VzXG4gICAgICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyKGlubmVyUG9pbnRzKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlubmVyUG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwID0gaW5uZXJQb2ludHNbaV07XG4gICAgICAgIHAuYW5nbGUgPSBNYXRoLmF0YW4yKHAueCAtIGNlbnRlci54LCBwLnkgLSBjZW50ZXIueSk7XG4gICAgICB9XG5cbiAgICAgIGlubmVyUG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuYW5nbGUgLSBhLmFuZ2xlO1xuICAgICAgfSk7IC8vIGl0ZXJhdGUgb3ZlciBhbGwgcG9pbnRzLCBnZXQgYXJjIGJldHdlZW4gdGhlIHBvaW50c1xuICAgICAgLy8gYW5kIHVwZGF0ZSB0aGUgYXJlYXNcblxuICAgICAgdmFyIHAyID0gaW5uZXJQb2ludHNbaW5uZXJQb2ludHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbm5lclBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcDEgPSBpbm5lclBvaW50c1tpXTsgLy8gcG9seWdvbiBhcmVhIHVwZGF0ZXMgZWFzaWx5IC4uLlxuXG4gICAgICAgIHBvbHlnb25BcmVhICs9IChwMi54ICsgcDEueCkgKiAocDEueSAtIHAyLnkpOyAvLyB1cGRhdGluZyB0aGUgYXJjIGFyZWEgaXMgYSBsaXR0bGUgbW9yZSBpbnZvbHZlZFxuXG4gICAgICAgIHZhciBtaWRQb2ludCA9IHtcbiAgICAgICAgICB4OiAocDEueCArIHAyLngpIC8gMixcbiAgICAgICAgICB5OiAocDEueSArIHAyLnkpIC8gMlxuICAgICAgICB9LFxuICAgICAgICAgICAgYXJjID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAxLnBhcmVudEluZGV4Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKHAyLnBhcmVudEluZGV4LmluZGV4T2YocDEucGFyZW50SW5kZXhbal0pID4gLTEpIHtcbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGFuZ2xlIGhhbGZ3YXkgYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xuICAgICAgICAgICAgLy8gb24gdGhlIGN1cnJlbnQgY2lyY2xlXG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gY2lyY2xlc1twMS5wYXJlbnRJbmRleFtqXV0sXG4gICAgICAgICAgICAgICAgYTEgPSBNYXRoLmF0YW4yKHAxLnggLSBjaXJjbGUueCwgcDEueSAtIGNpcmNsZS55KSxcbiAgICAgICAgICAgICAgICBhMiA9IE1hdGguYXRhbjIocDIueCAtIGNpcmNsZS54LCBwMi55IC0gY2lyY2xlLnkpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlRGlmZiA9IGEyIC0gYTE7XG5cbiAgICAgICAgICAgIGlmIChhbmdsZURpZmYgPCAwKSB7XG4gICAgICAgICAgICAgIGFuZ2xlRGlmZiArPSAyICogTWF0aC5QSTtcbiAgICAgICAgICAgIH0gLy8gYW5kIHVzZSB0aGF0IGFuZ2xlIHRvIGZpZ3VyZSBvdXQgdGhlIHdpZHRoIG9mIHRoZVxuICAgICAgICAgICAgLy8gYXJjXG5cblxuICAgICAgICAgICAgdmFyIGEgPSBhMiAtIGFuZ2xlRGlmZiAvIDIsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBkaXN0YW5jZShtaWRQb2ludCwge1xuICAgICAgICAgICAgICB4OiBjaXJjbGUueCArIGNpcmNsZS5yYWRpdXMgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICAgICAgeTogY2lyY2xlLnkgKyBjaXJjbGUucmFkaXVzICogTWF0aC5jb3MoYSlcbiAgICAgICAgICAgIH0pOyAvLyBjbGFtcCB0aGUgd2lkdGggdG8gdGhlIGxhcmdlc3QgaXMgY2FuIGFjdHVhbGx5IGJlXG4gICAgICAgICAgICAvLyAoc29tZXRpbWVzIHNsaWdodGx5IG92ZXJmbG93cyBiZWNhdXNlIG9mIEZQIGVycm9ycylcblxuICAgICAgICAgICAgaWYgKHdpZHRoID4gY2lyY2xlLnJhZGl1cyAqIDIpIHtcbiAgICAgICAgICAgICAgd2lkdGggPSBjaXJjbGUucmFkaXVzICogMjtcbiAgICAgICAgICAgIH0gLy8gcGljayB0aGUgY2lyY2xlIHdob3NlIGFyYyBoYXMgdGhlIHNtYWxsZXN0IHdpZHRoXG5cblxuICAgICAgICAgICAgaWYgKGFyYyA9PT0gbnVsbCB8fCBhcmMud2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICBhcmMgPSB7XG4gICAgICAgICAgICAgICAgY2lyY2xlOiBjaXJjbGUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIHAxOiBwMSxcbiAgICAgICAgICAgICAgICBwMjogcDJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJjICE9PSBudWxsKSB7XG4gICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgYXJjQXJlYSArPSBjaXJjbGVBcmVhKGFyYy5jaXJjbGUucmFkaXVzLCBhcmMud2lkdGgpO1xuICAgICAgICAgIHAyID0gcDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gaW50ZXJzZWN0aW9uIHBvaW50cywgaXMgZWl0aGVyIGRpc2pvaW50IC0gb3IgaXMgY29tcGxldGVseVxuICAgICAgLy8gb3ZlcmxhcHBlZC4gZmlndXJlIG91dCB3aGljaCBieSBleGFtaW5pbmcgdGhlIHNtYWxsZXN0IGNpcmNsZVxuICAgICAgdmFyIHNtYWxsZXN0ID0gY2lyY2xlc1swXTtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNpcmNsZXNbaV0ucmFkaXVzIDwgc21hbGxlc3QucmFkaXVzKSB7XG4gICAgICAgICAgc21hbGxlc3QgPSBjaXJjbGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1ha2Ugc3VyZSB0aGUgc21hbGxlc3QgY2lyY2xlIGlzIGNvbXBsZXRlbHkgY29udGFpbmVkIGluIGFsbFxuICAgICAgLy8gdGhlIG90aGVyIGNpcmNsZXNcblxuXG4gICAgICB2YXIgZGlzam9pbnQgPSBmYWxzZTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlKGNpcmNsZXNbaV0sIHNtYWxsZXN0KSA+IE1hdGguYWJzKHNtYWxsZXN0LnJhZGl1cyAtIGNpcmNsZXNbaV0ucmFkaXVzKSkge1xuICAgICAgICAgIGRpc2pvaW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlzam9pbnQpIHtcbiAgICAgICAgYXJjQXJlYSA9IHBvbHlnb25BcmVhID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyY0FyZWEgPSBzbWFsbGVzdC5yYWRpdXMgKiBzbWFsbGVzdC5yYWRpdXMgKiBNYXRoLlBJO1xuICAgICAgICBhcmNzLnB1c2goe1xuICAgICAgICAgIGNpcmNsZTogc21hbGxlc3QsXG4gICAgICAgICAgcDE6IHtcbiAgICAgICAgICAgIHg6IHNtYWxsZXN0LngsXG4gICAgICAgICAgICB5OiBzbWFsbGVzdC55ICsgc21hbGxlc3QucmFkaXVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwMjoge1xuICAgICAgICAgICAgeDogc21hbGxlc3QueCAtIFNNQUxMLFxuICAgICAgICAgICAgeTogc21hbGxlc3QueSArIHNtYWxsZXN0LnJhZGl1c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2lkdGg6IHNtYWxsZXN0LnJhZGl1cyAqIDJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9seWdvbkFyZWEgLz0gMjtcblxuICAgIGlmIChzdGF0cykge1xuICAgICAgc3RhdHMuYXJlYSA9IGFyY0FyZWEgKyBwb2x5Z29uQXJlYTtcbiAgICAgIHN0YXRzLmFyY0FyZWEgPSBhcmNBcmVhO1xuICAgICAgc3RhdHMucG9seWdvbkFyZWEgPSBwb2x5Z29uQXJlYTtcbiAgICAgIHN0YXRzLmFyY3MgPSBhcmNzO1xuICAgICAgc3RhdHMuaW5uZXJQb2ludHMgPSBpbm5lclBvaW50cztcbiAgICAgIHN0YXRzLmludGVyc2VjdGlvblBvaW50cyA9IGludGVyc2VjdGlvblBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gYXJjQXJlYSArIHBvbHlnb25BcmVhO1xuICB9XG4gIC8qKiByZXR1cm5zIHdoZXRoZXIgYSBwb2ludCBpcyBjb250YWluZWQgYnkgYWxsIG9mIGEgbGlzdCBvZiBjaXJjbGVzICovXG5cblxuICBmdW5jdGlvbiBjb250YWluZWRJbkNpcmNsZXMocG9pbnQsIGNpcmNsZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkaXN0YW5jZShwb2ludCwgY2lyY2xlc1tpXSkgPiBjaXJjbGVzW2ldLnJhZGl1cyArIFNNQUxMKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogR2V0cyBhbGwgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIGEgYnVuY2ggb2YgY2lyY2xlcyAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnRzKGNpcmNsZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGNpcmNsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGNpcmNsZUNpcmNsZUludGVyc2VjdGlvbihjaXJjbGVzW2ldLCBjaXJjbGVzW2pdKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGludGVyc2VjdC5sZW5ndGg7ICsraykge1xuICAgICAgICAgIHZhciBwID0gaW50ZXJzZWN0W2tdO1xuICAgICAgICAgIHAucGFyZW50SW5kZXggPSBbaSwgal07XG4gICAgICAgICAgcmV0LnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKiBDaXJjdWxhciBzZWdtZW50IGFyZWEgY2FsY3VsYXRpb24uIFNlZSBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmN1bGFyU2VnbWVudC5odG1sICovXG5cblxuICBmdW5jdGlvbiBjaXJjbGVBcmVhKHIsIHdpZHRoKSB7XG4gICAgcmV0dXJuIHIgKiByICogTWF0aC5hY29zKDEgLSB3aWR0aCAvIHIpIC0gKHIgLSB3aWR0aCkgKiBNYXRoLnNxcnQod2lkdGggKiAoMiAqIHIgLSB3aWR0aCkpO1xuICB9XG4gIC8qKiBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzICovXG5cblxuICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChwMS54IC0gcDIueCkgKiAocDEueCAtIHAyLngpICsgKHAxLnkgLSBwMi55KSAqIChwMS55IC0gcDIueSkpO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBvdmVybGFwIGFyZWEgb2YgdHdvIGNpcmNsZXMgb2YgcmFkaXVzIHIxIGFuZCByMiAtIHRoYXRcbiAgaGF2ZSB0aGVpciBjZW50ZXJzIHNlcGFyYXRlZCBieSBkaXN0YW5jZSBkLiBTaW1wbGVyIGZhc3RlclxuICBjaXJjbGUgaW50ZXJzZWN0aW9uIGZvciBvbmx5IHR3byBjaXJjbGVzICovXG5cblxuICBmdW5jdGlvbiBjaXJjbGVPdmVybGFwKHIxLCByMiwgZCkge1xuICAgIC8vIG5vIG92ZXJsYXBcbiAgICBpZiAoZCA+PSByMSArIHIyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IC8vIGNvbXBsZXRlbHkgb3ZlcmxhcHBlZFxuXG5cbiAgICBpZiAoZCA8PSBNYXRoLmFicyhyMSAtIHIyKSkge1xuICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLm1pbihyMSwgcjIpICogTWF0aC5taW4ocjEsIHIyKTtcbiAgICB9XG5cbiAgICB2YXIgdzEgPSByMSAtIChkICogZCAtIHIyICogcjIgKyByMSAqIHIxKSAvICgyICogZCksXG4gICAgICAgIHcyID0gcjIgLSAoZCAqIGQgLSByMSAqIHIxICsgcjIgKiByMikgLyAoMiAqIGQpO1xuICAgIHJldHVybiBjaXJjbGVBcmVhKHIxLCB3MSkgKyBjaXJjbGVBcmVhKHIyLCB3Mik7XG4gIH1cbiAgLyoqIEdpdmVuIHR3byBjaXJjbGVzIChjb250YWluaW5nIGEgeC95L3JhZGl1cyBhdHRyaWJ1dGVzKSxcbiAgcmV0dXJucyB0aGUgaW50ZXJzZWN0aW5nIHBvaW50cyBpZiBwb3NzaWJsZS5cbiAgbm90ZTogZG9lc24ndCBoYW5kbGUgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIGluZmluaXRlbHkgbWFueVxuICBpbnRlcnNlY3Rpb24gcG9pbnRzIChjaXJjbGVzIGFyZSBlcXVpdmFsZW50KTosIG9yIG9ubHkgb25lIGludGVyc2VjdGlvbiBwb2ludCovXG5cblxuICBmdW5jdGlvbiBjaXJjbGVDaXJjbGVJbnRlcnNlY3Rpb24ocDEsIHAyKSB7XG4gICAgdmFyIGQgPSBkaXN0YW5jZShwMSwgcDIpLFxuICAgICAgICByMSA9IHAxLnJhZGl1cyxcbiAgICAgICAgcjIgPSBwMi5yYWRpdXM7IC8vIGlmIHRvIGZhciBhd2F5LCBvciBzZWxmIGNvbnRhaW5lZCAtIGNhbid0IGJlIGRvbmVcblxuICAgIGlmIChkID49IHIxICsgcjIgfHwgZCA8PSBNYXRoLmFicyhyMSAtIHIyKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBhID0gKHIxICogcjEgLSByMiAqIHIyICsgZCAqIGQpIC8gKDIgKiBkKSxcbiAgICAgICAgaCA9IE1hdGguc3FydChyMSAqIHIxIC0gYSAqIGEpLFxuICAgICAgICB4MCA9IHAxLnggKyBhICogKHAyLnggLSBwMS54KSAvIGQsXG4gICAgICAgIHkwID0gcDEueSArIGEgKiAocDIueSAtIHAxLnkpIC8gZCxcbiAgICAgICAgcnggPSAtKHAyLnkgLSBwMS55KSAqIChoIC8gZCksXG4gICAgICAgIHJ5ID0gLShwMi54IC0gcDEueCkgKiAoaCAvIGQpO1xuICAgIHJldHVybiBbe1xuICAgICAgeDogeDAgKyByeCxcbiAgICAgIHk6IHkwIC0gcnlcbiAgICB9LCB7XG4gICAgICB4OiB4MCAtIHJ4LFxuICAgICAgeTogeTAgKyByeVxuICAgIH1dO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgYSBidW5jaCBvZiBwb2ludHMgKi9cblxuXG4gIGZ1bmN0aW9uIGdldENlbnRlcihwb2ludHMpIHtcbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbnRlci54ICs9IHBvaW50c1tpXS54O1xuICAgICAgY2VudGVyLnkgKz0gcG9pbnRzW2ldLnk7XG4gICAgfVxuXG4gICAgY2VudGVyLnggLz0gcG9pbnRzLmxlbmd0aDtcbiAgICBjZW50ZXIueSAvPSBwb2ludHMubGVuZ3RoO1xuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cbiAgLyoqIGZpbmRzIHRoZSB6ZXJvcyBvZiBhIGZ1bmN0aW9uLCBnaXZlbiB0d28gc3RhcnRpbmcgcG9pbnRzICh3aGljaCBtdXN0XG4gICAqIGhhdmUgb3Bwb3NpdGUgc2lnbnMgKi9cblxuXG4gIGZ1bmN0aW9uIGJpc2VjdChmLCBhLCBiLCBwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgfHwgMTAwLFxuICAgICAgICB0b2xlcmFuY2UgPSBwYXJhbWV0ZXJzLnRvbGVyYW5jZSB8fCAxZS0xMCxcbiAgICAgICAgZkEgPSBmKGEpLFxuICAgICAgICBmQiA9IGYoYiksXG4gICAgICAgIGRlbHRhID0gYiAtIGE7XG5cbiAgICBpZiAoZkEgKiBmQiA+IDApIHtcbiAgICAgIHRocm93IFwiSW5pdGlhbCBiaXNlY3QgcG9pbnRzIG11c3QgaGF2ZSBvcHBvc2l0ZSBzaWduc1wiO1xuICAgIH1cblxuICAgIGlmIChmQSA9PT0gMCkgcmV0dXJuIGE7XG4gICAgaWYgKGZCID09PSAwKSByZXR1cm4gYjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgKytpKSB7XG4gICAgICBkZWx0YSAvPSAyO1xuICAgICAgdmFyIG1pZCA9IGEgKyBkZWx0YSxcbiAgICAgICAgICBmTWlkID0gZihtaWQpO1xuXG4gICAgICBpZiAoZk1pZCAqIGZBID49IDApIHtcbiAgICAgICAgYSA9IG1pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA8IHRvbGVyYW5jZSB8fCBmTWlkID09PSAwKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKyBkZWx0YTtcbiAgfSAvLyBuZWVkIHNvbWUgYmFzaWMgb3BlcmF0aW9ucyBvbiB2ZWN0b3JzLCByYXRoZXIgdGhhbiBhZGRpbmcgYSBkZXBlbmRlbmN5LFxuICAvLyBqdXN0IGRlZmluZSBoZXJlXG5cblxuICBmdW5jdGlvbiB6ZXJvcyh4KSB7XG4gICAgdmFyIHIgPSBuZXcgQXJyYXkoeCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHg7ICsraSkge1xuICAgICAgcltpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBmdW5jdGlvbiB6ZXJvc00oeCwgeSkge1xuICAgIHJldHVybiB6ZXJvcyh4KS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHplcm9zKHkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICB2YXIgcmV0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgcmV0ICs9IGFbaV0gKiBiW2ldO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtMihhKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChkb3QoYSwgYSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUocmV0LCB2YWx1ZSwgYykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJldFtpXSA9IHZhbHVlW2ldICogYztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3ZWlnaHRlZFN1bShyZXQsIHcxLCB2MSwgdzIsIHYyKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIHJldFtqXSA9IHcxICogdjFbal0gKyB3MiAqIHYyW2pdO1xuICAgIH1cbiAgfVxuICAvKiogbWluaW1pemVzIGEgZnVuY3Rpb24gdXNpbmcgdGhlIGRvd25oaWxsIHNpbXBsZXggbWV0aG9kICovXG5cblxuICBmdW5jdGlvbiBuZWxkZXJNZWFkKGYsIHgwLCBwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgfHwgeDAubGVuZ3RoICogMjAwLFxuICAgICAgICBub25aZXJvRGVsdGEgPSBwYXJhbWV0ZXJzLm5vblplcm9EZWx0YSB8fCAxLjA1LFxuICAgICAgICB6ZXJvRGVsdGEgPSBwYXJhbWV0ZXJzLnplcm9EZWx0YSB8fCAwLjAwMSxcbiAgICAgICAgbWluRXJyb3JEZWx0YSA9IHBhcmFtZXRlcnMubWluRXJyb3JEZWx0YSB8fCAxZS02LFxuICAgICAgICBtaW5Ub2xlcmFuY2UgPSBwYXJhbWV0ZXJzLm1pbkVycm9yRGVsdGEgfHwgMWUtNSxcbiAgICAgICAgcmhvID0gcGFyYW1ldGVycy5yaG8gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucmhvIDogMSxcbiAgICAgICAgY2hpID0gcGFyYW1ldGVycy5jaGkgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2hpIDogMixcbiAgICAgICAgcHNpID0gcGFyYW1ldGVycy5wc2kgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHNpIDogLTAuNSxcbiAgICAgICAgc2lnbWEgPSBwYXJhbWV0ZXJzLnNpZ21hICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNpZ21hIDogMC41LFxuICAgICAgICBtYXhEaWZmOyAvLyBpbml0aWFsaXplIHNpbXBsZXguXG5cbiAgICB2YXIgTiA9IHgwLmxlbmd0aCxcbiAgICAgICAgc2ltcGxleCA9IG5ldyBBcnJheShOICsgMSk7XG4gICAgc2ltcGxleFswXSA9IHgwO1xuICAgIHNpbXBsZXhbMF0uZnggPSBmKHgwKTtcbiAgICBzaW1wbGV4WzBdLmlkID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICB2YXIgcG9pbnQgPSB4MC5zbGljZSgpO1xuICAgICAgcG9pbnRbaV0gPSBwb2ludFtpXSA/IHBvaW50W2ldICogbm9uWmVyb0RlbHRhIDogemVyb0RlbHRhO1xuICAgICAgc2ltcGxleFtpICsgMV0gPSBwb2ludDtcbiAgICAgIHNpbXBsZXhbaSArIDFdLmZ4ID0gZihwb2ludCk7XG4gICAgICBzaW1wbGV4W2kgKyAxXS5pZCA9IGkgKyAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZXgodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2ltcGxleFtOXVtpXSA9IHZhbHVlW2ldO1xuICAgICAgfVxuXG4gICAgICBzaW1wbGV4W05dLmZ4ID0gdmFsdWUuZng7XG4gICAgfVxuXG4gICAgdmFyIHNvcnRPcmRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5meCAtIGIuZng7XG4gICAgfTtcblxuICAgIHZhciBjZW50cm9pZCA9IHgwLnNsaWNlKCksXG4gICAgICAgIHJlZmxlY3RlZCA9IHgwLnNsaWNlKCksXG4gICAgICAgIGNvbnRyYWN0ZWQgPSB4MC5zbGljZSgpLFxuICAgICAgICBleHBhbmRlZCA9IHgwLnNsaWNlKCk7XG5cbiAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyArK2l0ZXJhdGlvbikge1xuICAgICAgc2ltcGxleC5zb3J0KHNvcnRPcmRlcik7XG5cbiAgICAgIGlmIChwYXJhbWV0ZXJzLmhpc3RvcnkpIHtcbiAgICAgICAgLy8gY29weSB0aGUgc2ltcGxleCAoc2luY2UgbGF0ZXIgaXRlcmF0aW9ucyB3aWxsIG11dGF0ZSkgYW5kXG4gICAgICAgIC8vIHNvcnQgaXQgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgb3JkZXIgYmV0d2VlbiBpdGVyYXRpb25zXG4gICAgICAgIHZhciBzb3J0ZWRTaW1wbGV4ID0gc2ltcGxleC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB4LnNsaWNlKCk7XG4gICAgICAgICAgc3RhdGUuZnggPSB4LmZ4O1xuICAgICAgICAgIHN0YXRlLmlkID0geC5pZDtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICBzb3J0ZWRTaW1wbGV4LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJhbWV0ZXJzLmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgeDogc2ltcGxleFswXS5zbGljZSgpLFxuICAgICAgICAgIGZ4OiBzaW1wbGV4WzBdLmZ4LFxuICAgICAgICAgIHNpbXBsZXg6IHNvcnRlZFNpbXBsZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG1heERpZmYgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBNYXRoLmFicyhzaW1wbGV4WzBdW2ldIC0gc2ltcGxleFsxXVtpXSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoc2ltcGxleFswXS5meCAtIHNpbXBsZXhbTl0uZngpIDwgbWluRXJyb3JEZWx0YSAmJiBtYXhEaWZmIDwgbWluVG9sZXJhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBjb21wdXRlIHRoZSBjZW50cm9pZCBvZiBhbGwgYnV0IHRoZSB3b3JzdCBwb2ludCBpbiB0aGUgc2ltcGxleFxuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICAgICAgY2VudHJvaWRbaV0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgY2VudHJvaWRbaV0gKz0gc2ltcGxleFtqXVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkW2ldIC89IE47XG4gICAgICB9IC8vIHJlZmxlY3QgdGhlIHdvcnN0IHBvaW50IHBhc3QgdGhlIGNlbnRyb2lkICBhbmQgY29tcHV0ZSBsb3NzIGF0IHJlZmxlY3RlZFxuICAgICAgLy8gcG9pbnRcblxuXG4gICAgICB2YXIgd29yc3QgPSBzaW1wbGV4W05dO1xuICAgICAgd2VpZ2h0ZWRTdW0ocmVmbGVjdGVkLCAxICsgcmhvLCBjZW50cm9pZCwgLXJobywgd29yc3QpO1xuICAgICAgcmVmbGVjdGVkLmZ4ID0gZihyZWZsZWN0ZWQpOyAvLyBpZiB0aGUgcmVmbGVjdGVkIHBvaW50IGlzIHRoZSBiZXN0IHNlZW4sIHRoZW4gcG9zc2libHkgZXhwYW5kXG5cbiAgICAgIGlmIChyZWZsZWN0ZWQuZnggPCBzaW1wbGV4WzBdLmZ4KSB7XG4gICAgICAgIHdlaWdodGVkU3VtKGV4cGFuZGVkLCAxICsgY2hpLCBjZW50cm9pZCwgLWNoaSwgd29yc3QpO1xuICAgICAgICBleHBhbmRlZC5meCA9IGYoZXhwYW5kZWQpO1xuXG4gICAgICAgIGlmIChleHBhbmRlZC5meCA8IHJlZmxlY3RlZC5meCkge1xuICAgICAgICAgIHVwZGF0ZVNpbXBsZXgoZXhwYW5kZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZVNpbXBsZXgocmVmbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiB0aGUgcmVmbGVjdGVkIHBvaW50IGlzIHdvcnNlIHRoYW4gdGhlIHNlY29uZCB3b3JzdCwgd2UgbmVlZCB0b1xuICAgICAgLy8gY29udHJhY3RcbiAgICAgIGVsc2UgaWYgKHJlZmxlY3RlZC5meCA+PSBzaW1wbGV4W04gLSAxXS5meCkge1xuICAgICAgICAgIHZhciBzaG91bGRSZWR1Y2UgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChyZWZsZWN0ZWQuZnggPiB3b3JzdC5meCkge1xuICAgICAgICAgICAgLy8gZG8gYW4gaW5zaWRlIGNvbnRyYWN0aW9uXG4gICAgICAgICAgICB3ZWlnaHRlZFN1bShjb250cmFjdGVkLCAxICsgcHNpLCBjZW50cm9pZCwgLXBzaSwgd29yc3QpO1xuICAgICAgICAgICAgY29udHJhY3RlZC5meCA9IGYoY29udHJhY3RlZCk7XG5cbiAgICAgICAgICAgIGlmIChjb250cmFjdGVkLmZ4IDwgd29yc3QuZngpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU2ltcGxleChjb250cmFjdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNob3VsZFJlZHVjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvIGFuIG91dHNpZGUgY29udHJhY3Rpb25cbiAgICAgICAgICAgIHdlaWdodGVkU3VtKGNvbnRyYWN0ZWQsIDEgLSBwc2kgKiByaG8sIGNlbnRyb2lkLCBwc2kgKiByaG8sIHdvcnN0KTtcbiAgICAgICAgICAgIGNvbnRyYWN0ZWQuZnggPSBmKGNvbnRyYWN0ZWQpO1xuXG4gICAgICAgICAgICBpZiAoY29udHJhY3RlZC5meCA8IHJlZmxlY3RlZC5meCkge1xuICAgICAgICAgICAgICB1cGRhdGVTaW1wbGV4KGNvbnRyYWN0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2hvdWxkUmVkdWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVkdWNlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBjb250cmFjdCBoZXJlLCB3ZSdyZSBkb25lXG4gICAgICAgICAgICBpZiAoc2lnbWEgPj0gMSkgYnJlYWs7IC8vIGRvIGEgcmVkdWN0aW9uXG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzaW1wbGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHdlaWdodGVkU3VtKHNpbXBsZXhbaV0sIDEgLSBzaWdtYSwgc2ltcGxleFswXSwgc2lnbWEsIHNpbXBsZXhbaV0pO1xuICAgICAgICAgICAgICBzaW1wbGV4W2ldLmZ4ID0gZihzaW1wbGV4W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlU2ltcGxleChyZWZsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2ltcGxleC5zb3J0KHNvcnRPcmRlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ4OiBzaW1wbGV4WzBdLmZ4LFxuICAgICAgeDogc2ltcGxleFswXVxuICAgIH07XG4gIH0gLy8vIHNlYXJjaGVzIGFsb25nIGxpbmUgJ3BrJyBmb3IgYSBwb2ludCB0aGF0IHNhdGlmaWVzIHRoZSB3b2xmZSBjb25kaXRpb25zXG4gIC8vLyBTZWUgJ051bWVyaWNhbCBPcHRpbWl6YXRpb24nIGJ5IE5vY2VkYWwgYW5kIFdyaWdodCBwNTktNjBcbiAgLy8vIGYgOiBvYmplY3RpdmUgZnVuY3Rpb25cbiAgLy8vIHBrIDogc2VhcmNoIGRpcmVjdGlvblxuICAvLy8gY3VycmVudDogb2JqZWN0IGNvbnRhaW5pbmcgY3VycmVudCBncmFkaWVudC9sb3NzXG4gIC8vLyBuZXh0OiBvdXRwdXQ6IGNvbnRhaW5zIG5leHQgZ3JhZGllbnQvbG9zc1xuICAvLy8gcmV0dXJucyBhOiBzdGVwIHNpemUgdGFrZW5cblxuXG4gIGZ1bmN0aW9uIHdvbGZlTGluZVNlYXJjaChmLCBwaywgY3VycmVudCwgbmV4dCwgYSwgYzEsIGMyKSB7XG4gICAgdmFyIHBoaTAgPSBjdXJyZW50LmZ4LFxuICAgICAgICBwaGlQcmltZTAgPSBkb3QoY3VycmVudC5meHByaW1lLCBwayksXG4gICAgICAgIHBoaSA9IHBoaTAsXG4gICAgICAgIHBoaV9vbGQgPSBwaGkwLFxuICAgICAgICBwaGlQcmltZSA9IHBoaVByaW1lMCxcbiAgICAgICAgYTAgPSAwO1xuICAgIGEgPSBhIHx8IDE7XG4gICAgYzEgPSBjMSB8fCAxZS02O1xuICAgIGMyID0gYzIgfHwgMC4xO1xuXG4gICAgZnVuY3Rpb24gem9vbShhX2xvLCBhX2hpZ2gsIHBoaV9sbykge1xuICAgICAgZm9yICh2YXIgaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgMTY7ICsraXRlcmF0aW9uKSB7XG4gICAgICAgIGEgPSAoYV9sbyArIGFfaGlnaCkgLyAyO1xuICAgICAgICB3ZWlnaHRlZFN1bShuZXh0LngsIDEuMCwgY3VycmVudC54LCBhLCBwayk7XG4gICAgICAgIHBoaSA9IG5leHQuZnggPSBmKG5leHQueCwgbmV4dC5meHByaW1lKTtcbiAgICAgICAgcGhpUHJpbWUgPSBkb3QobmV4dC5meHByaW1lLCBwayk7XG5cbiAgICAgICAgaWYgKHBoaSA+IHBoaTAgKyBjMSAqIGEgKiBwaGlQcmltZTAgfHwgcGhpID49IHBoaV9sbykge1xuICAgICAgICAgIGFfaGlnaCA9IGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKHBoaVByaW1lKSA8PSAtYzIgKiBwaGlQcmltZTApIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwaGlQcmltZSAqIChhX2hpZ2ggLSBhX2xvKSA+PSAwKSB7XG4gICAgICAgICAgICBhX2hpZ2ggPSBhX2xvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFfbG8gPSBhO1xuICAgICAgICAgIHBoaV9sbyA9IHBoaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCAxMDsgKytpdGVyYXRpb24pIHtcbiAgICAgIHdlaWdodGVkU3VtKG5leHQueCwgMS4wLCBjdXJyZW50LngsIGEsIHBrKTtcbiAgICAgIHBoaSA9IG5leHQuZnggPSBmKG5leHQueCwgbmV4dC5meHByaW1lKTtcbiAgICAgIHBoaVByaW1lID0gZG90KG5leHQuZnhwcmltZSwgcGspO1xuXG4gICAgICBpZiAocGhpID4gcGhpMCArIGMxICogYSAqIHBoaVByaW1lMCB8fCBpdGVyYXRpb24gJiYgcGhpID49IHBoaV9vbGQpIHtcbiAgICAgICAgcmV0dXJuIHpvb20oYTAsIGEsIHBoaV9vbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMocGhpUHJpbWUpIDw9IC1jMiAqIHBoaVByaW1lMCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBoaVByaW1lID49IDApIHtcbiAgICAgICAgcmV0dXJuIHpvb20oYSwgYTAsIHBoaSk7XG4gICAgICB9XG5cbiAgICAgIHBoaV9vbGQgPSBwaGk7XG4gICAgICBhMCA9IGE7XG4gICAgICBhICo9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBjb25qdWdhdGVHcmFkaWVudChmLCBpbml0aWFsLCBwYXJhbXMpIHtcbiAgICAvLyBhbGxvY2F0ZSBhbGwgbWVtb3J5IHVwIGZyb250IGhlcmUsIGtlZXAgb3V0IG9mIHRoZSBsb29wIGZvciBwZXJmb21hbmNlXG4gICAgLy8gcmVhc29uc1xuICAgIHZhciBjdXJyZW50ID0ge1xuICAgICAgeDogaW5pdGlhbC5zbGljZSgpLFxuICAgICAgZng6IDAsXG4gICAgICBmeHByaW1lOiBpbml0aWFsLnNsaWNlKClcbiAgICB9LFxuICAgICAgICBuZXh0ID0ge1xuICAgICAgeDogaW5pdGlhbC5zbGljZSgpLFxuICAgICAgZng6IDAsXG4gICAgICBmeHByaW1lOiBpbml0aWFsLnNsaWNlKClcbiAgICB9LFxuICAgICAgICB5ayA9IGluaXRpYWwuc2xpY2UoKSxcbiAgICAgICAgcGssXG4gICAgICAgIHRlbXAsXG4gICAgICAgIGEgPSAxLFxuICAgICAgICBtYXhJdGVyYXRpb25zO1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBtYXhJdGVyYXRpb25zID0gcGFyYW1zLm1heEl0ZXJhdGlvbnMgfHwgaW5pdGlhbC5sZW5ndGggKiAyMDtcbiAgICBjdXJyZW50LmZ4ID0gZihjdXJyZW50LngsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgcGsgPSBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKTtcbiAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgYSA9IHdvbGZlTGluZVNlYXJjaChmLCBwaywgY3VycmVudCwgbmV4dCwgYSk7IC8vIHRvZG86IGhpc3RvcnkgaW4gd3Jvbmcgc3BvdD9cblxuICAgICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgIHBhcmFtcy5oaXN0b3J5LnB1c2goe1xuICAgICAgICAgIHg6IGN1cnJlbnQueC5zbGljZSgpLFxuICAgICAgICAgIGZ4OiBjdXJyZW50LmZ4LFxuICAgICAgICAgIGZ4cHJpbWU6IGN1cnJlbnQuZnhwcmltZS5zbGljZSgpLFxuICAgICAgICAgIGFscGhhOiBhXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgLy8gZmFpaWxlZCB0byBmaW5kIHBvaW50IHRoYXQgc2F0aWZpZXMgd29sZmUgY29uZGl0aW9ucy5cbiAgICAgICAgLy8gcmVzZXQgZGlyZWN0aW9uIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgZGlyZWN0aW9uIHVzaW5nIFBvbGFr4oCTUmliaWVyZSBDRyBtZXRob2RcbiAgICAgICAgd2VpZ2h0ZWRTdW0oeWssIDEsIG5leHQuZnhwcmltZSwgLTEsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgICAgIHZhciBkZWx0YV9rID0gZG90KGN1cnJlbnQuZnhwcmltZSwgY3VycmVudC5meHByaW1lKSxcbiAgICAgICAgICAgIGJldGFfayA9IE1hdGgubWF4KDAsIGRvdCh5aywgbmV4dC5meHByaW1lKSAvIGRlbHRhX2spO1xuICAgICAgICB3ZWlnaHRlZFN1bShwaywgYmV0YV9rLCBwaywgLTEsIG5leHQuZnhwcmltZSk7XG4gICAgICAgIHRlbXAgPSBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgbmV4dCA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3JtMihjdXJyZW50LmZ4cHJpbWUpIDw9IDFlLTUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICBwYXJhbXMuaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgeDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgIGZ4OiBjdXJyZW50LmZ4LFxuICAgICAgICBmeHByaW1lOiBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKSxcbiAgICAgICAgYWxwaGE6IGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIC8qKiBnaXZlbiBhIGxpc3Qgb2Ygc2V0IG9iamVjdHMsIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG92ZXJsYXBzLlxuICB1cGRhdGVzIHRoZSAoeCwgeSwgcmFkaXVzKSBhdHRyaWJ1dGUgb24gZWFjaCBzZXQgc3VjaCB0aGF0IHRoZWlyIHBvc2l0aW9uc1xuICByb3VnaGx5IGNvcnJlc3BvbmQgdG8gdGhlIGRlc2lyZWQgb3ZlcmxhcHMgKi9cblxuXG4gIGZ1bmN0aW9uIHZlbm4oYXJlYXMsIHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcbiAgICBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgPSBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgfHwgNTAwO1xuICAgIHZhciBpbml0aWFsTGF5b3V0ID0gcGFyYW1ldGVycy5pbml0aWFsTGF5b3V0IHx8IGJlc3RJbml0aWFsTGF5b3V0O1xuICAgIHZhciBsb3NzID0gcGFyYW1ldGVycy5sb3NzRnVuY3Rpb24gfHwgbG9zc0Z1bmN0aW9uOyAvLyBhZGQgaW4gbWlzc2luZyBwYWlyd2lzZSBhcmVhcyBhcyBoYXZpbmcgMCBzaXplXG5cbiAgICBhcmVhcyA9IGFkZE1pc3NpbmdBcmVhcyhhcmVhcyk7IC8vIGluaXRpYWwgbGF5b3V0IGlzIGRvbmUgZ3JlZWRpbHlcblxuICAgIHZhciBjaXJjbGVzID0gaW5pdGlhbExheW91dChhcmVhcywgcGFyYW1ldGVycyk7IC8vIHRyYW5zZm9ybSB4L3kgY29vcmRpbmF0ZXMgdG8gYSB2ZWN0b3IgdG8gb3B0aW1pemVcblxuICAgIHZhciBpbml0aWFsID0gW10sXG4gICAgICAgIHNldGlkcyA9IFtdLFxuICAgICAgICBzZXRpZDtcblxuICAgIGZvciAoc2V0aWQgaW4gY2lyY2xlcykge1xuICAgICAgaWYgKGNpcmNsZXMuaGFzT3duUHJvcGVydHkoc2V0aWQpKSB7XG4gICAgICAgIGluaXRpYWwucHVzaChjaXJjbGVzW3NldGlkXS54KTtcbiAgICAgICAgaW5pdGlhbC5wdXNoKGNpcmNsZXNbc2V0aWRdLnkpO1xuICAgICAgICBzZXRpZHMucHVzaChzZXRpZCk7XG4gICAgICB9XG4gICAgfSAvLyBvcHRpbWl6ZSBpbml0aWFsIGxheW91dCBmcm9tIG91ciBsb3NzIGZ1bmN0aW9uXG5cblxuICAgIHZhciBzb2x1dGlvbiA9IG5lbGRlck1lYWQoZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRpZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNldGlkID0gc2V0aWRzW2ldO1xuICAgICAgICBjdXJyZW50W3NldGlkXSA9IHtcbiAgICAgICAgICB4OiB2YWx1ZXNbMiAqIGldLFxuICAgICAgICAgIHk6IHZhbHVlc1syICogaSArIDFdLFxuICAgICAgICAgIHJhZGl1czogY2lyY2xlc1tzZXRpZF0ucmFkaXVzIC8vIHNpemUgOiBjaXJjbGVzW3NldGlkXS5zaXplXG5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvc3MoY3VycmVudCwgYXJlYXMpO1xuICAgIH0sIGluaXRpYWwsIHBhcmFtZXRlcnMpOyAvLyB0cmFuc2Zvcm0gc29sdXRpb24gdmVjdG9yIGJhY2sgdG8geC95IHBvaW50c1xuXG4gICAgdmFyIHBvc2l0aW9ucyA9IHNvbHV0aW9uLng7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldGlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgc2V0aWQgPSBzZXRpZHNbaV07XG4gICAgICBjaXJjbGVzW3NldGlkXS54ID0gcG9zaXRpb25zWzIgKiBpXTtcbiAgICAgIGNpcmNsZXNbc2V0aWRdLnkgPSBwb3NpdGlvbnNbMiAqIGkgKyAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlcztcbiAgfVxuXG4gIHZhciBTTUFMTCQxID0gMWUtMTA7XG4gIC8qKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBuZWNlc3NhcnkgZm9yIHR3byBjaXJjbGVzIG9mIHJhZGl1cyByMSArIHIyIHRvXG4gIGhhdmUgdGhlIG92ZXJsYXAgYXJlYSAnb3ZlcmxhcCcgKi9cblxuICBmdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3RBcmVhKHIxLCByMiwgb3ZlcmxhcCkge1xuICAgIC8vIGhhbmRsZSBjb21wbGV0ZSBvdmVybGFwcGVkIGNpcmNsZXNcbiAgICBpZiAoTWF0aC5taW4ocjEsIHIyKSAqIE1hdGgubWluKHIxLCByMikgKiBNYXRoLlBJIDw9IG92ZXJsYXAgKyBTTUFMTCQxKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocjEgLSByMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpc2VjdChmdW5jdGlvbiAoZGlzdGFuY2UkJDEpIHtcbiAgICAgIHJldHVybiBjaXJjbGVPdmVybGFwKHIxLCByMiwgZGlzdGFuY2UkJDEpIC0gb3ZlcmxhcDtcbiAgICB9LCAwLCByMSArIHIyKTtcbiAgfVxuICAvKiogTWlzc2luZyBwYWlyLXdpc2UgaW50ZXJzZWN0aW9uIGFyZWEgZGF0YSBjYW4gY2F1c2UgcHJvYmxlbXM6XG4gICB0cmVhdGluZyBhcyBhbiB1bmtub3duIG1lYW5zIHRoYXQgc2V0cyB3aWxsIGJlIGxhaWQgb3V0IG92ZXJsYXBwaW5nLFxuICAgd2hpY2ggaXNuJ3Qgd2hhdCBwZW9wbGUgZXhwZWN0LiBUbyByZWZsZWN0IHRoYXQgd2Ugd2FudCBkaXNqb2ludCBzZXRzXG4gICBoZXJlLCBzZXQgdGhlIG92ZXJsYXAgdG8gMCBmb3IgYWxsIG1pc3NpbmcgcGFpcndpc2Ugc2V0IGludGVyc2VjdGlvbnMgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZE1pc3NpbmdBcmVhcyhhcmVhcykge1xuICAgIGFyZWFzID0gYXJlYXMuc2xpY2UoKTsgLy8gdHdvIGNpcmNsZSBpbnRlcnNlY3Rpb25zIHRoYXQgYXJlbid0IGRlZmluZWRcblxuICAgIHZhciBpZHMgPSBbXSxcbiAgICAgICAgcGFpcnMgPSB7fSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgYSxcbiAgICAgICAgYjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmVhcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZWEgPSBhcmVhc1tpXTtcblxuICAgICAgaWYgKGFyZWEuc2V0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZHMucHVzaChhcmVhLnNldHNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChhcmVhLnNldHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgYSA9IGFyZWEuc2V0c1swXTtcbiAgICAgICAgYiA9IGFyZWEuc2V0c1sxXTtcbiAgICAgICAgcGFpcnNbW2EsIGJdXSA9IHRydWU7XG4gICAgICAgIHBhaXJzW1tiLCBhXV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGI7XG4gICAgfSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBhID0gaWRzW2ldO1xuXG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGlkcy5sZW5ndGg7ICsraikge1xuICAgICAgICBiID0gaWRzW2pdO1xuXG4gICAgICAgIGlmICghKFthLCBiXSBpbiBwYWlycykpIHtcbiAgICAgICAgICBhcmVhcy5wdXNoKHtcbiAgICAgICAgICAgICdzZXRzJzogW2EsIGJdLFxuICAgICAgICAgICAgJ3NpemUnOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYXM7XG4gIH0gLy8vIFJldHVybnMgdHdvIG1hdHJpY2VzLCBvbmUgb2YgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgc2V0c1xuICAvLy8gYW5kIHRoZSBvdGhlciBpbmRpY2F0aW5nIGlmIHRoZXJlIGFyZSBzdWJzZXQgb3IgZGlzam9pbnQgc2V0IHJlbGF0aW9uc2hpcHNcblxuXG4gIGZ1bmN0aW9uIGdldERpc3RhbmNlTWF0cmljZXMoYXJlYXMsIHNldHMsIHNldGlkcykge1xuICAgIC8vIGluaXRpYWxpemUgYW4gZW1wdHkgZGlzdGFuY2UgbWF0cml4IGJldHdlZW4gYWxsIHRoZSBwb2ludHNcbiAgICB2YXIgZGlzdGFuY2VzID0gemVyb3NNKHNldHMubGVuZ3RoLCBzZXRzLmxlbmd0aCksXG4gICAgICAgIGNvbnN0cmFpbnRzID0gemVyb3NNKHNldHMubGVuZ3RoLCBzZXRzLmxlbmd0aCk7IC8vIGNvbXB1dGUgcmVxdWlyZWQgZGlzdGFuY2VzIGJldHdlZW4gYWxsIHRoZSBzZXRzIHN1Y2ggdGhhdFxuICAgIC8vIHRoZSBhcmVhcyBtYXRjaFxuXG4gICAgYXJlYXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5zZXRzLmxlbmd0aCA9PSAyO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgdmFyIGxlZnQgPSBzZXRpZHNbY3VycmVudC5zZXRzWzBdXSxcbiAgICAgICAgICByaWdodCA9IHNldGlkc1tjdXJyZW50LnNldHNbMV1dLFxuICAgICAgICAgIHIxID0gTWF0aC5zcXJ0KHNldHNbbGVmdF0uc2l6ZSAvIE1hdGguUEkpLFxuICAgICAgICAgIHIyID0gTWF0aC5zcXJ0KHNldHNbcmlnaHRdLnNpemUgLyBNYXRoLlBJKSxcbiAgICAgICAgICBkaXN0YW5jZSQkMSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdEFyZWEocjEsIHIyLCBjdXJyZW50LnNpemUpO1xuICAgICAgZGlzdGFuY2VzW2xlZnRdW3JpZ2h0XSA9IGRpc3RhbmNlc1tyaWdodF1bbGVmdF0gPSBkaXN0YW5jZSQkMTsgLy8gYWxzbyB1cGRhdGUgY29uc3RyYWludHMgdG8gaW5kaWNhdGUgaWYgaXRzIGEgc3Vic2V0IG9yIGRpc2pvaW50XG4gICAgICAvLyByZWxhdGlvbnNoaXBcblxuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICBpZiAoY3VycmVudC5zaXplICsgMWUtMTAgPj0gTWF0aC5taW4oc2V0c1tsZWZ0XS5zaXplLCBzZXRzW3JpZ2h0XS5zaXplKSkge1xuICAgICAgICBjID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5zaXplIDw9IDFlLTEwKSB7XG4gICAgICAgIGMgPSAtMTtcbiAgICAgIH1cblxuICAgICAgY29uc3RyYWludHNbbGVmdF1bcmlnaHRdID0gY29uc3RyYWludHNbcmlnaHRdW2xlZnRdID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VzOiBkaXN0YW5jZXMsXG4gICAgICBjb25zdHJhaW50czogY29uc3RyYWludHNcbiAgICB9O1xuICB9IC8vLyBjb21wdXRlcyB0aGUgZ3JhZGllbnQgYW5kIGxvc3Mgc2ltdWxhdGVub3VzbHkgZm9yIG91ciBjb25zdHJhaW5lZCBNRFMgb3B0aW1pemVyXG5cblxuICBmdW5jdGlvbiBjb25zdHJhaW5lZE1EU0dyYWRpZW50KHgsIGZ4cHJpbWUsIGRpc3RhbmNlcywgY29uc3RyYWludHMpIHtcbiAgICB2YXIgbG9zcyA9IDAsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZnhwcmltZS5sZW5ndGg7ICsraSkge1xuICAgICAgZnhwcmltZVtpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGRpc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHhpID0geFsyICogaV0sXG4gICAgICAgICAgeWkgPSB4WzIgKiBpICsgMV07XG5cbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRpc3RhbmNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgeGogPSB4WzIgKiBqXSxcbiAgICAgICAgICAgIHlqID0geFsyICogaiArIDFdLFxuICAgICAgICAgICAgZGlqID0gZGlzdGFuY2VzW2ldW2pdLFxuICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldW2pdO1xuICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gKHhqIC0geGkpICogKHhqIC0geGkpICsgKHlqIC0geWkpICogKHlqIC0geWkpLFxuICAgICAgICAgICAgZGlzdGFuY2UkJDEgPSBNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKSxcbiAgICAgICAgICAgIGRlbHRhID0gc3F1YXJlZERpc3RhbmNlIC0gZGlqICogZGlqO1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50ID4gMCAmJiBkaXN0YW5jZSQkMSA8PSBkaWogfHwgY29uc3RyYWludCA8IDAgJiYgZGlzdGFuY2UkJDEgPj0gZGlqKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb3NzICs9IDIgKiBkZWx0YSAqIGRlbHRhO1xuICAgICAgICBmeHByaW1lWzIgKiBpXSArPSA0ICogZGVsdGEgKiAoeGkgLSB4aik7XG4gICAgICAgIGZ4cHJpbWVbMiAqIGkgKyAxXSArPSA0ICogZGVsdGEgKiAoeWkgLSB5aik7XG4gICAgICAgIGZ4cHJpbWVbMiAqIGpdICs9IDQgKiBkZWx0YSAqICh4aiAtIHhpKTtcbiAgICAgICAgZnhwcmltZVsyICogaiArIDFdICs9IDQgKiBkZWx0YSAqICh5aiAtIHlpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbG9zcztcbiAgfSAvLy8gdGFrZXMgdGhlIGJlc3Qgd29ya2luZyB2YXJpYW50IG9mIGVpdGhlciBjb25zdHJhaW5lZCBNRFMgb3IgZ3JlZWR5XG5cblxuICBmdW5jdGlvbiBiZXN0SW5pdGlhbExheW91dChhcmVhcywgcGFyYW1zKSB7XG4gICAgdmFyIGluaXRpYWwgPSBncmVlZHlMYXlvdXQoYXJlYXMsIHBhcmFtcyk7XG4gICAgdmFyIGxvc3MgPSBwYXJhbXMubG9zc0Z1bmN0aW9uIHx8IGxvc3NGdW5jdGlvbjsgLy8gZ3JlZWR5bGF5b3V0IGlzIHN1ZmZpY2llbnQgZm9yIGFsbCAyLzMgY2lyY2xlIGNhc2VzLiB0cnkgb3V0XG4gICAgLy8gY29uc3RyYWluZWQgTURTIGZvciBoaWdoZXIgb3JkZXIgcHJvYmxlbXMsIHRha2UgaXRzIG91dHB1dFxuICAgIC8vIGlmIGl0IG91dHBlcmZvcm1zLiAoZ3JlZWR5IGlzIGFlc3RoZXRpY2FsbHkgYmV0dGVyIG9uIDIvMyBjaXJjbGVzXG4gICAgLy8gc2luY2UgaXQgYXhpcyBhbGlnbnMpXG5cbiAgICBpZiAoYXJlYXMubGVuZ3RoID49IDgpIHtcbiAgICAgIHZhciBjb25zdHJhaW5lZCA9IGNvbnN0cmFpbmVkTURTTGF5b3V0KGFyZWFzLCBwYXJhbXMpLFxuICAgICAgICAgIGNvbnN0cmFpbmVkTG9zcyA9IGxvc3MoY29uc3RyYWluZWQsIGFyZWFzKSxcbiAgICAgICAgICBncmVlZHlMb3NzID0gbG9zcyhpbml0aWFsLCBhcmVhcyk7XG5cbiAgICAgIGlmIChjb25zdHJhaW5lZExvc3MgKyAxZS04IDwgZ3JlZWR5TG9zcykge1xuICAgICAgICBpbml0aWFsID0gY29uc3RyYWluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH0gLy8vIHVzZSB0aGUgY29uc3RyYWluZWQgTURTIHZhcmlhbnQgdG8gZ2VuZXJhdGUgYW4gaW5pdGlhbCBsYXlvdXRcblxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpbmVkTURTTGF5b3V0KGFyZWFzLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFyIHJlc3RhcnRzID0gcGFyYW1zLnJlc3RhcnRzIHx8IDEwOyAvLyBiaWRpcmVjdGlvbmFsbHkgbWFwIHNldHMgdG8gYSByb3dpZCAgKHNvIHdlIGNhbiBjcmVhdGUgYSBtYXRyaXgpXG5cbiAgICB2YXIgc2V0cyA9IFtdLFxuICAgICAgICBzZXRpZHMgPSB7fSxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmVhcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZWEgPSBhcmVhc1tpXTtcblxuICAgICAgaWYgKGFyZWEuc2V0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBzZXRpZHNbYXJlYS5zZXRzWzBdXSA9IHNldHMubGVuZ3RoO1xuICAgICAgICBzZXRzLnB1c2goYXJlYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpY2VzID0gZ2V0RGlzdGFuY2VNYXRyaWNlcyhhcmVhcywgc2V0cywgc2V0aWRzKSxcbiAgICAgICAgZGlzdGFuY2VzID0gbWF0cmljZXMuZGlzdGFuY2VzLFxuICAgICAgICBjb25zdHJhaW50cyA9IG1hdHJpY2VzLmNvbnN0cmFpbnRzOyAvLyBrZWVwIGRpc3RhbmNlcyBib3VuZGVkLCB0aGluZ3MgZ2V0IG1lc3NlZCB1cCBvdGhlcndpc2UuXG4gICAgLy8gVE9ETzogcHJvcGVyIHByZWNvbmRpdGlvbmVyP1xuXG4gICAgdmFyIG5vcm0gPSBub3JtMihkaXN0YW5jZXMubWFwKG5vcm0yKSkgLyBkaXN0YW5jZXMubGVuZ3RoO1xuICAgIGRpc3RhbmNlcyA9IGRpc3RhbmNlcy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAvIG5vcm07XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBvYmogPSBmdW5jdGlvbiAoeCwgZnhwcmltZSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbmVkTURTR3JhZGllbnQoeCwgZnhwcmltZSwgZGlzdGFuY2VzLCBjb25zdHJhaW50cyk7XG4gICAgfTtcblxuICAgIHZhciBiZXN0LCBjdXJyZW50O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3RhcnRzOyArK2kpIHtcbiAgICAgIHZhciBpbml0aWFsID0gemVyb3MoZGlzdGFuY2VzLmxlbmd0aCAqIDIpLm1hcChNYXRoLnJhbmRvbSk7XG4gICAgICBjdXJyZW50ID0gY29uanVnYXRlR3JhZGllbnQob2JqLCBpbml0aWFsLCBwYXJhbXMpO1xuXG4gICAgICBpZiAoIWJlc3QgfHwgY3VycmVudC5meCA8IGJlc3QuZngpIHtcbiAgICAgICAgYmVzdCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9ucyA9IGJlc3QueDsgLy8gdHJhbnNsYXRlIHJvd3MgYmFjayB0byAoeCx5LHJhZGl1cykgY29vcmRpbmF0ZXNcblxuICAgIHZhciBjaXJjbGVzID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNldCA9IHNldHNbaV07XG4gICAgICBjaXJjbGVzW3NldC5zZXRzWzBdXSA9IHtcbiAgICAgICAgeDogcG9zaXRpb25zWzIgKiBpXSAqIG5vcm0sXG4gICAgICAgIHk6IHBvc2l0aW9uc1syICogaSArIDFdICogbm9ybSxcbiAgICAgICAgcmFkaXVzOiBNYXRoLnNxcnQoc2V0LnNpemUgLyBNYXRoLlBJKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmhpc3RvcnkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbXMuaGlzdG9yeS5sZW5ndGg7ICsraSkge1xuICAgICAgICBzY2FsZShwYXJhbXMuaGlzdG9yeVtpXS54LCBub3JtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlcztcbiAgfVxuICAvKiogTGF5cyBvdXQgYSBWZW5uIGRpYWdyYW0gZ3JlZWRpbHksIGdvaW5nIGZyb20gbW9zdCBvdmVybGFwcGVkIHNldHMgdG9cbiAgbGVhc3Qgb3ZlcmxhcHBlZCwgYXR0ZW1wdGluZyB0byBwb3NpdGlvbiBlYWNoIG5ldyBzZXQgc3VjaCB0aGF0IHRoZVxuICBvdmVybGFwcGluZyBhcmVhcyB0byBhbHJlYWR5IHBvc2l0aW9uZWQgc2V0cyBhcmUgYmFzaWNhbGx5IHJpZ2h0ICovXG5cblxuICBmdW5jdGlvbiBncmVlZHlMYXlvdXQoYXJlYXMsIHBhcmFtcykge1xuICAgIHZhciBsb3NzID0gcGFyYW1zICYmIHBhcmFtcy5sb3NzRnVuY3Rpb24gPyBwYXJhbXMubG9zc0Z1bmN0aW9uIDogbG9zc0Z1bmN0aW9uOyAvLyBkZWZpbmUgYSBjaXJjbGUgZm9yIGVhY2ggc2V0XG5cbiAgICB2YXIgY2lyY2xlcyA9IHt9LFxuICAgICAgICBzZXRPdmVybGFwcyA9IHt9LFxuICAgICAgICBzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJlYSA9IGFyZWFzW2ldO1xuXG4gICAgICBpZiAoYXJlYS5zZXRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHNldCA9IGFyZWEuc2V0c1swXTtcbiAgICAgICAgY2lyY2xlc1tzZXRdID0ge1xuICAgICAgICAgIHg6IDFlMTAsXG4gICAgICAgICAgeTogMWUxMCxcbiAgICAgICAgICByb3dpZDogY2lyY2xlcy5sZW5ndGgsXG4gICAgICAgICAgc2l6ZTogYXJlYS5zaXplLFxuICAgICAgICAgIHJhZGl1czogTWF0aC5zcXJ0KGFyZWEuc2l6ZSAvIE1hdGguUEkpXG4gICAgICAgIH07XG4gICAgICAgIHNldE92ZXJsYXBzW3NldF0gPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcmVhcyA9IGFyZWFzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEuc2V0cy5sZW5ndGggPT0gMjtcbiAgICB9KTsgLy8gbWFwIGVhY2ggc2V0IHRvIGEgbGlzdCBvZiBhbGwgdGhlIG90aGVyIHNldHMgdGhhdCBvdmVybGFwIGl0XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJlYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gYXJlYXNbaV07XG4gICAgICB2YXIgd2VpZ2h0ID0gY3VycmVudC5oYXNPd25Qcm9wZXJ0eSgnd2VpZ2h0JykgPyBjdXJyZW50LndlaWdodCA6IDEuMDtcbiAgICAgIHZhciBsZWZ0ID0gY3VycmVudC5zZXRzWzBdLFxuICAgICAgICAgIHJpZ2h0ID0gY3VycmVudC5zZXRzWzFdOyAvLyBjb21wbGV0ZWx5IG92ZXJsYXBwZWQgY2lyY2xlcyBzaG91bGRuJ3QgYmUgcG9zaXRpb25lZCBlYXJseSBoZXJlXG5cbiAgICAgIGlmIChjdXJyZW50LnNpemUgKyBTTUFMTCQxID49IE1hdGgubWluKGNpcmNsZXNbbGVmdF0uc2l6ZSwgY2lyY2xlc1tyaWdodF0uc2l6ZSkpIHtcbiAgICAgICAgd2VpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgc2V0T3ZlcmxhcHNbbGVmdF0ucHVzaCh7XG4gICAgICAgIHNldDogcmlnaHQsXG4gICAgICAgIHNpemU6IGN1cnJlbnQuc2l6ZSxcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHRcbiAgICAgIH0pO1xuICAgICAgc2V0T3ZlcmxhcHNbcmlnaHRdLnB1c2goe1xuICAgICAgICBzZXQ6IGxlZnQsXG4gICAgICAgIHNpemU6IGN1cnJlbnQuc2l6ZSxcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHRcbiAgICAgIH0pO1xuICAgIH0gLy8gZ2V0IGxpc3Qgb2YgbW9zdCBvdmVybGFwcGVkIHNldHNcblxuXG4gICAgdmFyIG1vc3RPdmVybGFwcGVkID0gW107XG5cbiAgICBmb3IgKHNldCBpbiBzZXRPdmVybGFwcykge1xuICAgICAgaWYgKHNldE92ZXJsYXBzLmhhc093blByb3BlcnR5KHNldCkpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXRPdmVybGFwc1tzZXRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgc2l6ZSArPSBzZXRPdmVybGFwc1tzZXRdW2ldLnNpemUgKiBzZXRPdmVybGFwc1tzZXRdW2ldLndlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vc3RPdmVybGFwcGVkLnB1c2goe1xuICAgICAgICAgIHNldDogc2V0LFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBzb3J0IGJ5IHNpemUgZGVzY1xuXG5cbiAgICBmdW5jdGlvbiBzb3J0T3JkZXIoYSwgYikge1xuICAgICAgcmV0dXJuIGIuc2l6ZSAtIGEuc2l6ZTtcbiAgICB9XG5cbiAgICBtb3N0T3ZlcmxhcHBlZC5zb3J0KHNvcnRPcmRlcik7IC8vIGtlZXAgdHJhY2sgb2Ygd2hhdCBzZXRzIGhhdmUgYmVlbiBsYWlkIG91dFxuXG4gICAgdmFyIHBvc2l0aW9uZWQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzUG9zaXRpb25lZChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXQgaW4gcG9zaXRpb25lZDtcbiAgICB9IC8vIGFkZHMgYSBwb2ludCB0byB0aGUgb3V0cHV0XG5cblxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uU2V0KHBvaW50LCBpbmRleCkge1xuICAgICAgY2lyY2xlc1tpbmRleF0ueCA9IHBvaW50Lng7XG4gICAgICBjaXJjbGVzW2luZGV4XS55ID0gcG9pbnQueTtcbiAgICAgIHBvc2l0aW9uZWRbaW5kZXhdID0gdHJ1ZTtcbiAgICB9IC8vIGFkZCBtb3N0IG92ZXJsYXBwZWQgc2V0IGF0ICgwLDApXG5cblxuICAgIHBvc2l0aW9uU2V0KHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSwgbW9zdE92ZXJsYXBwZWRbMF0uc2V0KTsgLy8gZ2V0IGRpc3RhbmNlcyBiZXR3ZWVuIGFsbCBwb2ludHMuIFRPRE8sIG5lY2Vzc2FyeT9cbiAgICAvLyBhbnN3ZXI6IHByb2JhYmx5IG5vdFxuICAgIC8vIHZhciBkaXN0YW5jZXMgPSB2ZW5uLmdldERpc3RhbmNlTWF0cmljZXMoY2lyY2xlcywgYXJlYXMpLmRpc3RhbmNlcztcblxuICAgIGZvciAoaSA9IDE7IGkgPCBtb3N0T3ZlcmxhcHBlZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNldEluZGV4ID0gbW9zdE92ZXJsYXBwZWRbaV0uc2V0LFxuICAgICAgICAgIG92ZXJsYXAgPSBzZXRPdmVybGFwc1tzZXRJbmRleF0uZmlsdGVyKGlzUG9zaXRpb25lZCk7XG4gICAgICBzZXQgPSBjaXJjbGVzW3NldEluZGV4XTtcbiAgICAgIG92ZXJsYXAuc29ydChzb3J0T3JkZXIpO1xuXG4gICAgICBpZiAob3ZlcmxhcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuIGFueW1vcmUgd2l0aCBhZGRNaXNzaW5nQXJlYXNcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogbWlzc2luZyBwYWlyd2lzZSBvdmVybGFwIGluZm9ybWF0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdmVybGFwLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIC8vIGdldCBhcHByb3ByaWF0ZSBkaXN0YW5jZSBmcm9tIG1vc3Qgb3ZlcmxhcHBlZCBhbHJlYWR5IGFkZGVkIHNldFxuICAgICAgICB2YXIgcDEgPSBjaXJjbGVzW292ZXJsYXBbal0uc2V0XSxcbiAgICAgICAgICAgIGQxID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0QXJlYShzZXQucmFkaXVzLCBwMS5yYWRpdXMsIG92ZXJsYXBbal0uc2l6ZSk7IC8vIHNhbXBsZSBwb3NpdGlvbnMgYXQgOTAgZGVncmVlcyBmb3IgbWF4aW11bSBhZXN0aGV0aWNzXG5cbiAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgIHg6IHAxLnggKyBkMSxcbiAgICAgICAgICB5OiBwMS55XG4gICAgICAgIH0pO1xuICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcDEueCAtIGQxLFxuICAgICAgICAgIHk6IHAxLnlcbiAgICAgICAgfSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICB5OiBwMS55ICsgZDEsXG4gICAgICAgICAgeDogcDEueFxuICAgICAgICB9KTtcbiAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgIHk6IHAxLnkgLSBkMSxcbiAgICAgICAgICB4OiBwMS54XG4gICAgICAgIH0pOyAvLyBpZiB3ZSBoYXZlIGF0IGxlYXN0IDIgb3ZlcmxhcHMsIHRoZW4gZmlndXJlIG91dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gc2V0IHNob3VsZCBiZSBwb3NpdGlvbmVkIGFuYWx5dGljYWxseSBhbmQgdHJ5IHRob3NlIHRvb1xuXG4gICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG92ZXJsYXAubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICB2YXIgcDIgPSBjaXJjbGVzW292ZXJsYXBba10uc2V0XSxcbiAgICAgICAgICAgICAgZDIgPSBkaXN0YW5jZUZyb21JbnRlcnNlY3RBcmVhKHNldC5yYWRpdXMsIHAyLnJhZGl1cywgb3ZlcmxhcFtrXS5zaXplKTtcbiAgICAgICAgICB2YXIgZXh0cmFQb2ludHMgPSBjaXJjbGVDaXJjbGVJbnRlcnNlY3Rpb24oe1xuICAgICAgICAgICAgeDogcDEueCxcbiAgICAgICAgICAgIHk6IHAxLnksXG4gICAgICAgICAgICByYWRpdXM6IGQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcDIueCxcbiAgICAgICAgICAgIHk6IHAyLnksXG4gICAgICAgICAgICByYWRpdXM6IGQyXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGV4dHJhUG9pbnRzLmxlbmd0aDsgKytsKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChleHRyYVBvaW50c1tsXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHdlIGhhdmUgc29tZSBjYW5kaWRhdGUgcG9zaXRpb25zIGZvciB0aGUgc2V0LCBleGFtaW5lIGxvc3NcbiAgICAgIC8vIGF0IGVhY2ggcG9zaXRpb24gdG8gZmlndXJlIG91dCB3aGVyZSB0byBwdXQgaXQgYXRcblxuXG4gICAgICB2YXIgYmVzdExvc3MgPSAxZTUwLFxuICAgICAgICAgIGJlc3RQb2ludCA9IHBvaW50c1swXTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7ICsraikge1xuICAgICAgICBjaXJjbGVzW3NldEluZGV4XS54ID0gcG9pbnRzW2pdLng7XG4gICAgICAgIGNpcmNsZXNbc2V0SW5kZXhdLnkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgdmFyIGxvY2FsTG9zcyA9IGxvc3MoY2lyY2xlcywgYXJlYXMpO1xuXG4gICAgICAgIGlmIChsb2NhbExvc3MgPCBiZXN0TG9zcykge1xuICAgICAgICAgIGJlc3RMb3NzID0gbG9jYWxMb3NzO1xuICAgICAgICAgIGJlc3RQb2ludCA9IHBvaW50c1tqXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3NpdGlvblNldChiZXN0UG9pbnQsIHNldEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlcztcbiAgfVxuICAvKiogR2l2ZW4gYSBidW5jaCBvZiBzZXRzLCBhbmQgdGhlIGRlc2lyZWQgb3ZlcmxhcHMgYmV0d2VlbiB0aGVzZSBzZXRzIC0gY29tcHV0ZXNcbiAgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGFjdHVhbCBvdmVybGFwcyB0byB0aGUgZGVzaXJlZCBvdmVybGFwcy4gTm90ZSB0aGF0XG4gIHRoaXMgbWV0aG9kIGlnbm9yZXMgb3ZlcmxhcHMgb2YgbW9yZSB0aGFuIDIgY2lyY2xlcyAqL1xuXG5cbiAgZnVuY3Rpb24gbG9zc0Z1bmN0aW9uKHNldHMsIG92ZXJsYXBzKSB7XG4gICAgdmFyIG91dHB1dCA9IDA7XG5cbiAgICBmdW5jdGlvbiBnZXRDaXJjbGVzKGluZGljZXMpIHtcbiAgICAgIHJldHVybiBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gc2V0c1tpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmVhID0gb3ZlcmxhcHNbaV0sXG4gICAgICAgICAgb3ZlcmxhcDtcblxuICAgICAgaWYgKGFyZWEuc2V0cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoYXJlYS5zZXRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gc2V0c1thcmVhLnNldHNbMF1dLFxuICAgICAgICAgICAgcmlnaHQgPSBzZXRzW2FyZWEuc2V0c1sxXV07XG4gICAgICAgIG92ZXJsYXAgPSBjaXJjbGVPdmVybGFwKGxlZnQucmFkaXVzLCByaWdodC5yYWRpdXMsIGRpc3RhbmNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShnZXRDaXJjbGVzKGFyZWEuc2V0cykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2VpZ2h0ID0gYXJlYS5oYXNPd25Qcm9wZXJ0eSgnd2VpZ2h0JykgPyBhcmVhLndlaWdodCA6IDEuMDtcbiAgICAgIG91dHB1dCArPSB3ZWlnaHQgKiAob3ZlcmxhcCAtIGFyZWEuc2l6ZSkgKiAob3ZlcmxhcCAtIGFyZWEuc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSAvLyBvcmllbnRhdGVzIGEgYnVuY2ggb2YgY2lyY2xlcyB0byBwb2ludCBpbiBvcmllbnRhdGlvblxuXG5cbiAgZnVuY3Rpb24gb3JpZW50YXRlQ2lyY2xlcyhjaXJjbGVzLCBvcmllbnRhdGlvbiwgb3JpZW50YXRpb25PcmRlcikge1xuICAgIGlmIChvcmllbnRhdGlvbk9yZGVyID09PSBudWxsKSB7XG4gICAgICBjaXJjbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmFkaXVzIC0gYS5yYWRpdXM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2lyY2xlcy5zb3J0KG9yaWVudGF0aW9uT3JkZXIpO1xuICAgIH1cblxuICAgIHZhciBpOyAvLyBzaGlmdCBjaXJjbGVzIHNvIGxhcmdlc3QgY2lyY2xlIGlzIGF0ICgwLCAwKVxuXG4gICAgaWYgKGNpcmNsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGxhcmdlc3RYID0gY2lyY2xlc1swXS54LFxuICAgICAgICAgIGxhcmdlc3RZID0gY2lyY2xlc1swXS55O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2lyY2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjaXJjbGVzW2ldLnggLT0gbGFyZ2VzdFg7XG4gICAgICAgIGNpcmNsZXNbaV0ueSAtPSBsYXJnZXN0WTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY2xlcy5sZW5ndGggPT0gMikge1xuICAgICAgLy8gaWYgdGhlIHNlY29uZCBjaXJjbGUgaXMgYSBzdWJzZXQgb2YgdGhlIGZpcnN0LCBhcnJhbmdlIHNvIHRoYXRcbiAgICAgIC8vIGl0IGlzIG9mZiB0byBvbmUgc2lkZS4gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2JlbmZyZWQvdmVubi5qcy9pc3N1ZXMvMTIwXG4gICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGNpcmNsZXNbMF0sIGNpcmNsZXNbMV0pO1xuXG4gICAgICBpZiAoZGlzdCA8IE1hdGguYWJzKGNpcmNsZXNbMV0ucmFkaXVzIC0gY2lyY2xlc1swXS5yYWRpdXMpKSB7XG4gICAgICAgIGNpcmNsZXNbMV0ueCA9IGNpcmNsZXNbMF0ueCArIGNpcmNsZXNbMF0ucmFkaXVzIC0gY2lyY2xlc1sxXS5yYWRpdXMgLSAxZS0xMDtcbiAgICAgICAgY2lyY2xlc1sxXS55ID0gY2lyY2xlc1swXS55O1xuICAgICAgfVxuICAgIH0gLy8gcm90YXRlIGNpcmNsZXMgc28gdGhhdCBzZWNvbmQgbGFyZ2VzdCBpcyBhdCBhbiBhbmdsZSBvZiAnb3JpZW50YXRpb24nXG4gICAgLy8gZnJvbSBsYXJnZXN0XG5cblxuICAgIGlmIChjaXJjbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIoY2lyY2xlc1sxXS54LCBjaXJjbGVzWzFdLnkpIC0gb3JpZW50YXRpb24sXG4gICAgICAgICAgYyA9IE1hdGguY29zKHJvdGF0aW9uKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4ocm90YXRpb24pLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeCA9IGNpcmNsZXNbaV0ueDtcbiAgICAgICAgeSA9IGNpcmNsZXNbaV0ueTtcbiAgICAgICAgY2lyY2xlc1tpXS54ID0gYyAqIHggLSBzICogeTtcbiAgICAgICAgY2lyY2xlc1tpXS55ID0gcyAqIHggKyBjICogeTtcbiAgICAgIH1cbiAgICB9IC8vIG1pcnJvciBzb2x1dGlvbiBpZiB0aGlyZCBzb2x1dGlvbiBpcyBhYm92ZSBwbGFuZSBzcGVjaWZpZWQgYnlcbiAgICAvLyBmaXJzdCB0d28gY2lyY2xlc1xuXG5cbiAgICBpZiAoY2lyY2xlcy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGNpcmNsZXNbMl0ueCwgY2lyY2xlc1syXS55KSAtIG9yaWVudGF0aW9uO1xuXG4gICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoYW5nbGUgPiAyICogTWF0aC5QSSkge1xuICAgICAgICBhbmdsZSAtPSAyICogTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSkge1xuICAgICAgICB2YXIgc2xvcGUgPSBjaXJjbGVzWzFdLnkgLyAoMWUtMTAgKyBjaXJjbGVzWzFdLngpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaXJjbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIGQgPSAoY2lyY2xlc1tpXS54ICsgc2xvcGUgKiBjaXJjbGVzW2ldLnkpIC8gKDEgKyBzbG9wZSAqIHNsb3BlKTtcbiAgICAgICAgICBjaXJjbGVzW2ldLnggPSAyICogZCAtIGNpcmNsZXNbaV0ueDtcbiAgICAgICAgICBjaXJjbGVzW2ldLnkgPSAyICogZCAqIHNsb3BlIC0gY2lyY2xlc1tpXS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzam9pbnRDbHVzdGVyKGNpcmNsZXMpIHtcbiAgICAvLyB1bmlvbi1maW5kIGNsdXN0ZXJpbmcgdG8gZ2V0IGRpc2pvaW50IHNldHNcbiAgICBjaXJjbGVzLm1hcChmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICBjaXJjbGUucGFyZW50ID0gY2lyY2xlO1xuICAgIH0pOyAvLyBwYXRoIGNvbXByZXNzaW9uIHN0ZXAgaW4gdW5pb24gZmluZFxuXG4gICAgZnVuY3Rpb24gZmluZChjaXJjbGUpIHtcbiAgICAgIGlmIChjaXJjbGUucGFyZW50ICE9PSBjaXJjbGUpIHtcbiAgICAgICAgY2lyY2xlLnBhcmVudCA9IGZpbmQoY2lyY2xlLnBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaXJjbGUucGFyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaW9uKHgsIHkpIHtcbiAgICAgIHZhciB4Um9vdCA9IGZpbmQoeCksXG4gICAgICAgICAgeVJvb3QgPSBmaW5kKHkpO1xuICAgICAgeFJvb3QucGFyZW50ID0geVJvb3Q7XG4gICAgfSAvLyBnZXQgdGhlIHVuaW9uIG9mIGFsbCBvdmVybGFwcGluZyBzZXRzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lyY2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgY2lyY2xlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBjaXJjbGVzW2ldLnJhZGl1cyArIGNpcmNsZXNbal0ucmFkaXVzO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZShjaXJjbGVzW2ldLCBjaXJjbGVzW2pdKSArIDFlLTEwIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICB1bmlvbihjaXJjbGVzW2pdLCBjaXJjbGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZmluZCBhbGwgdGhlIGRpc2pvaW50IGNsdXN0ZXJzIGFuZCBncm91cCB0aGVtIHRvZ2V0aGVyXG5cblxuICAgIHZhciBkaXNqb2ludENsdXN0ZXJzID0ge30sXG4gICAgICAgIHNldGlkO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNpcmNsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNldGlkID0gZmluZChjaXJjbGVzW2ldKS5wYXJlbnQuc2V0aWQ7XG5cbiAgICAgIGlmICghKHNldGlkIGluIGRpc2pvaW50Q2x1c3RlcnMpKSB7XG4gICAgICAgIGRpc2pvaW50Q2x1c3RlcnNbc2V0aWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGRpc2pvaW50Q2x1c3RlcnNbc2V0aWRdLnB1c2goY2lyY2xlc1tpXSk7XG4gICAgfSAvLyBjbGVhbnVwIGJvb2trZWVwaW5nXG5cblxuICAgIGNpcmNsZXMubWFwKGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgIGRlbGV0ZSBjaXJjbGUucGFyZW50O1xuICAgIH0pOyAvLyByZXR1cm4gaW4gbW9yZSB1c2FibGUgZm9ybVxuXG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yIChzZXRpZCBpbiBkaXNqb2ludENsdXN0ZXJzKSB7XG4gICAgICBpZiAoZGlzam9pbnRDbHVzdGVycy5oYXNPd25Qcm9wZXJ0eShzZXRpZCkpIHtcbiAgICAgICAgcmV0LnB1c2goZGlzam9pbnRDbHVzdGVyc1tzZXRpZF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChjaXJjbGVzKSB7XG4gICAgdmFyIG1pbk1heCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgaGkgPSBNYXRoLm1heC5hcHBseShudWxsLCBjaXJjbGVzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gY1tkXSArIGMucmFkaXVzO1xuICAgICAgfSkpLFxuICAgICAgICAgIGxvID0gTWF0aC5taW4uYXBwbHkobnVsbCwgY2lyY2xlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGNbZF0gLSBjLnJhZGl1cztcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heDogaGksXG4gICAgICAgIG1pbjogbG9cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB4UmFuZ2U6IG1pbk1heCgneCcpLFxuICAgICAgeVJhbmdlOiBtaW5NYXgoJ3knKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVTb2x1dGlvbihzb2x1dGlvbiwgb3JpZW50YXRpb24sIG9yaWVudGF0aW9uT3JkZXIpIHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IG51bGwpIHtcbiAgICAgIG9yaWVudGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgfSAvLyB3b3JrIHdpdGggYSBsaXN0IGluc3RlYWQgb2YgYSBkaWN0aW9uYXJ5LCBhbmQgdGFrZSBhIGNvcHkgc28gd2VcbiAgICAvLyBkb24ndCBtdXRhdGUgaW5wdXRcblxuXG4gICAgdmFyIGNpcmNsZXMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgc2V0aWQ7XG5cbiAgICBmb3IgKHNldGlkIGluIHNvbHV0aW9uKSB7XG4gICAgICBpZiAoc29sdXRpb24uaGFzT3duUHJvcGVydHkoc2V0aWQpKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHNvbHV0aW9uW3NldGlkXTtcbiAgICAgICAgY2lyY2xlcy5wdXNoKHtcbiAgICAgICAgICB4OiBwcmV2aW91cy54LFxuICAgICAgICAgIHk6IHByZXZpb3VzLnksXG4gICAgICAgICAgcmFkaXVzOiBwcmV2aW91cy5yYWRpdXMsXG4gICAgICAgICAgc2V0aWQ6IHNldGlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gZ2V0IGFsbCB0aGUgZGlzam9pbnQgY2x1c3RlcnNcblxuXG4gICAgdmFyIGNsdXN0ZXJzID0gZGlzam9pbnRDbHVzdGVyKGNpcmNsZXMpOyAvLyBvcmllbnRhdGUgYWxsIGRpc2pvaW50IHNldHMsIGdldCBzaXplc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBvcmllbnRhdGVDaXJjbGVzKGNsdXN0ZXJzW2ldLCBvcmllbnRhdGlvbiwgb3JpZW50YXRpb25PcmRlcik7XG4gICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdCb3goY2x1c3RlcnNbaV0pO1xuICAgICAgY2x1c3RlcnNbaV0uc2l6ZSA9IChib3VuZHMueFJhbmdlLm1heCAtIGJvdW5kcy54UmFuZ2UubWluKSAqIChib3VuZHMueVJhbmdlLm1heCAtIGJvdW5kcy55UmFuZ2UubWluKTtcbiAgICAgIGNsdXN0ZXJzW2ldLmJvdW5kcyA9IGJvdW5kcztcbiAgICB9XG5cbiAgICBjbHVzdGVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5zaXplIC0gYS5zaXplO1xuICAgIH0pOyAvLyBvcmllbnRhdGUgdGhlIGxhcmdlc3QgYXQgMCwwLCBhbmQgZ2V0IHRoZSBib3VuZHNcblxuICAgIGNpcmNsZXMgPSBjbHVzdGVyc1swXTtcbiAgICB2YXIgcmV0dXJuQm91bmRzID0gY2lyY2xlcy5ib3VuZHM7XG4gICAgdmFyIHNwYWNpbmcgPSAocmV0dXJuQm91bmRzLnhSYW5nZS5tYXggLSByZXR1cm5Cb3VuZHMueFJhbmdlLm1pbikgLyA1MDtcblxuICAgIGZ1bmN0aW9uIGFkZENsdXN0ZXIoY2x1c3RlciwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgaWYgKCFjbHVzdGVyKSByZXR1cm47XG4gICAgICB2YXIgYm91bmRzID0gY2x1c3Rlci5ib3VuZHMsXG4gICAgICAgICAgeE9mZnNldCxcbiAgICAgICAgICB5T2Zmc2V0LFxuICAgICAgICAgIGNlbnRyZWluZztcblxuICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIHhPZmZzZXQgPSByZXR1cm5Cb3VuZHMueFJhbmdlLm1heCAtIGJvdW5kcy54UmFuZ2UubWluICsgc3BhY2luZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhPZmZzZXQgPSByZXR1cm5Cb3VuZHMueFJhbmdlLm1heCAtIGJvdW5kcy54UmFuZ2UubWF4O1xuICAgICAgICBjZW50cmVpbmcgPSAoYm91bmRzLnhSYW5nZS5tYXggLSBib3VuZHMueFJhbmdlLm1pbikgLyAyIC0gKHJldHVybkJvdW5kcy54UmFuZ2UubWF4IC0gcmV0dXJuQm91bmRzLnhSYW5nZS5taW4pIC8gMjtcbiAgICAgICAgaWYgKGNlbnRyZWluZyA8IDApIHhPZmZzZXQgKz0gY2VudHJlaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm90dG9tKSB7XG4gICAgICAgIHlPZmZzZXQgPSByZXR1cm5Cb3VuZHMueVJhbmdlLm1heCAtIGJvdW5kcy55UmFuZ2UubWluICsgc3BhY2luZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlPZmZzZXQgPSByZXR1cm5Cb3VuZHMueVJhbmdlLm1heCAtIGJvdW5kcy55UmFuZ2UubWF4O1xuICAgICAgICBjZW50cmVpbmcgPSAoYm91bmRzLnlSYW5nZS5tYXggLSBib3VuZHMueVJhbmdlLm1pbikgLyAyIC0gKHJldHVybkJvdW5kcy55UmFuZ2UubWF4IC0gcmV0dXJuQm91bmRzLnlSYW5nZS5taW4pIC8gMjtcbiAgICAgICAgaWYgKGNlbnRyZWluZyA8IDApIHlPZmZzZXQgKz0gY2VudHJlaW5nO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2x1c3RlcltqXS54ICs9IHhPZmZzZXQ7XG4gICAgICAgIGNsdXN0ZXJbal0ueSArPSB5T2Zmc2V0O1xuICAgICAgICBjaXJjbGVzLnB1c2goY2x1c3RlcltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gMTtcblxuICAgIHdoaWxlIChpbmRleCA8IGNsdXN0ZXJzLmxlbmd0aCkge1xuICAgICAgYWRkQ2x1c3RlcihjbHVzdGVyc1tpbmRleF0sIHRydWUsIGZhbHNlKTtcbiAgICAgIGFkZENsdXN0ZXIoY2x1c3RlcnNbaW5kZXggKyAxXSwgZmFsc2UsIHRydWUpO1xuICAgICAgYWRkQ2x1c3RlcihjbHVzdGVyc1tpbmRleCArIDJdLCB0cnVlLCB0cnVlKTtcbiAgICAgIGluZGV4ICs9IDM7IC8vIGhhdmUgb25lIGNsdXN0ZXIgKGluIHRvcCBsZWZ0KS4gbGF5IG91dCBuZXh0IHRocmVlIHJlbGF0aXZlXG4gICAgICAvLyB0byBpdCBpbiBhIGdyaWRcblxuICAgICAgcmV0dXJuQm91bmRzID0gZ2V0Qm91bmRpbmdCb3goY2lyY2xlcyk7XG4gICAgfSAvLyBjb252ZXJ0IGJhY2sgdG8gc29sdXRpb24gZm9ybVxuXG5cbiAgICB2YXIgcmV0ID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2lyY2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmV0W2NpcmNsZXNbaV0uc2V0aWRdID0gY2lyY2xlc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKiBTY2FsZXMgYSBzb2x1dGlvbiBmcm9tIHZlbm4udmVubiBvciB2ZW5uLmdyZWVkeUxheW91dCBzdWNoIHRoYXQgaXQgZml0cyBpblxuICBhIHJlY3RhbmdsZSBvZiB3aWR0aC9oZWlnaHQgLSB3aXRoIHBhZGRpbmcgYXJvdW5kIHRoZSBib3JkZXJzLiBhbHNvXG4gIGNlbnRlcnMgdGhlIGRpYWdyYW0gaW4gdGhlIGF2YWlsYWJsZSBzcGFjZSBhdCB0aGUgc2FtZSB0aW1lICovXG5cblxuICBmdW5jdGlvbiBzY2FsZVNvbHV0aW9uKHNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgdmFyIGNpcmNsZXMgPSBbXSxcbiAgICAgICAgc2V0aWRzID0gW107XG5cbiAgICBmb3IgKHZhciBzZXRpZCBpbiBzb2x1dGlvbikge1xuICAgICAgaWYgKHNvbHV0aW9uLmhhc093blByb3BlcnR5KHNldGlkKSkge1xuICAgICAgICBzZXRpZHMucHVzaChzZXRpZCk7XG4gICAgICAgIGNpcmNsZXMucHVzaChzb2x1dGlvbltzZXRpZF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdpZHRoIC09IDIgKiBwYWRkaW5nO1xuICAgIGhlaWdodCAtPSAyICogcGFkZGluZztcbiAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdCb3goY2lyY2xlcyksXG4gICAgICAgIHhSYW5nZSA9IGJvdW5kcy54UmFuZ2UsXG4gICAgICAgIHlSYW5nZSA9IGJvdW5kcy55UmFuZ2U7XG5cbiAgICBpZiAoeFJhbmdlLm1heCA9PSB4UmFuZ2UubWluIHx8IHlSYW5nZS5tYXggPT0geVJhbmdlLm1pbikge1xuICAgICAgY29uc29sZS5sb2coXCJub3Qgc2NhbGluZyBzb2x1dGlvbjogemVybyBzaXplIGRldGVjdGVkXCIpO1xuICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgIH1cblxuICAgIHZhciB4U2NhbGluZyA9IHdpZHRoIC8gKHhSYW5nZS5tYXggLSB4UmFuZ2UubWluKSxcbiAgICAgICAgeVNjYWxpbmcgPSBoZWlnaHQgLyAoeVJhbmdlLm1heCAtIHlSYW5nZS5taW4pLFxuICAgICAgICBzY2FsaW5nID0gTWF0aC5taW4oeVNjYWxpbmcsIHhTY2FsaW5nKSxcbiAgICAgICAgLy8gd2hpbGUgd2UncmUgYXQgaXQsIGNlbnRlciB0aGUgZGlhZ3JhbSB0b29cbiAgICB4T2Zmc2V0ID0gKHdpZHRoIC0gKHhSYW5nZS5tYXggLSB4UmFuZ2UubWluKSAqIHNjYWxpbmcpIC8gMixcbiAgICAgICAgeU9mZnNldCA9IChoZWlnaHQgLSAoeVJhbmdlLm1heCAtIHlSYW5nZS5taW4pICogc2NhbGluZykgLyAyO1xuICAgIHZhciBzY2FsZWQgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lyY2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNpcmNsZSA9IGNpcmNsZXNbaV07XG4gICAgICBzY2FsZWRbc2V0aWRzW2ldXSA9IHtcbiAgICAgICAgcmFkaXVzOiBzY2FsaW5nICogY2lyY2xlLnJhZGl1cyxcbiAgICAgICAgeDogcGFkZGluZyArIHhPZmZzZXQgKyAoY2lyY2xlLnggLSB4UmFuZ2UubWluKSAqIHNjYWxpbmcsXG4gICAgICAgIHk6IHBhZGRpbmcgKyB5T2Zmc2V0ICsgKGNpcmNsZS55IC0geVJhbmdlLm1pbikgKiBzY2FsaW5nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZWQ7XG4gIH1cbiAgLypnbG9iYWwgY29uc29sZTp0cnVlKi9cblxuXG4gIGZ1bmN0aW9uIFZlbm5EaWFncmFtKCkge1xuICAgIHZhciB3aWR0aCA9IDYwMCxcbiAgICAgICAgaGVpZ2h0ID0gMzUwLFxuICAgICAgICBwYWRkaW5nID0gMTUsXG4gICAgICAgIGR1cmF0aW9uID0gMTAwMCxcbiAgICAgICAgb3JpZW50YXRpb24gPSBNYXRoLlBJIC8gMixcbiAgICAgICAgbm9ybWFsaXplID0gdHJ1ZSxcbiAgICAgICAgd3JhcCA9IHRydWUsXG4gICAgICAgIHN0eWxlZCA9IHRydWUsXG4gICAgICAgIGZvbnRTaXplID0gbnVsbCxcbiAgICAgICAgb3JpZW50YXRpb25PcmRlciA9IG51bGwsXG4gICAgICAgIC8vIG1pbWljIHRoZSBiZWhhdmlvdXIgb2YgZDMuc2NhbGUuY2F0ZWdvcnkxMCBmcm9tIHRoZSBwcmV2aW91c1xuICAgIC8vIHZlcnNpb24gb2YgZDNcbiAgICBjb2xvdXJNYXAgPSB7fSxcbiAgICAgICAgLy8gc28gdGhpcyBpcyB0aGUgc2FtZSBhcyBkMy5zY2hlbWVDYXRlZ29yeTEwLCB3aGljaCBpcyBvbmx5IGRlZmluZWQgaW4gZDMgNC4wXG4gICAgLy8gc2luY2Ugd2UgY2FuIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgb2YgZDMgYXMgbG9uZyBhcyB3ZSBkb24ndCBmb3JjZSB0aGlzLFxuICAgIC8vIEknbSBoYWNraWx5IHJlZGVmaW5pbmcgYmVsb3cuIFRPRE86IHJlbW92ZSB0aGlzIGFuZCBjaGFuZ2UgdG8gZDMuc2NoZW1lQ2F0ZWdvcnkxMFxuICAgIGNvbG91clNjaGVtZSA9IFtcIiMxZjc3YjRcIiwgXCIjZmY3ZjBlXCIsIFwiIzJjYTAyY1wiLCBcIiNkNjI3MjhcIiwgXCIjOTQ2N2JkXCIsIFwiIzhjNTY0YlwiLCBcIiNlMzc3YzJcIiwgXCIjN2Y3ZjdmXCIsIFwiI2JjYmQyMlwiLCBcIiMxN2JlY2ZcIl0sXG4gICAgICAgIGNvbG91ckluZGV4ID0gMCxcbiAgICAgICAgY29sb3VycyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gY29sb3VyTWFwKSB7XG4gICAgICAgIHJldHVybiBjb2xvdXJNYXBba2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IGNvbG91ck1hcFtrZXldID0gY29sb3VyU2NoZW1lW2NvbG91ckluZGV4XTtcbiAgICAgIGNvbG91ckluZGV4ICs9IDE7XG5cbiAgICAgIGlmIChjb2xvdXJJbmRleCA+PSBjb2xvdXJTY2hlbWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbG91ckluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgICAgICBsYXlvdXRGdW5jdGlvbiA9IHZlbm4sXG4gICAgICAgIGxvc3MgPSBsb3NzRnVuY3Rpb247XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgIHZhciBkYXRhID0gc2VsZWN0aW9uLmRhdHVtKCk7IC8vIGhhbmRsZSAwLXNpemVkIHNldHMgYnkgcmVtb3ZpbmcgZnJvbSBpbnB1dFxuXG4gICAgICB2YXIgdG9yZW1vdmUgPSB7fTtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgICAgaWYgKGRhdHVtLnNpemUgPT0gMCAmJiBkYXR1bS5zZXRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgdG9yZW1vdmVbZGF0dW0uc2V0c1swXV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgICAgcmV0dXJuICFkYXR1bS5zZXRzLnNvbWUoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXQgaW4gdG9yZW1vdmU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2lyY2xlcyA9IHt9O1xuICAgICAgdmFyIHRleHRDZW50cmVzID0ge307XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNvbHV0aW9uID0gbGF5b3V0RnVuY3Rpb24oZGF0YSwge1xuICAgICAgICAgIGxvc3NGdW5jdGlvbjogbG9zc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgICAgc29sdXRpb24gPSBub3JtYWxpemVTb2x1dGlvbihzb2x1dGlvbiwgb3JpZW50YXRpb24sIG9yaWVudGF0aW9uT3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2lyY2xlcyA9IHNjYWxlU29sdXRpb24oc29sdXRpb24sIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgICAgICB0ZXh0Q2VudHJlcyA9IGNvbXB1dGVUZXh0Q2VudHJlcyhjaXJjbGVzLCBkYXRhKTtcbiAgICAgIH0gLy8gRmlndXJlIG91dCB0aGUgY3VycmVudCBsYWJlbCBmb3IgZWFjaCBzZXQuIFRoZXNlIGNhbiBjaGFuZ2VcbiAgICAgIC8vIGFuZCBEMyB3b24ndCBuZWNlc3NhcmlseSB1cGRhdGUgKGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5mcmVkL3Zlbm4uanMvaXNzdWVzLzEwMylcblxuXG4gICAgICB2YXIgbGFiZWxzID0ge307XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdHVtKSB7XG4gICAgICAgIGlmIChkYXR1bS5sYWJlbCkge1xuICAgICAgICAgIGxhYmVsc1tkYXR1bS5zZXRzXSA9IGRhdHVtLmxhYmVsO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gbGFiZWwoZCkge1xuICAgICAgICBpZiAoZC5zZXRzIGluIGxhYmVscykge1xuICAgICAgICAgIHJldHVybiBsYWJlbHNbZC5zZXRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkLnNldHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyBkLnNldHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY3JlYXRlIHN2ZyBpZiBub3QgYWxyZWFkeSBleGlzdGluZ1xuXG5cbiAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCJzdmdcIikuZGF0YShbY2lyY2xlc10pLmVudGVyKCkuYXBwZW5kKFwic3ZnXCIpO1xuICAgICAgdmFyIHN2ZyA9IHNlbGVjdGlvbi5zZWxlY3QoXCJzdmdcIikuYXR0cihcIndpZHRoXCIsIHdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7IC8vIHRvIHByb3Blcmx5IHRyYW5zaXRpb24gaW50ZXJzZWN0aW9uIGFyZWFzLCB3ZSBuZWVkIHRoZVxuICAgICAgLy8gcHJldmlvdXMgY2lyY2xlcyBsb2NhdGlvbnMuIGxvYWQgZnJvbSBlbGVtZW50c1xuXG4gICAgICB2YXIgcHJldmlvdXMgPSB7fSxcbiAgICAgICAgICBoYXNQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgc3ZnLnNlbGVjdEFsbChcIi52ZW5uLWFyZWEgcGF0aFwiKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBwYXRoID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLmF0dHIoXCJkXCIpO1xuXG4gICAgICAgIGlmIChkLnNldHMubGVuZ3RoID09IDEgJiYgcGF0aCkge1xuICAgICAgICAgIGhhc1ByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2aW91c1tkLnNldHNbMF1dID0gY2lyY2xlRnJvbVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBpbnRlcnBvbGF0ZSBpbnRlcnNlY3Rpb24gYXJlYSBwYXRocyBiZXR3ZWVuIHByZXZpb3VzIGFuZFxuICAgICAgLy8gY3VycmVudCBwYXRoc1xuXG4gICAgICB2YXIgcGF0aFR3ZWVuID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGMgPSBkLnNldHMubWFwKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHByZXZpb3VzW3NldF0sXG4gICAgICAgICAgICAgICAgZW5kID0gY2lyY2xlc1tzZXRdO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgIHJhZGl1czogMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgeDogd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiAxXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICd4Jzogc3RhcnQueCAqICgxIC0gdCkgKyBlbmQueCAqIHQsXG4gICAgICAgICAgICAgICd5Jzogc3RhcnQueSAqICgxIC0gdCkgKyBlbmQueSAqIHQsXG4gICAgICAgICAgICAgICdyYWRpdXMnOiBzdGFydC5yYWRpdXMgKiAoMSAtIHQpICsgZW5kLnJhZGl1cyAqIHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbkFyZWFQYXRoKGMpO1xuICAgICAgICB9O1xuICAgICAgfTsgLy8gdXBkYXRlIGRhdGEsIGpvaW5pbmcgb24gdGhlIHNldCBpZHNcblxuXG4gICAgICB2YXIgbm9kZXMgPSBzdmcuc2VsZWN0QWxsKFwiLnZlbm4tYXJlYVwiKS5kYXRhKGRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnNldHM7XG4gICAgICB9KTsgLy8gY3JlYXRlIG5ldyBub2Rlc1xuXG4gICAgICB2YXIgZW50ZXIgPSBub2Rlcy5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gXCJ2ZW5uLWFyZWEgdmVubi1cIiArIChkLnNldHMubGVuZ3RoID09IDEgPyBcImNpcmNsZVwiIDogXCJpbnRlcnNlY3Rpb25cIik7XG4gICAgICB9KS5hdHRyKFwiZGF0YS12ZW5uLXNldHNcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc2V0cy5qb2luKFwiX1wiKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGVudGVyUGF0aCA9IGVudGVyLmFwcGVuZChcInBhdGhcIiksXG4gICAgICAgICAgZW50ZXJUZXh0ID0gZW50ZXIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBsYWJlbChkKTtcbiAgICAgIH0pLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKS5hdHRyKFwieFwiLCB3aWR0aCAvIDIpLmF0dHIoXCJ5XCIsIGhlaWdodCAvIDIpOyAvLyBhcHBseSBtaW5pbWFsIHN0eWxlIGlmIHdhbnRlZFxuXG4gICAgICBpZiAoc3R5bGVkKSB7XG4gICAgICAgIGVudGVyUGF0aC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIikuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuc2V0cy5sZW5ndGggPT0gMTtcbiAgICAgICAgfSkuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG91cnMoZC5zZXRzKTtcbiAgICAgICAgfSkuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIuMjVcIik7XG4gICAgICAgIGVudGVyVGV4dC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5zZXRzLmxlbmd0aCA9PSAxID8gY29sb3VycyhkLnNldHMpIDogXCIjNDQ0XCI7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyB1cGRhdGUgZXhpc3RpbmcsIHVzaW5nIHBhdGhUd2VlbiBpZiBuZWNlc3NhcnlcblxuXG4gICAgICB2YXIgdXBkYXRlID0gc2VsZWN0aW9uO1xuXG4gICAgICBpZiAoaGFzUHJldmlvdXMpIHtcbiAgICAgICAgdXBkYXRlID0gc2VsZWN0aW9uLnRyYW5zaXRpb24oXCJ2ZW5uXCIpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgdXBkYXRlLnNlbGVjdEFsbChcInBhdGhcIikuYXR0clR3ZWVuKFwiZFwiLCBwYXRoVHdlZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlLnNlbGVjdEFsbChcInBhdGhcIikuYXR0cihcImRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uQXJlYVBhdGgoZC5zZXRzLm1hcChmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2lyY2xlc1tzZXRdO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVUZXh0ID0gdXBkYXRlLnNlbGVjdEFsbChcInRleHRcIikuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnNldHMgaW4gdGV4dENlbnRyZXM7XG4gICAgICB9KS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBsYWJlbChkKTtcbiAgICAgIH0pLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRleHRDZW50cmVzW2Quc2V0c10ueCk7XG4gICAgICB9KS5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0ZXh0Q2VudHJlc1tkLnNldHNdLnkpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgIGlmIChoYXNQcmV2aW91cykge1xuICAgICAgICAgIC8vIGQzIDQuMCB1c2VzICdvbicgZm9yIGV2ZW50cyBvbiB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAvLyBidXQgZDMgMy4wIHVzZWQgJ2VhY2gnIGluc3RlYWQuIHN3aXRjaCBhcHByb3BpYXRlbHlcbiAgICAgICAgICBpZiAoJ29uJyBpbiB1cGRhdGVUZXh0KSB7XG4gICAgICAgICAgICB1cGRhdGVUZXh0Lm9uKFwiZW5kXCIsIHdyYXBUZXh0KGNpcmNsZXMsIGxhYmVsKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVRleHQuZWFjaChcImVuZFwiLCB3cmFwVGV4dChjaXJjbGVzLCBsYWJlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVUZXh0LmVhY2god3JhcFRleHQoY2lyY2xlcywgbGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZW1vdmUgb2xkXG5cblxuICAgICAgdmFyIGV4aXQgPSBub2Rlcy5leGl0KCkudHJhbnNpdGlvbigndmVubicpLmR1cmF0aW9uKGR1cmF0aW9uKS5yZW1vdmUoKTtcbiAgICAgIGV4aXQuc2VsZWN0QWxsKFwicGF0aFwiKS5hdHRyVHdlZW4oXCJkXCIsIHBhdGhUd2Vlbik7XG4gICAgICB2YXIgZXhpdFRleHQgPSBleGl0LnNlbGVjdEFsbChcInRleHRcIikuYXR0cihcInhcIiwgd2lkdGggLyAyKS5hdHRyKFwieVwiLCBoZWlnaHQgLyAyKTsgLy8gaWYgd2UndmUgYmVlbiBwYXNzZWQgYSBmb250U2l6ZSBleHBsaWNpdGx5LCB1c2UgaXQgdG9cbiAgICAgIC8vIHRyYW5zaXRpb25cblxuICAgICAgaWYgKGZvbnRTaXplICE9PSBudWxsKSB7XG4gICAgICAgIGVudGVyVGV4dC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjBweFwiKTtcbiAgICAgICAgdXBkYXRlVGV4dC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSk7XG4gICAgICAgIGV4aXRUZXh0LnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMHB4XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnY2lyY2xlcyc6IGNpcmNsZXMsXG4gICAgICAgICd0ZXh0Q2VudHJlcyc6IHRleHRDZW50cmVzLFxuICAgICAgICAnbm9kZXMnOiBub2RlcyxcbiAgICAgICAgJ2VudGVyJzogZW50ZXIsXG4gICAgICAgICd1cGRhdGUnOiB1cGRhdGUsXG4gICAgICAgICdleGl0JzogZXhpdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjaGFydC53cmFwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdyYXA7XG4gICAgICB3cmFwID0gXztcbiAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQud2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgICB3aWR0aCA9IF87XG4gICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0LmhlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgICBoZWlnaHQgPSBfO1xuICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5wYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0gXztcbiAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuY29sb3VycyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2xvdXJzO1xuICAgICAgY29sb3VycyA9IF87XG4gICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0LmZvbnRTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZvbnRTaXplO1xuICAgICAgZm9udFNpemUgPSBfO1xuICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5kdXJhdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQubGF5b3V0RnVuY3Rpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGF5b3V0RnVuY3Rpb247XG4gICAgICBsYXlvdXRGdW5jdGlvbiA9IF87XG4gICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub3JtYWxpemU7XG4gICAgICBub3JtYWxpemUgPSBfO1xuICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5zdHlsZWQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3R5bGVkO1xuICAgICAgc3R5bGVkID0gXztcbiAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQub3JpZW50YXRpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50YXRpb247XG4gICAgICBvcmllbnRhdGlvbiA9IF87XG4gICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIGNoYXJ0Lm9yaWVudGF0aW9uT3JkZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50YXRpb25PcmRlcjtcbiAgICAgIG9yaWVudGF0aW9uT3JkZXIgPSBfO1xuICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5sb3NzRnVuY3Rpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG9zcztcbiAgICAgIGxvc3MgPSBfO1xuICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICByZXR1cm4gY2hhcnQ7XG4gIH0gLy8gc29tZXRpbWVzIHRleHQgZG9lc24ndCBmaXQgaW5zaWRlIHRoZSBjaXJjbGUsIGlmIHRoYXRzIHRoZSBjYXNlIGxldHMgd3JhcFxuICAvLyB0aGUgdGV4dCBoZXJlIHN1Y2ggdGhhdCBpdCBmaXRzXG4gIC8vIHRvZG86IGxvb2tzIGxpa2UgdGhpcyBtaWdodCBiZSBtZXJnZWQgaW50byBkMyAoXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy9pc3N1ZXMvMTY0MiksXG4gIC8vIGFsc28gd29ydGggY2hlY2tpbmcgb3V0IGlzXG4gIC8vIGh0dHA6Ly9lbmdpbmVlcmluZy5maW5kdGhlYmVzdC5jb20vd3JhcHBpbmctYXhpcy1sYWJlbHMtaW4tZDMtanMvXG4gIC8vIHRoaXMgc2VlbXMgdG8gYmUgb25lIG9mIHRob3NlIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBlYXN5IGJ1dCBpc24ndFxuXG5cbiAgZnVuY3Rpb24gd3JhcFRleHQoY2lyY2xlcywgbGFiZWxsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRleHQgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcyksXG4gICAgICAgICAgZGF0YSA9IHRleHQuZGF0dW0oKSxcbiAgICAgICAgICB3aWR0aCA9IGNpcmNsZXNbZGF0YS5zZXRzWzBdXS5yYWRpdXMgfHwgNTAsXG4gICAgICAgICAgbGFiZWwgPSBsYWJlbGxlcihkYXRhKSB8fCAnJztcbiAgICAgIHZhciB3b3JkcyA9IGxhYmVsLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLFxuICAgICAgICAgIG1heExpbmVzID0gMyxcbiAgICAgICAgICBtaW5DaGFycyA9IChsYWJlbC5sZW5ndGggKyB3b3Jkcy5sZW5ndGgpIC8gbWF4TGluZXMsXG4gICAgICAgICAgd29yZCA9IHdvcmRzLnBvcCgpLFxuICAgICAgICAgIGxpbmUgPSBbd29yZF0sXG4gICAgICAgICAgam9pbmVkLFxuICAgICAgICAgIGxpbmVOdW1iZXIgPSAwLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSAxLjEsXG4gICAgICAgICAgLy8gZW1zXG4gICAgICB0c3BhbiA9IHRleHQudGV4dChudWxsKS5hcHBlbmQoXCJ0c3BhblwiKS50ZXh0KHdvcmQpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB3b3JkID0gd29yZHMucG9wKCk7XG4gICAgICAgIGlmICghd29yZCkgYnJlYWs7XG4gICAgICAgIGxpbmUucHVzaCh3b3JkKTtcbiAgICAgICAgam9pbmVkID0gbGluZS5qb2luKFwiIFwiKTtcbiAgICAgICAgdHNwYW4udGV4dChqb2luZWQpO1xuXG4gICAgICAgIGlmIChqb2luZWQubGVuZ3RoID4gbWluQ2hhcnMgJiYgdHNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgICAgICBsaW5lLnBvcCgpO1xuICAgICAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgbGluZSA9IFt3b3JkXTtcbiAgICAgICAgICB0c3BhbiA9IHRleHQuYXBwZW5kKFwidHNwYW5cIikudGV4dCh3b3JkKTtcbiAgICAgICAgICBsaW5lTnVtYmVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWwgPSAwLjM1IC0gbGluZU51bWJlciAqIGxpbmVIZWlnaHQgLyAyLFxuICAgICAgICAgIHggPSB0ZXh0LmF0dHIoXCJ4XCIpLFxuICAgICAgICAgIHkgPSB0ZXh0LmF0dHIoXCJ5XCIpO1xuICAgICAgdGV4dC5zZWxlY3RBbGwoXCJ0c3BhblwiKS5hdHRyKFwieFwiLCB4KS5hdHRyKFwieVwiLCB5KS5hdHRyKFwiZHlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWwgKyBpICogbGluZUhlaWdodCArIFwiZW1cIjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGVNYXJnaW4oY3VycmVudCwgaW50ZXJpb3IsIGV4dGVyaW9yKSB7XG4gICAgdmFyIG1hcmdpbiA9IGludGVyaW9yWzBdLnJhZGl1cyAtIGRpc3RhbmNlKGludGVyaW9yWzBdLCBjdXJyZW50KSxcbiAgICAgICAgaSxcbiAgICAgICAgbTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgbSA9IGludGVyaW9yW2ldLnJhZGl1cyAtIGRpc3RhbmNlKGludGVyaW9yW2ldLCBjdXJyZW50KTtcblxuICAgICAgaWYgKG0gPD0gbWFyZ2luKSB7XG4gICAgICAgIG1hcmdpbiA9IG07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4dGVyaW9yLmxlbmd0aDsgKytpKSB7XG4gICAgICBtID0gZGlzdGFuY2UoZXh0ZXJpb3JbaV0sIGN1cnJlbnQpIC0gZXh0ZXJpb3JbaV0ucmFkaXVzO1xuXG4gICAgICBpZiAobSA8PSBtYXJnaW4pIHtcbiAgICAgICAgbWFyZ2luID0gbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFyZ2luO1xuICB9IC8vIGNvbXB1dGUgdGhlIGNlbnRlciBvZiBzb21lIGNpcmNsZXMgYnkgbWF4aW1pemluZyB0aGUgbWFyZ2luIG9mXG4gIC8vIHRoZSBjZW50ZXIgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNpcmNsZXMgKGludGVyaW9yKSBhZnRlciBzdWJ0cmFjdGluZ1xuICAvLyBuZWFyYnkgY2lyY2xlcyAoZXh0ZXJpb3IpXG5cblxuICBmdW5jdGlvbiBjb21wdXRlVGV4dENlbnRyZShpbnRlcmlvciwgZXh0ZXJpb3IpIHtcbiAgICAvLyBnZXQgYW4gaW5pdGlhbCBlc3RpbWF0ZSBieSBzYW1wbGluZyBhcm91bmQgdGhlIGludGVyaW9yIGNpcmNsZXNcbiAgICAvLyBhbmQgdGFraW5nIHRoZSBwb2ludCB3aXRoIHRoZSBiaWdnZXN0IG1hcmdpblxuICAgIHZhciBwb2ludHMgPSBbXSxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGMgPSBpbnRlcmlvcltpXTtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogYy54LFxuICAgICAgICB5OiBjLnlcbiAgICAgIH0pO1xuICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICB4OiBjLnggKyBjLnJhZGl1cyAvIDIsXG4gICAgICAgIHk6IGMueVxuICAgICAgfSk7XG4gICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgIHg6IGMueCAtIGMucmFkaXVzIC8gMixcbiAgICAgICAgeTogYy55XG4gICAgICB9KTtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogYy54LFxuICAgICAgICB5OiBjLnkgKyBjLnJhZGl1cyAvIDJcbiAgICAgIH0pO1xuICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICB4OiBjLngsXG4gICAgICAgIHk6IGMueSAtIGMucmFkaXVzIC8gMlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWwgPSBwb2ludHNbMF0sXG4gICAgICAgIG1hcmdpbiA9IGNpcmNsZU1hcmdpbihwb2ludHNbMF0sIGludGVyaW9yLCBleHRlcmlvcik7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbSA9IGNpcmNsZU1hcmdpbihwb2ludHNbaV0sIGludGVyaW9yLCBleHRlcmlvcik7XG5cbiAgICAgIGlmIChtID49IG1hcmdpbikge1xuICAgICAgICBpbml0aWFsID0gcG9pbnRzW2ldO1xuICAgICAgICBtYXJnaW4gPSBtO1xuICAgICAgfVxuICAgIH0gLy8gbWF4aW1pemUgdGhlIG1hcmdpbiBudW1lcmljYWxseVxuXG5cbiAgICB2YXIgc29sdXRpb24gPSBuZWxkZXJNZWFkKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gLTEgKiBjaXJjbGVNYXJnaW4oe1xuICAgICAgICB4OiBwWzBdLFxuICAgICAgICB5OiBwWzFdXG4gICAgICB9LCBpbnRlcmlvciwgZXh0ZXJpb3IpO1xuICAgIH0sIFtpbml0aWFsLngsIGluaXRpYWwueV0sIHtcbiAgICAgIG1heEl0ZXJhdGlvbnM6IDUwMCxcbiAgICAgIG1pbkVycm9yRGVsdGE6IDFlLTEwXG4gICAgfSkueDtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgeDogc29sdXRpb25bMF0sXG4gICAgICB5OiBzb2x1dGlvblsxXVxuICAgIH07IC8vIGNoZWNrIHNvbHV0aW9uLCBmYWxsYmFjayBhcyBuZWVkZWQgKGhhcHBlbnMgaWYgZnVsbHkgb3ZlcmxhcHBlZFxuICAgIC8vIGV0YylcblxuICAgIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkaXN0YW5jZShyZXQsIGludGVyaW9yW2ldKSA+IGludGVyaW9yW2ldLnJhZGl1cykge1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZXh0ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkaXN0YW5jZShyZXQsIGV4dGVyaW9yW2ldKSA8IGV4dGVyaW9yW2ldLnJhZGl1cykge1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICBpZiAoaW50ZXJpb3IubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0ID0ge1xuICAgICAgICAgIHg6IGludGVyaW9yWzBdLngsXG4gICAgICAgICAgeTogaW50ZXJpb3JbMF0ueVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZWFTdGF0cyA9IHt9O1xuICAgICAgICBpbnRlcnNlY3Rpb25BcmVhKGludGVyaW9yLCBhcmVhU3RhdHMpO1xuXG4gICAgICAgIGlmIChhcmVhU3RhdHMuYXJjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAneCc6IDAsXG4gICAgICAgICAgICAneSc6IC0xMDAwLFxuICAgICAgICAgICAgZGlzam9pbnQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZWFTdGF0cy5hcmNzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcmV0ID0ge1xuICAgICAgICAgICAgJ3gnOiBhcmVhU3RhdHMuYXJjc1swXS5jaXJjbGUueCxcbiAgICAgICAgICAgICd5JzogYXJlYVN0YXRzLmFyY3NbMF0uY2lyY2xlLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGV4dGVyaW9yLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHRyeSBhZ2FpbiB3aXRob3V0IG90aGVyIGNpcmNsZXNcbiAgICAgICAgICByZXQgPSBjb21wdXRlVGV4dENlbnRyZShpbnRlcmlvciwgW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRha2UgYXZlcmFnZSBvZiBhbGwgdGhlIHBvaW50cyBpbiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgLy8gcG9seWdvbi4gdGhpcyBzaG91bGQgYmFzaWNhbGx5IG5ldmVyIGhhcHBlblxuICAgICAgICAgIC8vIGFuZCBoYXMgc29tZSBpc3N1ZXM6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmZyZWQvdmVubi5qcy9pc3N1ZXMvNDgjaXNzdWVjb21tZW50LTE0NjA2OTc3N1xuICAgICAgICAgIHJldCA9IGdldENlbnRlcihhcmVhU3RhdHMuYXJjcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnAxO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gZ2l2ZW4gYSBkaWN0aW9uYXJ5IG9mIHtzZXRpZCA6IGNpcmNsZX0sIHJldHVybnNcbiAgLy8gYSBkaWN0aW9uYXJ5IG9mIHNldGlkIHRvIGxpc3Qgb2YgY2lyY2xlcyB0aGF0IGNvbXBsZXRlbHkgb3ZlcmxhcCBpdFxuXG5cbiAgZnVuY3Rpb24gZ2V0T3ZlcmxhcHBpbmdDaXJjbGVzKGNpcmNsZXMpIHtcbiAgICB2YXIgcmV0ID0ge30sXG4gICAgICAgIGNpcmNsZWlkcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgY2lyY2xlaWQgaW4gY2lyY2xlcykge1xuICAgICAgY2lyY2xlaWRzLnB1c2goY2lyY2xlaWQpO1xuICAgICAgcmV0W2NpcmNsZWlkXSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lyY2xlaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYSA9IGNpcmNsZXNbY2lyY2xlaWRzW2ldXTtcblxuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgY2lyY2xlaWRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBiID0gY2lyY2xlc1tjaXJjbGVpZHNbal1dLFxuICAgICAgICAgICAgZCA9IGRpc3RhbmNlKGEsIGIpO1xuXG4gICAgICAgIGlmIChkICsgYi5yYWRpdXMgPD0gYS5yYWRpdXMgKyAxZS0xMCkge1xuICAgICAgICAgIHJldFtjaXJjbGVpZHNbal1dLnB1c2goY2lyY2xlaWRzW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChkICsgYS5yYWRpdXMgPD0gYi5yYWRpdXMgKyAxZS0xMCkge1xuICAgICAgICAgIHJldFtjaXJjbGVpZHNbaV1dLnB1c2goY2lyY2xlaWRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlVGV4dENlbnRyZXMoY2lyY2xlcywgYXJlYXMpIHtcbiAgICB2YXIgcmV0ID0ge30sXG4gICAgICAgIG92ZXJsYXBwZWQgPSBnZXRPdmVybGFwcGluZ0NpcmNsZXMoY2lyY2xlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJlYSA9IGFyZWFzW2ldLnNldHMsXG4gICAgICAgICAgYXJlYWlkcyA9IHt9LFxuICAgICAgICAgIGV4Y2x1ZGUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcmVhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGFyZWFpZHNbYXJlYVtqXV0gPSB0cnVlO1xuICAgICAgICB2YXIgb3ZlcmxhcHMgPSBvdmVybGFwcGVkW2FyZWFbal1dOyAvLyBrZWVwIHRyYWNrIG9mIGFueSBjaXJjbGVzIHRoYXQgb3ZlcmxhcCB0aGlzIGFyZWEsXG4gICAgICAgIC8vIGFuZCBkb24ndCBjb25zaWRlciBmb3IgcHVycG9zZXMgb2YgY29tcHV0aW5nIHRoZSB0ZXh0XG4gICAgICAgIC8vIGNlbnRyZVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3ZlcmxhcHMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICBleGNsdWRlW292ZXJsYXBzW2tdXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGludGVyaW9yID0gW10sXG4gICAgICAgICAgZXh0ZXJpb3IgPSBbXTtcblxuICAgICAgZm9yICh2YXIgc2V0aWQgaW4gY2lyY2xlcykge1xuICAgICAgICBpZiAoc2V0aWQgaW4gYXJlYWlkcykge1xuICAgICAgICAgIGludGVyaW9yLnB1c2goY2lyY2xlc1tzZXRpZF0pO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc2V0aWQgaW4gZXhjbHVkZSkpIHtcbiAgICAgICAgICBleHRlcmlvci5wdXNoKGNpcmNsZXNbc2V0aWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2VudHJlID0gY29tcHV0ZVRleHRDZW50cmUoaW50ZXJpb3IsIGV4dGVyaW9yKTtcbiAgICAgIHJldFthcmVhXSA9IGNlbnRyZTtcblxuICAgICAgaWYgKGNlbnRyZS5kaXNqb2ludCAmJiBhcmVhc1tpXS5zaXplID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IGFyZWEgXCIgKyBhcmVhICsgXCIgbm90IHJlcHJlc2VudGVkIG9uIHNjcmVlblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIHNvcnRzIGFsbCBhcmVhcyBpbiB0aGUgdmVubiBkaWFncmFtLCBzbyB0aGF0XG4gIC8vIGEgcGFydGljdWxhciBhcmVhIGlzIG9uIHRvcCAocmVsYXRpdmVUbykgLSBhbmRcbiAgLy8gYWxsIG90aGVyIGFyZWFzIGFyZSBzbyB0aGF0IHRoZSBzbWFsbGVzdCBhcmVhcyBhcmUgb24gdG9wXG5cblxuICBmdW5jdGlvbiBzb3J0QXJlYXMoZGl2LCByZWxhdGl2ZVRvKSB7XG4gICAgLy8gZmlndXJlIG91dCBzZXRzIHRoYXQgYXJlIGNvbXBsZXRseSBvdmVybGFwcGVkIGJ5IHJlbGF0aXZlVG9cbiAgICB2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcGluZ0NpcmNsZXMoZGl2LnNlbGVjdEFsbChcInN2Z1wiKS5kYXR1bSgpKTtcbiAgICB2YXIgZXhjbHVkZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWxhdGl2ZVRvLnNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaGVjayA9IHJlbGF0aXZlVG8uc2V0c1tpXTtcblxuICAgICAgZm9yICh2YXIgc2V0aWQgaW4gb3ZlcmxhcHMpIHtcbiAgICAgICAgdmFyIG92ZXJsYXAgPSBvdmVybGFwc1tzZXRpZF07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdmVybGFwLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKG92ZXJsYXBbal0gPT0gY2hlY2spIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVbc2V0aWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gY2hlY2tzIHRoYXQgYWxsIHNldHMgYXJlIGluIGV4Y2x1ZGU7XG5cblxuICAgIGZ1bmN0aW9uIHNob3VsZEV4Y2x1ZGUoc2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghKHNldHNbaV0gaW4gZXhjbHVkZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBuZWVkIHRvIHNvcnQgZGl2J3Mgc28gdGhhdCBaIG9yZGVyIGlzIGNvcnJlY3RcblxuXG4gICAgZGl2LnNlbGVjdEFsbChcImdcIikuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gaGlnaGVzdCBvcmRlciBzZXQgaW50ZXJzZWN0aW9ucyBmaXJzdFxuICAgICAgaWYgKGEuc2V0cy5sZW5ndGggIT0gYi5zZXRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYS5zZXRzLmxlbmd0aCAtIGIuc2V0cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChhID09IHJlbGF0aXZlVG8pIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZEV4Y2x1ZGUoYi5zZXRzKSA/IC0xIDogMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGIgPT0gcmVsYXRpdmVUbykge1xuICAgICAgICByZXR1cm4gc2hvdWxkRXhjbHVkZShhLnNldHMpID8gMSA6IC0xO1xuICAgICAgfSAvLyBmaW5hbGx5IGJ5IHNpemVcblxuXG4gICAgICByZXR1cm4gYi5zaXplIC0gYS5zaXplO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlUGF0aCh4LCB5LCByKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHJldC5wdXNoKFwiXFxuTVwiLCB4LCB5KTtcbiAgICByZXQucHVzaChcIlxcbm1cIiwgLXIsIDApO1xuICAgIHJldC5wdXNoKFwiXFxuYVwiLCByLCByLCAwLCAxLCAwLCByICogMiwgMCk7XG4gICAgcmV0LnB1c2goXCJcXG5hXCIsIHIsIHIsIDAsIDEsIDAsIC1yICogMiwgMCk7XG4gICAgcmV0dXJuIHJldC5qb2luKFwiIFwiKTtcbiAgfSAvLyBpbnZlcnNlIG9mIHRoZSBjaXJjbGVQYXRoIGZ1bmN0aW9uLCByZXR1cm5zIGEgY2lyY2xlIG9iamVjdCBmcm9tIGFuIHN2ZyBwYXRoXG5cblxuICBmdW5jdGlvbiBjaXJjbGVGcm9tUGF0aChwYXRoKSB7XG4gICAgdmFyIHRva2VucyA9IHBhdGguc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgJ3gnOiBwYXJzZUZsb2F0KHRva2Vuc1sxXSksXG4gICAgICAneSc6IHBhcnNlRmxvYXQodG9rZW5zWzJdKSxcbiAgICAgICdyYWRpdXMnOiAtcGFyc2VGbG9hdCh0b2tlbnNbNF0pXG4gICAgfTtcbiAgfVxuICAvKiogcmV0dXJucyBhIHN2ZyBwYXRoIG9mIHRoZSBpbnRlcnNlY3Rpb24gYXJlYSBvZiBhIGJ1bmNoIG9mIGNpcmNsZXMgKi9cblxuXG4gIGZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWFQYXRoKGNpcmNsZXMpIHtcbiAgICB2YXIgc3RhdHMgPSB7fTtcbiAgICBpbnRlcnNlY3Rpb25BcmVhKGNpcmNsZXMsIHN0YXRzKTtcbiAgICB2YXIgYXJjcyA9IHN0YXRzLmFyY3M7XG5cbiAgICBpZiAoYXJjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIk0gMCAwXCI7XG4gICAgfSBlbHNlIGlmIChhcmNzLmxlbmd0aCA9PSAxKSB7XG4gICAgICB2YXIgY2lyY2xlID0gYXJjc1swXS5jaXJjbGU7XG4gICAgICByZXR1cm4gY2lyY2xlUGF0aChjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yYWRpdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkcmF3IHBhdGggYXJvdW5kIGFyY3NcbiAgICAgIHZhciByZXQgPSBbXCJcXG5NXCIsIGFyY3NbMF0ucDIueCwgYXJjc1swXS5wMi55XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2ldLFxuICAgICAgICAgICAgciA9IGFyYy5jaXJjbGUucmFkaXVzLFxuICAgICAgICAgICAgd2lkZSA9IGFyYy53aWR0aCA+IHI7XG4gICAgICAgIHJldC5wdXNoKFwiXFxuQVwiLCByLCByLCAwLCB3aWRlID8gMSA6IDAsIDEsIGFyYy5wMS54LCBhcmMucDEueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQuam9pbihcIiBcIik7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5pbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uQXJlYTtcbiAgZXhwb3J0cy5jaXJjbGVDaXJjbGVJbnRlcnNlY3Rpb24gPSBjaXJjbGVDaXJjbGVJbnRlcnNlY3Rpb247XG4gIGV4cG9ydHMuY2lyY2xlT3ZlcmxhcCA9IGNpcmNsZU92ZXJsYXA7XG4gIGV4cG9ydHMuY2lyY2xlQXJlYSA9IGNpcmNsZUFyZWE7XG4gIGV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgZXhwb3J0cy52ZW5uID0gdmVubjtcbiAgZXhwb3J0cy5ncmVlZHlMYXlvdXQgPSBncmVlZHlMYXlvdXQ7XG4gIGV4cG9ydHMuc2NhbGVTb2x1dGlvbiA9IHNjYWxlU29sdXRpb247XG4gIGV4cG9ydHMubm9ybWFsaXplU29sdXRpb24gPSBub3JtYWxpemVTb2x1dGlvbjtcbiAgZXhwb3J0cy5iZXN0SW5pdGlhbExheW91dCA9IGJlc3RJbml0aWFsTGF5b3V0O1xuICBleHBvcnRzLmxvc3NGdW5jdGlvbiA9IGxvc3NGdW5jdGlvbjtcbiAgZXhwb3J0cy5kaXNqb2ludENsdXN0ZXIgPSBkaXNqb2ludENsdXN0ZXI7XG4gIGV4cG9ydHMuZGlzdGFuY2VGcm9tSW50ZXJzZWN0QXJlYSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdEFyZWE7XG4gIGV4cG9ydHMuVmVubkRpYWdyYW0gPSBWZW5uRGlhZ3JhbTtcbiAgZXhwb3J0cy53cmFwVGV4dCA9IHdyYXBUZXh0O1xuICBleHBvcnRzLmNvbXB1dGVUZXh0Q2VudHJlcyA9IGNvbXB1dGVUZXh0Q2VudHJlcztcbiAgZXhwb3J0cy5jb21wdXRlVGV4dENlbnRyZSA9IGNvbXB1dGVUZXh0Q2VudHJlO1xuICBleHBvcnRzLnNvcnRBcmVhcyA9IHNvcnRBcmVhcztcbiAgZXhwb3J0cy5jaXJjbGVQYXRoID0gY2lyY2xlUGF0aDtcbiAgZXhwb3J0cy5jaXJjbGVGcm9tUGF0aCA9IGNpcmNsZUZyb21QYXRoO1xuICBleHBvcnRzLmludGVyc2VjdGlvbkFyZWFQYXRoID0gaW50ZXJzZWN0aW9uQXJlYVBhdGg7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2NyZWF0b3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NlbGVjdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzkpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NlbGVjdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19jcmVhdG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3Rvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzIpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3Rvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfX1tcImFcIiAvKiBTZWxlY3Rpb24gKi9dKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3RvckFsbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODApO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3RvckFsbF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfX1tcImFcIiAvKiBTZWxlY3Rpb24gKi9dKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tYXRjaGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX21hdGNoZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fW1wiYVwiIC8qIFNlbGVjdGlvbiAqL10oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2VudGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19jb25zdGFudF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDYpO1xuXG5cblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoOyAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2VudGVyX19bXCJhXCIgLyogRW50ZXJOb2RlICovXShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfSAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuXG5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTsgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cblxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuXG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cblxuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSk7XG5cbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19lbnRlcl9fW1wiYVwiIC8qIEVudGVyTm9kZSAqL10ocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH0gLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZXNbaV1dID09PSBub2RlKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGRhdGFbKytqXSA9IGQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2NvbnN0YW50X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gdmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTsgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cblxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuXG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcblxuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fW1wiYVwiIC8qIFNlbGVjdGlvbiAqL10odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3BhcnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pbmRleF9fW1wiYVwiIC8qIFNlbGVjdGlvbiAqL10odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3BhcnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pLCB0aGlzLl9wYXJlbnRzKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2luZGV4X19bXCJhXCIgLyogU2VsZWN0aW9uICovXShtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfX1tcImFcIiAvKiBTZWxlY3Rpb24gKi9dKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59KTtcblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG4vKioqLyB9KSxcbi8qIDQxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksXG4gICAgICBpID0gLTE7XG4gIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgbm9kZXNbKytpXSA9IHRoaXM7XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICsrc2l6ZTtcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19uYW1lc3BhY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcwKTtcblxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO2Vsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19uYW1lc3BhY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWwgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCkgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uIDogZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIHZhbHVlKSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwcm9wZXJ0eVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07ZWxzZSB0aGlzW25hbWVdID0gdjtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BlcnR5RnVuY3Rpb24gOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpIDogdGhpcy5ub2RlKClbbmFtZV07XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG5cbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcblxuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5hbWVzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5hbWVzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBuYW1lcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlID8gY2xhc3NlZFRydWUgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbCA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB0ZXh0RnVuY3Rpb24gOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSkgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHRtbEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGwgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gaHRtbEZ1bmN0aW9uIDogaHRtbENvbnN0YW50KSh2YWx1ZSkpIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19jcmVhdG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2MCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY3JlYXRvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY3JlYXRvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fc2VsZWN0b3JfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcyKTtcblxuXG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19jcmVhdG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19zZWxlY3Rvcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNsb25lTm9kZShmYWxzZSksIHRoaXMubmV4dFNpYmxpbmcpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVEZWVwKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNsb25lTm9kZSh0cnVlKSwgdGhpcy5uZXh0U2libGluZyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSkgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3dpbmRvd19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzMpO1xuXG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX193aW5kb3dfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7ZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBkaXNwYXRjaEZ1bmN0aW9uIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGxvY2FsO1xudmFyIG5leHRJZCA9IDA7XG5mdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbCgpO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG5cbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcblxuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDQzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NvdXJjZUV2ZW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3NSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19wb2ludF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjEpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGV2ZW50ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc291cmNlRXZlbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoKTtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICByZXR1cm4gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcG9pbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSwgZXZlbnQpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0aW9uX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NlbGVjdGlvbl9pbmRleF9fW1wiYVwiIC8qIFNlbGVjdGlvbiAqL10oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pIDogbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2VsZWN0aW9uX2luZGV4X19bXCJhXCIgLyogU2VsZWN0aW9uICovXShbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NlbGVjdGlvbl9pbmRleF9fW1wiY1wiIC8qIHJvb3QgKi9dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NvdXJjZUV2ZW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3NSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19wb2ludF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjEpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NvdXJjZUV2ZW50X19bXCJhXCIgLyogZGVmYXVsdCAqL10pKCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcG9pbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSwgdG91Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc291cmNlRXZlbnRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzc1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3BvaW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2MSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobm9kZSwgdG91Y2hlcykge1xuICBpZiAodG91Y2hlcyA9PSBudWxsKSB0b3VjaGVzID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc291cmNlRXZlbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoKS50b3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgcG9pbnRzW2ldID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fcG9pbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSwgdG91Y2hlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX3NlbGVjdGlvbl9pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fc3JjX3RyYW5zaXRpb25faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NyY190cmFuc2l0aW9uX2luZGV4X19bXCJiXCJdOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NyY19hY3RpdmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDU3KTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFjdGl2ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc3JjX2FjdGl2ZV9fW1wiYVwiXTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19zcmNfaW50ZXJydXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4NSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbnRlcnJ1cHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX3NyY19pbnRlcnJ1cHRfX1tcImFcIl07IH0pO1xuXG5cblxuXG5cbi8qKiovIH0pLFxuLyogNDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19zZWxlY3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9faW50ZXJydXB0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX190cmFuc2l0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MCk7XG5cblxuXG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX19bXCJzZWxlY3Rpb25cIl0ucHJvdG90eXBlLmludGVycnVwdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9faW50ZXJydXB0X19bXCJhXCIgLyogZGVmYXVsdCAqL107XG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX19bXCJzZWxlY3Rpb25cIl0ucHJvdG90eXBlLnRyYW5zaXRpb24gPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3RyYW5zaXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXTtcblxuLyoqKi8gfSksXG4vKiA0MzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbnRlcnJ1cHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzg1KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbnRlcnJ1cHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcywgbmFtZSk7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc3JjX2Rpc3BhdGNoX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzOSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19zcmNfZGlzcGF0Y2hfX1tcImFcIl07IH0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIG5vb3AgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAoKSB7fVxufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8IHQgaW4gXykgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLFxuICAgICAgICBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0LFxuICAgICAgbmFtZTogbmFtZVxuICAgIH07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uICh0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoOyAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG5cblxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO2Vsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvcHkgPSB7fSxcbiAgICAgICAgXyA9IHRoaXMuXztcblxuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcblxuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uICh0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG5cbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiAodHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG5cbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZhbHVlOiBjYWxsYmFja1xuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZGlzcGF0Y2gpO1xuXG4vKioqLyB9KSxcbi8qIDQ0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RyYW5zaXRpb25faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3RyYW5zaXRpb25fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9kM19lYXNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX2QzX3RpbWVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MCk7XG5cblxuXG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLFxuICAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX2QzX2Vhc2VfX1tcImVhc2VDdWJpY0luT3V0XCJdXG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG5cbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRUaW1pbmcudGltZSA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfZDNfdGltZXJfX1tcIm5vd1wiXSkoKSwgZGVmYXVsdFRpbWluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGltaW5nO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpZCwgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190cmFuc2l0aW9uX2luZGV4X19bXCJhXCIgLyogVHJhbnNpdGlvbiAqL10pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RyYW5zaXRpb25faW5kZXhfX1tcImNcIiAvKiBuZXdJZCAqL10pKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19kM190aW1lcl9fW1wibm93XCJdKSgpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdHJhbnNpdGlvbl9zY2hlZHVsZV9fW1wiZVwiIC8qIGRlZmF1bHQgKi9dKShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RyYW5zaXRpb25faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfaW50ZXJwb2xhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3R3ZWVuX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19pbnRlcnBvbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODYpO1xuXG5cblxuXG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciB2YWx1ZTAwLCBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGwgOiB2YWx1ZTAgPT09IHZhbHVlMDAgPyBpbnRlcnBvbGF0ZTAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCwgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbCA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMCA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHZhbHVlMDAsIHZhbHVlMTAsIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUwLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGwgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHZhbHVlMDAsIHZhbHVlMTAsIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUwLFxuICAgICAgICB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbCA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kM19zZWxlY3Rpb25fX1tcIm5hbWVzcGFjZVwiXSkobmFtZSksXG4gICAgICBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfaW50ZXJwb2xhdGVfX1tcImludGVycG9sYXRlVHJhbnNmb3JtU3ZnXCJdIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19pbnRlcnBvbGF0ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3R3ZWVuX19bXCJiXCIgLyogdHdlZW5WYWx1ZSAqL10pKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSkgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSArIFwiXCIpKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLFxuICAgICAgICBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbiAodCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkodCkpO1xuICAgIH07XG4gIH1cblxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLFxuICAgICAgICBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbiAodCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgaSh0KSk7XG4gICAgfTtcbiAgfVxuXG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgdmFyIGZ1bGxuYW1lID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19zZWxlY3Rpb25fX1tcIm5hbWVzcGFjZVwiXSkobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImdcIiAvKiBpbml0ICovXSkodGhpcywgaWQpLmRlbGF5ID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGF5Q29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX19bXCJnXCIgLyogaW5pdCAqL10pKHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVsYXlGdW5jdGlvbiA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImZcIiAvKiBnZXQgKi9dKSh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImhcIiAvKiBzZXQgKi9dKSh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImhcIiAvKiBzZXQgKi9dKSh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGR1cmF0aW9uRnVuY3Rpb24gOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKSA6IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImhcIiAvKiBzZXQgKi9dKSh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImZcIiAvKiBnZXQgKi9dKSh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX3NlbGVjdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjkpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX3NlbGVjdGlvbl9fW1wibWF0Y2hlclwiXSkobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pbmRleF9fW1wiYVwiIC8qIFRyYW5zaXRpb24gKi9dKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3IoKTtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsXG4gICAgICBvbjEsXG4gICAgICBzaXQgPSBzdGFydChuYW1lKSA/IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImdcIiAvKiBpbml0ICovXSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fc2NoZWR1bGVfX1tcImhcIiAvKiBzZXQgKi9dO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNpdCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub247IC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cblxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKSA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMub24oXCJlbmQucmVtb3ZlXCIsIHJlbW92ZUZ1bmN0aW9uKHRoaXMuX2lkKSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX3NlbGVjdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19pbmRleF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fc2NoZWR1bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChmdW5jdGlvbiAoc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX19bXCJzZWxlY3RvclwiXSkoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NjaGVkdWxlX19bXCJlXCIgLyogZGVmYXVsdCAqL10pKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zY2hlZHVsZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uIChzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19zZWxlY3Rpb25fX1tcInNlbGVjdG9yQWxsXCJdKShzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkobm9kZSwgaWQpLCBrID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgayA8IGw7ICsraykge1xuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XG4gICAgICAgICAgICBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19zY2hlZHVsZV9fW1wiZVwiIC8qIGRlZmF1bHQgKi9dKShjaGlsZCwgbmFtZSwgaWQsIGssIGNoaWxkcmVuLCBpbmhlcml0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShzdWJncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfc2VsZWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcblxudmFyIFNlbGVjdGlvbiA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kM19zZWxlY3Rpb25fX1tcInNlbGVjdGlvblwiXS5wcm90b3R5cGUuY29uc3RydWN0b3I7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZDNfaW50ZXJwb2xhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3R3ZWVuX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19pbnRlcnBvbGF0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODYpO1xuXG5cblxuXG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciB2YWx1ZTAwLCB2YWx1ZTEwLCBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlMCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX19bXCJzdHlsZVwiXSkodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2QzX3NlbGVjdGlvbl9fW1wic3R5bGVcIl0pKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMCA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMTAgPSB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZUVuZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciB2YWx1ZTAwLCBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlMCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX19bXCJzdHlsZVwiXSkodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbCA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMCA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciB2YWx1ZTAwLCB2YWx1ZTEwLCBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlMCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX19bXCJzdHlsZVwiXSkodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZDNfc2VsZWN0aW9uX19bXCJzdHlsZVwiXSkodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGwgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2QzX2ludGVycG9sYXRlX19bXCJpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzc1wiXSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19faW50ZXJwb2xhdGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVSZW1vdmUobmFtZSwgaSkpLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmVFbmQobmFtZSkpIDogdGhpcy5zdHlsZVR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVGdW5jdGlvbihuYW1lLCBpLCBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX190d2Vlbl9fW1wiYlwiIC8qIHR3ZWVuVmFsdWUgKi9dKSh0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUpKSA6IHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUgKyBcIlwiKSwgcHJpb3JpdHkpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLFxuICAgICAgICBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbiAodCkge1xuICAgICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpKHQpLCBwcmlvcml0eSk7XG4gICAgfTtcbiAgfVxuXG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIga2V5ID0gXCJzdHlsZS5cIiArIChuYW1lICs9IFwiXCIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190d2Vlbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjIpO1xuXG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRleHRGdW5jdGlvbihPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190d2Vlbl9fW1wiYlwiIC8qIHR3ZWVuVmFsdWUgKi9dKSh0aGlzLCBcInRleHRcIiwgdmFsdWUpKSA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NjaGVkdWxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19pbmRleF9fW1wiY1wiIC8qIG5ld0lkICovXSkoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3NjaGVkdWxlX19bXCJmXCIgLyogZ2V0ICovXSkobm9kZSwgaWQwKTtcbiAgICAgICAgT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fc2NoZWR1bGVfX1tcImVcIiAvKiBkZWZhdWx0ICovXSkobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkMSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190cmFuc2l0aW9uX2luZGV4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX190cmFuc2l0aW9uX3NjaGVkdWxlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxuXG52YXIgcm9vdCA9IFtudWxsXTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3RyYW5zaXRpb25fc2NoZWR1bGVfX1tcImNcIiAvKiBTQ0hFRFVMRUQgKi9dICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3RyYW5zaXRpb25faW5kZXhfX1tcImFcIiAvKiBUcmFuc2l0aW9uICovXShbW25vZGVdXSwgcm9vdCwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyB2ZW5uIHNoYXBlc1xuICogQGF1dGhvciBsZXVuZ3dlbnNlbkBnbWFpbC5jb21cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIFBhdGhVdGlsID0gVXRpbC5QYXRoVXRpbDtcblxuZnVuY3Rpb24gZ2V0QXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0Q2ZnID0gR2xvYmFsLnNoYXBlLnZlbm47XG4gIHZhciBwYXRoQXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdENmZywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZEZpbGxBdHRycyhwYXRoQXR0cnMsIGNmZyk7XG4gIHJldHVybiBwYXRoQXR0cnM7XG59XG5cbmZ1bmN0aW9uIGdldEhvbGxvd0F0dHJzKGNmZykge1xuICB2YXIgZGVmYXVsdENmZyA9IEdsb2JhbC5zaGFwZS5ob2xsb3dWZW5uO1xuICB2YXIgcGF0aEF0dHJzID0gVXRpbC5taXgoe30sIGRlZmF1bHRDZmcsIGNmZy5zdHlsZSk7XG4gIFNoYXBlVXRpbC5hZGRTdHJva2VBdHRycyhwYXRoQXR0cnMsIGNmZyk7XG4gIHJldHVybiBwYXRoQXR0cnM7XG59IC8vIHJlZ2lzdGVyIHZlbm4gZ2VvbVxuXG5cbnZhciBWZW5uID0gU2hhcGUucmVnaXN0ZXJGYWN0b3J5KCd2ZW5uJywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAndmVubicsXG4gIGdldERlZmF1bHRQb2ludHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQb2ludHMocG9pbnRJbmZvKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIFV0aWwuZWFjaChwb2ludEluZm8ueCwgZnVuY3Rpb24gKHN1YlgsIGluZGV4KSB7XG4gICAgICB2YXIgc3ViWSA9IHBvaW50SW5mby55W2luZGV4XTtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogc3ViWCxcbiAgICAgICAgeTogc3ViWVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgZ2V0QWN0aXZlQ2ZnOiBmdW5jdGlvbiBnZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGNmZy5saW5lV2lkdGggfHwgMTtcblxuICAgIGlmICh0eXBlID09PSAnaG9sbG93Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGggKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gY2ZnLmZpbGxPcGFjaXR5IHx8IGNmZy5vcGFjaXR5IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGxpbmVXaWR0aCxcbiAgICAgIGZpbGxPcGFjaXR5OiBvcGFjaXR5IC0gMC4wOFxuICAgIH07XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2ZnOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENmZyh0eXBlLCBjZmcpIHtcbiAgICBpZiAoY2ZnICYmIGNmZy5zdHlsZSkge1xuICAgICAgcmV0dXJuIGNmZy5zdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDZmcodHlwZSwgY2ZnKTtcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCd2ZW5uJywgJ3Zlbm4nLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgb3JpZ2luID0gY2ZnLm9yaWdpbi5fb3JpZ2luO1xuICAgIHZhciBwYXRoID0gb3JpZ2luLnBhdGg7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoY2ZnKTtcbiAgICB2YXIgc2VnbWVudHMgPSBQYXRoVXRpbC5wYXJzZVBhdGhTdHJpbmcocGF0aCk7XG4gICAgdmFyIHBhdGhTaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBzZWdtZW50c1xuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aFNoYXBlO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICAgIHJhZGl1czogNFxuICAgIH0sIGdldEF0dHJzKGNmZykpO1xuICB9XG59KTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3Zlbm4nLCAnaG9sbG93Jywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIG9yaWdpbiA9IGNmZy5vcmlnaW4uX29yaWdpbjtcbiAgICB2YXIgcGF0aCA9IG9yaWdpbi5wYXRoO1xuICAgIHZhciBhdHRycyA9IGdldEhvbGxvd0F0dHJzKGNmZyk7XG4gICAgdmFyIHNlZ21lbnRzID0gUGF0aFV0aWwucGFyc2VQYXRoU3RyaW5nKHBhdGgpO1xuICAgIHZhciBwYXRoU2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogc2VnbWVudHNcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGhTaGFwZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LCBnZXRBdHRycyhjZmcpKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFZlbm47XG5cbi8qKiovIH0pLFxuLyogNDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFZlbm4gRGlhZ3JhbVxuICogQGF1dGhvciBsZXVuZ3dlbnNlbkBnbWFpbC5jb21cbiAqL1xudmFyIEdlb21CYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNpemVNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzU3KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg0NjApO1xuXG52YXIgVmlvbGluID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoVmlvbGluLCBfR2VvbUJhc2UpO1xuXG4gIHZhciBfcHJvdG8gPSBWaW9saW4ucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBnZXQgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAndmlvbGluJztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ3Zpb2xpbic7XG4gICAgY2ZnLmdlbmVyYXRlUG9pbnRzID0gdHJ1ZTsgLy8gc3VwZXIuZHJhdyhkYXRhLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBmdW5jdGlvbiBWaW9saW4oY2ZnKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfR2VvbUJhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgVXRpbC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFNpemVNaXhpbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX3Byb3RvLmNyZWF0ZVNoYXBlUG9pbnRzQ2ZnID0gZnVuY3Rpb24gY3JlYXRlU2hhcGVQb2ludHNDZmcob2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGNmZyA9IF9HZW9tQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgY2ZnLnNpemUgPSBzZWxmLmdldE5vcm1hbGl6ZWRTaXplKG9iaik7XG4gICAgdmFyIHNpemVGaWVsZCA9IHNlbGYuZ2V0KCdfc2l6ZUZpZWxkJyk7XG4gICAgY2ZnLl9zaXplID0gb2JqLl9vcmlnaW5bc2l6ZUZpZWxkXTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5jbGVhcklubmVyID0gZnVuY3Rpb24gY2xlYXJJbm5lcigpIHtcbiAgICBfR2VvbUJhc2UucHJvdG90eXBlLmNsZWFySW5uZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc2V0KCdkZWZhdWx0U2l6ZScsIG51bGwpO1xuICB9O1xuXG4gIF9wcm90by5faW5pdEF0dHJzID0gZnVuY3Rpb24gX2luaXRBdHRycygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJPcHRpb25zID0gc2VsZi5nZXQoJ2F0dHJPcHRpb25zJyk7XG4gICAgdmFyIHNpemVGaWVsZCA9IGF0dHJPcHRpb25zLnNpemUgPyBhdHRyT3B0aW9ucy5zaXplLmZpZWxkIDogc2VsZi5nZXQoJ19zaXplRmllbGQnKSA/IHNlbGYuZ2V0KCdfc2l6ZUZpZWxkJykgOiAnc2l6ZSc7XG4gICAgc2VsZi5zZXQoJ19zaXplRmllbGQnLCBzaXplRmllbGQpO1xuICAgIGRlbGV0ZSBhdHRyT3B0aW9ucy5zaXplO1xuXG4gICAgX0dlb21CYXNlLnByb3RvdHlwZS5faW5pdEF0dHJzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpb2xpbjtcbn0oR2VvbUJhc2UpO1xuXG52YXIgVmlvbGluRG9kZ2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9WaW9saW4pIHtcbiAgX2luaGVyaXRzTG9vc2UoVmlvbGluRG9kZ2UsIF9WaW9saW4pO1xuXG4gIGZ1bmN0aW9uIFZpb2xpbkRvZGdlKCkge1xuICAgIHJldHVybiBfVmlvbGluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gVmlvbGluRG9kZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9WaW9saW4ucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy5oYXNEZWZhdWx0QWRqdXN0ID0gdHJ1ZTtcbiAgICBjZmcuYWRqdXN0cyA9IFt7XG4gICAgICB0eXBlOiAnZG9kZ2UnXG4gICAgfV07XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICByZXR1cm4gVmlvbGluRG9kZ2U7XG59KFZpb2xpbik7XG5cblZpb2xpbi5Eb2RnZSA9IFZpb2xpbkRvZGdlO1xuR2VvbUJhc2UuVmlvbGluID0gVmlvbGluO1xuR2VvbUJhc2UuVmlvbGluRG9kZ2UgPSBWaW9saW5Eb2RnZTtcbm1vZHVsZS5leHBvcnRzID0gVmlvbGluO1xuXG4vKioqLyB9KSxcbi8qIDQ2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgdmVubiBzaGFwZXNcbiAqIEBhdXRob3IgbGV1bmd3ZW5zZW5AZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBTaGFwZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBQYXRoVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG5mdW5jdGlvbiBnZXRBdHRycyhjZmcpIHtcbiAgdmFyIGRlZmF1bHRDZmcgPSBHbG9iYWwuc2hhcGUudmVubjtcbiAgdmFyIHBhdGhBdHRycyA9IFV0aWwubWl4KHt9LCBkZWZhdWx0Q2ZnLCBjZmcuc3R5bGUpO1xuICBTaGFwZVV0aWwuYWRkRmlsbEF0dHJzKHBhdGhBdHRycywgY2ZnKTtcblxuICBpZiAoY2ZnLmNvbG9yKSB7XG4gICAgcGF0aEF0dHJzLnN0cm9rZSA9IHBhdGhBdHRycy5zdHJva2UgfHwgY2ZnLmNvbG9yO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhBdHRycztcbn1cblxuZnVuY3Rpb24gZ2V0SG9sbG93QXR0cnMoY2ZnKSB7XG4gIHZhciBkZWZhdWx0Q2ZnID0gR2xvYmFsLnNoYXBlLmhvbGxvd1Zlbm47XG4gIHZhciBwYXRoQXR0cnMgPSBVdGlsLm1peCh7fSwgZGVmYXVsdENmZywgY2ZnLnN0eWxlKTtcbiAgU2hhcGVVdGlsLmFkZFN0cm9rZUF0dHJzKHBhdGhBdHRycywgY2ZnKTtcbiAgcmV0dXJuIHBhdGhBdHRycztcbn1cblxuZnVuY3Rpb24gZ2V0VmlvbGluUGF0aChwb2ludHMpIHtcbiAgdmFyIHBhdGggPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgIGlmIChwb2ludCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGkgPT09IDAgPyAnTScgOiAnTCc7XG4gICAgICBwYXRoLnB1c2goW2FjdGlvbiwgcG9pbnQueCwgcG9pbnQueV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaXJzdCA9IHBvaW50c1swXTtcblxuICBpZiAoZmlyc3QpIHtcbiAgICBwYXRoLnB1c2goWydMJywgZmlyc3QueCwgZmlyc3QueV0pO1xuICAgIHBhdGgucHVzaChbJ3onXSk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0U21vb3RoVmlvbGluUGF0aChwb2ludHMpIHtcbiAgdmFyIGhhbGYgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIGxlZnRQb2ludHMgPSBbXTtcbiAgdmFyIHJpZ2h0UG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA8IGhhbGYpIHtcbiAgICAgIGxlZnRQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRQYXRoID0gUGF0aFV0aWwuZ2V0U3BsaW5lUGF0aChsZWZ0UG9pbnRzLCBmYWxzZSk7XG4gIHZhciByaWdodFBhdGggPSBQYXRoVXRpbC5nZXRTcGxpbmVQYXRoKHJpZ2h0UG9pbnRzLCBmYWxzZSk7XG4gIGxlZnRQYXRoLnB1c2goWydMJywgcmlnaHRQb2ludHNbMF0ueCwgcmlnaHRQb2ludHNbMF0ueV0pO1xuICByaWdodFBhdGguc2hpZnQoKTtcbiAgdmFyIHBhdGggPSBsZWZ0UGF0aC5jb25jYXQocmlnaHRQYXRoKTtcbiAgcGF0aC5wdXNoKFsnTCcsIGxlZnRQb2ludHNbMF0ueCwgbGVmdFBvaW50c1swXS55XSk7XG4gIHBhdGgucHVzaChbJ3onXSk7XG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTaXplKGFycikge1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgYXJyKTtcbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBudW0gLyBtYXg7XG4gIH0pO1xufSAvLyByZWdpc3RlciB2aW9saW4gZ2VvbSBzaGFwZVxuXG5cbnZhciBWaW9saW4gPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ3Zpb2xpbicsIHtcbiAgZGVmYXVsdFNoYXBlVHlwZTogJ3Zpb2xpbicsXG4gIGdldERlZmF1bHRQb2ludHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQb2ludHMocG9pbnRJbmZvKSB7XG4gICAgdmFyIHJhZGl1cyA9IHBvaW50SW5mby5zaXplIC8gMjtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHNpemVBcnIgPSBub3JtYWxpemVTaXplKHBvaW50SW5mby5fc2l6ZSk7XG4gICAgVXRpbC5lYWNoKHBvaW50SW5mby55LCBmdW5jdGlvbiAoeSwgaW5kZXgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBzaXplQXJyW2luZGV4XSAqIHJhZGl1cztcbiAgICAgIHZhciBpc01pbiA9IGluZGV4ID09PSAwO1xuICAgICAgdmFyIGlzTWF4ID0gaW5kZXggPT09IHBvaW50SW5mby55Lmxlbmd0aCAtIDE7XG4gICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgIGlzTWluOiBpc01pbixcbiAgICAgICAgaXNNYXg6IGlzTWF4LFxuICAgICAgICB4OiBwb2ludEluZm8ueCAtIG9mZnNldCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgICBwb2ludHMudW5zaGlmdCh7XG4gICAgICAgIGlzTWluOiBpc01pbixcbiAgICAgICAgaXNNYXg6IGlzTWF4LFxuICAgICAgICB4OiBwb2ludEluZm8ueCArIG9mZnNldCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgZ2V0QWN0aXZlQ2ZnOiBmdW5jdGlvbiBnZXRBY3RpdmVDZmcodHlwZSwgY2ZnKSB7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGNmZy5saW5lV2lkdGggfHwgMTtcblxuICAgIGlmICh0eXBlID09PSAnaG9sbG93Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGggKyAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gY2ZnLmZpbGxPcGFjaXR5IHx8IGNmZy5vcGFjaXR5IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGxpbmVXaWR0aCxcbiAgICAgIGZpbGxPcGFjaXR5OiBvcGFjaXR5IC0gMC4wOFxuICAgIH07XG4gIH0sXG4gIGdldFNlbGVjdGVkQ2ZnOiBmdW5jdGlvbiBnZXRTZWxlY3RlZENmZyh0eXBlLCBjZmcpIHtcbiAgICBpZiAoY2ZnICYmIGNmZy5zdHlsZSkge1xuICAgICAgcmV0dXJuIGNmZy5zdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVDZmcodHlwZSwgY2ZnKTtcbiAgfVxufSk7IC8vIG5vcm1hbCB2aW9saW4sIGZpbGxlZCBwYXRoXG5cblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3Zpb2xpbicsICd2aW9saW4nLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyhjZmcpO1xuICAgIHZhciBwYXRoID0gZ2V0VmlvbGluUGF0aChjZmcucG9pbnRzKTtcbiAgICBwYXRoID0gdGhpcy5wYXJzZVBhdGgocGF0aCk7XG4gICAgdmFyIHBhdGhTaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peChhdHRycywge1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoU2hhcGU7XG4gIH0sXG4gIGdldE1hcmtlckNmZzogZnVuY3Rpb24gZ2V0TWFya2VyQ2ZnKGNmZykge1xuICAgIHJldHVybiBVdGlsLm1peCh7XG4gICAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgICAgcmFkaXVzOiA0XG4gICAgfSwgZ2V0QXR0cnMoY2ZnKSk7XG4gIH1cbn0pOyAvLyBzbW9vdGggc3BsaW5lIHZpb2xpbiwgZmlsbGVkIHBhdGhcblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgndmlvbGluJywgJ3Ntb290aCcsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEF0dHJzKGNmZyk7XG4gICAgdmFyIHBhdGggPSBnZXRTbW9vdGhWaW9saW5QYXRoKGNmZy5wb2ludHMpO1xuICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICB2YXIgcGF0aFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGhTaGFwZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LCBnZXRBdHRycyhjZmcpKTtcbiAgfVxufSk7IC8vIGhvbGxvdyB2aW9saW4sIHN0cm9rZWQgcGF0aFxuXG5TaGFwZS5yZWdpc3RlclNoYXBlKCd2aW9saW4nLCAnaG9sbG93Jywge1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgdmFyIGF0dHJzID0gZ2V0SG9sbG93QXR0cnMoY2ZnKTtcbiAgICB2YXIgcGF0aCA9IGdldFZpb2xpblBhdGgoY2ZnLnBvaW50cyk7XG4gICAgcGF0aCA9IHRoaXMucGFyc2VQYXRoKHBhdGgpO1xuICAgIHZhciBwYXRoU2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3BhdGgnLCB7XG4gICAgICBhdHRyczogVXRpbC5taXgoYXR0cnMsIHtcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aFNoYXBlO1xuICB9LFxuICBnZXRNYXJrZXJDZmc6IGZ1bmN0aW9uIGdldE1hcmtlckNmZyhjZmcpIHtcbiAgICByZXR1cm4gVXRpbC5taXgoe1xuICAgICAgc3ltYm9sOiAnY2lyY2xlJyxcbiAgICAgIHJhZGl1czogNFxuICAgIH0sIGdldEhvbGxvd0F0dHJzKGNmZykpO1xuICB9XG59KTsgLy8gaG9sbG93IHNtb290aCBzcGxpbmUgdmlvbGluLCBzdHJva2VkIHBhdGhcblxuU2hhcGUucmVnaXN0ZXJTaGFwZSgndmlvbGluJywgJ3Ntb290aEhvbGxvdycsIHtcbiAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBhdHRycyA9IGdldEhvbGxvd0F0dHJzKGNmZyk7XG4gICAgdmFyIHBhdGggPSBnZXRTbW9vdGhWaW9saW5QYXRoKGNmZy5wb2ludHMpO1xuICAgIHBhdGggPSB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICB2YXIgcGF0aFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgYXR0cnM6IFV0aWwubWl4KGF0dHJzLCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGhTaGFwZTtcbiAgfSxcbiAgZ2V0TWFya2VyQ2ZnOiBmdW5jdGlvbiBnZXRNYXJrZXJDZmcoY2ZnKSB7XG4gICAgcmV0dXJuIFV0aWwubWl4KHtcbiAgICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgICByYWRpdXM6IDRcbiAgICB9LCBnZXRIb2xsb3dBdHRycyhjZmcpKTtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFZpb2xpbjtcblxuLyoqKi8gfSksXG4vKiA0NjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEZhY2V0IOeahOWFpeWPo1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENoYXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpO1xuXG52YXIgRmFjZXRzID0ge307XG5GYWNldHMuUmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzg3KTtcbkZhY2V0cy5MaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODgpO1xuRmFjZXRzLkNpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYyKTtcbkZhY2V0cy5UcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjMpO1xuRmFjZXRzLk1pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDY0KTtcbkZhY2V0cy5NYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NSk7XG5cbkNoYXJ0LnByb3RvdHlwZS5mYWNldCA9IGZ1bmN0aW9uICh0eXBlLCBjZmcpIHtcbiAgdmFyIGNscyA9IEZhY2V0c1tVdGlsLnVwcGVyRmlyc3QodHlwZSldO1xuXG4gIGlmICghY2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydCBzdWNoIHR5cGUgb2YgZmFjZXRzIGFzOiAnICsgdHlwZSk7XG4gIH1cblxuICB2YXIgcHJlRmFjZXRzID0gdGhpcy5nZXQoJ2ZhY2V0cycpO1xuXG4gIGlmIChwcmVGYWNldHMpIHtcbiAgICBwcmVGYWNldHMuZGVzdHJveSgpO1xuICB9XG5cbiAgY2ZnLmNoYXJ0ID0gdGhpcztcbiAgdmFyIGZhY2V0cyA9IG5ldyBjbHMoY2ZnKTtcbiAgdGhpcy5zZXQoJ2ZhY2V0cycsIGZhY2V0cyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0cztcblxuLyoqKi8gfSksXG4vKiA0NjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBjaXJjbGUgZmFjZXRzXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Myk7XG5cbmZ1bmN0aW9uIGdldFBvaW50KGNlbnRlciwgciwgYW5nbGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBjZW50ZXIueCArIHIgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgeTogY2VudGVyLnkgKyByICogTWF0aC5zaW4oYW5nbGUpXG4gIH07XG59XG5cbnZhciBDaXJjbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKENpcmNsZSwgX0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENpcmNsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnY2lyY2xlJztcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5nZXRSZWdpb24gPSBmdW5jdGlvbiBnZXRSZWdpb24oY291bnQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSAxIC8gMjsgLy8g55S75biD5Y2K5b6EXG5cbiAgICB2YXIgYXZnQW5nbGUgPSBNYXRoLlBJICogMiAvIGNvdW50O1xuICAgIHZhciBhbmdsZSA9IC0xICogTWF0aC5QSSAvIDIgKyBhdmdBbmdsZSAqIGluZGV4OyAvLyDlvZPliY3liIbpnaLmiYDlnKjnmoTlvKfluqZcblxuICAgIHZhciBmYWNldFIgPSByIC8gKDEgKyAxIC8gTWF0aC5zaW4oYXZnQW5nbGUgLyAyKSk7XG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IDAuNSxcbiAgICAgIHk6IDAuNVxuICAgIH07IC8vIOeUu+W4g+WchuW/g1xuXG4gICAgdmFyIG1pZGRsZSA9IGdldFBvaW50KGNlbnRlciwgciAtIGZhY2V0UiwgYW5nbGUpOyAvLyDliIbpnaLnmoTkuK3lv4PngrlcblxuICAgIHZhciBzdGFydEFuZ2xlID0gTWF0aC5QSSAqIDUgLyA0OyAvLyDlj7PkuIrop5JcblxuICAgIHZhciBlbmRBbmdsZSA9IE1hdGguUEkgKiAxIC8gNDsgLy8g5bem5LiL6KeSXG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IGdldFBvaW50KG1pZGRsZSwgZmFjZXRSLCBzdGFydEFuZ2xlKSxcbiAgICAgIGVuZDogZ2V0UG9pbnQobWlkZGxlLCBmYWNldFIsIGVuZEFuZ2xlKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdlbmVyYXRlRmFjZXRzID0gZnVuY3Rpb24gZ2VuZXJhdGVGYWNldHMoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGRzID0gc2VsZi5maWVsZHM7XG4gICAgdmFyIGZpZWxkID0gZmllbGRzWzBdO1xuXG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgdGhyb3cgJ1BsZWFzZSBzcGVjaWZ5IGZvciB0aGUgZmllbGQgZm9yIGZhY2V0ISc7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IHNlbGYuZ2V0RmllbGRWYWx1ZXMoZmllbGQsIGRhdGEpO1xuICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBjb25kaXRpb25zID0gW3tcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICB9XTtcbiAgICAgIHZhciBmaWx0ZXIgPSBzZWxmLmdldEZpbHRlcihjb25kaXRpb25zKTtcbiAgICAgIHZhciBzdWJEYXRhID0gZGF0YS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgIHZhciBmYWNldCA9IHtcbiAgICAgICAgdHlwZTogc2VsZi50eXBlLFxuICAgICAgICBjb2xWYWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbEZpZWxkOiBmaWVsZCxcbiAgICAgICAgY29sSW5kZXg6IGluZGV4LFxuICAgICAgICBjb2xzOiBjb3VudCxcbiAgICAgICAgcm93czogMSxcbiAgICAgICAgcm93SW5kZXg6IDAsXG4gICAgICAgIGRhdGE6IHN1YkRhdGEsXG4gICAgICAgIHJlZ2lvbjogc2VsZi5nZXRSZWdpb24oY291bnQsIGluZGV4KVxuICAgICAgfTtcbiAgICAgIHJzdC5wdXNoKGZhY2V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIHJldHVybiBDaXJjbGU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqKi8gfSksXG4vKiA0NjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyB0cmVlIGZhY2V0c1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjMpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBhc3NpZ24gPSBVdGlsLmFzc2lnbjtcblxudmFyIFRyZWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyZWUsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBUcmVlKCkge1xuICAgIHJldHVybiBfQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJlZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfQmFzZS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAndHJlZSc7XG4gICAgY2ZnLmxpbmUgPSB7XG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzdHJva2U6ICcjZGRkJ1xuICAgIH07XG4gICAgY2ZnLmxpbmVTbW9vdGggPSBmYWxzZTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5nZW5lcmF0ZUZhY2V0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlRmFjZXRzKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZpZWxkcyA9IHNlbGYuZmllbGRzO1xuXG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyAnUGxlYXNlIHNwZWNpZnkgZm9yIHRoZSBmaWVsZHMgZm9yIGZhY2V0ISc7XG4gICAgfVxuXG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIHZhciByb290ID0gc2VsZi5nZXRSb290RmFjZXQoZGF0YSk7IC8vIGlmIChzZWxmLnNob3dSb290KSB7XG5cbiAgICByc3QucHVzaChyb290KTsgLy8gfVxuXG4gICAgcm9vdC5jaGlsZHJlbiA9IHNlbGYuZ2V0Q2hpbGRGYWNldHMoZGF0YSwgMSwgcnN0KTtcbiAgICBzZWxmLnNldFJlZ2lvbihyc3QpO1xuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLmdldFJvb3RGYWNldCA9IGZ1bmN0aW9uIGdldFJvb3RGYWNldChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmYWNldCA9IHtcbiAgICAgIHR5cGU6IHNlbGYudHlwZSxcbiAgICAgIHJvd3M6IHNlbGYuZ2V0Um93cygpLFxuICAgICAgcm93SW5kZXg6IDAsXG4gICAgICBjb2xJbmRleDogMCxcbiAgICAgIGNvbFZhbHVlOiBzZWxmLnJvb3RUaXRsZSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBmYWNldDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Um93cyA9IGZ1bmN0aW9uIGdldFJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzLmxlbmd0aCArIDE7XG4gIH07IC8vIGdldCBjaGlsZFxuXG5cbiAgX3Byb3RvLmdldENoaWxkRmFjZXRzID0gZnVuY3Rpb24gZ2V0Q2hpbGRGYWNldHMoZGF0YSwgbGV2ZWwsIGFycikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGRzID0gc2VsZi5maWVsZHM7XG4gICAgdmFyIGxlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoIDwgbGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIGZpZWxkID0gZmllbGRzW2xldmVsIC0gMV07XG4gICAgdmFyIHZhbHVlcyA9IHNlbGYuZ2V0RmllbGRWYWx1ZXMoZmllbGQsIGRhdGEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBjb25kaXRpb25zID0gW3tcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICB9XTtcbiAgICAgIHZhciBmaWx0ZXIgPSBzZWxmLmdldEZpbHRlcihjb25kaXRpb25zKTtcbiAgICAgIHZhciBzdWJEYXRhID0gZGF0YS5maWx0ZXIoZmlsdGVyKTtcblxuICAgICAgaWYgKHN1YkRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmYWNldCA9IHtcbiAgICAgICAgICB0eXBlOiBzZWxmLnR5cGUsXG4gICAgICAgICAgY29sVmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGNvbEZpZWxkOiBmaWVsZCxcbiAgICAgICAgICBjb2xJbmRleDogaW5kZXgsXG4gICAgICAgICAgcm93czogc2VsZi5nZXRSb3dzKCksXG4gICAgICAgICAgcm93SW5kZXg6IGxldmVsLFxuICAgICAgICAgIGRhdGE6IHN1YkRhdGEsXG4gICAgICAgICAgY2hpbGRyZW46IHNlbGYuZ2V0Q2hpbGRGYWNldHMoc3ViRGF0YSwgbGV2ZWwgKyAxLCBhcnIpXG4gICAgICAgIH07XG4gICAgICAgIHJzdC5wdXNoKGZhY2V0KTtcbiAgICAgICAgYXJyLnB1c2goZmFjZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH07IC8vIOiuvue9riByZWdpb25cblxuXG4gIF9wcm90by5zZXRSZWdpb24gPSBmdW5jdGlvbiBzZXRSZWdpb24oZmFjZXRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZm9yY2VDb2xJbmRleChmYWNldHMpO1xuICAgIGZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNldCkge1xuICAgICAgZmFjZXQucmVnaW9uID0gc2VsZi5nZXRSZWdpb24oZmFjZXQucm93cywgZmFjZXQuY29scywgZmFjZXQuY29sSW5kZXgsIGZhY2V0LnJvd0luZGV4KTtcbiAgICB9KTtcbiAgfTsgLy8gc2V0IGNvbHVtbiBpbmRleCBvZiBmYWNldHNcblxuXG4gIF9wcm90by5mb3JjZUNvbEluZGV4ID0gZnVuY3Rpb24gZm9yY2VDb2xJbmRleChmYWNldHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlYWZzID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgIGlmIChzZWxmLmlzTGVhZihmYWNldCkpIHtcbiAgICAgICAgbGVhZnMucHVzaChmYWNldCk7XG4gICAgICAgIGZhY2V0LmNvbEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGVhZnMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgIGZhY2V0LmNvbHMgPSBsZWFmcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdmFyIG1heExldmVsID0gc2VsZi5maWVsZHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heExldmVsIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsZXZlbEZhY2V0cyA9IHNlbGYuZ2V0RmFjZXRzQnlMZXZlbChmYWNldHMsIGkpOyAvLyB2YXIgeUluZGV4ID0gbWF4TGV2ZWwgLSBpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsRmFjZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmYWNldCA9IGxldmVsRmFjZXRzW2pdO1xuXG4gICAgICAgIGlmICghc2VsZi5pc0xlYWYoZmFjZXQpKSB7XG4gICAgICAgICAgZmFjZXQub3JpZ2luQ29sSW5kZXggPSBmYWNldC5jb2xJbmRleDtcbiAgICAgICAgICBmYWNldC5jb2xJbmRleCA9IHNlbGYuZ2V0UmVnaW9uSW5kZXgoZmFjZXQuY2hpbGRyZW4pO1xuICAgICAgICAgIGZhY2V0LmNvbHMgPSBsZWFmcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGdldCBmYWNldCB1c2UgbGV2ZWxcblxuXG4gIF9wcm90by5nZXRGYWNldHNCeUxldmVsID0gZnVuY3Rpb24gZ2V0RmFjZXRzQnlMZXZlbChmYWNldHMsIGxldmVsKSB7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGZhY2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNldCkge1xuICAgICAgaWYgKGZhY2V0LnJvd0luZGV4ID09PSBsZXZlbCkge1xuICAgICAgICByc3QucHVzaChmYWNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfTsgLy8gc2V0IGZhY2V0cyByZWdpb25cblxuXG4gIF9wcm90by5nZXRSZWdpb24gPSBmdW5jdGlvbiBnZXRSZWdpb24ocm93cywgY29scywgeEluZGV4LCB5SW5kZXgpIHtcbiAgICB2YXIgeFdpZHRoID0gMSAvIGNvbHM7IC8vIHjovbTmlrnlkJHnmoTmr4/kuKrliIbpnaLnmoTlgY/np7tcblxuICAgIHZhciB5V2lkdGggPSAxIC8gcm93czsgLy8geei9tOaWueWQkeeahOavj+S4quWIhumdoueahOWBj+enu1xuXG4gICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgeDogeFdpZHRoICogeEluZGV4LFxuICAgICAgeTogeVdpZHRoICogeUluZGV4XG4gICAgfTtcbiAgICB2YXIgZW5kID0ge1xuICAgICAgeDogc3RhcnQueCArIHhXaWR0aCxcbiAgICAgIHk6IHN0YXJ0LnkgKyB5V2lkdGggKiAyIC8gMyAvLyDpooTnlZkxLzPnmoTnqbrpmpnvvIzmlrnkvr/mt7vliqDov57mjqXnur9cblxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgfTsgLy8gaWYgdGhlIGZhY2V0IGhhcyBjaGlsZHJlbiAsIG1ha2UgaXQncyBjb2x1bW4gaW5kZXggaW4gdGhlIG1pZGRsZSBvZiBpdCdzIGNoaWxkcmVuXG5cblxuICBfcHJvdG8uZ2V0UmVnaW9uSW5kZXggPSBmdW5jdGlvbiBnZXRSZWdpb25JbmRleChjaGlsZHJlbikge1xuICAgIHZhciBmaXJzdCA9IGNoaWxkcmVuWzBdO1xuICAgIHZhciBsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIChsYXN0LmNvbEluZGV4IC0gZmlyc3QuY29sSW5kZXgpIC8gMiArIGZpcnN0LmNvbEluZGV4O1xuICB9OyAvLyBpcyAgYSBsZWFmIHdpdGhvdXQgY2hpbGRyZW5cblxuXG4gIF9wcm90by5pc0xlYWYgPSBmdW5jdGlvbiBpc0xlYWYoZmFjZXQpIHtcbiAgICByZXR1cm4gIWZhY2V0LmNoaWxkcmVuIHx8ICFmYWNldC5jaGlsZHJlbi5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnNldFhBeGlzID0gZnVuY3Rpb24gc2V0WEF4aXMoeEZpZWxkLCBheGVzLCBmYWNldCkge1xuICAgIC8vIOW9k+aYr+acgOWQjuS4gOihjOaIluiAheS4i+mdouayoeaciSB2aWV3IOaXtuaWh+acrOS4jeaYvuekulxuICAgIGlmIChmYWNldC5yb3dJbmRleCAhPT0gZmFjZXQucm93cyAtIDEpIHtcbiAgICAgIGF4ZXNbeEZpZWxkXS5sYWJlbCA9IG51bGw7XG4gICAgICBheGVzW3hGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgIH1cbiAgfTsgLy8g6K6+572uIHkg5Z2Q5qCH6L2055qE5paH5pys44CBdGl0bGUg5piv5ZCm5pi+56S6XG5cblxuICBfcHJvdG8uc2V0WUF4aXMgPSBmdW5jdGlvbiBzZXRZQXhpcyh5RmllbGQsIGF4ZXMsIGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0Lm9yaWdpbkNvbEluZGV4ICE9PSAwICYmIGZhY2V0LmNvbEluZGV4ICE9PSAwKSB7XG4gICAgICBheGVzW3lGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgICAgYXhlc1t5RmllbGRdLmxhYmVsID0gbnVsbDtcbiAgICB9XG4gIH07IC8vIOe7mOWItuWujOaIkOWQjlxuXG5cbiAgX3Byb3RvLm9uUGFpbnQgPSBmdW5jdGlvbiBvblBhaW50KCkge1xuICAgIF9CYXNlLnByb3RvdHlwZS5vblBhaW50LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmdyb3VwLmNsZWFyKCk7XG5cbiAgICBpZiAodGhpcy5mYWNldHMgJiYgdGhpcy5saW5lKSB7XG4gICAgICB0aGlzLmRyYXdMaW5lcyh0aGlzLmZhY2V0cywgdGhpcy5ncm91cCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kcmF3TGluZXMgPSBmdW5jdGlvbiBkcmF3TGluZXMoZmFjZXRzLCBncm91cCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGluZUdyb3VwID0gZ3JvdXAuYWRkR3JvdXAoKTtcbiAgICBmYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgIGlmICghc2VsZi5pc0xlYWYoZmFjZXQpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGZhY2V0LmNoaWxkcmVuO1xuXG4gICAgICAgIHNlbGYuX2FkZEZhY2V0TGluZXMoZmFjZXQsIGNoaWxkcmVuLCBsaW5lR3JvdXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9OyAvLyBhZGQgbGluZXMgd2l0aCBpdCdzIGNoaWxkcmVuXG5cblxuICBfcHJvdG8uX2FkZEZhY2V0TGluZXMgPSBmdW5jdGlvbiBfYWRkRmFjZXRMaW5lcyhmYWNldCwgY2hpbGRyZW4sIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gZmFjZXQudmlldztcbiAgICB2YXIgcmVnaW9uID0gdmlldy5nZXRWaWV3UmVnaW9uKCk7XG4gICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgeDogcmVnaW9uLnN0YXJ0LnggKyAocmVnaW9uLmVuZC54IC0gcmVnaW9uLnN0YXJ0LngpIC8gMixcbiAgICAgIHk6IHJlZ2lvbi5zdGFydC55XG4gICAgfTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJGYWNldCkge1xuICAgICAgdmFyIHN1YlJlZ2lvbiA9IHN1YkZhY2V0LnZpZXcuZ2V0Vmlld1JlZ2lvbigpO1xuICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgeDogc3ViUmVnaW9uLnN0YXJ0LnggKyAoc3ViUmVnaW9uLmVuZC54IC0gc3ViUmVnaW9uLnN0YXJ0LngpIC8gMixcbiAgICAgICAgeTogc3ViUmVnaW9uLmVuZC55XG4gICAgICB9O1xuICAgICAgdmFyIG1pZGRsZTEgPSB7XG4gICAgICAgIHg6IHN0YXJ0LngsXG4gICAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAvIDJcbiAgICAgIH07XG4gICAgICB2YXIgbWlkZGxlMiA9IHtcbiAgICAgICAgeDogZW5kLngsXG4gICAgICAgIHk6IG1pZGRsZTEueVxuICAgICAgfTtcblxuICAgICAgc2VsZi5fZHJhd0xpbmUoW3N0YXJ0LCBtaWRkbGUxLCBtaWRkbGUyLCBlbmRdLCBncm91cCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRQYXRoID0gZnVuY3Rpb24gX2dldFBhdGgocG9pbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHNtb290aCA9IHNlbGYubGluZVNtb290aDtcblxuICAgIGlmIChzbW9vdGgpIHtcbiAgICAgIHBhdGgucHVzaChbJ00nLCBwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnldKTtcbiAgICAgIHBhdGgucHVzaChbJ0MnLCBwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnksIHBvaW50c1syXS54LCBwb2ludHNbMl0ueSwgcG9pbnRzWzNdLngsIHBvaW50c1szXS55XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFsnTScsIHBvaW50LngsIHBvaW50LnldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goWydMJywgcG9pbnQueCwgcG9pbnQueV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTsgLy8gZHJhdyBsaW5lIHdpZHRoIHBvaW50c1xuXG5cbiAgX3Byb3RvLl9kcmF3TGluZSA9IGZ1bmN0aW9uIF9kcmF3TGluZShwb2ludHMsIGdyb3VwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHBhdGggPSBzZWxmLl9nZXRQYXRoKHBvaW50cyk7XG5cbiAgICB2YXIgbGluZSA9IHNlbGYubGluZTtcbiAgICBncm91cC5hZGRTaGFwZSgncGF0aCcsIHtcbiAgICAgIGF0dHJzOiBhc3NpZ24oe1xuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9LCBsaW5lKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUcmVlO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlO1xuXG4vKioqLyB9KSxcbi8qIDQ2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IG1pcnJvciBmYWNldHNcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzg4KTtcblxudmFyIE1pcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0xpc3QpIHtcbiAgX2luaGVyaXRzTG9vc2UoTWlycm9yLCBfTGlzdCk7XG5cbiAgZnVuY3Rpb24gTWlycm9yKCkge1xuICAgIHJldHVybiBfTGlzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWlycm9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9MaXN0LnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcudHlwZSA9ICdtaXJyb3InO1xuICAgIHRoaXMudHJhbnNwb3NlID0gZmFsc2U7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYudHJhbnNwb3NlKSB7XG4gICAgICBzZWxmLmNvbHMgPSAyO1xuICAgICAgc2VsZi5yb3dzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jb2xzID0gMTtcbiAgICAgIHNlbGYucm93cyA9IDI7XG4gICAgfVxuXG4gICAgX0xpc3QucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYmVmb3JlUHJvY2Vzc1ZpZXcgPSBmdW5jdGlvbiBiZWZvcmVQcm9jZXNzVmlldyh2aWV3LCBmYWNldCkge1xuICAgIGlmICh0aGlzLnRyYW5zcG9zZSkge1xuICAgICAgaWYgKGZhY2V0LmNvbEluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICB2aWV3LmNvb3JkKCkudHJhbnNwb3NlKCkuc2NhbGUoLTEsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5jb29yZCgpLnRyYW5zcG9zZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFjZXQucm93SW5kZXggJSAyICE9PSAwKSB7XG4gICAgICAgIHZpZXcuY29vcmQoKS5zY2FsZSgxLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uIHJlbmRlclRpdGxlKHZpZXcsIGZhY2V0KSB7XG4gICAgaWYgKHRoaXMudHJhbnNwb3NlKSB7XG4gICAgICB0aGlzLmRyYXdDb2xUaXRsZSh2aWV3LCBmYWNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd1Jvd1RpdGxlKHZpZXcsIGZhY2V0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNldFhBeGlzID0gZnVuY3Rpb24gc2V0WEF4aXMoeEZpZWxkLCBheGVzLCBmYWNldCkge1xuICAgIC8vIOW9k+aYr+acgOWQjuS4gOihjOaIluiAheS4i+mdouayoeaciSB2aWV3IOaXtuaWh+acrOS4jeaYvuekulxuICAgIGlmIChmYWNldC5jb2xJbmRleCA9PT0gMSB8fCBmYWNldC5yb3dJbmRleCA9PT0gMSkge1xuICAgICAgYXhlc1t4RmllbGRdLmxhYmVsID0gbnVsbDtcbiAgICAgIGF4ZXNbeEZpZWxkXS50aXRsZSA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zZXRZQXhpcyA9IGZ1bmN0aW9uIHNldFlBeGlzKClcbiAgLyogeUZpZWxkLCBheGVzLCBmYWNldCAqL1xuICB7fTtcblxuICByZXR1cm4gTWlycm9yO1xufShMaXN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaXJyb3I7XG5cbi8qKiovIH0pLFxuLyogNDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVXNlIG1hdHJpY2VzIHRvIGNvbXBhcmUgZGlmZmVyZW50IGZpZWxkc1xuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBSZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODcpO1xuXG52YXIgTWF0cml4ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVjdCkge1xuICBfaW5oZXJpdHNMb29zZShNYXRyaXgsIF9SZWN0KTtcblxuICBmdW5jdGlvbiBNYXRyaXgoKSB7XG4gICAgcmV0dXJuIF9SZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNYXRyaXgucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX1JlY3QucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ21hdHJpeCc7XG4gICAgY2ZnLnNob3dUaXRsZSA9IGZhbHNlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmdlbmVyYXRlRmFjZXRzID0gZnVuY3Rpb24gZ2VuZXJhdGVGYWNldHMoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGRzID0gc2VsZi5maWVsZHM7XG4gICAgdmFyIHJvd3MgPSBmaWVsZHMubGVuZ3RoO1xuICAgIHZhciBjb2xzID0gcm93czsgLy8g55+p6Zi15Lit6KGM5YiX55u4562J77yM562J5LqO5oyH5a6a55qE5a2X5q615Liq5pWwXG5cbiAgICB2YXIgcnN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7IGkrKykge1xuICAgICAgdmFyIGNvbEZpZWxkID0gZmllbGRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd3M7IGorKykge1xuICAgICAgICB2YXIgcm93RmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciBmYWNldCA9IHtcbiAgICAgICAgICB0eXBlOiBzZWxmLnR5cGUsXG4gICAgICAgICAgY29sVmFsdWU6IGNvbEZpZWxkLFxuICAgICAgICAgIHJvd1ZhbHVlOiByb3dGaWVsZCxcbiAgICAgICAgICBjb2xGaWVsZDogY29sRmllbGQsXG4gICAgICAgICAgcm93RmllbGQ6IHJvd0ZpZWxkLFxuICAgICAgICAgIGNvbEluZGV4OiBpLFxuICAgICAgICAgIHJvd0luZGV4OiBqLFxuICAgICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHJlZ2lvbjogc2VsZi5nZXRSZWdpb24ocm93cywgY29scywgaSwgailcbiAgICAgICAgfTtcbiAgICAgICAgcnN0LnB1c2goZmFjZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07IC8vIOiuvue9riB4IOWdkOagh+i9tOeahOaWh+acrOOAgXRpdGxlIOaYr+WQpuaYvuekulxuXG5cbiAgX3Byb3RvLnNldFhBeGlzID0gZnVuY3Rpb24gc2V0WEF4aXMoeEZpZWxkLCBheGVzLCBmYWNldCkge1xuICAgIGlmIChmYWNldC5yb3dJbmRleCAhPT0gZmFjZXQucm93cyAtIDEpIHtcbiAgICAgIGF4ZXNbeEZpZWxkXS50aXRsZSA9IG51bGw7XG4gICAgICBheGVzW3hGaWVsZF0ubGFiZWwgPSBudWxsO1xuICAgIH1cbiAgfTsgLy8g6K6+572uIHkg5Z2Q5qCH6L2055qE5paH5pys44CBdGl0bGUg5piv5ZCm5pi+56S6XG5cblxuICBfcHJvdG8uc2V0WUF4aXMgPSBmdW5jdGlvbiBzZXRZQXhpcyh5RmllbGQsIGF4ZXMsIGZhY2V0KSB7XG4gICAgaWYgKGZhY2V0LmNvbEluZGV4ICE9PSAwKSB7XG4gICAgICBheGVzW3lGaWVsZF0udGl0bGUgPSBudWxsO1xuICAgICAgYXhlc1t5RmllbGRdLmxhYmVsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1hdHJpeDtcbn0oUmVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKioqLyB9KSxcbi8qIDQ2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgSW50ZXJhY3Rpb25cbiAqIEBhdXRob3IgbGV1bmd3ZW5zZW5AZ21haWwuY29tXG4gKi9cbnZhciBHMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcyKTtcblxudmFyIENoYXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBJbnRlcmFjdGlvbnMgPSB7XG4gIEJhc2U6IF9fd2VicGFja19yZXF1aXJlX18oMTcxKSxcbiAgQnJ1c2g6IF9fd2VicGFja19yZXF1aXJlX18oNDY3KSxcbiAgRHJhZzogX193ZWJwYWNrX3JlcXVpcmVfXyg0NjgpLFxuICBTY3JvbGxCYXI6IF9fd2VicGFja19yZXF1aXJlX18oNDcwKSxcbiAgU2hhcGVTZWxlY3Q6IF9fd2VicGFja19yZXF1aXJlX18oNDcyKSxcbiAgU2xpZGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3MyksXG4gIFpvb206IF9fd2VicGFja19yZXF1aXJlX18oNDc1KVxufTtcbkcyLl9JbnRlcmFjdGlvbnMgPSB7fTtcblxuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBjb25zdHJ1Y3Rvcikge1xuICBHMi5fSW50ZXJhY3Rpb25zW3R5cGVdID0gY29uc3RydWN0b3I7XG59O1xuXG5HMi5nZXRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBHMi5fSW50ZXJhY3Rpb25zW3R5cGVdO1xufTsgLy8gYmluZGluZyBvbiBWaWV3XG5cblxuQ2hhcnQucHJvdG90eXBlLmdldEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZiAoIW1lLl9pbnRlcmFjdGlvbnMpIHtcbiAgICBtZS5faW50ZXJhY3Rpb25zID0ge307XG4gIH1cblxuICByZXR1cm4gbWUuX2ludGVyYWN0aW9ucztcbn07XG5cbkNoYXJ0LnByb3RvdHlwZS5fc2V0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgaW50ZXJhY3Rpb24pIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGludGVyYWN0aW9ucyA9IG1lLmdldEludGVyYWN0aW9ucygpO1xuXG4gIGlmIChpbnRlcmFjdGlvbnNbdHlwZV0gJiYgaW50ZXJhY3Rpb25zW3R5cGVdICE9PSBpbnRlcmFjdGlvbikge1xuICAgIC8vIG9ubHkgb25lIGludGVyYWN0aW9uIGZvciBhIGtleVxuICAgIGludGVyYWN0aW9uc1t0eXBlXS5kZXN0cm95KCk7XG4gIH1cblxuICBpbnRlcmFjdGlvbnNbdHlwZV0gPSBpbnRlcmFjdGlvbjtcbn07XG5cbkNoYXJ0LnByb3RvdHlwZS5jbGVhckludGVyYWN0aW9uID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIGludGVyYWN0aW9ucyA9IG1lLmdldEludGVyYWN0aW9ucygpO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKGludGVyYWN0aW9uc1t0eXBlXSkge1xuICAgICAgaW50ZXJhY3Rpb25zW3R5cGVdLl9yZXNldCgpO1xuXG4gICAgICBpbnRlcmFjdGlvbnNbdHlwZV0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnRlcmFjdGlvbnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgVXRpbC5lYWNoKGludGVyYWN0aW9ucywgZnVuY3Rpb24gKGludGVyYWN0aW9uLCBrZXkpIHtcbiAgICAgIGludGVyYWN0aW9uLl9yZXNldCgpO1xuXG4gICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgaW50ZXJhY3Rpb25zW2tleV07XG4gICAgfSk7XG4gIH1cbn07XG5cbkNoYXJ0LnByb3RvdHlwZS5pbnRlcmFjdCA9IENoYXJ0LnByb3RvdHlwZS5pbnRlcmFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBjZmcpIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIEN0b3IgPSBHMi5nZXRJbnRlcmFjdGlvbih0eXBlKTtcbiAgdmFyIGludGVyYWN0aW9uID0gbmV3IEN0b3IoY2ZnLCBtZSk7XG5cbiAgbWUuX3NldEludGVyYWN0aW9uKHR5cGUsIGludGVyYWN0aW9uKTtcblxuICByZXR1cm4gbWU7XG59O1xuXG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdicnVzaCcsIEludGVyYWN0aW9ucy5CcnVzaCk7XG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdCcnVzaCcsIEludGVyYWN0aW9ucy5CcnVzaCk7XG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdkcmFnJywgSW50ZXJhY3Rpb25zLkRyYWcpO1xuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbignRHJhZycsIEludGVyYWN0aW9ucy5EcmFnKTtcbkcyLnJlZ2lzdGVySW50ZXJhY3Rpb24oJ3pvb20nLCBJbnRlcmFjdGlvbnMuWm9vbSk7XG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdab29tJywgSW50ZXJhY3Rpb25zLlpvb20pO1xuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbignc2Nyb2xsLWJhcicsIEludGVyYWN0aW9ucy5TY3JvbGxCYXIpO1xuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbignU2Nyb2xsQmFyJywgSW50ZXJhY3Rpb25zLlNjcm9sbEJhcik7XG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdzaGFwZS1zZWxlY3QnLCBJbnRlcmFjdGlvbnMuU2hhcGVTZWxlY3QpO1xuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbignU2hhcGVTZWxlY3QnLCBJbnRlcmFjdGlvbnMuU2hhcGVTZWxlY3QpO1xuRzIucmVnaXN0ZXJJbnRlcmFjdGlvbignc2xpZGVyJywgSW50ZXJhY3Rpb25zLlNsaWRlcik7XG5HMi5yZWdpc3RlckludGVyYWN0aW9uKCdTbGlkZXInLCBJbnRlcmFjdGlvbnMuU2xpZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb25zO1xuXG4vKioqLyB9KSxcbi8qIDQ2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEludGVyYWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzEpOyAvLyBjb25zdCBHMiA9IHJlcXVpcmUoJy4uL2NvcmUuanMnKTtcblxuXG52YXIgQlJVU0hfVFlQRVMgPSBbJ1gnLCAnWScsICdYWScsICdQT0xZR09OJ107XG52YXIgREVGQVVMVF9UWVBFID0gJ1hZJztcblxudmFyIEJydXNoID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW50ZXJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoQnJ1c2gsIF9JbnRlcmFjdGlvbik7XG5cbiAgdmFyIF9wcm90byA9IEJydXNoLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9JbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIHR5cGU6IERFRkFVTFRfVFlQRSxcbiAgICAgIHN0YXJ0UG9pbnQ6IG51bGwsXG4gICAgICBicnVzaGluZzogZmFsc2UsXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBicnVzaFNoYXBlOiBudWxsLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgcG9seWdvblBhdGg6IG51bGwsXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiAnI0M1RDRFQicsXG4gICAgICAgIG9wYWNpdHk6IDAuMyxcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6ICcjODJBNkREJ1xuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICBkcmFnT2ZmWDogMCxcbiAgICAgIGRyYWdPZmZZOiAwLFxuICAgICAgaW5QbG90OiB0cnVlLFxuICAgICAgeEZpZWxkOiBudWxsLFxuICAgICAgeUZpZWxkOiBudWxsXG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQnJ1c2goY2ZnLCB2aWV3KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCBjZmcsIHZpZXcpIHx8IHRoaXM7XG5cbiAgICB2YXIgbWUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIG1lLmZpbHRlciA9ICFtZS5kcmFnZ2FibGU7XG4gICAgbWUudHlwZSA9IG1lLnR5cGUudG9VcHBlckNhc2UoKTtcbiAgICBtZS5jaGFydCA9IHZpZXc7XG5cbiAgICBpZiAoQlJVU0hfVFlQRVMuaW5kZXhPZihtZS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIG1lLnR5cGUgPSBERUZBVUxUX1RZUEU7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcblxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHZhciBwbG90UmFuZ2U7XG4gICAgICBjYW52YXMuZ2V0KCdjaGlsZHJlbicpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmdldCgndHlwZScpID09PSAncGxvdEJhY2snKSB7XG4gICAgICAgICAgcGxvdFJhbmdlID0gY2hpbGQuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIG1lLnBsb3QgPSB7XG4gICAgICAgIHN0YXJ0OiBwbG90UmFuZ2UuYmwsXG4gICAgICAgIGVuZDogcGxvdFJhbmdlLnRyXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh2aWV3KSB7XG4gICAgICB2YXIgY29vcmQgPSB2aWV3LmdldCgnY29vcmQnKTtcbiAgICAgIG1lLnBsb3QgPSB7XG4gICAgICAgIHN0YXJ0OiBjb29yZC5zdGFydCxcbiAgICAgICAgZW5kOiBjb29yZC5lbmRcbiAgICAgIH07XG5cbiAgICAgIHZhciB4U2NhbGVzID0gdmlldy5fZ2V0U2NhbGVzKCd4Jyk7XG5cbiAgICAgIHZhciB5U2NhbGVzID0gdmlldy5fZ2V0U2NhbGVzKCd5Jyk7XG5cbiAgICAgIG1lLnhTY2FsZSA9IG1lLnhGaWVsZCA/IHhTY2FsZXNbbWUueEZpZWxkXSA6IHZpZXcuZ2V0WFNjYWxlKCk7XG4gICAgICBtZS55U2NhbGUgPSBtZS55RmllbGQgPyB5U2NhbGVzW21lLnlGaWVsZF0gOiB2aWV3LmdldFlTY2FsZXMoKVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gb25CdXJzaHN0YXJ0KCkgeyB9XG4gIC8vIG9uQnJ1c2htb3ZlKCkgeyB9XG4gIC8vIG9uQnJ1c2hlbmQoKSB7fVxuICAvLyBvbkRyYWdzdGFydCgpIHt9XG4gIC8vIG9uRHJhZ21vdmUoKSB7fVxuICAvLyBvbkRyYWdlbmQoKSB7fVxuXG5cbiAgX3Byb3RvLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoZXYpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBtZS5jYW52YXMsXG4gICAgICAgIHR5cGUgPSBtZS50eXBlLFxuICAgICAgICBicnVzaFNoYXBlID0gbWUuYnJ1c2hTaGFwZTtcbiAgICBpZiAoIXR5cGUpIHJldHVybjtcbiAgICB2YXIgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IGV2Lm9mZnNldFgsXG4gICAgICB5OiBldi5vZmZzZXRZXG4gICAgfTtcbiAgICBpZiAoIXN0YXJ0UG9pbnQueCkgcmV0dXJuO1xuICAgIHZhciBpc0luUGxvdCA9IG1lLnBsb3QgJiYgbWUuaW5QbG90O1xuICAgIHZhciBjYW52YXNET00gPSBjYW52YXMuZ2V0KCdjYW52YXNET00nKTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGNhbnZhcy5nZXQoJ3BpeGVsUmF0aW8nKTtcbiAgICBpZiAobWUuc2VsZWN0aW9uKSBtZS5zZWxlY3Rpb24gPSBudWxsO1xuXG4gICAgaWYgKG1lLmRyYWdnYWJsZSAmJiBicnVzaFNoYXBlICYmICFicnVzaFNoYXBlLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgIC8vIGFsbG93IGRyYWcgdGhlIGJydXNoU2hhcGVcbiAgICAgIGlmIChicnVzaFNoYXBlLmlzSGl0KHN0YXJ0UG9pbnQueCAqIHBpeGVsUmF0aW8sIHN0YXJ0UG9pbnQueSAqIHBpeGVsUmF0aW8pKSB7XG4gICAgICAgIGNhbnZhc0RPTS5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgICAgIG1lLnNlbGVjdGlvbiA9IGJydXNoU2hhcGU7XG4gICAgICAgIG1lLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ1gnKSB7XG4gICAgICAgICAgbWUuZHJhZ29mZlggPSBzdGFydFBvaW50LnggLSBicnVzaFNoYXBlLmF0dHIoJ3gnKTtcbiAgICAgICAgICBtZS5kcmFnb2ZmWSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1knKSB7XG4gICAgICAgICAgbWUuZHJhZ29mZlggPSAwO1xuICAgICAgICAgIG1lLmRyYWdvZmZZID0gc3RhcnRQb2ludC55IC0gYnJ1c2hTaGFwZS5hdHRyKCd5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1hZJykge1xuICAgICAgICAgIG1lLmRyYWdvZmZYID0gc3RhcnRQb2ludC54IC0gYnJ1c2hTaGFwZS5hdHRyKCd4Jyk7XG4gICAgICAgICAgbWUuZHJhZ29mZlkgPSBzdGFydFBvaW50LnkgLSBicnVzaFNoYXBlLmF0dHIoJ3knKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUE9MWUdPTicpIHtcbiAgICAgICAgICB2YXIgYm94ID0gYnJ1c2hTaGFwZS5nZXRCQm94KCk7XG4gICAgICAgICAgbWUuZHJhZ29mZlggPSBzdGFydFBvaW50LnggLSBib3gubWluWDtcbiAgICAgICAgICBtZS5kcmFnb2ZmWSA9IHN0YXJ0UG9pbnQueSAtIGJveC5taW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5QbG90KSB7Ly8gbWUuc2VsZWN0aW9uLmF0dHIoJ2NsaXAnLCBjYW52YXMuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICAgICAgLy8gICBhdHRyczoge1xuICAgICAgICAgIC8vICAgICB4OiB0aGlzLnBsb3Quc3RhcnQueCxcbiAgICAgICAgICAvLyAgICAgeTogdGhpcy5wbG90LmVuZC55LFxuICAgICAgICAgIC8vICAgICB3aWR0aDogdGhpcy5wbG90LmVuZC54IC0gdGhpcy5wbG90LnN0YXJ0LngsXG4gICAgICAgICAgLy8gICAgIGhlaWdodDogdGhpcy5wbG90LnN0YXJ0LnkgLSB0aGlzLnBsb3QuZW5kLnksXG4gICAgICAgICAgLy8gICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgICAvLyAgICAgZmlsbE9wYWNpdHk6IDBcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5vbkRyYWdzdGFydCAmJiBtZS5vbkRyYWdzdGFydChldik7XG4gICAgICB9XG5cbiAgICAgIG1lLnByZVBvaW50ID0gc3RhcnRQb2ludDtcbiAgICB9XG5cbiAgICBpZiAoIW1lLmRyYWdnaW5nKSB7XG4gICAgICAvLyBicnVzaCBzdGFydFxuICAgICAgbWUub25CcnVzaHN0YXJ0ICYmIG1lLm9uQnJ1c2hzdGFydChzdGFydFBvaW50KTtcbiAgICAgIHZhciBjb250YWluZXIgPSBtZS5jb250YWluZXI7XG5cbiAgICAgIGlmIChpc0luUGxvdCkge1xuICAgICAgICB2YXIgX21lJHBsb3QgPSBtZS5wbG90LFxuICAgICAgICAgICAgc3RhcnQgPSBfbWUkcGxvdC5zdGFydCxcbiAgICAgICAgICAgIGVuZCA9IF9tZSRwbG90LmVuZDtcbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQueCA8IHN0YXJ0LnggfHwgc3RhcnRQb2ludC54ID4gZW5kLnggfHwgc3RhcnRQb2ludC55IDwgZW5kLnkgfHwgc3RhcnRQb2ludC55ID4gc3RhcnQueSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNET00uc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICBtZS5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcbiAgICAgIG1lLmJydXNoU2hhcGUgPSBudWxsO1xuICAgICAgbWUuYnJ1c2hpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIgPSBjYW52YXMuYWRkR3JvdXAoe1xuICAgICAgICAgIHpJbmRleDogNSAvLyB1cHBlclxuXG4gICAgICAgIH0pO1xuICAgICAgICBjb250YWluZXIuaW5pdFRyYW5zZm9ybSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIG1lLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIGlmICh0eXBlID09PSAnUE9MWUdPTicpIG1lLnBvbHlnb25QYXRoID0gXCJNIFwiICsgc3RhcnRQb2ludC54ICsgXCIgXCIgKyBzdGFydFBvaW50Lnk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzcyhldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGJydXNoaW5nID0gbWUuYnJ1c2hpbmcsXG4gICAgICAgIGRyYWdnaW5nID0gbWUuZHJhZ2dpbmcsXG4gICAgICAgIHR5cGUgPSBtZS50eXBlLFxuICAgICAgICBwbG90ID0gbWUucGxvdCxcbiAgICAgICAgc3RhcnRQb2ludCA9IG1lLnN0YXJ0UG9pbnQsXG4gICAgICAgIHhTY2FsZSA9IG1lLnhTY2FsZSxcbiAgICAgICAgeVNjYWxlID0gbWUueVNjYWxlLFxuICAgICAgICBjYW52YXMgPSBtZS5jYW52YXM7XG5cbiAgICBpZiAoIWJydXNoaW5nICYmICFkcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50UG9pbnQgPSB7XG4gICAgICB4OiBldi5vZmZzZXRYLFxuICAgICAgeTogZXYub2Zmc2V0WVxuICAgIH07XG4gICAgdmFyIGNhbnZhc0RPTSA9IGNhbnZhcy5nZXQoJ2NhbnZhc0RPTScpO1xuXG4gICAgaWYgKGJydXNoaW5nKSB7XG4gICAgICBjYW52YXNET00uc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICB2YXIgc3RhcnQgPSBwbG90LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHBsb3QuZW5kO1xuICAgICAgdmFyIHBvbHlnb25QYXRoID0gbWUucG9seWdvblBhdGg7XG4gICAgICB2YXIgYnJ1c2hTaGFwZSA9IG1lLmJydXNoU2hhcGU7XG4gICAgICB2YXIgY29udGFpbmVyID0gbWUuY29udGFpbmVyO1xuXG4gICAgICBpZiAobWUucGxvdCAmJiBtZS5pblBsb3QpIHtcbiAgICAgICAgY3VycmVudFBvaW50ID0gbWUuX2xpbWl0Q29vcmRTY29wZShjdXJyZW50UG9pbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdFN0YXJ0WDtcbiAgICAgIHZhciByZWN0U3RhcnRZO1xuICAgICAgdmFyIHJlY3RXaWR0aDtcbiAgICAgIHZhciByZWN0SGVpZ2h0O1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ1knKSB7XG4gICAgICAgIHJlY3RTdGFydFggPSBzdGFydC54O1xuICAgICAgICByZWN0U3RhcnRZID0gY3VycmVudFBvaW50LnkgPj0gc3RhcnRQb2ludC55ID8gc3RhcnRQb2ludC55IDogY3VycmVudFBvaW50Lnk7XG4gICAgICAgIHJlY3RXaWR0aCA9IE1hdGguYWJzKHN0YXJ0LnggLSBlbmQueCk7XG4gICAgICAgIHJlY3RIZWlnaHQgPSBNYXRoLmFicyhzdGFydFBvaW50LnkgLSBjdXJyZW50UG9pbnQueSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdYJykge1xuICAgICAgICByZWN0U3RhcnRYID0gY3VycmVudFBvaW50LnggPj0gc3RhcnRQb2ludC54ID8gc3RhcnRQb2ludC54IDogY3VycmVudFBvaW50Lng7XG4gICAgICAgIHJlY3RTdGFydFkgPSBlbmQueTtcbiAgICAgICAgcmVjdFdpZHRoID0gTWF0aC5hYnMoc3RhcnRQb2ludC54IC0gY3VycmVudFBvaW50LngpO1xuICAgICAgICByZWN0SGVpZ2h0ID0gTWF0aC5hYnMoZW5kLnkgLSBzdGFydC55KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1hZJykge1xuICAgICAgICBpZiAoY3VycmVudFBvaW50LnggPj0gc3RhcnRQb2ludC54KSB7XG4gICAgICAgICAgcmVjdFN0YXJ0WCA9IHN0YXJ0UG9pbnQueDtcbiAgICAgICAgICByZWN0U3RhcnRZID0gY3VycmVudFBvaW50LnkgPj0gc3RhcnRQb2ludC55ID8gc3RhcnRQb2ludC55IDogY3VycmVudFBvaW50Lnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdFN0YXJ0WCA9IGN1cnJlbnRQb2ludC54O1xuICAgICAgICAgIHJlY3RTdGFydFkgPSBjdXJyZW50UG9pbnQueSA+PSBzdGFydFBvaW50LnkgPyBzdGFydFBvaW50LnkgOiBjdXJyZW50UG9pbnQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3RXaWR0aCA9IE1hdGguYWJzKHN0YXJ0UG9pbnQueCAtIGN1cnJlbnRQb2ludC54KTtcbiAgICAgICAgcmVjdEhlaWdodCA9IE1hdGguYWJzKHN0YXJ0UG9pbnQueSAtIGN1cnJlbnRQb2ludC55KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BPTFlHT04nKSB7XG4gICAgICAgIHBvbHlnb25QYXRoICs9IFwiTCBcIiArIGN1cnJlbnRQb2ludC54ICsgXCIgXCIgKyBjdXJyZW50UG9pbnQueTtcbiAgICAgICAgbWUucG9seWdvblBhdGggPSBwb2x5Z29uUGF0aDtcblxuICAgICAgICBpZiAoIWJydXNoU2hhcGUpIHtcbiAgICAgICAgICBicnVzaFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdwYXRoJywge1xuICAgICAgICAgICAgYXR0cnM6IFV0aWwubWl4KG1lLnN0eWxlLCB7XG4gICAgICAgICAgICAgIHBhdGg6IHBvbHlnb25QYXRoXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICFicnVzaFNoYXBlLmdldCgnZGVzdHJveWVkJykgJiYgYnJ1c2hTaGFwZS5hdHRyKFV0aWwubWl4KHt9LCBicnVzaFNoYXBlLl9hdHRycywge1xuICAgICAgICAgICAgcGF0aDogcG9seWdvblBhdGhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09ICdQT0xZR09OJykge1xuICAgICAgICBpZiAoIWJydXNoU2hhcGUpIHtcbiAgICAgICAgICBicnVzaFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdyZWN0Jywge1xuICAgICAgICAgICAgYXR0cnM6IFV0aWwubWl4KG1lLnN0eWxlLCB7XG4gICAgICAgICAgICAgIHg6IHJlY3RTdGFydFgsXG4gICAgICAgICAgICAgIHk6IHJlY3RTdGFydFksXG4gICAgICAgICAgICAgIHdpZHRoOiByZWN0V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogcmVjdEhlaWdodFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAhYnJ1c2hTaGFwZS5nZXQoJ2Rlc3Ryb3llZCcpICYmIGJydXNoU2hhcGUuYXR0cihVdGlsLm1peCh7fSwgYnJ1c2hTaGFwZS5fYXR0cnMsIHtcbiAgICAgICAgICAgIHg6IHJlY3RTdGFydFgsXG4gICAgICAgICAgICB5OiByZWN0U3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IHJlY3RXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdEhlaWdodFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZS5icnVzaFNoYXBlID0gYnJ1c2hTaGFwZTtcbiAgICB9IGVsc2UgaWYgKGRyYWdnaW5nKSB7XG4gICAgICBjYW52YXNET00uc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IG1lLnNlbGVjdGlvbjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmdldCgnZGVzdHJveWVkJykpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdQT0xZR09OJykge1xuICAgICAgICAgIHZhciBwcmVQb2ludCA9IG1lLnByZVBvaW50O1xuICAgICAgICAgIG1lLnNlbGVjdGlvbi50cmFuc2xhdGUoY3VycmVudFBvaW50LnggLSBwcmVQb2ludC54LCBjdXJyZW50UG9pbnQueSAtIHByZVBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLmRyYWdvZmZYICYmIHNlbGVjdGlvbi5hdHRyKCd4JywgY3VycmVudFBvaW50LnggLSBtZS5kcmFnb2ZmWCk7XG4gICAgICAgICAgbWUuZHJhZ29mZlkgJiYgc2VsZWN0aW9uLmF0dHIoJ3knLCBjdXJyZW50UG9pbnQueSAtIG1lLmRyYWdvZmZZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1lLnByZVBvaW50ID0gY3VycmVudFBvaW50O1xuICAgIGNhbnZhcy5kcmF3KCk7XG5cbiAgICB2YXIgX21lJF9nZXRTZWxlY3RlZCA9IG1lLl9nZXRTZWxlY3RlZCgpLFxuICAgICAgICBkYXRhID0gX21lJF9nZXRTZWxlY3RlZC5kYXRhLFxuICAgICAgICBzaGFwZXMgPSBfbWUkX2dldFNlbGVjdGVkLnNoYXBlcyxcbiAgICAgICAgeFZhbHVlcyA9IF9tZSRfZ2V0U2VsZWN0ZWQueFZhbHVlcyxcbiAgICAgICAgeVZhbHVlcyA9IF9tZSRfZ2V0U2VsZWN0ZWQueVZhbHVlcztcblxuICAgIHZhciBldmVudE9iaiA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgIHg6IGN1cnJlbnRQb2ludC54LFxuICAgICAgeTogY3VycmVudFBvaW50LnlcbiAgICB9O1xuXG4gICAgaWYgKHhTY2FsZSkge1xuICAgICAgZXZlbnRPYmpbeFNjYWxlLmZpZWxkXSA9IHhWYWx1ZXM7XG4gICAgfVxuXG4gICAgaWYgKHlTY2FsZSkge1xuICAgICAgZXZlbnRPYmpbeVNjYWxlLmZpZWxkXSA9IHlWYWx1ZXM7XG4gICAgfVxuXG4gICAgbWUub25EcmFnbW92ZSAmJiBtZS5vbkRyYWdtb3ZlKGV2ZW50T2JqKTtcbiAgICBtZS5vbkJydXNobW92ZSAmJiBtZS5vbkJydXNobW92ZShldmVudE9iaik7XG4gIH07XG5cbiAgX3Byb3RvLmVuZCA9IGZ1bmN0aW9uIGVuZChldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSBtZS5kYXRhLFxuICAgICAgICBzaGFwZXMgPSBtZS5zaGFwZXMsXG4gICAgICAgIHhWYWx1ZXMgPSBtZS54VmFsdWVzLFxuICAgICAgICB5VmFsdWVzID0gbWUueVZhbHVlcyxcbiAgICAgICAgY2FudmFzID0gbWUuY2FudmFzLFxuICAgICAgICB0eXBlID0gbWUudHlwZSxcbiAgICAgICAgc3RhcnRQb2ludCA9IG1lLnN0YXJ0UG9pbnQsXG4gICAgICAgIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIGNvbnRhaW5lciA9IG1lLmNvbnRhaW5lcixcbiAgICAgICAgeFNjYWxlID0gbWUueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBtZS55U2NhbGU7XG4gICAgdmFyIG9mZnNldFggPSBldi5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZID0gZXYub2Zmc2V0WTtcbiAgICB2YXIgY2FudmFzRE9NID0gY2FudmFzLmdldCgnY2FudmFzRE9NJyk7XG4gICAgY2FudmFzRE9NLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgIGlmIChNYXRoLmFicyhzdGFydFBvaW50LnggLSBvZmZzZXRYKSA8PSAxICYmIE1hdGguYWJzKHN0YXJ0UG9pbnQueSAtIG9mZnNldFkpIDw9IDEpIHtcbiAgICAgIC8vIOmYsuatoueCueWHu+S6i+S7tlxuICAgICAgbWUuYnJ1c2hpbmcgPSBmYWxzZTtcbiAgICAgIG1lLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50T2JqID0ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHNoYXBlczogc2hhcGVzLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFlcbiAgICB9O1xuXG4gICAgaWYgKHhTY2FsZSkge1xuICAgICAgZXZlbnRPYmpbeFNjYWxlLmZpZWxkXSA9IHhWYWx1ZXM7XG4gICAgfVxuXG4gICAgaWYgKHlTY2FsZSkge1xuICAgICAgZXZlbnRPYmpbeVNjYWxlLmZpZWxkXSA9IHlWYWx1ZXM7XG4gICAgfVxuXG4gICAgaWYgKG1lLmRyYWdnaW5nKSB7XG4gICAgICBtZS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgbWUub25EcmFnZW5kICYmIG1lLm9uRHJhZ2VuZChldmVudE9iaik7XG4gICAgfSBlbHNlIGlmIChtZS5icnVzaGluZykge1xuICAgICAgbWUuYnJ1c2hpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBicnVzaFNoYXBlID0gbWUuYnJ1c2hTaGFwZTtcbiAgICAgIHZhciBwb2x5Z29uUGF0aCA9IG1lLnBvbHlnb25QYXRoO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ1BPTFlHT04nKSB7XG4gICAgICAgIHBvbHlnb25QYXRoICs9ICd6JztcbiAgICAgICAgYnJ1c2hTaGFwZSAmJiAhYnJ1c2hTaGFwZS5nZXQoJ2Rlc3Ryb3llZCcpICYmIGJydXNoU2hhcGUuYXR0cihVdGlsLm1peCh7fSwgYnJ1c2hTaGFwZS5fYXR0cnMsIHtcbiAgICAgICAgICBwYXRoOiBwb2x5Z29uUGF0aFxuICAgICAgICB9KSk7XG4gICAgICAgIG1lLnBvbHlnb25QYXRoID0gcG9seWdvblBhdGg7XG4gICAgICAgIGNhbnZhcy5kcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZS5vbkJydXNoZW5kKSB7XG4gICAgICAgIG1lLm9uQnJ1c2hlbmQoZXZlbnRPYmopO1xuICAgICAgfSBlbHNlIGlmIChjaGFydCAmJiBtZS5maWx0ZXIpIHtcbiAgICAgICAgY29udGFpbmVyLmNsZWFyKCk7IC8vIGNsZWFyIHRoZSBicnVzaFxuICAgICAgICAvLyBmaWx0ZXIgZGF0YVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnWCcpIHtcbiAgICAgICAgICB4U2NhbGUgJiYgY2hhcnQuZmlsdGVyKHhTY2FsZS5maWVsZCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWx1ZXMuaW5kZXhPZih2YWwpID4gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1knKSB7XG4gICAgICAgICAgeVNjYWxlICYmIGNoYXJ0LmZpbHRlcih5U2NhbGUuZmllbGQsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB5VmFsdWVzLmluZGV4T2YodmFsKSA+IC0xO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhTY2FsZSAmJiBjaGFydC5maWx0ZXIoeFNjYWxlLmZpZWxkLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4geFZhbHVlcy5pbmRleE9mKHZhbCkgPiAtMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB5U2NhbGUgJiYgY2hhcnQuZmlsdGVyKHlTY2FsZS5maWVsZCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHlWYWx1ZXMuaW5kZXhPZih2YWwpID4gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC5yZXBhaW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIGZpbHRlciA9IG1lLmZpbHRlcixcbiAgICAgICAgYnJ1c2hTaGFwZSA9IG1lLmJydXNoU2hhcGUsXG4gICAgICAgIGNhbnZhcyA9IG1lLmNhbnZhcztcblxuICAgIGlmIChjaGFydCAmJiBmaWx0ZXIpIHtcbiAgICAgIGNoYXJ0LmdldCgnb3B0aW9ucycpLmZpbHRlcnMgPSB7fTtcbiAgICAgIGNoYXJ0LnJlcGFpbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoYnJ1c2hTaGFwZSkge1xuICAgICAgYnJ1c2hTaGFwZS5kZXN0cm95KCk7XG4gICAgICBjYW52YXMuZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2xpbWl0Q29vcmRTY29wZSA9IGZ1bmN0aW9uIF9saW1pdENvb3JkU2NvcGUocG9pbnQpIHtcbiAgICB2YXIgcGxvdCA9IHRoaXMucGxvdDtcbiAgICB2YXIgc3RhcnQgPSBwbG90LnN0YXJ0LFxuICAgICAgICBlbmQgPSBwbG90LmVuZDtcblxuICAgIGlmIChwb2ludC54IDwgc3RhcnQueCkge1xuICAgICAgcG9pbnQueCA9IHN0YXJ0Lng7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50LnggPiBlbmQueCkge1xuICAgICAgcG9pbnQueCA9IGVuZC54O1xuICAgIH1cblxuICAgIGlmIChwb2ludC55IDwgZW5kLnkpIHtcbiAgICAgIHBvaW50LnkgPSBlbmQueTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnQueSA+IHN0YXJ0LnkpIHtcbiAgICAgIHBvaW50LnkgPSBzdGFydC55O1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBfcHJvdG8uX2dldFNlbGVjdGVkID0gZnVuY3Rpb24gX2dldFNlbGVjdGVkKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIHhTY2FsZSA9IG1lLnhTY2FsZSxcbiAgICAgICAgeVNjYWxlID0gbWUueVNjYWxlLFxuICAgICAgICBicnVzaFNoYXBlID0gbWUuYnJ1c2hTaGFwZSxcbiAgICAgICAgY2FudmFzID0gbWUuY2FudmFzO1xuICAgIHZhciBwaXhlbFJhdGlvID0gY2FudmFzLmdldCgncGl4ZWxSYXRpbycpO1xuICAgIHZhciBzZWxlY3RlZFNoYXBlcyA9IFtdO1xuICAgIHZhciB4VmFsdWVzID0gW107XG4gICAgdmFyIHlWYWx1ZXMgPSBbXTtcbiAgICB2YXIgc2VsZWN0ZWREYXRhID0gW107XG5cbiAgICBpZiAoY2hhcnQpIHtcbiAgICAgIHZhciBnZW9tcyA9IGNoYXJ0LmdldCgnZ2VvbXMnKTtcbiAgICAgIGdlb21zLm1hcChmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgICB2YXIgc2hhcGVzID0gZ2VvbS5nZXRTaGFwZXMoKTtcbiAgICAgICAgc2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcGVEYXRhID0gc2hhcGUuZ2V0KCdvcmlnaW4nKTtcblxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZURhdGEpKSB7XG4gICAgICAgICAgICAvLyDnur/lm77jgIHljLrln5/lm77nrYlcbiAgICAgICAgICAgIHNoYXBlRGF0YSA9IFtzaGFwZURhdGFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNoYXBlRGF0YS5tYXAoZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgIGlmIChicnVzaFNoYXBlLmlzSGl0KGVhY2gueCAqIHBpeGVsUmF0aW8sIGVhY2gueSAqIHBpeGVsUmF0aW8pKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZWFjaC5fb3JpZ2luO1xuICAgICAgICAgICAgICBzZWxlY3RlZERhdGEucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgICB4U2NhbGUgJiYgeFZhbHVlcy5wdXNoKG9yaWdpblt4U2NhbGUuZmllbGRdKTtcbiAgICAgICAgICAgICAgeVNjYWxlICYmIHlWYWx1ZXMucHVzaChvcmlnaW5beVNjYWxlLmZpZWxkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlYWNoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWUuc2hhcGVzID0gc2VsZWN0ZWRTaGFwZXM7XG4gICAgbWUueFZhbHVlcyA9IHhWYWx1ZXM7XG4gICAgbWUueVZhbHVlcyA9IHlWYWx1ZXM7XG4gICAgbWUuZGF0YSA9IHNlbGVjdGVkRGF0YTtcbiAgICBjYW52YXMuZHJhdygpO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBzZWxlY3RlZERhdGEsXG4gICAgICB4VmFsdWVzOiB4VmFsdWVzLFxuICAgICAgeVZhbHVlczogeVZhbHVlcyxcbiAgICAgIHNoYXBlczogc2VsZWN0ZWRTaGFwZXNcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCcnVzaDtcbn0oSW50ZXJhY3Rpb24pOyAvLyBHMi5yZWdpc3RlckludGVyYWN0aW9uKCdicnVzaCcsIEJydXNoKTtcbi8vIEcyLnJlZ2lzdGVySW50ZXJhY3Rpb24oJ0JydXNoJywgQnJ1c2gpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQnJ1c2g7XG5cbi8qKiovIH0pLFxuLyogNDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgSW50ZXJhY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MSk7XG5cbnZhciBmaWx0ZXJEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NjkpO1xuXG52YXIgZ2V0Q29sRGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzcpO1xuXG52YXIgZ2V0TGltaXRSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4KTtcblxudmFyIERBWV9USU1FU1RBTVBTID0gODY0MDAwMDA7IC8vIGNvbnN0IEcyID0gcmVxdWlyZSgnLi4vY29yZS5qcycpO1xuXG52YXIgRFJBR0dJTkdfVFlQRVMgPSBbJ1gnLCAnWScsICdYWSddO1xudmFyIERFRkFVTFRfVFlQRSA9ICdYJztcblxudmFyIERyYWcgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnRlcmFjdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShEcmFnLCBfSW50ZXJhY3Rpb24pO1xuXG4gIHZhciBfcHJvdG8gPSBEcmFnLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9JbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIHR5cGU6IERFRkFVTFRfVFlQRSxcbiAgICAgIHN0ZXBSYXRpbzogMC4wNSxcbiAgICAgIGxpbWl0UmFuZ2U6IHt9LFxuICAgICAgc3RlcEJ5RmllbGQ6IHt9LFxuICAgICAgdGhyZXNob2xkOiAyMCxcbiAgICAgIG9yaWdpblNjYWxlRGVmc0J5RmllbGQ6IHt9LFxuICAgICAgcHJldmlvdXNQb2ludDogbnVsbCxcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9kaXNhYmxlVG9vbHRpcCA9IGZ1bmN0aW9uIF9kaXNhYmxlVG9vbHRpcCgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIHZhciB0b29sdGlwQ29udHJvbGxlciA9IGNoYXJ0LmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcblxuICAgIGlmICh0b29sdGlwQ29udHJvbGxlcikge1xuICAgICAgbWUuX3Nob3dUb29sdGlwID0gdHJ1ZTtcbiAgICAgIGNoYXJ0LnRvb2x0aXAoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2VuYWJsZVRvb2x0aXAgPSBmdW5jdGlvbiBfZW5hYmxlVG9vbHRpcChldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cbiAgICBpZiAobWUuX3Nob3dUb29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwKHRydWUpO1xuICAgICAgY2hhcnQuc2hvd1Rvb2x0aXAoZXYpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBEcmFnKGNmZywgY2hhcnQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9JbnRlcmFjdGlvbi5jYWxsKHRoaXMsIGNmZywgY2hhcnQpIHx8IHRoaXM7XG5cbiAgICB2YXIgbWUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIG1lLnR5cGUgPSBtZS50eXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgbWUuY2hhcnQgPSBjaGFydDtcbiAgICBtZS5jb29yZCA9IGNoYXJ0LmdldCgnY29vcmQnKTtcbiAgICB2YXIgZGF0YSA9IG1lLmRhdGEgPSBjaGFydC5nZXQoJ2RhdGEnKTsgLy8gcHJlIHByb2Nlc3NcblxuICAgIGZpbHRlckRhdGEoY2hhcnQpO1xuICAgIHZhciBzY2FsZXMgPSBjaGFydC5nZXRZU2NhbGVzKCk7XG4gICAgdmFyIHhTY2FsZSA9IGNoYXJ0LmdldFhTY2FsZSgpO1xuICAgIHNjYWxlcy5wdXNoKHhTY2FsZSk7XG4gICAgdmFyIHNjYWxlQ29udHJvbGxlciA9IGNoYXJ0LmdldCgnc2NhbGVDb250cm9sbGVyJyk7XG4gICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICAgIG1lLmxpbWl0UmFuZ2VbZmllbGRdID0gZ2V0TGltaXRSYW5nZShkYXRhLCBzY2FsZSk7XG4gICAgICB2YXIgZGVmID0gc2NhbGVDb250cm9sbGVyLmRlZnNbZmllbGRdIHx8IHt9O1xuICAgICAgbWUub3JpZ2luU2NhbGVEZWZzQnlGaWVsZFtmaWVsZF0gPSBVdGlsLm1peChkZWYsIHtcbiAgICAgICAgbmljZTogISFkZWYubmljZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY2FsZS5pc0xpbmVhcikge1xuICAgICAgICBtZS5zdGVwQnlGaWVsZFtmaWVsZF0gPSAoc2NhbGUubWF4IC0gc2NhbGUubWluKSAqIG1lLnN0ZXBSYXRpbztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChEUkFHR0lOR19UWVBFUy5pbmRleE9mKG1lLnR5cGUpID09PSAtMSkge1xuICAgICAgbWUudHlwZSA9IERFRkFVTFRfVFlQRTtcbiAgICB9XG5cbiAgICBtZS5fZGlzYWJsZVRvb2x0aXAoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyBvbkRyYWdzdGFydCgpIHsgfVxuICAvLyBvbkRyYWcoKSB7IH1cbiAgLy8gb25EcmFnZW5kKCkgeyB9XG5cblxuICBfcHJvdG8uX2FwcGx5VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FwcGx5VHJhbnNsYXRlKHNjYWxlLCBvZmZzZXQsIHRvdGFsKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAoc2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgIG1lLl90cmFuc2xhdGVMaW5lYXJTY2FsZShzY2FsZSwgb2Zmc2V0LCB0b3RhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lLl90cmFuc2xhdGVDYXRTY2FsZShzY2FsZSwgb2Zmc2V0LCB0b3RhbCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fdHJhbnNsYXRlQ2F0U2NhbGUgPSBmdW5jdGlvbiBfdHJhbnNsYXRlQ2F0U2NhbGUoc2NhbGUsIG9mZnNldCwgdG90YWwpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuICAgIHZhciB0eXBlID0gc2NhbGUudHlwZSxcbiAgICAgICAgZmllbGQgPSBzY2FsZS5maWVsZCxcbiAgICAgICAgdmFsdWVzID0gc2NhbGUudmFsdWVzLFxuICAgICAgICB0aWNrcyA9IHNjYWxlLnRpY2tzO1xuICAgIHZhciBjb2xEZWYgPSBnZXRDb2xEZWYoY2hhcnQsIGZpZWxkKTtcbiAgICB2YXIgb3JpZ2luVmFsdWVzID0gbWUubGltaXRSYW5nZVtmaWVsZF07XG4gICAgdmFyIHJhdGlvID0gb2Zmc2V0IC8gdG90YWw7XG4gICAgdmFyIHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgZGVsdGFDb3VudCA9IE1hdGgubWF4KDEsIE1hdGguYWJzKHBhcnNlSW50KHJhdGlvICogdmFsdWVMZW5ndGgpKSk7XG4gICAgdmFyIGZpcnN0SW5kZXggPSBvcmlnaW5WYWx1ZXMuaW5kZXhPZih2YWx1ZXNbMF0pO1xuICAgIHZhciBsYXN0SW5kZXggPSBvcmlnaW5WYWx1ZXMuaW5kZXhPZih2YWx1ZXNbdmFsdWVMZW5ndGggLSAxXSk7XG5cbiAgICBpZiAob2Zmc2V0ID4gMCAmJiBmaXJzdEluZGV4ID49IDApIHtcbiAgICAgIC8vIHJpZ2h0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhQ291bnQgJiYgZmlyc3RJbmRleCA+IDA7IGkrKykge1xuICAgICAgICBmaXJzdEluZGV4IC09IDE7XG4gICAgICAgIGxhc3RJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3VmFsdWVzID0gb3JpZ2luVmFsdWVzLnNsaWNlKGZpcnN0SW5kZXgsIGxhc3RJbmRleCArIDEpO1xuICAgICAgdmFyIG5ld1RpY2tzID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGUgPT09ICd0aW1lQ2F0Jykge1xuICAgICAgICB2YXIgdGlja0dhcCA9IHRpY2tzLmxlbmd0aCA+IDIgPyB0aWNrc1sxXSAtIHRpY2tzWzBdIDogREFZX1RJTUVTVEFNUFM7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSB0aWNrc1swXSAtIHRpY2tHYXA7IF9pID49IG5ld1ZhbHVlc1swXTsgX2kgLT0gdGlja0dhcCkge1xuICAgICAgICAgIHRpY2tzLnVuc2hpZnQoX2kpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3VGlja3MgPSB0aWNrcztcbiAgICAgIH1cblxuICAgICAgY2hhcnQuc2NhbGUoZmllbGQsIFV0aWwubWl4KHt9LCBjb2xEZWYsIHtcbiAgICAgICAgdmFsdWVzOiBuZXdWYWx1ZXMsXG4gICAgICAgIHRpY2tzOiBuZXdUaWNrc1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgMCAmJiBsYXN0SW5kZXggPD0gb3JpZ2luVmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGxlZnRcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGRlbHRhQ291bnQgJiYgbGFzdEluZGV4IDwgb3JpZ2luVmFsdWVzLmxlbmd0aCAtIDE7IF9pMisrKSB7XG4gICAgICAgIGZpcnN0SW5kZXggKz0gMTtcbiAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbmV3VmFsdWVzID0gb3JpZ2luVmFsdWVzLnNsaWNlKGZpcnN0SW5kZXgsIGxhc3RJbmRleCArIDEpO1xuXG4gICAgICB2YXIgX25ld1RpY2tzID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGUgPT09ICd0aW1lQ2F0Jykge1xuICAgICAgICB2YXIgX3RpY2tHYXAgPSB0aWNrcy5sZW5ndGggPiAyID8gdGlja3NbMV0gLSB0aWNrc1swXSA6IERBWV9USU1FU1RBTVBTO1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdICsgX3RpY2tHYXA7IF9pMyA8PSBfbmV3VmFsdWVzW19uZXdWYWx1ZXMubGVuZ3RoIC0gMV07IF9pMyArPSBfdGlja0dhcCkge1xuICAgICAgICAgIHRpY2tzLnB1c2goX2kzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9uZXdUaWNrcyA9IHRpY2tzO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5zY2FsZShmaWVsZCwgVXRpbC5taXgoe30sIGNvbERlZiwge1xuICAgICAgICB2YWx1ZXM6IF9uZXdWYWx1ZXMsXG4gICAgICAgIHRpY2tzOiBfbmV3VGlja3NcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl90cmFuc2xhdGVMaW5lYXJTY2FsZSA9IGZ1bmN0aW9uIF90cmFuc2xhdGVMaW5lYXJTY2FsZShzY2FsZSwgb2Zmc2V0LCB0b3RhbCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIGxpbWl0UmFuZ2UgPSBtZS5saW1pdFJhbmdlOyAvLyBsaW5lYXIgLyBjYXRcblxuICAgIHZhciBtaW4gPSBzY2FsZS5taW4sXG4gICAgICAgIG1heCA9IHNjYWxlLm1heCxcbiAgICAgICAgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICBpZiAobWluID09PSBsaW1pdFJhbmdlW2ZpZWxkXS5taW4gJiYgbWF4ID09PSBsaW1pdFJhbmdlW2ZpZWxkXS5tYXgpIHJldHVybjtcbiAgICB2YXIgcmF0aW8gPSBvZmZzZXQgLyB0b3RhbDtcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgdmFyIGNvbERlZiA9IGdldENvbERlZihjaGFydCwgZmllbGQpO1xuICAgIGNoYXJ0LnNjYWxlKGZpZWxkLCBVdGlsLm1peCh7fSwgY29sRGVmLCB7XG4gICAgICBuaWNlOiBmYWxzZSxcbiAgICAgIG1pbjogbWluICsgcmF0aW8gKiByYW5nZSxcbiAgICAgIG1heDogbWF4ICsgcmF0aW8gKiByYW5nZVxuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnQgPSBmdW5jdGlvbiBzdGFydChldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcbiAgICB2YXIgY2FudmFzRE9NID0gY2FudmFzLmdldCgnY2FudmFzRE9NJyk7XG4gICAgY2FudmFzRE9NLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJzsgLy8gY29uc3QgY29vcmQgPSBjaGFydC5nZXQoJ2Nvb3JkJyk7XG5cbiAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICBtZS5wcmV2aW91c1BvaW50ID0ge1xuICAgICAgeDogZXYueCxcbiAgICAgIHk6IGV2LnlcbiAgICB9O1xuXG4gICAgbWUuX2Rpc2FibGVUb29sdGlwKCk7XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGV2KSB7XG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGlmIChtZS5pc0RyYWdnaW5nKSB7XG4gICAgICB2YXIgY2hhcnQgPSBtZS5jaGFydCxcbiAgICAgICAgICB0eXBlID0gbWUudHlwZSxcbiAgICAgICAgICBjYW52YXMgPSBtZS5jYW52YXMsXG4gICAgICAgICAgY29vcmQgPSBtZS5jb29yZCxcbiAgICAgICAgICB0aHJlc2hvbGQgPSBtZS50aHJlc2hvbGQ7XG4gICAgICB2YXIgY2FudmFzRE9NID0gY2FudmFzLmdldCgnY2FudmFzRE9NJyk7XG4gICAgICBjYW52YXNET00uc3R5bGUuY3Vyc29yID0gJ21vdmUnOyAvLyBjb25zdCBjb29yZCA9IGNoYXJ0LmdldCgnY29vcmQnKTtcblxuICAgICAgdmFyIHByZXZpb3VzUG9pbnQgPSBtZS5wcmV2aW91c1BvaW50O1xuICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IGV2O1xuICAgICAgdmFyIGRlbHRhWCA9IGN1cnJlbnRQb2ludC54IC0gcHJldmlvdXNQb2ludC54O1xuICAgICAgdmFyIGRlbHRhWSA9IGN1cnJlbnRQb2ludC55IC0gcHJldmlvdXNQb2ludC55O1xuICAgICAgdmFyIG1vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID4gdGhyZXNob2xkICYmIHR5cGUuaW5kZXhPZignWCcpID4gLTEpIHtcbiAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB2YXIgeFNjYWxlID0gY2hhcnQuZ2V0WFNjYWxlKCk7XG5cbiAgICAgICAgbWUuX2FwcGx5VHJhbnNsYXRlKHhTY2FsZSwgeFNjYWxlLmlzTGluZWFyID8gLWRlbHRhWCA6IGRlbHRhWCwgY29vcmQud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IHRocmVzaG9sZCAmJiB0eXBlLmluZGV4T2YoJ1knKSA+IC0xKSB7XG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHlTY2FsZXMgPSBjaGFydC5nZXRZU2NhbGVzKCk7XG4gICAgICAgIHlTY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoeVNjYWxlKSB7XG4gICAgICAgICAgbWUuX2FwcGx5VHJhbnNsYXRlKHlTY2FsZSwgY3VycmVudFBvaW50LnkgLSBwcmV2aW91c1BvaW50LnksIGNvb3JkLmhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgICAgbWUucHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgICAgY2hhcnQucmVwYWludCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKGV2KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBtZS5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcbiAgICB2YXIgY2FudmFzRE9NID0gY2FudmFzLmdldCgnY2FudmFzRE9NJyk7XG4gICAgY2FudmFzRE9NLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgIG1lLl9lbmFibGVUb29sdGlwKGV2KTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciB2aWV3ID0gbWUudmlldyxcbiAgICAgICAgb3JpZ2luU2NhbGVEZWZzQnlGaWVsZCA9IG1lLm9yaWdpblNjYWxlRGVmc0J5RmllbGQ7XG4gICAgdmFyIHNjYWxlcyA9IHZpZXcuZ2V0WVNjYWxlcygpO1xuICAgIHZhciB4U2NhbGUgPSB2aWV3LmdldFhTY2FsZSgpO1xuICAgIHNjYWxlcy5wdXNoKHhTY2FsZSk7XG4gICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBpZiAoc2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgICAgIHZpZXcuc2NhbGUoZmllbGQsIG9yaWdpblNjYWxlRGVmc0J5RmllbGRbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2aWV3LnJlcGFpbnQoKTtcblxuICAgIG1lLl9kaXNhYmxlVG9vbHRpcCgpO1xuICB9O1xuXG4gIHJldHVybiBEcmFnO1xufShJbnRlcmFjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhZztcblxuLyoqKi8gfSksXG4vKiA0NjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgVGltZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxudmFyIGdldENvbERlZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Nik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYXJ0KSB7XG4gIGNoYXJ0Lm9uKCdiZWZvcmVpbml0Z2VvbXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2hhcnQuc2V0KCdsaW1pdEluUGxvdCcsIHRydWUpO1xuICAgIHZhciBkYXRhID0gY2hhcnQuZ2V0KCdkYXRhJyk7XG4gICAgdmFyIGNvbERlZnMgPSBnZXRDb2xEZWZzKGNoYXJ0KTtcbiAgICBpZiAoIWNvbERlZnMpIHJldHVybiBkYXRhO1xuICAgIHZhciBnZW9tcyA9IGNoYXJ0LmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgaXNTcGVjaWFsR2VvbSA9IGZhbHNlO1xuICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgIGlmIChbJ2FyZWEnLCAnbGluZScsICdwYXRoJ10uaW5kZXhPZihnZW9tLmdldCgndHlwZScpKSAhPT0gLTEpIHtcbiAgICAgICAgaXNTcGVjaWFsR2VvbSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgVXRpbC5lYWNoKGNvbERlZnMsIGZ1bmN0aW9uIChkZWYsIGtleSkge1xuICAgICAgaWYgKCFpc1NwZWNpYWxHZW9tICYmIGRlZiAmJiAoZGVmLnZhbHVlcyB8fCBkZWYubWluIHx8IGRlZi5tYXgpKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdmFyIGdlb21EYXRhID0gW107XG4gICAgVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgIFV0aWwuZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpbZmllbGRdO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBjb2xEZWYgPSBjb2xEZWZzW2ZpZWxkXTtcblxuICAgICAgICAgIGlmIChjb2xEZWYudHlwZSA9PT0gJ3RpbWVDYXQnKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gY29sRGVmLnZhbHVlcztcblxuICAgICAgICAgICAgaWYgKFV0aWwuaXNOdW1iZXIodmFsdWVzWzBdKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFRpbWVVdGlsLnRvVGltZVN0YW1wKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29sRGVmLnZhbHVlcyAmJiBjb2xEZWYudmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSB8fCBjb2xEZWYubWluICYmIHZhbHVlIDwgY29sRGVmLm1pbiB8fCBjb2xEZWYubWF4ICYmIHZhbHVlID4gY29sRGVmLm1heCkge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIGdlb21EYXRhLnB1c2gob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjaGFydC5zZXQoJ2ZpbHRlcmVkRGF0YScsIGdlb21EYXRhKTtcbiAgfSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQ3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgSW50ZXJhY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MSk7XG5cbnZhciBnZXRGaWVsZFJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzEpO1xuXG52YXIgZ2V0TGltaXRSYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzc4KTtcblxudmFyIERFRkFVTFRfVFlQRSA9ICdYJztcblxudmFyIFNjcm9sbEJhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0ludGVyYWN0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNjcm9sbEJhciwgX0ludGVyYWN0aW9uKTtcblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsQmFyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9JbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIHN0YXJ0RXZlbnQ6IG51bGwsXG4gICAgICBwcm9jZXNzRXZlbnQ6IG51bGwsXG4gICAgICBlbmRFdmVudDogbnVsbCxcbiAgICAgIHJlc2V0RXZlbnQ6IG51bGwsXG4gICAgICB0eXBlOiBERUZBVUxUX1RZUEUsXG4gICAgICB4U3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyMDIsIDIxNSwgMjM5LCAuMiknLFxuICAgICAgICBmaWxsZXJDb2xvcjogJ3JnYmEoMjAyLCAyMTUsIDIzOSwgLjc1KScsXG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIGxpbmVDYXA6ICdyb3VuZCcsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IC0xMFxuICAgICAgfSxcbiAgICAgIHlTdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDIwMiwgMjE1LCAyMzksIC4yKScsXG4gICAgICAgIGZpbGxlckNvbG9yOiAncmdiYSgyMDIsIDIxNSwgMjM5LCAuNzUpJyxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgb2Zmc2V0WDogOCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyU2Nyb2xsQmFycyA9IGZ1bmN0aW9uIF9yZW5kZXJTY3JvbGxCYXJzKCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdmFyIHNjcm9sbEJhckNmZyA9IGNoYXJ0LmdldCgnX3Njcm9sbEJhckNmZycpO1xuICAgIGlmICghc2Nyb2xsQmFyQ2ZnKSByZXR1cm47XG4gICAgdmFyIGRhdGEgPSBjaGFydC5nZXQoJ2RhdGEnKTtcbiAgICB2YXIgcGxvdFJhbmdlID0gY2hhcnQuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICBwbG90UmFuZ2Uud2lkdGggPSBNYXRoLmFicyhwbG90UmFuZ2UuYnIueCAtIHBsb3RSYW5nZS5ibC54KTtcbiAgICBwbG90UmFuZ2UuaGVpZ2h0ID0gTWF0aC5hYnMocGxvdFJhbmdlLnRsLnkgLSBwbG90UmFuZ2UuYmwueSk7XG4gICAgdmFyIGJhY2tQbG90ID0gY2hhcnQuZ2V0KCdiYWNrUGxvdCcpO1xuICAgIHZhciBjYW52YXMgPSBjaGFydC5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBjYW52YXMuZ2V0KCdoZWlnaHQnKTtcbiAgICB2YXIgbGltaXRSYW5nZSA9IGNoYXJ0LmdldCgnX2xpbWl0UmFuZ2UnKTtcbiAgICB2YXIgdHlwZSA9IHNjcm9sbEJhckNmZy50eXBlO1xuXG4gICAgaWYgKHR5cGUuaW5kZXhPZignWCcpID4gLTEpIHtcbiAgICAgIHZhciBfc2Nyb2xsQmFyQ2ZnJHhTdHlsZSA9IHNjcm9sbEJhckNmZy54U3R5bGUsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9zY3JvbGxCYXJDZmckeFN0eWxlLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WSA9IF9zY3JvbGxCYXJDZmckeFN0eWxlLm9mZnNldFksXG4gICAgICAgICAgbGluZUNhcCA9IF9zY3JvbGxCYXJDZmckeFN0eWxlLmxpbmVDYXAsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gX3Njcm9sbEJhckNmZyR4U3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGZpbGxlckNvbG9yID0gX3Njcm9sbEJhckNmZyR4U3R5bGUuZmlsbGVyQ29sb3IsXG4gICAgICAgICAgc2l6ZSA9IF9zY3JvbGxCYXJDZmckeFN0eWxlLnNpemU7XG4gICAgICB2YXIgeFNjYWxlID0gY2hhcnQuZ2V0WFNjYWxlKCk7XG4gICAgICB2YXIgeExpbWl0UmFuZ2UgPSBsaW1pdFJhbmdlW3hTY2FsZS5maWVsZF07XG5cbiAgICAgIGlmICgheExpbWl0UmFuZ2UpIHtcbiAgICAgICAgeExpbWl0UmFuZ2UgPSBnZXRMaW1pdFJhbmdlKGRhdGEsIHhTY2FsZSk7XG4gICAgICAgIGxpbWl0UmFuZ2VbeFNjYWxlLmZpZWxkXSA9IHhMaW1pdFJhbmdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFJhbmdlID0gZ2V0RmllbGRSYW5nZSh4U2NhbGUsIHhMaW1pdFJhbmdlLCB4U2NhbGUudHlwZSk7XG4gICAgICB2YXIgaG9yaXpvbnRhbEJhciA9IGNoYXJ0LmdldCgnX2hvcml6b250YWxCYXInKTtcbiAgICAgIHZhciB5UG9zID0gY2FudmFzSGVpZ2h0IC0gc2l6ZSAvIDIgKyBvZmZzZXRZO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbEJhcikge1xuICAgICAgICB2YXIgcHJvZ3Jlc3NMaW5lID0gaG9yaXpvbnRhbEJhci5nZXQoJ2NoaWxkcmVuJylbMV07XG4gICAgICAgIHByb2dyZXNzTGluZS5hdHRyKHtcbiAgICAgICAgICB4MTogTWF0aC5tYXgocGxvdFJhbmdlLmJsLnggKyBwbG90UmFuZ2Uud2lkdGggKiBjdXJyZW50UmFuZ2VbMF0gKyBvZmZzZXRYLCBwbG90UmFuZ2UuYmwueCksXG4gICAgICAgICAgeDI6IE1hdGgubWluKHBsb3RSYW5nZS5ibC54ICsgcGxvdFJhbmdlLndpZHRoICogY3VycmVudFJhbmdlWzFdICsgb2Zmc2V0WCwgcGxvdFJhbmdlLmJyLngpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9yaXpvbnRhbEJhciA9IGJhY2tQbG90LmFkZEdyb3VwKHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdob3Jpem9udGFsQmFyJ1xuICAgICAgICB9KTtcbiAgICAgICAgaG9yaXpvbnRhbEJhci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDE6IHBsb3RSYW5nZS5ibC54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIHkxOiB5UG9zLFxuICAgICAgICAgICAgeDI6IHBsb3RSYW5nZS5ici54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIHkyOiB5UG9zLFxuICAgICAgICAgICAgbGluZVdpZHRoOiBzaXplLFxuICAgICAgICAgICAgc3Ryb2tlOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBsaW5lQ2FwOiBsaW5lQ2FwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaG9yaXpvbnRhbEJhci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDE6IE1hdGgubWF4KHBsb3RSYW5nZS5ibC54ICsgcGxvdFJhbmdlLndpZHRoICogY3VycmVudFJhbmdlWzBdICsgb2Zmc2V0WCwgcGxvdFJhbmdlLmJsLngpLFxuICAgICAgICAgICAgeTE6IHlQb3MsXG4gICAgICAgICAgICB4MjogTWF0aC5taW4ocGxvdFJhbmdlLmJsLnggKyBwbG90UmFuZ2Uud2lkdGggKiBjdXJyZW50UmFuZ2VbMV0gKyBvZmZzZXRYLCBwbG90UmFuZ2UuYnIueCksXG4gICAgICAgICAgICB5MjogeVBvcyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogc2l6ZSxcbiAgICAgICAgICAgIHN0cm9rZTogZmlsbGVyQ29sb3IsXG4gICAgICAgICAgICBsaW5lQ2FwOiBsaW5lQ2FwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hhcnQuc2V0KCdfaG9yaXpvbnRhbEJhcicsIGhvcml6b250YWxCYXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlLmluZGV4T2YoJ1knKSA+IC0xKSB7XG4gICAgICB2YXIgX3Njcm9sbEJhckNmZyR5U3R5bGUgPSBzY3JvbGxCYXJDZmcueVN0eWxlLFxuICAgICAgICAgIF9vZmZzZXRYID0gX3Njcm9sbEJhckNmZyR5U3R5bGUub2Zmc2V0WCxcbiAgICAgICAgICBfb2Zmc2V0WSA9IF9zY3JvbGxCYXJDZmckeVN0eWxlLm9mZnNldFksXG4gICAgICAgICAgX2xpbmVDYXAgPSBfc2Nyb2xsQmFyQ2ZnJHlTdHlsZS5saW5lQ2FwLFxuICAgICAgICAgIF9iYWNrZ3JvdW5kQ29sb3IgPSBfc2Nyb2xsQmFyQ2ZnJHlTdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgX2ZpbGxlckNvbG9yID0gX3Njcm9sbEJhckNmZyR5U3R5bGUuZmlsbGVyQ29sb3IsXG4gICAgICAgICAgX3NpemUgPSBfc2Nyb2xsQmFyQ2ZnJHlTdHlsZS5zaXplO1xuICAgICAgdmFyIHlTY2FsZSA9IGNoYXJ0LmdldFlTY2FsZXMoKVswXTtcbiAgICAgIHZhciB5TGltaXRSYW5nZSA9IGxpbWl0UmFuZ2VbeVNjYWxlLmZpZWxkXTtcblxuICAgICAgaWYgKCF5TGltaXRSYW5nZSkge1xuICAgICAgICB5TGltaXRSYW5nZSA9IGdldExpbWl0UmFuZ2UoZGF0YSwgeVNjYWxlKTtcbiAgICAgICAgbGltaXRSYW5nZVt5U2NhbGUuZmllbGRdID0geUxpbWl0UmFuZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfY3VycmVudFJhbmdlID0gZ2V0RmllbGRSYW5nZSh5U2NhbGUsIHlMaW1pdFJhbmdlLCB5U2NhbGUudHlwZSk7XG5cbiAgICAgIHZhciB2ZXJ0aWNhbEJhciA9IGNoYXJ0LmdldCgnX3ZlcnRpY2FsQmFyJyk7XG4gICAgICB2YXIgeFBvcyA9IF9zaXplIC8gMiArIF9vZmZzZXRYO1xuXG4gICAgICBpZiAodmVydGljYWxCYXIpIHtcbiAgICAgICAgdmFyIF9wcm9ncmVzc0xpbmUgPSB2ZXJ0aWNhbEJhci5nZXQoJ2NoaWxkcmVuJylbMV07XG5cbiAgICAgICAgX3Byb2dyZXNzTGluZS5hdHRyKHtcbiAgICAgICAgICB5MTogTWF0aC5tYXgocGxvdFJhbmdlLnRsLnkgKyBwbG90UmFuZ2UuaGVpZ2h0ICogX2N1cnJlbnRSYW5nZVswXSArIF9vZmZzZXRZLCBwbG90UmFuZ2UudGwueSksXG4gICAgICAgICAgeTI6IE1hdGgubWluKHBsb3RSYW5nZS50bC55ICsgcGxvdFJhbmdlLmhlaWdodCAqIF9jdXJyZW50UmFuZ2VbMV0gKyBfb2Zmc2V0WSwgcGxvdFJhbmdlLmJsLnkpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVydGljYWxCYXIgPSBiYWNrUGxvdC5hZGRHcm91cCh7XG4gICAgICAgICAgY2xhc3NOYW1lOiAndmVydGljYWxCYXInXG4gICAgICAgIH0pO1xuICAgICAgICB2ZXJ0aWNhbEJhci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDE6IHhQb3MsXG4gICAgICAgICAgICB5MTogcGxvdFJhbmdlLnRsLnkgKyBfb2Zmc2V0WSxcbiAgICAgICAgICAgIHgyOiB4UG9zLFxuICAgICAgICAgICAgeTI6IHBsb3RSYW5nZS5ibC55ICsgX29mZnNldFksXG4gICAgICAgICAgICBsaW5lV2lkdGg6IF9zaXplLFxuICAgICAgICAgICAgc3Ryb2tlOiBfYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgbGluZUNhcDogX2xpbmVDYXBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2ZXJ0aWNhbEJhci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgeDE6IHhQb3MsXG4gICAgICAgICAgICB5MTogTWF0aC5tYXgocGxvdFJhbmdlLnRsLnkgKyBwbG90UmFuZ2UuaGVpZ2h0ICogX2N1cnJlbnRSYW5nZVswXSArIF9vZmZzZXRZLCBwbG90UmFuZ2UudGwueSksXG4gICAgICAgICAgICB4MjogeFBvcyxcbiAgICAgICAgICAgIHkyOiBNYXRoLm1pbihwbG90UmFuZ2UudGwueSArIHBsb3RSYW5nZS5oZWlnaHQgKiBfY3VycmVudFJhbmdlWzFdICsgX29mZnNldFksIHBsb3RSYW5nZS5ibC55KSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogX3NpemUsXG4gICAgICAgICAgICBzdHJva2U6IF9maWxsZXJDb2xvcixcbiAgICAgICAgICAgIGxpbmVDYXA6IF9saW5lQ2FwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2hhcnQuc2V0KCdfdmVydGljYWxCYXInLCB2ZXJ0aWNhbEJhcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNjcm9sbEJhcihjZmcsIGNoYXJ0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCBjZmcsIGNoYXJ0KSB8fCB0aGlzO1xuXG4gICAgdmFyIGRlZmF1bHRDZmcgPSBfdGhpcy5nZXREZWZhdWx0Q2ZnKCk7XG5cbiAgICBjaGFydC5zZXQoJ19zY3JvbGxCYXJDZmcnLCBVdGlsLmRlZXBNaXgoe30sIGRlZmF1bHRDZmcsIGNmZykpO1xuICAgIGNoYXJ0LnNldCgnX2xpbWl0UmFuZ2UnLCB7fSk7XG5cbiAgICBpZiAoIWNoYXJ0LmdldCgnX2hvcml6b250YWxCYXInKSAmJiAhY2hhcnQuZ2V0KCdfdmVydGljYWxCYXInKSkge1xuICAgICAgX3RoaXMuX3JlbmRlclNjcm9sbEJhcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfcHJvdG8uX2NsZWFyID0gZnVuY3Rpb24gX2NsZWFyKCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICBpZiAoY2hhcnQpIHtcbiAgICAgIHZhciBoQmFyID0gY2hhcnQuZ2V0KCdfaG9yaXpvbnRhbEJhcicpO1xuICAgICAgdmFyIHZCYXIgPSBjaGFydC5nZXQoJ192ZXJ0aWNhbEJhcicpO1xuICAgICAgaEJhciAmJiBoQmFyLnJlbW92ZSh0cnVlKTtcbiAgICAgIHZCYXIgJiYgdkJhci5yZW1vdmUodHJ1ZSk7XG4gICAgICBjaGFydC5zZXQoJ19ob3Jpem9udGFsQmFyJywgbnVsbCk7XG4gICAgICBjaGFydC5zZXQoJ192ZXJ0aWNhbEJhcicsIG51bGwpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2JpbmRFdmVudHMgPSBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLl9vbkFmdGVyY2xlYXJPckJlZm9yZWNoYW5nZWRhdGEgPSB0aGlzLl9vbkFmdGVyY2xlYXJPckJlZm9yZWNoYW5nZWRhdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkFmdGVyY2xlYXJpbm5lciA9IHRoaXMuX29uQWZ0ZXJjbGVhcmlubmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25BZnRlcmRyYXdnZW9tcyA9IHRoaXMuX29uQWZ0ZXJkcmF3Z2VvbXMuYmluZCh0aGlzKTtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNoYXJ0Lm9uKCdhZnRlcmNsZWFyJywgdGhpcy5fb25BZnRlcmNsZWFyT3JCZWZvcmVjaGFuZ2VkYXRhKTtcbiAgICBjaGFydC5vbignYmVmb3JlY2hhbmdlZGF0YScsIHRoaXMuX29uQWZ0ZXJjbGVhck9yQmVmb3JlY2hhbmdlZGF0YSk7XG4gICAgY2hhcnQub24oJ2FmdGVyY2xlYXJpbm5lcicsIHRoaXMuX29uQWZ0ZXJjbGVhcmlubmVyKTtcbiAgICBjaGFydC5vbignYWZ0ZXJkcmF3Z2VvbXMnLCB0aGlzLl9vbkFmdGVyZHJhd2dlb21zKTtcbiAgfTtcblxuICBfcHJvdG8uX29uQWZ0ZXJjbGVhck9yQmVmb3JlY2hhbmdlZGF0YSA9IGZ1bmN0aW9uIF9vbkFmdGVyY2xlYXJPckJlZm9yZWNoYW5nZWRhdGEoKSB7XG4gICAgdGhpcy5jaGFydCAmJiB0aGlzLmNoYXJ0LnNldCgnX2xpbWl0UmFuZ2UnLCB7fSk7XG4gIH07XG5cbiAgX3Byb3RvLl9vbkFmdGVyY2xlYXJpbm5lciA9IGZ1bmN0aW9uIF9vbkFmdGVyY2xlYXJpbm5lcigpIHtcbiAgICB0aGlzLl9jbGVhcigpO1xuICB9O1xuXG4gIF9wcm90by5fb25BZnRlcmRyYXdnZW9tcyA9IGZ1bmN0aW9uIF9vbkFmdGVyZHJhd2dlb21zKCkge1xuICAgIHRoaXMuX3JlbmRlclNjcm9sbEJhcnMoKTtcbiAgfTtcblxuICBfcHJvdG8uX2NsZWFyRXZlbnRzID0gZnVuY3Rpb24gX2NsZWFyRXZlbnRzKCkge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICBpZiAoY2hhcnQpIHtcbiAgICAgIGNoYXJ0Lm9mZignYWZ0ZXJjbGVhcicsIHRoaXMuX29uQWZ0ZXJjbGVhck9yQmVmb3JlY2hhbmdlZGF0YSk7XG4gICAgICBjaGFydC5vZmYoJ2JlZm9yZWNoYW5nZWRhdGEnLCB0aGlzLl9vbkFmdGVyY2xlYXJPckJlZm9yZWNoYW5nZWRhdGEpO1xuICAgICAgY2hhcnQub2ZmKCdhZnRlcmNsZWFyaW5uZXInLCB0aGlzLl9vbkFmdGVyY2xlYXJpbm5lcik7XG4gICAgICBjaGFydC5vZmYoJ2FmdGVyZHJhd2dlb21zJywgdGhpcy5fb25BZnRlcmRyYXdnZW9tcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGVhckV2ZW50cygpO1xuXG4gICAgdGhpcy5fY2xlYXIoKTtcblxuICAgIHRoaXMuY2FudmFzLmRyYXcoKTtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsQmFyO1xufShJbnRlcmFjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsQmFyO1xuXG4vKioqLyB9KSxcbi8qIDQ3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2FsZSwgbGltaXRSYW5nZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlKSByZXR1cm4gWzAsIDFdO1xuICB2YXIgbWluUmF0aW8gPSAwO1xuICB2YXIgbWF4UmF0aW8gPSAwO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJykge1xuICAgIHZhciBtaW4gPSBsaW1pdFJhbmdlLm1pbixcbiAgICAgICAgbWF4ID0gbGltaXRSYW5nZS5tYXg7XG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICAgIG1pblJhdGlvID0gKHNjYWxlLm1pbiAtIG1pbikgLyByYW5nZTtcbiAgICBtYXhSYXRpbyA9IChzY2FsZS5tYXggLSBtaW4pIC8gcmFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9yaWdpblZhbHVlcyA9IGxpbWl0UmFuZ2U7XG4gICAgdmFyIHZhbHVlcyA9IHNjYWxlLnZhbHVlcztcbiAgICB2YXIgZmlyc3RJbmRleCA9IG9yaWdpblZhbHVlcy5pbmRleE9mKHZhbHVlc1swXSk7XG4gICAgdmFyIGxhc3RJbmRleCA9IG9yaWdpblZhbHVlcy5pbmRleE9mKHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0pO1xuICAgIG1pblJhdGlvID0gZmlyc3RJbmRleCAvIChvcmlnaW5WYWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgbWF4UmF0aW8gPSBsYXN0SW5kZXggLyAob3JpZ2luVmFsdWVzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIFttaW5SYXRpbywgbWF4UmF0aW9dO1xufTtcblxuLyoqKi8gfSksXG4vKiA0NzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEludGVyYWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzEpO1xuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbEF0dHJzKGF0dHJzLCBzdHlsZXMpIHtcbiAgdmFyIG9yaWdpbiA9IHt9O1xuXG4gIGZvciAodmFyIHN0eWxlIGluIHN0eWxlcykge1xuICAgIG9yaWdpbltzdHlsZV0gPSBhdHRyc1tzdHlsZV07XG4gIH1cblxuICByZXR1cm4gb3JpZ2luO1xufVxuXG52YXIgU2VsZWN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW50ZXJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoU2VsZWN0LCBfSW50ZXJhY3Rpb24pO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdCgpIHtcbiAgICByZXR1cm4gX0ludGVyYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTZWxlY3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgZGVmYXVsdENmZyA9IF9JbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBkZWZhdWx0Q2ZnLCB7XG4gICAgICBzdGFydEV2ZW50OiAnbW91c2V1cCcsXG4gICAgICBwcm9jZXNzRXZlbnQ6IG51bGwsXG4gICAgICBzZWxlY3RTdHlsZToge1xuICAgICAgICBmaWxsT3BhY2l0eTogMVxuICAgICAgfSxcbiAgICAgIHVuU2VsZWN0U3R5bGU6IHtcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMVxuICAgICAgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnQgPSBmdW5jdGlvbiBzdGFydChldikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhcnQgPSBzZWxmLnZpZXc7XG4gICAgdmFyIHNlbGVjdGVkU2hhcGU7XG4gICAgdmFyIHVuU2VsZWN0ZWRTaGFwZXMgPSBbXTtcbiAgICBjaGFydC5lYWNoU2hhcGUoZnVuY3Rpb24gKG9iaiwgc2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZS5pc1BvaW50SW5QYXRoKGV2LngsIGV2LnkpKSB7XG4gICAgICAgIHNlbGVjdGVkU2hhcGUgPSBzaGFwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuU2VsZWN0ZWRTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXNlbGVjdGVkU2hhcGUpIHtcbiAgICAgIHNlbGYucmVzZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRTaGFwZS5nZXQoJ19zZWxlY3RlZCcpKSB7XG4gICAgICAvLyDlt7Lnu4/ooqvpgInkuK1cbiAgICAgIGlmICghc2VsZi5jYW5jZWxhYmxlKSB7XG4gICAgICAgIC8vIOS4jeWFgeiuuOWPlua2iOmAieS4reWImeS4jeWkhOeQhlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmVzZXQoKTsgLy8g5YWB6K645Y+W5raI6YCJ5LitXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOacquiiq+mAieS4rVxuICAgICAgdmFyIHNlbGVjdFN0eWxlID0gc2VsZi5zZWxlY3RTdHlsZSxcbiAgICAgICAgICB1blNlbGVjdFN0eWxlID0gc2VsZi51blNlbGVjdFN0eWxlOyAvLyDojrflj5bpgInkuK3mlYjmnpzlr7nlupTnmoTmnKzmnaXmlYjmnpws5L+d5a2Y5LiL5p2lXG5cbiAgICAgIHZhciBvcmlnaW5BdHRycyA9IGdldE9yaWdpbmFsQXR0cnMoc2VsZWN0ZWRTaGFwZS5hdHRyKCksIHNlbGVjdGVkU2hhcGUpO1xuICAgICAgc2VsZWN0ZWRTaGFwZS5zZXQoJ19vcmlnaW5BdHRycycsIG9yaWdpbkF0dHJzKTtcbiAgICAgIHNlbGVjdGVkU2hhcGUuYXR0cihzZWxlY3RTdHlsZSk7XG4gICAgICBVdGlsLmVhY2godW5TZWxlY3RlZFNoYXBlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBvcmlnaW5BdHRycyA9IGNoaWxkLmdldCgnX29yaWdpbkF0dHJzJyk7IC8vIOWFiOaBouWkjeWIsOm7mOiupOeKtuaAgeS4i1xuXG4gICAgICAgIGlmIChvcmlnaW5BdHRycykge1xuICAgICAgICAgIGNoaWxkLmF0dHIob3JpZ2luQXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuc2V0KCdfc2VsZWN0ZWQnLCBmYWxzZSk7IC8vIOS/neWtmOacqumAieS4reaViOaenOWvueW6lOeahOWOn+Wni+aViOaenFxuXG4gICAgICAgIGlmICh1blNlbGVjdFN0eWxlKSB7XG4gICAgICAgICAgb3JpZ2luQXR0cnMgPSBnZXRPcmlnaW5hbEF0dHJzKGNoaWxkLmF0dHIoKSwgdW5TZWxlY3RTdHlsZSk7XG4gICAgICAgICAgY2hpbGQuc2V0KCdfb3JpZ2luQXR0cnMnLCBvcmlnaW5BdHRycyk7XG4gICAgICAgICAgY2hpbGQuYXR0cih1blNlbGVjdFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxlY3RlZFNoYXBlLnNldCgnX3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICBzZWxmLnNlbGVjdGVkU2hhcGUgPSBzZWxlY3RlZFNoYXBlO1xuICAgICAgc2VsZi5jYW52YXMuZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKGV2KSB7XG4gICAgdmFyIHNlbGVjdGVkU2hhcGUgPSB0aGlzLnNlbGVjdGVkU2hhcGU7XG5cbiAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAhc2VsZWN0ZWRTaGFwZS5nZXQoJ2Rlc3Ryb3llZCcpICYmIHNlbGVjdGVkU2hhcGUuZ2V0KCdvcmlnaW4nKSkge1xuICAgICAgZXYuZGF0YSA9IHNlbGVjdGVkU2hhcGUuZ2V0KCdvcmlnaW4nKS5fb3JpZ2luOyAvLyDnu5jliLbmlbDmja7vvIzljIXlkKvljp/lp4vmlbDmja7llYpcblxuICAgICAgZXYuc2hhcGVJbmZvID0gc2VsZWN0ZWRTaGFwZS5nZXQoJ29yaWdpbicpO1xuICAgICAgZXYuc2hhcGUgPSBzZWxlY3RlZFNoYXBlO1xuICAgICAgZXYuc2VsZWN0ZWQgPSAhIXNlbGVjdGVkU2hhcGUuZ2V0KCdfc2VsZWN0ZWQnKTsgLy8g6L+U5Zue6YCJ5Lit55qE54q25oCBXG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghc2VsZi5zZWxlY3RlZFNoYXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoYXJ0ID0gc2VsZi52aWV3O1xuICAgIHZhciBnZW9tID0gY2hhcnQuZ2V0KCdnZW9tcycpWzBdO1xuICAgIHZhciBjb250YWluZXIgPSBnZW9tLmdldCgnY29udGFpbmVyJykuZ2V0KCdjaGlsZHJlbicpWzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IGNvbnRhaW5lci5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgVXRpbC5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBvcmlnaW5BdHRycyA9IGNoaWxkLmdldCgnX29yaWdpbkF0dHJzJyk7XG5cbiAgICAgIGlmIChvcmlnaW5BdHRycykge1xuICAgICAgICBjaGlsZC5fYXR0cnMgPSBvcmlnaW5BdHRycztcbiAgICAgICAgY2hpbGQuc2V0KCdfb3JpZ2luQXR0cnMnLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuc2V0KCdfc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgc2VsZi5jYW52YXMuZHJhdygpO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3Q7XG59KEludGVyYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Q7XG5cbi8qKiovIH0pLFxuLyogNDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxudmFyIFJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzQpO1xuXG52YXIgQ2hhcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nyk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBJbnRlcmFjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcxKTtcblxudmFyIGdldENvbERlZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzc3KTtcblxudmFyIGdldENvbERlZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3Nik7XG5cbnZhciBDYW52YXMgPSBHLkNhbnZhcztcbnZhciBEb21VdGlsID0gVXRpbC5Eb21VdGlsLFxuICAgIGlzTnVtYmVyID0gVXRpbC5pc051bWJlcjtcblxudmFyIFNsaWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0ludGVyYWN0aW9uKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNsaWRlciwgX0ludGVyYWN0aW9uKTtcblxuICB2YXIgX3Byb3RvID0gU2xpZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9JbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgcmV0dXJuIFV0aWwubWl4KHt9LCBjZmcsIHtcbiAgICAgIHN0YXJ0RXZlbnQ6IG51bGwsXG4gICAgICBwcm9jZXNzRXZlbnQ6IG51bGwsXG4gICAgICBlbmRFdmVudDogbnVsbCxcbiAgICAgIHJlc2V0RXZlbnQ6IG51bGwsXG4gICAgICBoZWlnaHQ6IDI2LFxuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIC8vIOm7mOiupOiHqumAguW6lFxuICAgICAgcGFkZGluZzogR2xvYmFsLnBsb3RDZmcucGFkZGluZyxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIHhBeGlzOiBudWxsLFxuICAgICAgeUF4aXM6IG51bGwsXG4gICAgICAvLyDpgInkuK3ljLrln5/nmoTmoLflvI9cbiAgICAgIGZpbGxlclN0eWxlOiB7XG4gICAgICAgIGZpbGw6ICcjQkRDQ0VEJyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuM1xuICAgICAgfSxcbiAgICAgIC8vIOa7keWKqOadoeiDjOaZr+agt+W8j1xuICAgICAgYmFja2dyb3VuZFN0eWxlOiB7XG4gICAgICAgIHN0cm9rZTogJyNDQ0Q2RUMnLFxuICAgICAgICBmaWxsOiAnI0NDRDZFQycsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjMsXG4gICAgICAgIGxpbmVXaWR0aDogMVxuICAgICAgfSxcbiAgICAgIHJhbmdlOiBbMCwgMTAwXSxcbiAgICAgIGxheW91dDogJ2hvcml6b250YWwnLFxuICAgICAgLy8g5paH5pys6aKc6ImyXG4gICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgZmlsbDogJyM1NDU0NTQnXG4gICAgICB9LFxuICAgICAgLy8g5ruR5Z2X55qE5qC35byPXG4gICAgICBoYW5kbGVTdHlsZToge1xuICAgICAgICBpbWc6ICdodHRwczovL2d3LmFsaXBheW9iamVjdHMuY29tL3pvcy9ybXNwb3J0YWwvUVh0ZmhPUkdsRHVSdkxYRnpwc1EucG5nJyxcbiAgICAgICAgd2lkdGg6IDVcbiAgICAgIH0sXG4gICAgICAvLyDog4zmma/lm77ooajnmoTphY3nva7vvIzlpoLmnpzkuLogZmFsc2Ug5YiZ6KGo56S65LiN5riy5p+TXG4gICAgICBiYWNrZ3JvdW5kQ2hhcnQ6IHtcbiAgICAgICAgdHlwZTogWydhcmVhJ10sXG4gICAgICAgIC8vIOWbvuihqOeahOexu+Wei++8jOWPr+S7peaYr+Wtl+espuS4suS5n+WPr+aYr+aYr+aVsOe7hFxuICAgICAgICBjb2xvcjogJyNDQ0Q2RUMnXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0Q29udGFpbmVyID0gZnVuY3Rpb24gX2luaXRDb250YWluZXIoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyID0gbWUuY29udGFpbmVyO1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNwZWNpZnkgdGhlIGNvbnRhaW5lciBmb3IgdGhlIFNsaWRlciEnKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgICBtZS5kb21Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5kb21Db250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5mb3JjZUZpdCA9IGZ1bmN0aW9uIGZvcmNlRml0KCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAoIW1lIHx8IG1lLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IERvbVV0aWwuZ2V0V2lkdGgobWUuZG9tQ29udGFpbmVyKTtcbiAgICB2YXIgaGVpZ2h0ID0gbWUuaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoICE9PSBtZS5kb21XaWR0aCkge1xuICAgICAgdmFyIGNhbnZhcyA9IG1lLmNhbnZhcztcbiAgICAgIGNhbnZhcy5jaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpOyAvLyDmlLnlj5jnlLvluIPlsLrlr7hcblxuICAgICAgbWUuYmdDaGFydCAmJiBtZS5iZ0NoYXJ0LmNoYW5nZVdpZHRoKHdpZHRoKTtcbiAgICAgIGNhbnZhcy5jbGVhcigpO1xuXG4gICAgICBtZS5faW5pdFdpZHRoKCk7XG5cbiAgICAgIG1lLl9pbml0U2xpZGVyKCk7IC8vIOWIneWni+WMlua7keWKqOadoVxuXG5cbiAgICAgIG1lLl9iaW5kRXZlbnQoKTtcblxuICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0Rm9yY2VGaXRFdmVudCA9IGZ1bmN0aW9uIF9pbml0Rm9yY2VGaXRFdmVudCgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoVXRpbC53cmFwQmVoYXZpb3IobWUsICdmb3JjZUZpdCcpLCAyMDApO1xuICAgIGNsZWFyVGltZW91dChtZS5yZXNpemVUaW1lcik7XG4gICAgbWUucmVzaXplVGltZXIgPSB0aW1lcjtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRTdHlsZSA9IGZ1bmN0aW9uIF9pbml0U3R5bGUoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBtZS5oYW5kbGVTdHlsZSA9IFV0aWwubWl4KHtcbiAgICAgIHdpZHRoOiBtZS5oZWlnaHQsXG4gICAgICBoZWlnaHQ6IG1lLmhlaWdodFxuICAgIH0sIG1lLmhhbmRsZVN0eWxlKTtcblxuICAgIGlmIChtZS53aWR0aCA9PT0gJ2F1dG8nKSB7XG4gICAgICAvLyDlrr3luqboh6rpgILlupRcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBVdGlsLndyYXBCZWhhdmlvcihtZSwgJ19pbml0Rm9yY2VGaXRFdmVudCcpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0V2lkdGggPSBmdW5jdGlvbiBfaW5pdFdpZHRoKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHdpZHRoO1xuXG4gICAgaWYgKG1lLndpZHRoID09PSAnYXV0bycpIHtcbiAgICAgIHdpZHRoID0gRG9tVXRpbC5nZXRXaWR0aChtZS5kb21Db250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IG1lLndpZHRoO1xuICAgIH1cblxuICAgIG1lLmRvbVdpZHRoID0gd2lkdGg7XG4gICAgdmFyIHBhZGRpbmcgPSBVdGlsLnRvQWxsUGFkZGluZyhtZS5wYWRkaW5nKTtcblxuICAgIGlmIChtZS5sYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgbWUucGxvdFdpZHRoID0gd2lkdGggLSBwYWRkaW5nWzFdIC0gcGFkZGluZ1szXTtcbiAgICAgIG1lLnBsb3RQYWRkaW5nID0gcGFkZGluZ1szXTtcbiAgICAgIG1lLnBsb3RIZWlnaHQgPSBtZS5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChtZS5sYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIG1lLnBsb3RXaWR0aCA9IG1lLndpZHRoO1xuICAgICAgbWUucGxvdEhlaWdodCA9IG1lLmhlaWdodCAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdO1xuICAgICAgbWUucGxvdFBhZGRpbmcgPSBwYWRkaW5nWzBdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2luaXRDYW52YXMgPSBmdW5jdGlvbiBfaW5pdENhbnZhcygpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciB3aWR0aCA9IG1lLmRvbVdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBtZS5oZWlnaHQ7XG4gICAgdmFyIGNhbnZhcyA9IG5ldyBDYW52YXMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBjb250YWluZXJET006IG1lLmRvbUNvbnRhaW5lcixcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIG5vZGUgPSBjYW52YXMuZ2V0KCdlbCcpO1xuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIG5vZGUuc3R5bGUudG9wID0gMDtcbiAgICBub2RlLnN0eWxlLmxlZnQgPSAwO1xuICAgIG5vZGUuc3R5bGUuekluZGV4ID0gMztcbiAgICBtZS5jYW52YXMgPSBjYW52YXM7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0QmFja2dyb3VuZCA9IGZ1bmN0aW9uIF9pbml0QmFja2dyb3VuZCgpIHtcbiAgICB2YXIgX1V0aWwkZGVlcE1peDtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB2YXIgZ2VvbSA9IGNoYXJ0LmdldEFsbEdlb21zWzBdO1xuICAgIHZhciBkYXRhID0gbWUuZGF0YSA9IG1lLmRhdGEgfHwgY2hhcnQuZ2V0KCdkYXRhJyk7XG4gICAgdmFyIHhTY2FsZSA9IGNoYXJ0LmdldFhTY2FsZSgpO1xuICAgIHZhciB4QXhpcyA9IG1lLnhBeGlzIHx8IHhTY2FsZS5maWVsZDtcbiAgICB2YXIgeUF4aXMgPSBtZS55QXhpcyB8fCBjaGFydC5nZXRZU2NhbGVzKClbMF0uZmllbGQ7XG4gICAgdmFyIHNjYWxlcyA9IFV0aWwuZGVlcE1peCgoX1V0aWwkZGVlcE1peCA9IHt9LCBfVXRpbCRkZWVwTWl4W1wiXCIgKyB4QXhpc10gPSB7XG4gICAgICByYW5nZTogWzAsIDFdXG4gICAgfSwgX1V0aWwkZGVlcE1peCksIGdldENvbERlZnMoY2hhcnQpLCBtZS5zY2FsZXMpOyAvLyDnlKjmiLfliJflrprkuYlcblxuICAgIGRlbGV0ZSBzY2FsZXNbeEF4aXNdLm1pbjtcbiAgICBkZWxldGUgc2NhbGVzW3hBeGlzXS5tYXg7XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIC8vIOayoeacieaVsOaNru+8jOWImeS4jeWIm+W7ulxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSB0aGUgZGF0YSEnKTtcbiAgICB9XG5cbiAgICBpZiAoIXhBeGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSB4QXhpcyEnKTtcbiAgICB9XG5cbiAgICBpZiAoIXlBeGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSB5QXhpcyEnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZENoYXJ0ID0gbWUuYmFja2dyb3VuZENoYXJ0O1xuICAgIHZhciB0eXBlID0gYmFja2dyb3VuZENoYXJ0LnR5cGUgfHwgZ2VvbS5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgY29sb3IgPSBiYWNrZ3JvdW5kQ2hhcnQuY29sb3IgfHwgJ2dyZXknO1xuXG4gICAgaWYgKCFVdGlsLmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBVdGlsLnRvQWxsUGFkZGluZyhtZS5wYWRkaW5nKTtcbiAgICB2YXIgYmdDaGFydCA9IG5ldyBDaGFydCh7XG4gICAgICBjb250YWluZXI6IG1lLmNvbnRhaW5lcixcbiAgICAgIHdpZHRoOiBtZS5kb21XaWR0aCxcbiAgICAgIGhlaWdodDogbWUuaGVpZ2h0LFxuICAgICAgcGFkZGluZzogWzAsIHBhZGRpbmdbMV0sIDAsIHBhZGRpbmdbM11dLFxuICAgICAgYW5pbWF0ZTogZmFsc2VcbiAgICB9KTtcbiAgICBiZ0NoYXJ0LnNvdXJjZShkYXRhKTtcbiAgICBiZ0NoYXJ0LnNjYWxlKHNjYWxlcyk7XG4gICAgYmdDaGFydC5heGlzKGZhbHNlKTtcbiAgICBiZ0NoYXJ0LnRvb2x0aXAoZmFsc2UpO1xuICAgIGJnQ2hhcnQubGVnZW5kKGZhbHNlKTtcbiAgICBVdGlsLmVhY2godHlwZSwgZnVuY3Rpb24gKGVhY2hUeXBlKSB7XG4gICAgICBiZ0NoYXJ0W2VhY2hUeXBlXSgpLnBvc2l0aW9uKHhBeGlzICsgJyonICsgeUF4aXMpLmNvbG9yKGNvbG9yKS5vcGFjaXR5KDEpO1xuICAgIH0pO1xuICAgIGJnQ2hhcnQucmVuZGVyKCk7XG4gICAgbWUuYmdDaGFydCA9IGJnQ2hhcnQ7XG4gICAgbWUuc2NhbGUgPSBtZS5sYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IGJnQ2hhcnQuZ2V0WFNjYWxlKCkgOiBiZ0NoYXJ0LmdldFlTY2FsZXMoKVswXTtcblxuICAgIGlmIChtZS5sYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIGJnQ2hhcnQuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2luaXRSYW5nZSA9IGZ1bmN0aW9uIF9pbml0UmFuZ2UoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgc3RhcnRSYWRpbyA9IG1lLnN0YXJ0UmFkaW87XG4gICAgdmFyIGVuZFJhZGlvID0gbWUuZW5kUmFkaW87XG4gICAgdmFyIHN0YXJ0ID0gbWUuX3N0YXJ0VmFsdWU7XG4gICAgdmFyIGVuZCA9IG1lLl9lbmRWYWx1ZTtcbiAgICB2YXIgc2NhbGUgPSBtZS5zY2FsZTtcbiAgICB2YXIgbWluID0gMDtcbiAgICB2YXIgbWF4ID0gMTsgLy8gc3RhcnRSYWRpbyDkvJjlhYjnuqfpq5jkuo4gc3RhcnRcblxuICAgIGlmIChpc051bWJlcihzdGFydFJhZGlvKSkge1xuICAgICAgbWluID0gc3RhcnRSYWRpbztcbiAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICBtaW4gPSBzY2FsZS5zY2FsZShzY2FsZS50cmFuc2xhdGUoc3RhcnQpKTtcbiAgICB9IC8vIGVuZFJhZGlvIOS8mOWFiOe6p+mrmOS6jiBlbmRcblxuXG4gICAgaWYgKGlzTnVtYmVyKGVuZFJhZGlvKSkge1xuICAgICAgbWF4ID0gZW5kUmFkaW87XG4gICAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAgIG1heCA9IHNjYWxlLnNjYWxlKHNjYWxlLnRyYW5zbGF0ZShlbmQpKTtcbiAgICB9XG5cbiAgICB2YXIgbWluU3BhbiA9IG1lLm1pblNwYW4sXG4gICAgICAgIG1heFNwYW4gPSBtZS5tYXhTcGFuO1xuICAgIHZhciB0b3RhbFNwYW4gPSAwO1xuXG4gICAgaWYgKHNjYWxlLnR5cGUgPT09ICd0aW1lJyB8fCBzY2FsZS50eXBlID09PSAndGltZUNhdCcpIHtcbiAgICAgIC8vIOaXtumXtOexu+Wei+W3suaOkuW6j1xuICAgICAgdmFyIHZhbHVlcyA9IHNjYWxlLnZhbHVlcztcbiAgICAgIHZhciBmaXJzdFZhbHVlID0gdmFsdWVzWzBdO1xuICAgICAgdmFyIGxhc3RWYWx1ZSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICB0b3RhbFNwYW4gPSBsYXN0VmFsdWUgLSBmaXJzdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgIHRvdGFsU3BhbiA9IHNjYWxlLm1heCAtIHNjYWxlLm1pbjtcbiAgICB9XG5cbiAgICBpZiAodG90YWxTcGFuICYmIG1pblNwYW4pIHtcbiAgICAgIG1lLm1pblJhbmdlID0gbWluU3BhbiAvIHRvdGFsU3BhbiAqIDEwMDtcbiAgICB9XG5cbiAgICBpZiAodG90YWxTcGFuICYmIG1heFNwYW4pIHtcbiAgICAgIG1lLm1heFJhbmdlID0gbWF4U3BhbiAvIHRvdGFsU3BhbiAqIDEwMDtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBbbWluICogMTAwLCBtYXggKiAxMDBdO1xuICAgIG1lLnJhbmdlID0gcmFuZ2U7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0SGFuZGxlVmFsdWUgPSBmdW5jdGlvbiBfZ2V0SGFuZGxlVmFsdWUodHlwZSkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciByYW5nZSA9IG1lLnJhbmdlO1xuICAgIHZhciBtaW4gPSByYW5nZVswXSAvIDEwMDtcbiAgICB2YXIgbWF4ID0gcmFuZ2VbMV0gLyAxMDA7XG4gICAgdmFyIHNjYWxlID0gbWUuc2NhbGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ21pbicpIHtcbiAgICAgIHZhbHVlID0gbWUuX3N0YXJ0VmFsdWUgPyBtZS5fc3RhcnRWYWx1ZSA6IHNjYWxlLmludmVydChtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IG1lLl9lbmRWYWx1ZSA/IG1lLl9lbmRWYWx1ZSA6IHNjYWxlLmludmVydChtYXgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRTbGlkZXIgPSBmdW5jdGlvbiBfaW5pdFNsaWRlcigpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cbiAgICB2YXIgcmFuZ2UgPSBtZS5faW5pdFJhbmdlKCk7XG5cbiAgICB2YXIgc2NhbGUgPSBtZS5zY2FsZTtcbiAgICB2YXIgcmFuZ2VFbGVtZW50ID0gY2FudmFzLmFkZEdyb3VwKFJhbmdlLCB7XG4gICAgICBtaWRkbGVBdHRyOiBtZS5maWxsZXJTdHlsZSxcbiAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgIG1pblJhbmdlOiBtZS5taW5SYW5nZSxcbiAgICAgIG1heFJhbmdlOiBtZS5tYXhSYW5nZSxcbiAgICAgIGxheW91dDogbWUubGF5b3V0LFxuICAgICAgd2lkdGg6IG1lLnBsb3RXaWR0aCxcbiAgICAgIGhlaWdodDogbWUucGxvdEhlaWdodCxcbiAgICAgIGJhY2tncm91bmRTdHlsZTogbWUuYmFja2dyb3VuZFN0eWxlLFxuICAgICAgdGV4dFN0eWxlOiBtZS50ZXh0U3R5bGUsXG4gICAgICBoYW5kbGVTdHlsZTogbWUuaGFuZGxlU3R5bGUsXG4gICAgICBtaW5UZXh0OiBzY2FsZS5nZXRUZXh0KG1lLl9nZXRIYW5kbGVWYWx1ZSgnbWluJykpLFxuICAgICAgbWF4VGV4dDogc2NhbGUuZ2V0VGV4dChtZS5fZ2V0SGFuZGxlVmFsdWUoJ21heCcpKVxuICAgIH0pO1xuXG4gICAgaWYgKG1lLmxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICByYW5nZUVsZW1lbnQudHJhbnNsYXRlKG1lLnBsb3RQYWRkaW5nLCAwKTtcbiAgICB9IGVsc2UgaWYgKG1lLmxheW91dCA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmFuZ2VFbGVtZW50LnRyYW5zbGF0ZSgwLCBtZS5wbG90UGFkZGluZyk7XG4gICAgfVxuXG4gICAgbWUucmFuZ2VFbGVtZW50ID0gcmFuZ2VFbGVtZW50O1xuICB9O1xuXG4gIF9wcm90by5fdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF91cGRhdGVFbGVtZW50KG1pblJhdGlvLCBtYXhSYXRpbykge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIHNjYWxlID0gbWUuc2NhbGUsXG4gICAgICAgIHJhbmdlRWxlbWVudCA9IG1lLnJhbmdlRWxlbWVudDtcbiAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICB2YXIgbWluVGV4dEVsZW1lbnQgPSByYW5nZUVsZW1lbnQuZ2V0KCdtaW5UZXh0RWxlbWVudCcpO1xuICAgIHZhciBtYXhUZXh0RWxlbWVudCA9IHJhbmdlRWxlbWVudC5nZXQoJ21heFRleHRFbGVtZW50Jyk7XG4gICAgdmFyIG1pbiA9IHNjYWxlLmludmVydChtaW5SYXRpbyk7XG4gICAgdmFyIG1heCA9IHNjYWxlLmludmVydChtYXhSYXRpbyk7XG4gICAgdmFyIG1pblRleHQgPSBzY2FsZS5nZXRUZXh0KG1pbik7XG4gICAgdmFyIG1heFRleHQgPSBzY2FsZS5nZXRUZXh0KG1heCk7XG4gICAgbWluVGV4dEVsZW1lbnQuYXR0cigndGV4dCcsIG1pblRleHQpO1xuICAgIG1heFRleHRFbGVtZW50LmF0dHIoJ3RleHQnLCBtYXhUZXh0KTtcbiAgICBtZS5fc3RhcnRWYWx1ZSA9IG1pblRleHQ7XG4gICAgbWUuX2VuZFZhbHVlID0gbWF4VGV4dDtcblxuICAgIGlmIChtZS5vbkNoYW5nZSkge1xuICAgICAgbWUub25DaGFuZ2Uoe1xuICAgICAgICBzdGFydFRleHQ6IG1pblRleHQsXG4gICAgICAgIGVuZFRleHQ6IG1heFRleHQsXG4gICAgICAgIHN0YXJ0VmFsdWU6IG1pbixcbiAgICAgICAgZW5kVmFsdWU6IG1heCxcbiAgICAgICAgc3RhcnRSYWRpbzogbWluUmF0aW8sXG4gICAgICAgIGVuZFJhZGlvOiBtYXhSYXRpb1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hhcnQuc2NhbGUoZmllbGQsIFV0aWwubWl4KHt9LCBnZXRDb2xEZWYoY2hhcnQsIGZpZWxkKSwge1xuICAgICAgbmljZTogZmFsc2UsXG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfSkpO1xuICAgIGNoYXJ0LnJlcGFpbnQoKTtcbiAgfTtcblxuICBfcHJvdG8uX2JpbmRFdmVudCA9IGZ1bmN0aW9uIF9iaW5kRXZlbnQoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmFuZ2VFbGVtZW50ID0gbWUucmFuZ2VFbGVtZW50O1xuICAgIHJhbmdlRWxlbWVudC5vbignc2xpZGVyY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmFuZ2UgPSBldi5yYW5nZTtcbiAgICAgIHZhciBtaW5SYXRpbyA9IHJhbmdlWzBdIC8gMTAwO1xuICAgICAgdmFyIG1heFJhdGlvID0gcmFuZ2VbMV0gLyAxMDA7XG5cbiAgICAgIG1lLl91cGRhdGVFbGVtZW50KG1pblJhdGlvLCBtYXhSYXRpbyk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gU2xpZGVyKGNmZywgY2hhcnQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9JbnRlcmFjdGlvbi5jYWxsKHRoaXMsIGNmZywgY2hhcnQpIHx8IHRoaXM7XG5cbiAgICB2YXIgbWUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIG1lLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgICBtZS5faW5pdFN0eWxlKCk7XG5cbiAgICBtZS5yZW5kZXIoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLmNhbnZhcy5jbGVhcigpO1xuICAgIG1lLmJnQ2hhcnQgJiYgbWUuYmdDaGFydC5kZXN0cm95KCk7XG4gICAgbWUuYmdDaGFydCA9IG51bGw7XG4gICAgbWUuc2NhbGUgPSBudWxsO1xuICAgIG1lLmNhbnZhcy5kcmF3KCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGFpbnQgPSBmdW5jdGlvbiByZXBhaW50KCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgbWUuY2xlYXIoKTtcbiAgICBtZS5yZW5kZXIoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBtZS5faW5pdFdpZHRoKCk7XG5cbiAgICBtZS5faW5pdENhbnZhcygpO1xuXG4gICAgbWUuX2luaXRCYWNrZ3JvdW5kKCk7XG5cbiAgICBtZS5faW5pdFNsaWRlcigpO1xuXG4gICAgbWUuX2JpbmRFdmVudCgpO1xuXG4gICAgbWUuY2FudmFzLmRyYXcoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBjbGVhclRpbWVvdXQobWUucmVzaXplVGltZXIpO1xuICAgIHZhciByYW5nZUVsZW1lbnQgPSBtZS5yYW5nZUVsZW1lbnQ7XG4gICAgcmFuZ2VFbGVtZW50Lm9mZignc2xpZGVyY2hhbmdlJyk7XG4gICAgbWUuYmdDaGFydCAmJiBtZS5iZ0NoYXJ0LmRlc3Ryb3koKTtcbiAgICBtZS5jYW52YXMuZGVzdHJveSgpO1xuICAgIHZhciBjb250YWluZXIgPSBtZS5kb21Db250YWluZXI7XG5cbiAgICB3aGlsZSAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgVXRpbC5nZXRXcmFwQmVoYXZpb3IobWUsICdfaW5pdEZvcmNlRml0RXZlbnQnKSk7XG4gICAgbWUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gU2xpZGVyO1xufShJbnRlcmFjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuXG4vKioqLyB9KSxcbi8qIDQ3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgR3JvdXAgPSBHLkdyb3VwO1xudmFyIERvbVV0aWwgPSBVdGlsLkRvbVV0aWw7XG52YXIgT0ZGU0VUID0gNTtcblxudmFyIFJhbmdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3JvdXApIHtcbiAgX2luaGVyaXRzTG9vc2UoUmFuZ2UsIF9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gUmFuZ2UoKSB7XG4gICAgcmV0dXJuIF9Hcm91cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmFuZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiDojIPlm7RcbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgcmFuZ2U6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5Lit5ruR5Z2X5bGe5oCnXG4gICAgICAgKiBAdHlwZSB7QVRUUlN9XG4gICAgICAgKi9cbiAgICAgIG1pZGRsZUF0dHI6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog6IOM5pmvXG4gICAgICAgKiBAdHlwZSB7Ry1FbGVtZW50fVxuICAgICAgICovXG4gICAgICBiYWNrZ3JvdW5kRWxlbWVudDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDkuIvmu5HlnZdcbiAgICAgICAqIEB0eXBlIHtHLUVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIG1pbkhhbmRsZUVsZW1lbnQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5LiK5ruR5Z2XXG4gICAgICAgKiBAdHlwZSB7Ry1FbGVtZW50fVxuICAgICAgICovXG4gICAgICBtYXhIYW5kbGVFbGVtZW50OiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOS4reWdl1xuICAgICAgICogQHR5cGUge0ctRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgbWlkZGxlSGFuZGxlRWxlbWVudDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiDlvZPliY3nmoTmv4DmtLvnmoTlhYPntKBcbiAgICAgICAqIEB0eXBlIHtHLUVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIGN1cnJlbnRUYXJnZXQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5biD5bGA5pa55byP77yaIGhvcml6b250YWzvvIx2ZXJ0aWNhbFxuICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxuXG4gICAgICAvKipcbiAgICAgICAqIOWuvVxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgd2lkdGg6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog6auYXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBoZWlnaHQ6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICog5b2T5YmN55qEUGFnZVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHBhZ2VYOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIOW9k+WJjeeahFBhZ2VZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBwYWdlWTogbnVsbFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0SGFuZGxlID0gZnVuY3Rpb24gX2luaXRIYW5kbGUodHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaGFuZGxlID0gc2VsZi5hZGRHcm91cCgpO1xuICAgIHZhciBsYXlvdXQgPSBzZWxmLmdldCgnbGF5b3V0Jyk7XG4gICAgdmFyIGhhbmRsZVN0eWxlID0gc2VsZi5nZXQoJ2hhbmRsZVN0eWxlJyk7XG4gICAgdmFyIGltZyA9IGhhbmRsZVN0eWxlLmltZztcbiAgICB2YXIgaWNvbldpZHRoID0gaGFuZGxlU3R5bGUud2lkdGg7XG4gICAgdmFyIGljb25IZWlnaHQgPSBoYW5kbGVTdHlsZS5oZWlnaHQ7XG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIGhhbmRsZUljb247XG4gICAgdmFyIHRyaWdnZXJDdXJzb3I7XG5cbiAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHZhciBfaWNvbldpZHRoID0gaGFuZGxlU3R5bGUud2lkdGg7XG4gICAgICB0cmlnZ2VyQ3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgICBoYW5kbGVJY29uID0gaGFuZGxlLmFkZFNoYXBlKCdJbWFnZScsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB4OiAtX2ljb25XaWR0aCAvIDIsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogX2ljb25XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGljb25IZWlnaHQsXG4gICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgY3Vyc29yOiB0cmlnZ2VyQ3Vyc29yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGV4dCA9IGhhbmRsZS5hZGRTaGFwZSgnVGV4dCcsIHtcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICB4OiB0eXBlID09PSAnbWluJyA/IC0oX2ljb25XaWR0aCAvIDIgKyBPRkZTRVQpIDogX2ljb25XaWR0aCAvIDIgKyBPRkZTRVQsXG4gICAgICAgICAgeTogaWNvbkhlaWdodCAvIDIsXG4gICAgICAgICAgdGV4dEFsaWduOiB0eXBlID09PSAnbWluJyA/ICdlbmQnIDogJ3N0YXJ0JyxcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICAgIHRleHQ6IHR5cGUgPT09ICdtaW4nID8gdGhpcy5nZXQoJ21pblRleHQnKSA6IHRoaXMuZ2V0KCdtYXhUZXh0JyksXG4gICAgICAgICAgY3Vyc29yOiB0cmlnZ2VyQ3Vyc29yXG4gICAgICAgIH0sIHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyQ3Vyc29yID0gJ25zLXJlc2l6ZSc7XG4gICAgICBoYW5kbGVJY29uID0gaGFuZGxlLmFkZFNoYXBlKCdJbWFnZScsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IC1pY29uSGVpZ2h0IC8gMixcbiAgICAgICAgICB3aWR0aDogaWNvbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogaWNvbkhlaWdodCxcbiAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICBjdXJzb3I6IHRyaWdnZXJDdXJzb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0ZXh0ID0gaGFuZGxlLmFkZFNoYXBlKCdUZXh0Jywge1xuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IGljb25XaWR0aCAvIDIsXG4gICAgICAgICAgeTogdHlwZSA9PT0gJ21pbicgPyBpY29uSGVpZ2h0IC8gMiArIE9GRlNFVCA6IC0oaWNvbkhlaWdodCAvIDIgKyBPRkZTRVQpLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICB0ZXh0OiB0eXBlID09PSAnbWluJyA/IHRoaXMuZ2V0KCdtaW5UZXh0JykgOiB0aGlzLmdldCgnbWF4VGV4dCcpLFxuICAgICAgICAgIGN1cnNvcjogdHJpZ2dlckN1cnNvclxuICAgICAgICB9LCB0aGlzLmdldCgndGV4dFN0eWxlJykpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldCh0eXBlICsgJ1RleHRFbGVtZW50JywgdGV4dCk7XG4gICAgdGhpcy5zZXQodHlwZSArICdJY29uRWxlbWVudCcsIGhhbmRsZUljb24pO1xuICAgIHJldHVybiBoYW5kbGU7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0U2xpZGVyQmFja2dyb3VuZCA9IGZ1bmN0aW9uIF9pbml0U2xpZGVyQmFja2dyb3VuZCgpIHtcbiAgICB2YXIgYmFja2dyb3VuZEVsZW1lbnQgPSB0aGlzLmFkZEdyb3VwKCk7XG4gICAgYmFja2dyb3VuZEVsZW1lbnQuaW5pdFRyYW5zZm9ybSgpO1xuICAgIGJhY2tncm91bmRFbGVtZW50LnRyYW5zbGF0ZSgwLCAwKTtcbiAgICBiYWNrZ3JvdW5kRWxlbWVudC5hZGRTaGFwZSgnUmVjdCcsIHtcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB0aGlzLmdldCgnd2lkdGgnKSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmdldCgnaGVpZ2h0JylcbiAgICAgIH0sIHRoaXMuZ2V0KCdiYWNrZ3JvdW5kU3R5bGUnKSlcbiAgICB9KTtcbiAgICByZXR1cm4gYmFja2dyb3VuZEVsZW1lbnQ7XG4gIH07XG5cbiAgX3Byb3RvLl9iZWZvcmVSZW5kZXJVSSA9IGZ1bmN0aW9uIF9iZWZvcmVSZW5kZXJVSSgpIHtcbiAgICB2YXIgYmFja2dyb3VuZEVsZW1lbnQgPSB0aGlzLl9pbml0U2xpZGVyQmFja2dyb3VuZCgpO1xuXG4gICAgdmFyIG1pbkhhbmRsZUVsZW1lbnQgPSB0aGlzLl9pbml0SGFuZGxlKCdtaW4nKTtcblxuICAgIHZhciBtYXhIYW5kbGVFbGVtZW50ID0gdGhpcy5faW5pdEhhbmRsZSgnbWF4Jyk7XG5cbiAgICB2YXIgbWlkZGxlSGFuZGxlRWxlbWVudCA9IHRoaXMuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBhdHRyczogdGhpcy5nZXQoJ21pZGRsZUF0dHInKVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdtaWRkbGVIYW5kbGVFbGVtZW50JywgbWlkZGxlSGFuZGxlRWxlbWVudCk7XG4gICAgdGhpcy5zZXQoJ21pbkhhbmRsZUVsZW1lbnQnLCBtaW5IYW5kbGVFbGVtZW50KTtcbiAgICB0aGlzLnNldCgnbWF4SGFuZGxlRWxlbWVudCcsIG1heEhhbmRsZUVsZW1lbnQpO1xuICAgIHRoaXMuc2V0KCdiYWNrZ3JvdW5kRWxlbWVudCcsIGJhY2tncm91bmRFbGVtZW50KTtcbiAgICBiYWNrZ3JvdW5kRWxlbWVudC5zZXQoJ3pJbmRleCcsIDApO1xuICAgIG1pZGRsZUhhbmRsZUVsZW1lbnQuc2V0KCd6SW5kZXgnLCAxKTtcbiAgICBtaW5IYW5kbGVFbGVtZW50LnNldCgnekluZGV4JywgMik7XG4gICAgbWF4SGFuZGxlRWxlbWVudC5zZXQoJ3pJbmRleCcsIDIpO1xuICAgIG1pZGRsZUhhbmRsZUVsZW1lbnQuYXR0cignY3Vyc29yJywgJ21vdmUnKTtcbiAgICB0aGlzLnNvcnQoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlclVJID0gZnVuY3Rpb24gX3JlbmRlclVJKCkge1xuICAgIGlmICh0aGlzLmdldCgnbGF5b3V0JykgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy5fcmVuZGVySG9yaXpvbnRhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJWZXJ0aWNhbCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIF90cmFuc2Zvcm0obGF5b3V0KSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXQoJ3JhbmdlJyk7XG4gICAgdmFyIG1pblJhdGlvID0gcmFuZ2VbMF0gLyAxMDA7XG4gICAgdmFyIG1heFJhdGlvID0gcmFuZ2VbMV0gLyAxMDA7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXQoJ3dpZHRoJyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0KCdoZWlnaHQnKTtcbiAgICB2YXIgbWluSGFuZGxlRWxlbWVudCA9IHRoaXMuZ2V0KCdtaW5IYW5kbGVFbGVtZW50Jyk7XG4gICAgdmFyIG1heEhhbmRsZUVsZW1lbnQgPSB0aGlzLmdldCgnbWF4SGFuZGxlRWxlbWVudCcpO1xuICAgIHZhciBtaWRkbGVIYW5kbGVFbGVtZW50ID0gdGhpcy5nZXQoJ21pZGRsZUhhbmRsZUVsZW1lbnQnKTtcblxuICAgIGlmIChtaW5IYW5kbGVFbGVtZW50LnJlc2V0TWF0cml4KSB7XG4gICAgICBtaW5IYW5kbGVFbGVtZW50LnJlc2V0TWF0cml4KCk7XG4gICAgICBtYXhIYW5kbGVFbGVtZW50LnJlc2V0TWF0cml4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkhhbmRsZUVsZW1lbnQuaW5pdFRyYW5zZm9ybSgpO1xuICAgICAgbWF4SGFuZGxlRWxlbWVudC5pbml0VHJhbnNmb3JtKCk7XG4gICAgfVxuXG4gICAgaWYgKGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICBtaWRkbGVIYW5kbGVFbGVtZW50LmF0dHIoe1xuICAgICAgICB4OiB3aWR0aCAqIG1pblJhdGlvLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogKG1heFJhdGlvIC0gbWluUmF0aW8pICogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIG1pbkhhbmRsZUVsZW1lbnQudHJhbnNsYXRlKG1pblJhdGlvICogd2lkdGgsIDApO1xuICAgICAgbWF4SGFuZGxlRWxlbWVudC50cmFuc2xhdGUobWF4UmF0aW8gKiB3aWR0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZUhhbmRsZUVsZW1lbnQuYXR0cih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IGhlaWdodCAqICgxIC0gbWF4UmF0aW8pLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogKG1heFJhdGlvIC0gbWluUmF0aW8pICogaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIG1pbkhhbmRsZUVsZW1lbnQudHJhbnNsYXRlKDAsICgxIC0gbWluUmF0aW8pICogaGVpZ2h0KTtcbiAgICAgIG1heEhhbmRsZUVsZW1lbnQudHJhbnNsYXRlKDAsICgxIC0gbWF4UmF0aW8pICogaGVpZ2h0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJIb3Jpem9udGFsID0gZnVuY3Rpb24gX3JlbmRlckhvcml6b250YWwoKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtKCdob3Jpem9udGFsJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW5kZXJWZXJ0aWNhbCA9IGZ1bmN0aW9uIF9yZW5kZXJWZXJ0aWNhbCgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0oJ3ZlcnRpY2FsJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5kVUkgPSBmdW5jdGlvbiBfYmluZFVJKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIFV0aWwud3JhcEJlaGF2aW9yKHRoaXMsICdfb25Nb3VzZURvd24nKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9pc0VsZW1lbnQgPSBmdW5jdGlvbiBfaXNFbGVtZW50KHRhcmdldCwgbmFtZSkge1xuICAgIC8vIOWIpOaWreaYr+WQpuaYr+ivpeWFg+e0oFxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXQobmFtZSk7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5pc0dyb3VwKSB7XG4gICAgICB2YXIgZWxlbWVudENoaWxkcmVuID0gZWxlbWVudC5nZXQoJ2NoaWxkcmVuJyk7XG4gICAgICByZXR1cm4gZWxlbWVudENoaWxkcmVuLmluZGV4T2YodGFyZ2V0KSA+IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFJhbmdlID0gZnVuY3Rpb24gX2dldFJhbmdlKGRpZmYsIHJhbmdlKSB7XG4gICAgdmFyIHJzdCA9IGRpZmYgKyByYW5nZTtcbiAgICByc3QgPSByc3QgPiAxMDAgPyAxMDAgOiByc3Q7XG4gICAgcnN0ID0gcnN0IDwgMCA/IDAgOiByc3Q7XG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uX2xpbWl0UmFuZ2UgPSBmdW5jdGlvbiBfbGltaXRSYW5nZShkaWZmLCBsaW1pdCwgcmFuZ2UpIHtcbiAgICByYW5nZVswXSA9IHRoaXMuX2dldFJhbmdlKGRpZmYsIHJhbmdlWzBdKTtcbiAgICByYW5nZVsxXSA9IHJhbmdlWzBdICsgbGltaXQ7XG5cbiAgICBpZiAocmFuZ2VbMV0gPiAxMDApIHtcbiAgICAgIHJhbmdlWzFdID0gMTAwO1xuICAgICAgcmFuZ2VbMF0gPSByYW5nZVsxXSAtIGxpbWl0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3VwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIF91cGRhdGVTdGF0dXMoZGltLCBldikge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGRpbSA9PT0gJ3gnID8gdGhpcy5nZXQoJ3dpZHRoJykgOiB0aGlzLmdldCgnaGVpZ2h0Jyk7XG4gICAgZGltID0gVXRpbC51cHBlckZpcnN0KGRpbSk7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5nZXQoJ3JhbmdlJyk7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldCgncGFnZScgKyBkaW0pO1xuICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gdGhpcy5nZXQoJ2N1cnJlbnRUYXJnZXQnKTtcbiAgICB2YXIgcmFuZ2VTdGFzaCA9IHRoaXMuZ2V0KCdyYW5nZVN0YXNoJyk7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcbiAgICB2YXIgc2lnbiA9IGxheW91dCA9PT0gJ3ZlcnRpY2FsJyA/IC0xIDogMTtcbiAgICB2YXIgY3VycmVudFBhZ2UgPSBldlsncGFnZScgKyBkaW1dO1xuICAgIHZhciBkaWZmUGFnZSA9IGN1cnJlbnRQYWdlIC0gcGFnZTtcbiAgICB2YXIgZGlmZlJhbmdlID0gZGlmZlBhZ2UgLyB0b3RhbExlbmd0aCAqIDEwMCAqIHNpZ247XG4gICAgdmFyIGRpZmZTdGFzaFJhbmdlO1xuICAgIHZhciBtaW5SYW5nZSA9IHRoaXMuZ2V0KCdtaW5SYW5nZScpO1xuICAgIHZhciBtYXhSYW5nZSA9IHRoaXMuZ2V0KCdtYXhSYW5nZScpO1xuXG4gICAgaWYgKHJhbmdlWzFdIDw9IHJhbmdlWzBdKSB7XG4gICAgICBpZiAodGhpcy5faXNFbGVtZW50KGN1cnJlbnRUYXJnZXQsICdtaW5IYW5kbGVFbGVtZW50JykgfHwgdGhpcy5faXNFbGVtZW50KGN1cnJlbnRUYXJnZXQsICdtYXhIYW5kbGVFbGVtZW50JykpIHtcbiAgICAgICAgcmFuZ2VbMF0gPSB0aGlzLl9nZXRSYW5nZShkaWZmUmFuZ2UsIHJhbmdlWzBdKTtcbiAgICAgICAgcmFuZ2VbMV0gPSB0aGlzLl9nZXRSYW5nZShkaWZmUmFuZ2UsIHJhbmdlWzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzRWxlbWVudChjdXJyZW50VGFyZ2V0LCAnbWluSGFuZGxlRWxlbWVudCcpKSB7XG4gICAgICAgIHJhbmdlWzBdID0gdGhpcy5fZ2V0UmFuZ2UoZGlmZlJhbmdlLCByYW5nZVswXSk7XG5cbiAgICAgICAgaWYgKG1pblJhbmdlKSB7XG4gICAgICAgICAgLy8g6K6+572u5LqG5pyA5bCP6IyD5Zu0XG4gICAgICAgICAgaWYgKHJhbmdlWzFdIC0gcmFuZ2VbMF0gPD0gbWluUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbWl0UmFuZ2UoZGlmZlJhbmdlLCBtaW5SYW5nZSwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhSYW5nZSkge1xuICAgICAgICAgIC8vIOiuvue9ruS6huacgOWkp+iMg+WbtFxuICAgICAgICAgIGlmIChyYW5nZVsxXSAtIHJhbmdlWzBdID49IG1heFJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdFJhbmdlKGRpZmZSYW5nZSwgbWF4UmFuZ2UsIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRWxlbWVudChjdXJyZW50VGFyZ2V0LCAnbWF4SGFuZGxlRWxlbWVudCcpKSB7XG4gICAgICAgIHJhbmdlWzFdID0gdGhpcy5fZ2V0UmFuZ2UoZGlmZlJhbmdlLCByYW5nZVsxXSk7XG5cbiAgICAgICAgaWYgKG1pblJhbmdlKSB7XG4gICAgICAgICAgLy8g6K6+572u5LqG5pyA5bCP6IyD5Zu0XG4gICAgICAgICAgaWYgKHJhbmdlWzFdIC0gcmFuZ2VbMF0gPD0gbWluUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbWl0UmFuZ2UoZGlmZlJhbmdlLCBtaW5SYW5nZSwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhSYW5nZSkge1xuICAgICAgICAgIC8vIOiuvue9ruS6huacgOWkp+iMg+WbtFxuICAgICAgICAgIGlmIChyYW5nZVsxXSAtIHJhbmdlWzBdID49IG1heFJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9saW1pdFJhbmdlKGRpZmZSYW5nZSwgbWF4UmFuZ2UsIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNFbGVtZW50KGN1cnJlbnRUYXJnZXQsICdtaWRkbGVIYW5kbGVFbGVtZW50JykpIHtcbiAgICAgIGRpZmZTdGFzaFJhbmdlID0gcmFuZ2VTdGFzaFsxXSAtIHJhbmdlU3Rhc2hbMF07XG5cbiAgICAgIHRoaXMuX2xpbWl0UmFuZ2UoZGlmZlJhbmdlLCBkaWZmU3Rhc2hSYW5nZSwgcmFuZ2UpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnc2xpZGVyY2hhbmdlJywge1xuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfSk7XG4gICAgdGhpcy5zZXQoJ3BhZ2UnICsgZGltLCBjdXJyZW50UGFnZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJVSSgpO1xuXG4gICAgdGhpcy5nZXQoJ2NhbnZhcycpLmRyYXcoKTsgLy8gbmVlZCBkZWxldGVcblxuICAgIHJldHVybjtcbiAgfTtcblxuICBfcHJvdG8uX29uTW91c2VEb3duID0gZnVuY3Rpb24gX29uTW91c2VEb3duKGV2KSB7XG4gICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBldi5jdXJyZW50VGFyZ2V0O1xuICAgIHZhciBvcmlnaW5FdmVudCA9IGV2LmV2ZW50O1xuICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0KCdyYW5nZScpO1xuICAgIG9yaWdpbkV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIG9yaWdpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5zZXQoJ3BhZ2VYJywgb3JpZ2luRXZlbnQucGFnZVgpO1xuICAgIHRoaXMuc2V0KCdwYWdlWScsIG9yaWdpbkV2ZW50LnBhZ2VZKTtcbiAgICB0aGlzLnNldCgnY3VycmVudFRhcmdldCcsIGN1cnJlbnRUYXJnZXQpO1xuICAgIHRoaXMuc2V0KCdyYW5nZVN0YXNoJywgW3JhbmdlWzBdLCByYW5nZVsxXV0pO1xuXG4gICAgdGhpcy5fYmluZENhbnZhc0V2ZW50cygpO1xuICB9O1xuXG4gIF9wcm90by5fYmluZENhbnZhc0V2ZW50cyA9IGZ1bmN0aW9uIF9iaW5kQ2FudmFzRXZlbnRzKCkge1xuICAgIHZhciBjb250YWluZXJET00gPSB0aGlzLmdldCgnY2FudmFzJykuZ2V0KCdjb250YWluZXJET00nKTtcbiAgICB0aGlzLm9uTW91c2VNb3ZlTGlzdGVuZXIgPSBEb21VdGlsLmFkZEV2ZW50TGlzdGVuZXIoY29udGFpbmVyRE9NLCAnbW91c2Vtb3ZlJywgVXRpbC53cmFwQmVoYXZpb3IodGhpcywgJ19vbkNhbnZhc01vdXNlTW92ZScpKTtcbiAgICB0aGlzLm9uTW91c2VVcExpc3RlbmVyID0gRG9tVXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lckRPTSwgJ21vdXNldXAnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uQ2FudmFzTW91c2VVcCcpKTsgLy8gQDIwMTgtMDYtMDYgYnkgYmx1ZS5sYiDmt7vliqBtb3VzZWxlYXZl5LqL5Lu255uR5ZCs77yM6K6p55So5oi35Zyo5pON5L2c5Ye65ruR5Z2X5Yy65Z+f5ZCO5pyJ5LiA5Liq4oCc5q2j5bi44oCd55qE5pWI5p6c77yM5Y+v5Lul5q2j5bi46YeN5paw6Kem5Y+R5ruR5Z2X55qE5pON5L2c5rWB56iLXG5cbiAgICB0aGlzLm9uTW91c2VMZWF2ZUxpc3RlbmVyID0gRG9tVXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lckRPTSwgJ21vdXNlbGVhdmUnLCBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnX29uQ2FudmFzTW91c2VVcCcpKTtcbiAgfTtcblxuICBfcHJvdG8uX29uQ2FudmFzTW91c2VNb3ZlID0gZnVuY3Rpb24gX29uQ2FudmFzTW91c2VNb3ZlKGV2KSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0KCdsYXlvdXQnKTtcblxuICAgIGlmIChsYXlvdXQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdHVzKCd4JywgZXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0dXMoJ3knLCBldik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fb25DYW52YXNNb3VzZVVwID0gZnVuY3Rpb24gX29uQ2FudmFzTW91c2VVcCgpIHtcbiAgICB0aGlzLl9yZW1vdmVEb2N1bWVudEV2ZW50cygpO1xuICB9O1xuXG4gIF9wcm90by5fcmVtb3ZlRG9jdW1lbnRFdmVudHMgPSBmdW5jdGlvbiBfcmVtb3ZlRG9jdW1lbnRFdmVudHMoKSB7XG4gICAgdGhpcy5vbk1vdXNlTW92ZUxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMub25Nb3VzZVVwTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5vbk1vdXNlTGVhdmVMaXN0ZW5lci5yZW1vdmUoKTtcbiAgfTtcblxuICByZXR1cm4gUmFuZ2U7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZTtcblxuLyoqKi8gfSksXG4vKiA0NzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBJbnRlcmFjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTcxKTtcblxudmFyIGdldENvbERlZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzc3KTtcblxudmFyIGdldExpbWl0UmFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3OCk7XG5cbnZhciBaT09NSU5HX1RZUEVTID0gWydYJywgJ1knLCAnWFknXTtcbnZhciBERUZBVUxUX1RZUEUgPSAnWCc7XG5cbnZhciBab29tID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW50ZXJhY3Rpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9vbSwgX0ludGVyYWN0aW9uKTtcblxuICB2YXIgX3Byb3RvID0gWm9vbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfSW50ZXJhY3Rpb24ucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHJldHVybiBVdGlsLm1peCh7fSwgY2ZnLCB7XG4gICAgICBwcm9jZXNzRXZlbnQ6ICdtb3VzZXdoZWVsJyxcbiAgICAgIHR5cGU6IERFRkFVTFRfVFlQRSxcbiAgICAgIHN0ZXBSYXRpbzogMC4wNSxcbiAgICAgIHN0ZXBCeUZpZWxkOiB7fSxcbiAgICAgIG1pblNjYWxlOiAxLFxuICAgICAgbWF4U2NhbGU6IDQsXG4gICAgICBjYXRTdGVwOiAyLFxuICAgICAgbGltaXRSYW5nZToge30sXG4gICAgICBvcmlnaW5TY2FsZURlZnNCeUZpZWxkOiB7fVxuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFpvb20oY2ZnLCBjaGFydCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0ludGVyYWN0aW9uLmNhbGwodGhpcywgY2ZnLCBjaGFydCkgfHwgdGhpcztcblxuICAgIHZhciBtZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgbWUuY2hhcnQgPSBjaGFydDtcbiAgICBtZS50eXBlID0gbWUudHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBkYXRhID0gbWUuZGF0YSA9IGNoYXJ0LmdldCgnZGF0YScpO1xuICAgIHZhciBzY2FsZXMgPSBjaGFydC5nZXRZU2NhbGVzKCk7XG4gICAgdmFyIHhTY2FsZSA9IGNoYXJ0LmdldFhTY2FsZSgpO1xuICAgIHNjYWxlcy5wdXNoKHhTY2FsZSk7XG4gICAgdmFyIHNjYWxlQ29udHJvbGxlciA9IGNoYXJ0LmdldCgnc2NhbGVDb250cm9sbGVyJyk7XG4gICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICAgIHZhciBkZWYgPSBzY2FsZUNvbnRyb2xsZXIuZGVmc1tmaWVsZF0gfHwge307XG4gICAgICBtZS5saW1pdFJhbmdlW2ZpZWxkXSA9IGdldExpbWl0UmFuZ2UoZGF0YSwgc2NhbGUpO1xuICAgICAgbWUub3JpZ2luU2NhbGVEZWZzQnlGaWVsZFtmaWVsZF0gPSBVdGlsLm1peChkZWYsIHtcbiAgICAgICAgbmljZTogISFkZWYubmljZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY2FsZS5pc0xpbmVhcikge1xuICAgICAgICBtZS5zdGVwQnlGaWVsZFtmaWVsZF0gPSAoc2NhbGUubWF4IC0gc2NhbGUubWluKSAqIG1lLnN0ZXBSYXRpbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lLnN0ZXBCeUZpZWxkW2ZpZWxkXSA9IG1lLmNhdFN0ZXA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoWk9PTUlOR19UWVBFUy5pbmRleE9mKG1lLnR5cGUpID09PSAtMSkge1xuICAgICAgbWUudHlwZSA9IERFRkFVTFRfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gb25ab29tKCkgeyB9XG4gIC8vIG9uWm9vbWluKCkgeyB9XG4gIC8vIG9uWm9vbW91dCgpIHsgfVxuXG5cbiAgX3Byb3RvLl9hcHBseVNjYWxlID0gZnVuY3Rpb24gX2FwcGx5U2NhbGUoc2NhbGUsIGRlbHRhLCBtaW5PZmZzZXQsIGNlbnRlcikge1xuICAgIGlmIChtaW5PZmZzZXQgPT09IHZvaWQgMCkge1xuICAgICAgbWluT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IG1lLmNoYXJ0LFxuICAgICAgICBzdGVwQnlGaWVsZCA9IG1lLnN0ZXBCeUZpZWxkO1xuXG4gICAgaWYgKHNjYWxlLmlzTGluZWFyKSB7XG4gICAgICB2YXIgbWluID0gc2NhbGUubWluLFxuICAgICAgICAgIG1heCA9IHNjYWxlLm1heCxcbiAgICAgICAgICBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgICAgdmFyIG1heE9mZnNldCA9IDEgLSBtaW5PZmZzZXQ7XG4gICAgICB2YXIgc3RlcCA9IHN0ZXBCeUZpZWxkW2ZpZWxkXSAqIGRlbHRhO1xuICAgICAgdmFyIG5ld01pbiA9IG1pbiArIHN0ZXAgKiBtaW5PZmZzZXQ7XG4gICAgICB2YXIgbmV3TWF4ID0gbWF4IC0gc3RlcCAqIG1heE9mZnNldDtcblxuICAgICAgaWYgKG5ld01heCA+IG5ld01pbikge1xuICAgICAgICBjaGFydC5zY2FsZShmaWVsZCwge1xuICAgICAgICAgIG5pY2U6IGZhbHNlLFxuICAgICAgICAgIG1pbjogbmV3TWluLFxuICAgICAgICAgIG1heDogbmV3TWF4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2ZpZWxkID0gc2NhbGUuZmllbGQsXG4gICAgICAgICAgdmFsdWVzID0gc2NhbGUudmFsdWVzO1xuICAgICAgdmFyIF9jaGFydCA9IG1lLmNoYXJ0O1xuXG4gICAgICB2YXIgY29vcmQgPSBfY2hhcnQuZ2V0KCdjb29yZCcpO1xuXG4gICAgICB2YXIgY29sRGVmID0gZ2V0Q29sRGVmKF9jaGFydCwgX2ZpZWxkKTtcbiAgICAgIHZhciBvcmlnaW5WYWx1ZXMgPSBtZS5saW1pdFJhbmdlW19maWVsZF07XG4gICAgICB2YXIgb3JpZ2luVmFsdWVzTGVuID0gb3JpZ2luVmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciBtYXhTY2FsZSA9IG1lLm1heFNjYWxlO1xuICAgICAgdmFyIG1pblNjYWxlID0gbWUubWluU2NhbGU7XG4gICAgICB2YXIgbWluQ291bnQgPSBvcmlnaW5WYWx1ZXNMZW4gLyBtYXhTY2FsZTtcbiAgICAgIHZhciBtYXhDb3VudCA9IG9yaWdpblZhbHVlc0xlbiAvIG1pblNjYWxlO1xuICAgICAgdmFyIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgb2Zmc2V0UG9pbnQgPSBjb29yZC5pbnZlcnRQb2ludChjZW50ZXIpO1xuICAgICAgdmFyIHBlcmNlbnQgPSBvZmZzZXRQb2ludC54O1xuICAgICAgdmFyIGRlbHRhQ291bnQgPSB2YWx1ZXNMZW5ndGggLSBkZWx0YSAqIHRoaXMuY2F0U3RlcDtcbiAgICAgIHZhciBtaW5EZWx0YSA9IHBhcnNlSW50KGRlbHRhQ291bnQgKiBwZXJjZW50KTtcbiAgICAgIHZhciBtYXhEZWx0YSA9IGRlbHRhQ291bnQgKyBtaW5EZWx0YTtcblxuICAgICAgaWYgKGRlbHRhID4gMCAmJiB2YWx1ZXNMZW5ndGggPj0gbWluQ291bnQpIHtcbiAgICAgICAgLy8gem9vbSBvdXRcbiAgICAgICAgdmFyIF9taW4gPSBtaW5EZWx0YTtcbiAgICAgICAgdmFyIF9tYXggPSBtYXhEZWx0YTtcblxuICAgICAgICBpZiAobWF4RGVsdGEgPiB2YWx1ZXNMZW5ndGgpIHtcbiAgICAgICAgICBfbWF4ID0gdmFsdWVzTGVuZ3RoIC0gMTtcbiAgICAgICAgICBfbWluID0gdmFsdWVzTGVuZ3RoIC0gZGVsdGFDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoX21pbiwgX21heCk7XG5cbiAgICAgICAgX2NoYXJ0LnNjYWxlKF9maWVsZCwgVXRpbC5taXgoe30sIGNvbERlZiwge1xuICAgICAgICAgIHZhbHVlczogbmV3VmFsdWVzXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAwICYmIHZhbHVlc0xlbmd0aCA8PSBtYXhDb3VudCkge1xuICAgICAgICAvLyB6b29tIGluXG4gICAgICAgIHZhciBmaXJzdEluZGV4ID0gb3JpZ2luVmFsdWVzLmluZGV4T2YodmFsdWVzWzBdKTtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IG9yaWdpblZhbHVlcy5pbmRleE9mKHZhbHVlc1t2YWx1ZXNMZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBtaW5JbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXggLSBtaW5EZWx0YSk7XG4gICAgICAgIHZhciBtYXhJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCArIG1heERlbHRhLCBvcmlnaW5WYWx1ZXNMZW4pO1xuXG4gICAgICAgIHZhciBfbmV3VmFsdWVzID0gb3JpZ2luVmFsdWVzLnNsaWNlKG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgX2NoYXJ0LnNjYWxlKF9maWVsZCwgVXRpbC5taXgoe30sIGNvbERlZiwge1xuICAgICAgICAgIHZhbHVlczogX25ld1ZhbHVlc1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2Vzcyhldikge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gbWUuY2hhcnQsXG4gICAgICAgIHR5cGUgPSBtZS50eXBlO1xuICAgIHZhciBjb29yZCA9IGNoYXJ0LmdldCgnY29vcmQnKTtcbiAgICB2YXIgZGVsdGFZID0gZXYuZGVsdGFZO1xuICAgIHZhciBvZmZzZXRQb2ludCA9IGNvb3JkLmludmVydFBvaW50KGV2KTtcblxuICAgIGlmIChkZWx0YVkpIHtcbiAgICAgIG1lLm9uWm9vbSAmJiBtZS5vblpvb20oZGVsdGFZLCBvZmZzZXRQb2ludCwgbWUpO1xuXG4gICAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICBtZS5vblpvb21pbiAmJiBtZS5vblpvb21pbihkZWx0YVksIG9mZnNldFBvaW50LCBtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZS5vblpvb21vdXQgJiYgbWUub25ab29tb3V0KGRlbHRhWSwgb2Zmc2V0UG9pbnQsIG1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gZGVsdGFZIC8gTWF0aC5hYnMoZGVsdGFZKTtcblxuICAgICAgaWYgKHR5cGUuaW5kZXhPZignWCcpID4gLTEpIHtcbiAgICAgICAgbWUuX2FwcGx5U2NhbGUoY2hhcnQuZ2V0WFNjYWxlKCksIGRlbHRhLCBvZmZzZXRQb2ludC54LCBldik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLmluZGV4T2YoJ1knKSA+IC0xKSB7XG4gICAgICAgIHZhciB5U2NhbGVzID0gY2hhcnQuZ2V0WVNjYWxlcygpO1xuICAgICAgICB5U2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKHlTY2FsZSkge1xuICAgICAgICAgIG1lLl9hcHBseVNjYWxlKHlTY2FsZSwgZGVsdGEsIG9mZnNldFBvaW50LnksIGV2KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hhcnQucmVwYWludCgpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHZpZXcgPSBtZS52aWV3LFxuICAgICAgICBvcmlnaW5TY2FsZURlZnNCeUZpZWxkID0gbWUub3JpZ2luU2NhbGVEZWZzQnlGaWVsZDtcbiAgICB2YXIgc2NhbGVzID0gdmlldy5nZXRZU2NhbGVzKCk7XG4gICAgdmFyIHhTY2FsZSA9IHZpZXcuZ2V0WFNjYWxlKCk7XG4gICAgc2NhbGVzLnB1c2goeFNjYWxlKTtcbiAgICBzY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIGlmIChzY2FsZS5pc0xpbmVhcikge1xuICAgICAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICAgICAgdmlldy5zY2FsZShmaWVsZCwgb3JpZ2luU2NhbGVEZWZzQnlGaWVsZFtmaWVsZF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZpZXcucmVwYWludCgpO1xuICB9O1xuXG4gIHJldHVybiBab29tO1xufShJbnRlcmFjdGlvbik7IC8vIEcyLnJlZ2lzdGVySW50ZXJhY3Rpb24oJ3pvb20nLCBab29tKTtcbi8vIEcyLnJlZ2lzdGVySW50ZXJhY3Rpb24oJ1pvb20nLCBab29tKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZzIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxRQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@antv/g2/build/g2.js\n");

/***/ })

}]);